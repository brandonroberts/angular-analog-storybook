import {
  esm_exports as esm_exports3,
  init_esm as init_esm3
} from "./chunk-SNOMC6VJ.js";
import {
  init_public_api,
  public_api_exports
} from "./chunk-ZXUQATKE.js";
import {
  esm_exports as esm_exports2,
  init_esm as init_esm2
} from "./chunk-FRD2Y65G.js";
import {
  require_browser
} from "./chunk-N2FZLRTI.js";
import {
  esm_exports,
  init_esm
} from "./chunk-XAJ4SFQJ.js";
import {
  require_window
} from "./chunk-XCM4TOIV.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  define_ngDevMode_default,
  init_define_ngDevMode
} from "./chunk-XN7ES5DP.js";

// node_modules/tslib/tslib.es6.js
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  }, f, y, t, g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {
          value: o && o[i++],
          done: !o
        };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = {
      error: error2
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from2.length, ar; i < l; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({
        value: v2,
        done: d
      });
    }, reject);
  }
}
var extendStatics;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.js"() {
    init_define_ngDevMode();
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}
var init_isFunction = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isFunction.js"() {
    init_define_ngDevMode();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var init_createErrorClass = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js"() {
    init_define_ngDevMode();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError;
var init_UnsubscriptionError = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js"() {
    init_define_ngDevMode();
    init_createErrorClass();
    UnsubscriptionError = createErrorClass(function(_super) {
      return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
          return i + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
      };
    });
  }
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
var init_arrRemove = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/arrRemove.js"() {
    init_define_ngDevMode();
  }
});

// node_modules/rxjs/dist/esm5/internal/Subscription.js
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var Subscription, EMPTY_SUBSCRIPTION;
var init_Subscription = __esm({
  "node_modules/rxjs/dist/esm5/internal/Subscription.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_isFunction();
    init_UnsubscriptionError();
    init_arrRemove();
    Subscription = function() {
      function Subscription2(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
      }
      Subscription2.prototype.unsubscribe = function() {
        var e_1, _a, e_2, _b;
        var errors;
        if (!this.closed) {
          this.closed = true;
          var _parentage = this._parentage;
          if (_parentage) {
            this._parentage = null;
            if (Array.isArray(_parentage)) {
              try {
                for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                  var parent_1 = _parentage_1_1.value;
                  parent_1.remove(this);
                }
              } catch (e_1_1) {
                e_1 = {
                  error: e_1_1
                };
              } finally {
                try {
                  if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                    _a.call(_parentage_1);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
            } else {
              _parentage.remove(this);
            }
          }
          var initialFinalizer = this.initialTeardown;
          if (isFunction(initialFinalizer)) {
            try {
              initialFinalizer();
            } catch (e) {
              errors = e instanceof UnsubscriptionError ? e.errors : [e];
            }
          }
          var _finalizers = this._finalizers;
          if (_finalizers) {
            this._finalizers = null;
            try {
              for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                var finalizer = _finalizers_1_1.value;
                try {
                  execFinalizer(finalizer);
                } catch (err) {
                  errors = errors !== null && errors !== void 0 ? errors : [];
                  if (err instanceof UnsubscriptionError) {
                    errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                  } else {
                    errors.push(err);
                  }
                }
              }
            } catch (e_2_1) {
              e_2 = {
                error: e_2_1
              };
            } finally {
              try {
                if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                  _b.call(_finalizers_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
          if (errors) {
            throw new UnsubscriptionError(errors);
          }
        }
      };
      Subscription2.prototype.add = function(teardown) {
        var _a;
        if (teardown && teardown !== this) {
          if (this.closed) {
            execFinalizer(teardown);
          } else {
            if (teardown instanceof Subscription2) {
              if (teardown.closed || teardown._hasParent(this)) {
                return;
              }
              teardown._addParent(this);
            }
            (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
          }
        }
      };
      Subscription2.prototype._hasParent = function(parent) {
        var _parentage = this._parentage;
        return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
      };
      Subscription2.prototype._addParent = function(parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
      };
      Subscription2.prototype._removeParent = function(parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) {
          this._parentage = null;
        } else if (Array.isArray(_parentage)) {
          arrRemove(_parentage, parent);
        }
      };
      Subscription2.prototype.remove = function(teardown) {
        var _finalizers = this._finalizers;
        _finalizers && arrRemove(_finalizers, teardown);
        if (teardown instanceof Subscription2) {
          teardown._removeParent(this);
        }
      };
      Subscription2.EMPTY = function() {
        var empty2 = new Subscription2();
        empty2.closed = true;
        return empty2;
      }();
      return Subscription2;
    }();
    EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  }
});

// node_modules/rxjs/dist/esm5/internal/config.js
var config;
var init_config = __esm({
  "node_modules/rxjs/dist/esm5/internal/config.js"() {
    init_define_ngDevMode();
    config = {
      onUnhandledError: null,
      onStoppedNotification: null,
      Promise: void 0,
      useDeprecatedSynchronousErrorHandling: false,
      useDeprecatedNextContext: false
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider;
var init_timeoutProvider = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    timeoutProvider = {
      setTimeout: function(handler, timeout2) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
          return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
        }
        return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
      },
      clearTimeout: function(handle) {
        var delegate = timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}
var init_reportUnhandledError = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js"() {
    init_define_ngDevMode();
    init_config();
    init_timeoutProvider();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}
var init_noop = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/noop.js"() {
    init_define_ngDevMode();
  }
});

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
function errorNotification(error2) {
  return createNotification("E", void 0, error2);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error2) {
  return {
    kind,
    value,
    error: error2
  };
}
var COMPLETE_NOTIFICATION;
var init_NotificationFactories = __esm({
  "node_modules/rxjs/dist/esm5/internal/NotificationFactories.js"() {
    init_define_ngDevMode();
    COMPLETE_NOTIFICATION = function() {
      return createNotification("C", void 0, void 0);
    }();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = {
        errorThrown: false,
        error: null
      };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error2 = _a.error;
      context = null;
      if (errorThrown) {
        throw error2;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}
var context;
var init_errorContext = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/errorContext.js"() {
    init_define_ngDevMode();
    init_config();
    context = null;
  }
});

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
function bind(fn2, thisArg) {
  return _bind.call(fn2, thisArg);
}
function handleUnhandledError(error2) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error2);
  } else {
    reportUnhandledError(error2);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var Subscriber, _bind, ConsumerObserver, SafeSubscriber, EMPTY_OBSERVER;
var init_Subscriber = __esm({
  "node_modules/rxjs/dist/esm5/internal/Subscriber.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_isFunction();
    init_Subscription();
    init_config();
    init_reportUnhandledError();
    init_noop();
    init_NotificationFactories();
    init_timeoutProvider();
    init_errorContext();
    Subscriber = function(_super) {
      __extends(Subscriber2, _super);
      function Subscriber2(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
          _this.destination = destination;
          if (isSubscription(destination)) {
            destination.add(_this);
          }
        } else {
          _this.destination = EMPTY_OBSERVER;
        }
        return _this;
      }
      Subscriber2.create = function(next, error2, complete) {
        return new SafeSubscriber(next, error2, complete);
      };
      Subscriber2.prototype.next = function(value) {
        if (this.isStopped) {
          handleStoppedNotification(nextNotification(value), this);
        } else {
          this._next(value);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (this.isStopped) {
          handleStoppedNotification(errorNotification(err), this);
        } else {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (this.isStopped) {
          handleStoppedNotification(COMPLETE_NOTIFICATION, this);
        } else {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.isStopped = true;
          _super.prototype.unsubscribe.call(this);
          this.destination = null;
        }
      };
      Subscriber2.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber2.prototype._error = function(err) {
        try {
          this.destination.error(err);
        } finally {
          this.unsubscribe();
        }
      };
      Subscriber2.prototype._complete = function() {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      };
      return Subscriber2;
    }(Subscription);
    _bind = Function.prototype.bind;
    ConsumerObserver = function() {
      function ConsumerObserver2(partialObserver) {
        this.partialObserver = partialObserver;
      }
      ConsumerObserver2.prototype.next = function(value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) {
          try {
            partialObserver.next(value);
          } catch (error2) {
            handleUnhandledError(error2);
          }
        }
      };
      ConsumerObserver2.prototype.error = function(err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) {
          try {
            partialObserver.error(err);
          } catch (error2) {
            handleUnhandledError(error2);
          }
        } else {
          handleUnhandledError(err);
        }
      };
      ConsumerObserver2.prototype.complete = function() {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) {
          try {
            partialObserver.complete();
          } catch (error2) {
            handleUnhandledError(error2);
          }
        }
      };
      return ConsumerObserver2;
    }();
    SafeSubscriber = function(_super) {
      __extends(SafeSubscriber2, _super);
      function SafeSubscriber2(observerOrNext, error2, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if (isFunction(observerOrNext) || !observerOrNext) {
          partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
            error: error2 !== null && error2 !== void 0 ? error2 : void 0,
            complete: complete !== null && complete !== void 0 ? complete : void 0
          };
        } else {
          var context_1;
          if (_this && config.useDeprecatedNextContext) {
            context_1 = Object.create(observerOrNext);
            context_1.unsubscribe = function() {
              return _this.unsubscribe();
            };
            partialObserver = {
              next: observerOrNext.next && bind(observerOrNext.next, context_1),
              error: observerOrNext.error && bind(observerOrNext.error, context_1),
              complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
            };
          } else {
            partialObserver = observerOrNext;
          }
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
      }
      return SafeSubscriber2;
    }(Subscriber);
    EMPTY_OBSERVER = {
      closed: true,
      next: noop,
      error: defaultErrorHandler,
      complete: noop
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable;
var init_observable = __esm({
  "node_modules/rxjs/dist/esm5/internal/symbol/observable.js"() {
    init_define_ngDevMode();
    observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}
var init_identity = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/identity.js"() {
    init_define_ngDevMode();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn2) {
      return fn2(prev);
    }, input);
  };
}
var init_pipe = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/pipe.js"() {
    init_define_ngDevMode();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm5/internal/Observable.js
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}
var Observable;
var init_Observable = __esm({
  "node_modules/rxjs/dist/esm5/internal/Observable.js"() {
    init_define_ngDevMode();
    init_Subscriber();
    init_Subscription();
    init_observable();
    init_pipe();
    init_config();
    init_isFunction();
    init_errorContext();
    Observable = function() {
      function Observable2(subscribe) {
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      Observable2.prototype.lift = function(operator) {
        var observable2 = new Observable2();
        observable2.source = this;
        observable2.operator = operator;
        return observable2;
      };
      Observable2.prototype.subscribe = function(observerOrNext, error2, complete) {
        var _this = this;
        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error2, complete);
        errorContext(function() {
          var _a = _this, operator = _a.operator, source = _a.source;
          subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
        });
        return subscriber;
      };
      Observable2.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          sink.error(err);
        }
      };
      Observable2.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var subscriber = new SafeSubscriber({
            next: function(value) {
              try {
                next(value);
              } catch (err) {
                reject(err);
                subscriber.unsubscribe();
              }
            },
            error: reject,
            complete: resolve
          });
          _this.subscribe(subscriber);
        });
      };
      Observable2.prototype._subscribe = function(subscriber) {
        var _a;
        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
      };
      Observable2.prototype[observable] = function() {
        return this;
      };
      Observable2.prototype.pipe = function() {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i] = arguments[_i];
        }
        return pipeFromArray(operations)(this);
      };
      Observable2.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var value;
          _this.subscribe(function(x) {
            return value = x;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve(value);
          });
        });
      };
      Observable2.create = function(subscribe) {
        return new Observable2(subscribe);
      };
      return Observable2;
    }();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
var init_lift = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/lift.js"() {
    init_define_ngDevMode();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber;
var init_OperatorSubscriber = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_Subscriber();
    OperatorSubscriber = function(_super) {
      __extends(OperatorSubscriber2, _super);
      function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this.shouldUnsubscribe = shouldUnsubscribe;
        _this._next = onNext ? function(value) {
          try {
            onNext(value);
          } catch (err) {
            destination.error(err);
          }
        } : _super.prototype._next;
        _this._error = onError ? function(err) {
          try {
            onError(err);
          } catch (err2) {
            destination.error(err2);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._error;
        _this._complete = onComplete ? function() {
          try {
            onComplete();
          } catch (err) {
            destination.error(err);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._complete;
        return _this;
      }
      OperatorSubscriber2.prototype.unsubscribe = function() {
        var _a;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
          var closed_1 = this.closed;
          _super.prototype.unsubscribe.call(this);
          !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
        }
      };
      return OperatorSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}
var init_refCount = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/refCount.js"() {
    init_define_ngDevMode();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable;
var init_ConnectableObservable = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_Observable();
    init_Subscription();
    init_refCount();
    init_OperatorSubscriber();
    init_lift();
    ConnectableObservable = function(_super) {
      __extends(ConnectableObservable2, _super);
      function ConnectableObservable2(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._subject = null;
        _this._refCount = 0;
        _this._connection = null;
        if (hasLift(source)) {
          _this.lift = source.lift;
        }
        return _this;
      }
      ConnectableObservable2.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
      };
      ConnectableObservable2.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }
        return this._subject;
      };
      ConnectableObservable2.prototype._teardown = function() {
        this._refCount = 0;
        var _connection = this._connection;
        this._subject = this._connection = null;
        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
      };
      ConnectableObservable2.prototype.connect = function() {
        var _this = this;
        var connection = this._connection;
        if (!connection) {
          connection = this._connection = new Subscription();
          var subject_1 = this.getSubject();
          connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
            _this._teardown();
            subject_1.complete();
          }, function(err) {
            _this._teardown();
            subject_1.error(err);
          }, function() {
            return _this._teardown();
          })));
          if (connection.closed) {
            this._connection = null;
            connection = Subscription.EMPTY;
          }
        }
        return connection;
      };
      ConnectableObservable2.prototype.refCount = function() {
        return refCount()(this);
      };
      return ConnectableObservable2;
    }(Observable);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider;
var init_performanceTimestampProvider = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js"() {
    init_define_ngDevMode();
    performanceTimestampProvider = {
      now: function() {
        return (performanceTimestampProvider.delegate || performance).now();
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider;
var init_animationFrameProvider = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_Subscription();
    animationFrameProvider = {
      schedule: function(callback) {
        var request = requestAnimationFrame;
        var cancel = cancelAnimationFrame;
        var delegate = animationFrameProvider.delegate;
        if (delegate) {
          request = delegate.requestAnimationFrame;
          cancel = delegate.cancelAnimationFrame;
        }
        var handle = request(function(timestamp2) {
          cancel = void 0;
          callback(timestamp2);
        });
        return new Subscription(function() {
          return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
        });
      },
      requestAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
      },
      cancelAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  var schedule = animationFrameProvider.schedule;
  return new Observable(function(subscriber) {
    var subscription = new Subscription();
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var run = function(timestamp2) {
      var now = provider.now();
      subscriber.next({
        timestamp: timestampProvider ? now : timestamp2,
        elapsed: now - start
      });
      if (!subscriber.closed) {
        subscription.add(schedule(run));
      }
    };
    subscription.add(schedule(run));
    return subscription;
  });
}
var DEFAULT_ANIMATION_FRAMES;
var init_animationFrames = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js"() {
    init_define_ngDevMode();
    init_Observable();
    init_Subscription();
    init_performanceTimestampProvider();
    init_animationFrameProvider();
    DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError;
var init_ObjectUnsubscribedError = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js"() {
    init_define_ngDevMode();
    init_createErrorClass();
    ObjectUnsubscribedError = createErrorClass(function(_super) {
      return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = "ObjectUnsubscribedError";
        this.message = "object unsubscribed";
      };
    });
  }
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject, AnonymousSubject;
var init_Subject = __esm({
  "node_modules/rxjs/dist/esm5/internal/Subject.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_Observable();
    init_Subscription();
    init_ObjectUnsubscribedError();
    init_arrRemove();
    init_errorContext();
    Subject = function(_super) {
      __extends(Subject2, _super);
      function Subject2() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.currentObservers = null;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }
      Subject2.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject2.prototype._throwIfClosed = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
      };
      Subject2.prototype.next = function(value) {
        var _this = this;
        errorContext(function() {
          var e_1, _a;
          _this._throwIfClosed();
          if (!_this.isStopped) {
            if (!_this.currentObservers) {
              _this.currentObservers = Array.from(_this.observers);
            }
            try {
              for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var observer = _c.value;
                observer.next(value);
              }
            } catch (e_1_1) {
              e_1 = {
                error: e_1_1
              };
            } finally {
              try {
                if (_c && !_c.done && (_a = _b.return))
                  _a.call(_b);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }
        });
      };
      Subject2.prototype.error = function(err) {
        var _this = this;
        errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.hasError = _this.isStopped = true;
            _this.thrownError = err;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().error(err);
            }
          }
        });
      };
      Subject2.prototype.complete = function() {
        var _this = this;
        errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.isStopped = true;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().complete();
            }
          }
        });
      };
      Subject2.prototype.unsubscribe = function() {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
      };
      Object.defineProperty(Subject2.prototype, "observed", {
        get: function() {
          var _a;
          return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
        },
        enumerable: false,
        configurable: true
      });
      Subject2.prototype._trySubscribe = function(subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
      };
      Subject2.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
      };
      Subject2.prototype._innerSubscribe = function(subscriber) {
        var _this = this;
        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
        if (hasError || isStopped) {
          return EMPTY_SUBSCRIPTION;
        }
        this.currentObservers = null;
        observers.push(subscriber);
        return new Subscription(function() {
          _this.currentObservers = null;
          arrRemove(observers, subscriber);
        });
      };
      Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped) {
          subscriber.complete();
        }
      };
      Subject2.prototype.asObservable = function() {
        var observable2 = new Observable();
        observable2.source = this;
        return observable2;
      };
      Subject2.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
      };
      return Subject2;
    }(Observable);
    AnonymousSubject = function(_super) {
      __extends(AnonymousSubject2, _super);
      function AnonymousSubject2(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
      }
      AnonymousSubject2.prototype.next = function(value) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
      };
      AnonymousSubject2.prototype.error = function(err) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
      };
      AnonymousSubject2.prototype.complete = function() {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
      };
      AnonymousSubject2.prototype._subscribe = function(subscriber) {
        var _a, _b;
        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
      };
      return AnonymousSubject2;
    }(Subject);
  }
});

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject;
var init_BehaviorSubject = __esm({
  "node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_Subject();
    BehaviorSubject = function(_super) {
      __extends(BehaviorSubject2, _super);
      function BehaviorSubject2(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
      }
      Object.defineProperty(BehaviorSubject2.prototype, "value", {
        get: function() {
          return this.getValue();
        },
        enumerable: false,
        configurable: true
      });
      BehaviorSubject2.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
      };
      BehaviorSubject2.prototype.getValue = function() {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
        if (hasError) {
          throw thrownError;
        }
        this._throwIfClosed();
        return _value;
      };
      BehaviorSubject2.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
      };
      return BehaviorSubject2;
    }(Subject);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider;
var init_dateTimestampProvider = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js"() {
    init_define_ngDevMode();
    dateTimestampProvider = {
      now: function() {
        return (dateTimestampProvider.delegate || Date).now();
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject;
var init_ReplaySubject = __esm({
  "node_modules/rxjs/dist/esm5/internal/ReplaySubject.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_Subject();
    init_dateTimestampProvider();
    ReplaySubject = function(_super) {
      __extends(ReplaySubject2, _super);
      function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
        if (_bufferSize === void 0) {
          _bufferSize = Infinity;
        }
        if (_windowTime === void 0) {
          _windowTime = Infinity;
        }
        if (_timestampProvider === void 0) {
          _timestampProvider = dateTimestampProvider;
        }
        var _this = _super.call(this) || this;
        _this._bufferSize = _bufferSize;
        _this._windowTime = _windowTime;
        _this._timestampProvider = _timestampProvider;
        _this._buffer = [];
        _this._infiniteTimeWindow = true;
        _this._infiniteTimeWindow = _windowTime === Infinity;
        _this._bufferSize = Math.max(1, _bufferSize);
        _this._windowTime = Math.max(1, _windowTime);
        return _this;
      }
      ReplaySubject2.prototype.next = function(value) {
        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
        if (!isStopped) {
          _buffer.push(value);
          !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
        }
        this._trimBuffer();
        _super.prototype.next.call(this, value);
      };
      ReplaySubject2.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._trimBuffer();
        var subscription = this._innerSubscribe(subscriber);
        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
        var copy = _buffer.slice();
        for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
          subscriber.next(copy[i]);
        }
        this._checkFinalizedStatuses(subscriber);
        return subscription;
      };
      ReplaySubject2.prototype._trimBuffer = function() {
        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
        if (!_infiniteTimeWindow) {
          var now = _timestampProvider.now();
          var last3 = 0;
          for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
            last3 = i;
          }
          last3 && _buffer.splice(0, last3 + 1);
        }
      };
      return ReplaySubject2;
    }(Subject);
  }
});

// node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject;
var init_AsyncSubject = __esm({
  "node_modules/rxjs/dist/esm5/internal/AsyncSubject.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_Subject();
    AsyncSubject = function(_super) {
      __extends(AsyncSubject2, _super);
      function AsyncSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._value = null;
        _this._hasValue = false;
        _this._isComplete = false;
        return _this;
      }
      AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped || _isComplete) {
          _hasValue && subscriber.next(_value);
          subscriber.complete();
        }
      };
      AsyncSubject2.prototype.next = function(value) {
        if (!this.isStopped) {
          this._value = value;
          this._hasValue = true;
        }
      };
      AsyncSubject2.prototype.complete = function() {
        var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
        if (!_isComplete) {
          this._isComplete = true;
          _hasValue && _super.prototype.next.call(this, _value);
          _super.prototype.complete.call(this);
        }
      };
      return AsyncSubject2;
    }(Subject);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action;
var init_Action = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/Action.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_Subscription();
    Action = function(_super) {
      __extends(Action2, _super);
      function Action2(scheduler, work) {
        return _super.call(this) || this;
      }
      Action2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return this;
      };
      return Action2;
    }(Subscription);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider;
var init_intervalProvider = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    intervalProvider = {
      setInterval: function(handler, timeout2) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = intervalProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
          return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
        }
        return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
      },
      clearInterval: function(handle) {
        var delegate = intervalProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction;
var init_AsyncAction = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_Action();
    init_intervalProvider();
    init_arrRemove();
    AsyncAction = function(_super) {
      __extends(AsyncAction2, _super);
      function AsyncAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
      }
      AsyncAction2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (this.closed) {
          return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, delay2);
        }
        this.pending = true;
        this.delay = delay2;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay2);
        return this;
      };
      AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
      };
      AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 != null && this.delay === delay2 && this.pending === false) {
          return id;
        }
        intervalProvider.clearInterval(id);
        return void 0;
      };
      AsyncAction2.prototype.execute = function(state, delay2) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        var error2 = this._execute(state, delay2);
        if (error2) {
          return error2;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      };
      AsyncAction2.prototype._execute = function(state, _delay) {
        var errored = false;
        var errorValue;
        try {
          this.work(state);
        } catch (e) {
          errored = true;
          errorValue = e ? e : new Error("Scheduled action threw falsy error");
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      };
      AsyncAction2.prototype.unsubscribe = function() {
        if (!this.closed) {
          var _a = this, id = _a.id, scheduler = _a.scheduler;
          var actions = scheduler.actions;
          this.work = this.state = this.scheduler = null;
          this.pending = false;
          arrRemove(actions, this);
          if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
          }
          this.delay = null;
          _super.prototype.unsubscribe.call(this);
        }
      };
      return AsyncAction2;
    }(Action);
  }
});

// node_modules/rxjs/dist/esm5/internal/util/Immediate.js
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var nextHandle, resolved, activeHandles, Immediate;
var init_Immediate = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/Immediate.js"() {
    init_define_ngDevMode();
    nextHandle = 1;
    activeHandles = {};
    Immediate = {
      setImmediate: function(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        if (!resolved) {
          resolved = Promise.resolve();
        }
        resolved.then(function() {
          return findAndClearHandle(handle) && cb();
        });
        return handle;
      },
      clearImmediate: function(handle) {
        findAndClearHandle(handle);
      }
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate, clearImmediate, immediateProvider;
var init_immediateProvider = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_Immediate();
    setImmediate = Immediate.setImmediate;
    clearImmediate = Immediate.clearImmediate;
    immediateProvider = {
      setImmediate: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
      },
      clearImmediate: function(handle) {
        var delegate = immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction;
var init_AsapAction = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_AsyncAction();
    init_immediateProvider();
    AsapAction = function(_super) {
      __extends(AsapAction2, _super);
      function AsapAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
      };
      AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
        }
        if (!scheduler.actions.some(function(action) {
          return action.id === id;
        })) {
          immediateProvider.clearImmediate(id);
          scheduler._scheduled = void 0;
        }
        return void 0;
      };
      return AsapAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler;
var init_Scheduler = __esm({
  "node_modules/rxjs/dist/esm5/internal/Scheduler.js"() {
    init_define_ngDevMode();
    init_dateTimestampProvider();
    Scheduler = function() {
      function Scheduler2(schedulerActionCtor, now) {
        if (now === void 0) {
          now = Scheduler2.now;
        }
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now;
      }
      Scheduler2.prototype.schedule = function(work, delay2, state) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return new this.schedulerActionCtor(this, work).schedule(state, delay2);
      };
      Scheduler2.now = dateTimestampProvider.now;
      return Scheduler2;
    }();
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler;
var init_AsyncScheduler = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_Scheduler();
    AsyncScheduler = function(_super) {
      __extends(AsyncScheduler2, _super);
      function AsyncScheduler2(SchedulerAction, now) {
        if (now === void 0) {
          now = Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, now) || this;
        _this.actions = [];
        _this._active = false;
        _this._scheduled = void 0;
        return _this;
      }
      AsyncScheduler2.prototype.flush = function(action) {
        var actions = this.actions;
        if (this._active) {
          actions.push(action);
          return;
        }
        var error2;
        this._active = true;
        do {
          if (error2 = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this._active = false;
        if (error2) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error2;
        }
      };
      return AsyncScheduler2;
    }(Scheduler);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler;
var init_AsapScheduler = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_AsyncScheduler();
    AsapScheduler = function(_super) {
      __extends(AsapScheduler2, _super);
      function AsapScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AsapScheduler2.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error2;
        action = action || actions.shift();
        do {
          if (error2 = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error2) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error2;
        }
      };
      return AsapScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler;
var init_asap = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/asap.js"() {
    init_define_ngDevMode();
    init_AsapAction();
    init_AsapScheduler();
    asapScheduler = new AsapScheduler(AsapAction);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler, async;
var init_async = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/async.js"() {
    init_define_ngDevMode();
    init_AsyncAction();
    init_AsyncScheduler();
    asyncScheduler = new AsyncScheduler(AsyncAction);
    async = asyncScheduler;
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction;
var init_QueueAction = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_AsyncAction();
    QueueAction = function(_super) {
      __extends(QueueAction2, _super);
      function QueueAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      QueueAction2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 > 0) {
          return _super.prototype.schedule.call(this, state, delay2);
        }
        this.delay = delay2;
        this.state = state;
        this.scheduler.flush(this);
        return this;
      };
      QueueAction2.prototype.execute = function(state, delay2) {
        return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
      };
      QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
        }
        return scheduler.flush(this);
      };
      return QueueAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler;
var init_QueueScheduler = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_AsyncScheduler();
    QueueScheduler = function(_super) {
      __extends(QueueScheduler2, _super);
      function QueueScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return QueueScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler;
var init_queue = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/queue.js"() {
    init_define_ngDevMode();
    init_QueueAction();
    init_QueueScheduler();
    queueScheduler = new QueueScheduler(QueueAction);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction;
var init_AnimationFrameAction = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_AsyncAction();
    init_animationFrameProvider();
    AnimationFrameAction = function(_super) {
      __extends(AnimationFrameAction2, _super);
      function AnimationFrameAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
          return scheduler.flush(void 0);
        }));
      };
      AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
        }
        if (!scheduler.actions.some(function(action) {
          return action.id === id;
        })) {
          animationFrameProvider.cancelAnimationFrame(id);
          scheduler._scheduled = void 0;
        }
        return void 0;
      };
      return AnimationFrameAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler;
var init_AnimationFrameScheduler = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_AsyncScheduler();
    AnimationFrameScheduler = function(_super) {
      __extends(AnimationFrameScheduler2, _super);
      function AnimationFrameScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AnimationFrameScheduler2.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error2;
        action = action || actions.shift();
        do {
          if (error2 = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error2) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error2;
        }
      };
      return AnimationFrameScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler;
var init_animationFrame = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js"() {
    init_define_ngDevMode();
    init_AnimationFrameAction();
    init_AnimationFrameScheduler();
    animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler, VirtualAction;
var init_VirtualTimeScheduler = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_AsyncAction();
    init_Subscription();
    init_AsyncScheduler();
    VirtualTimeScheduler = function(_super) {
      __extends(VirtualTimeScheduler2, _super);
      function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
        if (schedulerActionCtor === void 0) {
          schedulerActionCtor = VirtualAction;
        }
        if (maxFrames === void 0) {
          maxFrames = Infinity;
        }
        var _this = _super.call(this, schedulerActionCtor, function() {
          return _this.frame;
        }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
      }
      VirtualTimeScheduler2.prototype.flush = function() {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error2;
        var action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
          actions.shift();
          this.frame = action.delay;
          if (error2 = action.execute(action.state, action.delay)) {
            break;
          }
        }
        if (error2) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error2;
        }
      };
      VirtualTimeScheduler2.frameTimeFactor = 10;
      return VirtualTimeScheduler2;
    }(AsyncScheduler);
    VirtualAction = function(_super) {
      __extends(VirtualAction2, _super);
      function VirtualAction2(scheduler, work, index) {
        if (index === void 0) {
          index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
      }
      VirtualAction2.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (Number.isFinite(delay2)) {
          if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay2);
          }
          this.active = false;
          var action = new VirtualAction2(this.scheduler, this.work);
          this.add(action);
          return action.schedule(state, delay2);
        } else {
          return Subscription.EMPTY;
        }
      };
      VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        this.delay = scheduler.frame + delay2;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction2.sortActions);
        return true;
      };
      VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return void 0;
      };
      VirtualAction2.prototype._execute = function(state, delay2) {
        if (this.active === true) {
          return _super.prototype._execute.call(this, state, delay2);
        }
      };
      VirtualAction2.sortActions = function(a, b) {
        if (a.delay === b.delay) {
          if (a.index === b.index) {
            return 0;
          } else if (a.index > b.index) {
            return 1;
          } else {
            return -1;
          }
        } else if (a.delay > b.delay) {
          return 1;
        } else {
          return -1;
        }
      };
      return VirtualAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY;
var init_empty = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/empty.js"() {
    init_define_ngDevMode();
    init_Observable();
    EMPTY = new Observable(function(subscriber) {
      return subscriber.complete();
    });
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}
var init_isScheduler = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isScheduler.js"() {
    init_define_ngDevMode();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}
var init_args = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/args.js"() {
    init_define_ngDevMode();
    init_isFunction();
    init_isScheduler();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike;
var init_isArrayLike = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js"() {
    init_define_ngDevMode();
    isArrayLike = function(x) {
      return x && typeof x.length === "number" && typeof x !== "function";
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}
var init_isPromise = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isPromise.js"() {
    init_define_ngDevMode();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}
var init_isInteropObservable = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js"() {
    init_define_ngDevMode();
    init_observable();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
var init_isAsyncIterable = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js"() {
    init_define_ngDevMode();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
var init_throwUnobservableError = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js"() {
    init_define_ngDevMode();
  }
});

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator;
var init_iterator = __esm({
  "node_modules/rxjs/dist/esm5/internal/symbol/iterator.js"() {
    init_define_ngDevMode();
    iterator = getSymbolIterator();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}
var init_isIterable = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isIterable.js"() {
    init_define_ngDevMode();
    init_iterator();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false)
            return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
var init_isReadableStreamLike = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise2) {
  return new Observable(function(subscriber) {
    promise2.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = {
            error: e_2_1
          };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
var init_innerFrom = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_isArrayLike();
    init_isPromise();
    init_Observable();
    init_isInteropObservable();
    init_isAsyncIterable();
    init_throwUnobservableError();
    init_isIterable();
    init_isReadableStreamLike();
    init_isFunction();
    init_reportUnhandledError();
    init_observable();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}
var init_executeSchedule = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js"() {
    init_define_ngDevMode();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}
var init_observeOn = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/observeOn.js"() {
    init_define_ngDevMode();
    init_executeSchedule();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}
var init_subscribeOn = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js"() {
    init_define_ngDevMode();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
var init_scheduleObservable = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js"() {
    init_define_ngDevMode();
    init_innerFrom();
    init_observeOn();
    init_subscribeOn();
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}
var init_schedulePromise = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js"() {
    init_define_ngDevMode();
    init_innerFrom();
    init_observeOn();
    init_subscribeOn();
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
var init_scheduleArray = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js"() {
    init_define_ngDevMode();
    init_Observable();
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}
var init_scheduleIterable = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js"() {
    init_define_ngDevMode();
    init_Observable();
    init_iterator();
    init_isFunction();
    init_executeSchedule();
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
var init_scheduleAsyncIterable = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js"() {
    init_define_ngDevMode();
    init_Observable();
    init_executeSchedule();
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}
var init_scheduleReadableStreamLike = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js"() {
    init_define_ngDevMode();
    init_scheduleAsyncIterable();
    init_isReadableStreamLike();
  }
});

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}
var init_scheduled = __esm({
  "node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js"() {
    init_define_ngDevMode();
    init_scheduleObservable();
    init_schedulePromise();
    init_scheduleArray();
    init_scheduleIterable();
    init_scheduleAsyncIterable();
    init_isInteropObservable();
    init_isPromise();
    init_isArrayLike();
    init_isIterable();
    init_isAsyncIterable();
    init_throwUnobservableError();
    init_isReadableStreamLike();
    init_scheduleReadableStreamLike();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}
var init_from = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/from.js"() {
    init_define_ngDevMode();
    init_scheduled();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}
var init_of = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/of.js"() {
    init_define_ngDevMode();
    init_args();
    init_from();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}
var init_throwError = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/throwError.js"() {
    init_define_ngDevMode();
    init_Observable();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/Notification.js
function observeNotification(notification, observer) {
  var _a, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error2 = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error2) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}
var NotificationKind, Notification;
var init_Notification = __esm({
  "node_modules/rxjs/dist/esm5/internal/Notification.js"() {
    init_define_ngDevMode();
    init_empty();
    init_of();
    init_throwError();
    init_isFunction();
    (function(NotificationKind2) {
      NotificationKind2["NEXT"] = "N";
      NotificationKind2["ERROR"] = "E";
      NotificationKind2["COMPLETE"] = "C";
    })(NotificationKind || (NotificationKind = {}));
    Notification = function() {
      function Notification2(kind, value, error2) {
        this.kind = kind;
        this.value = value;
        this.error = error2;
        this.hasValue = kind === "N";
      }
      Notification2.prototype.observe = function(observer) {
        return observeNotification(this, observer);
      };
      Notification2.prototype.do = function(nextHandler, errorHandler2, completeHandler) {
        var _a = this, kind = _a.kind, value = _a.value, error2 = _a.error;
        return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler2 === null || errorHandler2 === void 0 ? void 0 : errorHandler2(error2) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
      };
      Notification2.prototype.accept = function(nextOrObserver, error2, complete) {
        var _a;
        return isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error2, complete);
      };
      Notification2.prototype.toObservable = function() {
        var _a = this, kind = _a.kind, value = _a.value, error2 = _a.error;
        var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
          return error2;
        }) : kind === "C" ? EMPTY : 0;
        if (!result) {
          throw new TypeError("Unexpected notification kind " + kind);
        }
        return result;
      };
      Notification2.createNext = function(value) {
        return new Notification2("N", value);
      };
      Notification2.createError = function(err) {
        return new Notification2("E", void 0, err);
      };
      Notification2.createComplete = function() {
        return Notification2.completeNotification;
      };
      Notification2.completeNotification = new Notification2("C");
      return Notification2;
    }();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isObservable.js
var init_isObservable = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isObservable.js"() {
    init_define_ngDevMode();
    init_Observable();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError;
var init_EmptyError = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/EmptyError.js"() {
    init_define_ngDevMode();
    init_createErrorClass();
    EmptyError = createErrorClass(function(_super) {
      return function EmptyErrorImpl() {
        _super(this);
        this.name = "EmptyError";
        this.message = "no elements in sequence";
      };
    });
  }
});

// node_modules/rxjs/dist/esm5/internal/lastValueFrom.js
var init_lastValueFrom = __esm({
  "node_modules/rxjs/dist/esm5/internal/lastValueFrom.js"() {
    init_define_ngDevMode();
    init_EmptyError();
  }
});

// node_modules/rxjs/dist/esm5/internal/firstValueFrom.js
var init_firstValueFrom = __esm({
  "node_modules/rxjs/dist/esm5/internal/firstValueFrom.js"() {
    init_define_ngDevMode();
    init_EmptyError();
    init_Subscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError;
var init_ArgumentOutOfRangeError = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js"() {
    init_define_ngDevMode();
    init_createErrorClass();
    ArgumentOutOfRangeError = createErrorClass(function(_super) {
      return function ArgumentOutOfRangeErrorImpl() {
        _super(this);
        this.name = "ArgumentOutOfRangeError";
        this.message = "argument out of range";
      };
    });
  }
});

// node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError;
var init_NotFoundError = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js"() {
    init_define_ngDevMode();
    init_createErrorClass();
    NotFoundError = createErrorClass(function(_super) {
      return function NotFoundErrorImpl(message) {
        _super(this);
        this.name = "NotFoundError";
        this.message = message;
      };
    });
  }
});

// node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError;
var init_SequenceError = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/SequenceError.js"() {
    init_define_ngDevMode();
    init_createErrorClass();
    SequenceError = createErrorClass(function(_super) {
      return function SequenceErrorImpl(message) {
        _super(this);
        this.name = "SequenceError";
        this.message = message;
      };
    });
  }
});

// node_modules/rxjs/dist/esm5/internal/util/isDate.js
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}
var init_isDate = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/isDate.js"() {
    init_define_ngDevMode();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/timeout.js
function timeout(config2, schedulerArg) {
  var _a = isValidDate(config2) ? {
    first: config2
  } : typeof config2 === "number" ? {
    each: config2
  } : config2, first2 = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
  if (first2 == null && each == null) {
    throw new TypeError("No timeout provided.");
  }
  return operate(function(source, subscriber) {
    var originalSourceSubscription;
    var timerSubscription;
    var lastValue = null;
    var seen = 0;
    var startTimer = function(delay2) {
      timerSubscription = executeSchedule(subscriber, scheduler, function() {
        try {
          originalSourceSubscription.unsubscribe();
          innerFrom(_with({
            meta,
            lastValue,
            seen
          })).subscribe(subscriber);
        } catch (err) {
          subscriber.error(err);
        }
      }, delay2);
    };
    originalSourceSubscription = source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
      seen++;
      subscriber.next(lastValue = value);
      each > 0 && startTimer(each);
    }, void 0, void 0, function() {
      if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
        timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
      }
      lastValue = null;
    }));
    !seen && startTimer(first2 != null ? typeof first2 === "number" ? first2 : +first2 - scheduler.now() : each);
  });
}
function timeoutErrorFactory(info) {
  throw new TimeoutError(info);
}
var TimeoutError;
var init_timeout = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/timeout.js"() {
    init_define_ngDevMode();
    init_async();
    init_isDate();
    init_lift();
    init_innerFrom();
    init_createErrorClass();
    init_OperatorSubscriber();
    init_executeSchedule();
    TimeoutError = createErrorClass(function(_super) {
      return function TimeoutErrorImpl(info) {
        if (info === void 0) {
          info = null;
        }
        _super(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        this.info = info;
      };
    });
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/map.js
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}
var init_map = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/map.js"() {
    init_define_ngDevMode();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
function callOrApply(fn2, args) {
  return isArray(args) ? fn2.apply(void 0, __spreadArray([], __read(args))) : fn2(args);
}
function mapOneOrManyArgs(fn2) {
  return map(function(args) {
    return callOrApply(fn2, args);
  });
}
var isArray;
var init_mapOneOrManyArgs = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_map();
    isArray = Array.isArray;
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/bindCallbackInternals.js
var init_bindCallbackInternals = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/bindCallbackInternals.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_isScheduler();
    init_Observable();
    init_subscribeOn();
    init_mapOneOrManyArgs();
    init_observeOn();
    init_AsyncSubject();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/bindCallback.js
var init_bindCallback = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/bindCallback.js"() {
    init_define_ngDevMode();
    init_bindCallbackInternals();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/bindNodeCallback.js
var init_bindNodeCallback = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/bindNodeCallback.js"() {
    init_define_ngDevMode();
    init_bindCallbackInternals();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray2(first_1)) {
      return {
        args: first_1,
        keys: null
      };
    }
    if (isPOJO(first_1)) {
      var keys = getKeys(first_1);
      return {
        args: keys.map(function(key) {
          return first_1[key];
        }),
        keys
      };
    }
  }
  return {
    args,
    keys: null
  };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}
var isArray2, getPrototypeOf, objectProto, getKeys;
var init_argsArgArrayOrObject = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js"() {
    init_define_ngDevMode();
    isArray2 = Array.isArray;
    getPrototypeOf = Object.getPrototypeOf;
    objectProto = Object.prototype;
    getKeys = Object.keys;
  }
});

// node_modules/rxjs/dist/esm5/internal/util/createObject.js
function createObject(keys, values) {
  return keys.reduce(function(result, key, i) {
    return result[key] = values[i], result;
  }, {});
}
var init_createObject = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/createObject.js"() {
    init_define_ngDevMode();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
function combineLatest() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
  if (observables.length === 0) {
    return from([], scheduler);
  }
  var result = new Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
    return createObject(keys, values);
  } : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function(i2) {
        maybeSchedule(scheduler, function() {
          var source = from(observables[i2], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i2] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i = 0; i < length; i++) {
        _loop_1(i);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}
var init_combineLatest = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js"() {
    init_define_ngDevMode();
    init_Observable();
    init_argsArgArrayOrObject();
    init_from();
    init_identity();
    init_mapOneOrManyArgs();
    init_args();
    init_createObject();
    init_OperatorSubscriber();
    init_executeSchedule();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}
var init_mergeInternals = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js"() {
    init_define_ngDevMode();
    init_innerFrom();
    init_executeSchedule();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a, i) {
      return map(function(b, ii) {
        return resultSelector(a, b, i, ii);
      })(innerFrom(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}
var init_mergeMap = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js"() {
    init_define_ngDevMode();
    init_map();
    init_innerFrom();
    init_lift();
    init_mergeInternals();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}
var init_mergeAll = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js"() {
    init_define_ngDevMode();
    init_mergeMap();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}
var init_concatAll = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/concatAll.js"() {
    init_define_ngDevMode();
    init_mergeAll();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/concat.js
function concat() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return concatAll()(from(args, popScheduler(args)));
}
var init_concat = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/concat.js"() {
    init_define_ngDevMode();
    init_concatAll();
    init_args();
    init_from();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/defer.js
var init_defer = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/defer.js"() {
    init_define_ngDevMode();
    init_Observable();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/connectable.js
var init_connectable = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/connectable.js"() {
    init_define_ngDevMode();
    init_Subject();
    init_Observable();
    init_defer();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/forkJoin.js
function forkJoin() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
  var result = new Observable(function(subscriber) {
    var length = sources.length;
    if (!length) {
      subscriber.complete();
      return;
    }
    var values = new Array(length);
    var remainingCompletions = length;
    var remainingEmissions = length;
    var _loop_1 = function(sourceIndex2) {
      var hasValue = false;
      innerFrom(sources[sourceIndex2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (!hasValue) {
          hasValue = true;
          remainingEmissions--;
        }
        values[sourceIndex2] = value;
      }, function() {
        return remainingCompletions--;
      }, void 0, function() {
        if (!remainingCompletions || !hasValue) {
          if (!remainingEmissions) {
            subscriber.next(keys ? createObject(keys, values) : values);
          }
          subscriber.complete();
        }
      }));
    };
    for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
      _loop_1(sourceIndex);
    }
  });
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
var init_forkJoin = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/forkJoin.js"() {
    init_define_ngDevMode();
    init_Observable();
    init_argsArgArrayOrObject();
    init_innerFrom();
    init_args();
    init_OperatorSubscriber();
    init_mapOneOrManyArgs();
    init_createObject();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js
var init_fromEvent = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_innerFrom();
    init_Observable();
    init_mergeMap();
    init_isArrayLike();
    init_isFunction();
    init_mapOneOrManyArgs();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/fromEventPattern.js
var init_fromEventPattern = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/fromEventPattern.js"() {
    init_define_ngDevMode();
    init_Observable();
    init_isFunction();
    init_mapOneOrManyArgs();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/generate.js
var init_generate = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/generate.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_identity();
    init_isScheduler();
    init_defer();
    init_scheduleIterable();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/iif.js
var init_iif = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/iif.js"() {
    init_define_ngDevMode();
    init_defer();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/timer.js
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}
var init_timer = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/timer.js"() {
    init_define_ngDevMode();
    init_Observable();
    init_async();
    init_isScheduler();
    init_isDate();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/interval.js
function interval(period, scheduler) {
  if (period === void 0) {
    period = 0;
  }
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  if (period < 0) {
    period = 0;
  }
  return timer(period, period, scheduler);
}
var init_interval = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/interval.js"() {
    init_define_ngDevMode();
    init_async();
    init_timer();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/merge.js
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}
var init_merge = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/merge.js"() {
    init_define_ngDevMode();
    init_mergeAll();
    init_innerFrom();
    init_empty();
    init_args();
    init_from();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER;
var init_never = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/never.js"() {
    init_define_ngDevMode();
    init_Observable();
    init_noop();
    NEVER = new Observable(noop);
  }
});

// node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
function argsOrArgArray(args) {
  return args.length === 1 && isArray3(args[0]) ? args[0] : args;
}
var isArray3;
var init_argsOrArgArray = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js"() {
    init_define_ngDevMode();
    isArray3 = Array.isArray;
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/onErrorResumeNext.js
function onErrorResumeNext() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  var nextSources = argsOrArgArray(sources);
  return operate(function(source, subscriber) {
    var remaining = __spreadArray([source], __read(nextSources));
    var subscribeNext = function() {
      if (!subscriber.closed) {
        if (remaining.length > 0) {
          var nextSource = void 0;
          try {
            nextSource = innerFrom(remaining.shift());
          } catch (err) {
            subscribeNext();
            return;
          }
          var innerSub = createOperatorSubscriber(subscriber, void 0, noop, noop);
          nextSource.subscribe(innerSub);
          innerSub.add(subscribeNext);
        } else {
          subscriber.complete();
        }
      }
    };
    subscribeNext();
  });
}
var init_onErrorResumeNext = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/onErrorResumeNext.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_lift();
    init_innerFrom();
    init_argsOrArgArray();
    init_OperatorSubscriber();
    init_noop();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/onErrorResumeNext.js
var init_onErrorResumeNext2 = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/onErrorResumeNext.js"() {
    init_define_ngDevMode();
    init_empty();
    init_onErrorResumeNext();
    init_argsOrArgArray();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/pairs.js
var init_pairs = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/pairs.js"() {
    init_define_ngDevMode();
    init_from();
  }
});

// node_modules/rxjs/dist/esm5/internal/util/not.js
function not(pred, thisArg) {
  return function(value, index) {
    return !pred.call(thisArg, value, index);
  };
}
var init_not = __esm({
  "node_modules/rxjs/dist/esm5/internal/util/not.js"() {
    init_define_ngDevMode();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/filter.js
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}
var init_filter = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/filter.js"() {
    init_define_ngDevMode();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/partition.js
var init_partition = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/partition.js"() {
    init_define_ngDevMode();
    init_not();
    init_filter();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/race.js
function raceInit(sources) {
  return function(subscriber) {
    var subscriptions = [];
    var _loop_1 = function(i2) {
      subscriptions.push(innerFrom(sources[i2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (subscriptions) {
          for (var s = 0; s < subscriptions.length; s++) {
            s !== i2 && subscriptions[s].unsubscribe();
          }
          subscriptions = null;
        }
        subscriber.next(value);
      })));
    };
    for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
      _loop_1(i);
    }
  };
}
var init_race = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/race.js"() {
    init_define_ngDevMode();
    init_Observable();
    init_innerFrom();
    init_argsOrArgArray();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/range.js
var init_range = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/range.js"() {
    init_define_ngDevMode();
    init_Observable();
    init_empty();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/using.js
var init_using = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/using.js"() {
    init_define_ngDevMode();
    init_Observable();
    init_innerFrom();
    init_empty();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/zip.js
function zip() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var resultSelector = popResultSelector(args);
  var sources = argsOrArgArray(args);
  return sources.length ? new Observable(function(subscriber) {
    var buffers = sources.map(function() {
      return [];
    });
    var completed = sources.map(function() {
      return false;
    });
    subscriber.add(function() {
      buffers = completed = null;
    });
    var _loop_1 = function(sourceIndex2) {
      innerFrom(sources[sourceIndex2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        buffers[sourceIndex2].push(value);
        if (buffers.every(function(buffer2) {
          return buffer2.length;
        })) {
          var result = buffers.map(function(buffer2) {
            return buffer2.shift();
          });
          subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray([], __read(result))) : result);
          if (buffers.some(function(buffer2, i) {
            return !buffer2.length && completed[i];
          })) {
            subscriber.complete();
          }
        }
      }, function() {
        completed[sourceIndex2] = true;
        !buffers[sourceIndex2].length && subscriber.complete();
      }));
    };
    for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
      _loop_1(sourceIndex);
    }
    return function() {
      buffers = completed = null;
    };
  }) : EMPTY;
}
var init_zip = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/zip.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_Observable();
    init_innerFrom();
    init_argsOrArgArray();
    init_empty();
    init_OperatorSubscriber();
    init_args();
  }
});

// node_modules/rxjs/dist/esm5/internal/types.js
var init_types = __esm({
  "node_modules/rxjs/dist/esm5/internal/types.js"() {
    init_define_ngDevMode();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/audit.js
function audit(durationSelector) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    var lastValue = null;
    var durationSubscriber = null;
    var isComplete = false;
    var endDuration = function() {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      durationSubscriber = null;
      if (hasValue) {
        hasValue = false;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
      isComplete && subscriber.complete();
    };
    var cleanupDuration = function() {
      durationSubscriber = null;
      isComplete && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      lastValue = value;
      if (!durationSubscriber) {
        innerFrom(durationSelector(value)).subscribe(durationSubscriber = createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
      }
    }, function() {
      isComplete = true;
      (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
    }));
  });
}
var init_audit = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/audit.js"() {
    init_define_ngDevMode();
    init_lift();
    init_innerFrom();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/auditTime.js
function auditTime(duration, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return audit(function() {
    return timer(duration, scheduler);
  });
}
var init_auditTime = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/auditTime.js"() {
    init_define_ngDevMode();
    init_async();
    init_audit();
    init_timer();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/buffer.js
function buffer(closingNotifier) {
  return operate(function(source, subscriber) {
    var currentBuffer = [];
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return currentBuffer.push(value);
    }, function() {
      subscriber.next(currentBuffer);
      subscriber.complete();
    }));
    closingNotifier.subscribe(createOperatorSubscriber(subscriber, function() {
      var b = currentBuffer;
      currentBuffer = [];
      subscriber.next(b);
    }, noop));
    return function() {
      currentBuffer = null;
    };
  });
}
var init_buffer = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/buffer.js"() {
    init_define_ngDevMode();
    init_lift();
    init_noop();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/bufferCount.js
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }
  startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
  return operate(function(source, subscriber) {
    var buffers = [];
    var count2 = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a, e_2, _b;
      var toEmit = null;
      if (count2++ % startBufferEvery === 0) {
        buffers.push([]);
      }
      try {
        for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
          var buffer2 = buffers_1_1.value;
          buffer2.push(value);
          if (bufferSize <= buffer2.length) {
            toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
            toEmit.push(buffer2);
          }
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
            _a.call(buffers_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (toEmit) {
        try {
          for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
            var buffer2 = toEmit_1_1.value;
            arrRemove(buffers, buffer2);
            subscriber.next(buffer2);
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return))
              _b.call(toEmit_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
    }, function() {
      var e_3, _a;
      try {
        for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
          var buffer2 = buffers_2_1.value;
          subscriber.next(buffer2);
        }
      } catch (e_3_1) {
        e_3 = {
          error: e_3_1
        };
      } finally {
        try {
          if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return))
            _a.call(buffers_2);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      subscriber.complete();
    }, void 0, function() {
      buffers = null;
    }));
  });
}
var init_bufferCount = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/bufferCount.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_lift();
    init_OperatorSubscriber();
    init_arrRemove();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/bufferTime.js
function bufferTime(bufferTimeSpan) {
  var _a, _b;
  var otherArgs = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    otherArgs[_i - 1] = arguments[_i];
  }
  var scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;
  var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
  var maxBufferSize = otherArgs[1] || Infinity;
  return operate(function(source, subscriber) {
    var bufferRecords = [];
    var restartOnEmit = false;
    var emit = function(record) {
      var buffer2 = record.buffer, subs = record.subs;
      subs.unsubscribe();
      arrRemove(bufferRecords, record);
      subscriber.next(buffer2);
      restartOnEmit && startBuffer();
    };
    var startBuffer = function() {
      if (bufferRecords) {
        var subs = new Subscription();
        subscriber.add(subs);
        var buffer2 = [];
        var record_1 = {
          buffer: buffer2,
          subs
        };
        bufferRecords.push(record_1);
        executeSchedule(subs, scheduler, function() {
          return emit(record_1);
        }, bufferTimeSpan);
      }
    };
    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
      executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
    } else {
      restartOnEmit = true;
    }
    startBuffer();
    var bufferTimeSubscriber = createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a2;
      var recordsCopy = bufferRecords.slice();
      try {
        for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
          var record = recordsCopy_1_1.value;
          var buffer2 = record.buffer;
          buffer2.push(value);
          maxBufferSize <= buffer2.length && emit(record);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return))
            _a2.call(recordsCopy_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }, function() {
      while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
        subscriber.next(bufferRecords.shift().buffer);
      }
      bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
      subscriber.complete();
      subscriber.unsubscribe();
    }, void 0, function() {
      return bufferRecords = null;
    });
    source.subscribe(bufferTimeSubscriber);
  });
}
var init_bufferTime = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/bufferTime.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_Subscription();
    init_lift();
    init_OperatorSubscriber();
    init_arrRemove();
    init_async();
    init_args();
    init_executeSchedule();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/bufferToggle.js
function bufferToggle(openings, closingSelector) {
  return operate(function(source, subscriber) {
    var buffers = [];
    innerFrom(openings).subscribe(createOperatorSubscriber(subscriber, function(openValue) {
      var buffer2 = [];
      buffers.push(buffer2);
      var closingSubscription = new Subscription();
      var emitBuffer = function() {
        arrRemove(buffers, buffer2);
        subscriber.next(buffer2);
        closingSubscription.unsubscribe();
      };
      closingSubscription.add(innerFrom(closingSelector(openValue)).subscribe(createOperatorSubscriber(subscriber, emitBuffer, noop)));
    }, noop));
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a;
      try {
        for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
          var buffer2 = buffers_1_1.value;
          buffer2.push(value);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
            _a.call(buffers_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }, function() {
      while (buffers.length > 0) {
        subscriber.next(buffers.shift());
      }
      subscriber.complete();
    }));
  });
}
var init_bufferToggle = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/bufferToggle.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_Subscription();
    init_lift();
    init_innerFrom();
    init_OperatorSubscriber();
    init_noop();
    init_arrRemove();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/bufferWhen.js
function bufferWhen(closingSelector) {
  return operate(function(source, subscriber) {
    var buffer2 = null;
    var closingSubscriber = null;
    var openBuffer = function() {
      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
      var b = buffer2;
      buffer2 = [];
      b && subscriber.next(b);
      innerFrom(closingSelector()).subscribe(closingSubscriber = createOperatorSubscriber(subscriber, openBuffer, noop));
    };
    openBuffer();
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.push(value);
    }, function() {
      buffer2 && subscriber.next(buffer2);
      subscriber.complete();
    }, void 0, function() {
      return buffer2 = closingSubscriber = null;
    }));
  });
}
var init_bufferWhen = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/bufferWhen.js"() {
    init_define_ngDevMode();
    init_lift();
    init_noop();
    init_OperatorSubscriber();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/catchError.js
function catchError(selector) {
  return operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}
var init_catchError = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/catchError.js"() {
    init_define_ngDevMode();
    init_innerFrom();
    init_OperatorSubscriber();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return function(source, subscriber) {
    var hasState = hasSeed;
    var state = seed;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var i = index++;
      state = hasState ? accumulator(state, value, i) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && function() {
      hasState && subscriber.next(state);
      subscriber.complete();
    }));
  };
}
var init_scanInternals = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js"() {
    init_define_ngDevMode();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/reduce.js
function reduce(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, false, true));
}
var init_reduce = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/reduce.js"() {
    init_define_ngDevMode();
    init_scanInternals();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/toArray.js
function toArray() {
  return operate(function(source, subscriber) {
    reduce(arrReducer, [])(source).subscribe(subscriber);
  });
}
var arrReducer;
var init_toArray = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/toArray.js"() {
    init_define_ngDevMode();
    init_reduce();
    init_lift();
    arrReducer = function(arr, value) {
      return arr.push(value), arr;
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/joinAllInternals.js
function joinAllInternals(joinFn, project) {
  return pipe(toArray(), mergeMap(function(sources) {
    return joinFn(sources);
  }), project ? mapOneOrManyArgs(project) : identity);
}
var init_joinAllInternals = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/joinAllInternals.js"() {
    init_define_ngDevMode();
    init_identity();
    init_mapOneOrManyArgs();
    init_pipe();
    init_mergeMap();
    init_toArray();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/combineLatestAll.js
function combineLatestAll(project) {
  return joinAllInternals(combineLatest, project);
}
var init_combineLatestAll = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/combineLatestAll.js"() {
    init_define_ngDevMode();
    init_combineLatest();
    init_joinAllInternals();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/combineAll.js
var combineAll;
var init_combineAll = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/combineAll.js"() {
    init_define_ngDevMode();
    init_combineLatestAll();
    combineAll = combineLatestAll;
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/combineLatest.js
function combineLatest2() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var resultSelector = popResultSelector(args);
  return resultSelector ? pipe(combineLatest2.apply(void 0, __spreadArray([], __read(args))), mapOneOrManyArgs(resultSelector)) : operate(function(source, subscriber) {
    combineLatestInit(__spreadArray([source], __read(argsOrArgArray(args))))(subscriber);
  });
}
var init_combineLatest2 = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/combineLatest.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_combineLatest();
    init_lift();
    init_argsOrArgArray();
    init_mapOneOrManyArgs();
    init_pipe();
    init_args();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/combineLatestWith.js
function combineLatestWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return combineLatest2.apply(void 0, __spreadArray([], __read(otherSources)));
}
var init_combineLatestWith = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/combineLatestWith.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_combineLatest2();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/concatMap.js
function concatMap(project, resultSelector) {
  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
}
var init_concatMap = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/concatMap.js"() {
    init_define_ngDevMode();
    init_mergeMap();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/concatMapTo.js
function concatMapTo(innerObservable, resultSelector) {
  return isFunction(resultSelector) ? concatMap(function() {
    return innerObservable;
  }, resultSelector) : concatMap(function() {
    return innerObservable;
  });
}
var init_concatMapTo = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/concatMapTo.js"() {
    init_define_ngDevMode();
    init_concatMap();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/concat.js
function concat2() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return operate(function(source, subscriber) {
    concatAll()(from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
  });
}
var init_concat2 = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/concat.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_lift();
    init_concatAll();
    init_args();
    init_from();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/concatWith.js
function concatWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return concat2.apply(void 0, __spreadArray([], __read(otherSources)));
}
var init_concatWith = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/concatWith.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_concat2();
  }
});

// node_modules/rxjs/dist/esm5/internal/observable/fromSubscribable.js
function fromSubscribable(subscribable) {
  return new Observable(function(subscriber) {
    return subscribable.subscribe(subscriber);
  });
}
var init_fromSubscribable = __esm({
  "node_modules/rxjs/dist/esm5/internal/observable/fromSubscribable.js"() {
    init_define_ngDevMode();
    init_Observable();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/connect.js
function connect(selector, config2) {
  if (config2 === void 0) {
    config2 = DEFAULT_CONFIG;
  }
  var connector = config2.connector;
  return operate(function(source, subscriber) {
    var subject = connector();
    innerFrom(selector(fromSubscribable(subject))).subscribe(subscriber);
    subscriber.add(source.subscribe(subject));
  });
}
var DEFAULT_CONFIG;
var init_connect = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/connect.js"() {
    init_define_ngDevMode();
    init_Subject();
    init_innerFrom();
    init_lift();
    init_fromSubscribable();
    DEFAULT_CONFIG = {
      connector: function() {
        return new Subject();
      }
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/count.js
function count(predicate) {
  return reduce(function(total, value, i) {
    return !predicate || predicate(value, i) ? total + 1 : total;
  }, 0);
}
var init_count = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/count.js"() {
    init_define_ngDevMode();
    init_reduce();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/debounce.js
function debounce(durationSelector) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    var lastValue = null;
    var durationSubscriber = null;
    var emit = function() {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      durationSubscriber = null;
      if (hasValue) {
        hasValue = false;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      hasValue = true;
      lastValue = value;
      durationSubscriber = createOperatorSubscriber(subscriber, emit, noop);
      innerFrom(durationSelector(value)).subscribe(durationSubscriber);
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = durationSubscriber = null;
    }));
  });
}
var init_debounce = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/debounce.js"() {
    init_define_ngDevMode();
    init_lift();
    init_noop();
    init_OperatorSubscriber();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return operate(function(source, subscriber) {
    var activeTask = null;
    var lastValue = null;
    var lastTime = null;
    var emit = function() {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    function emitWhenIdle() {
      var targetTime = lastTime + dueTime;
      var now = scheduler.now();
      if (now < targetTime) {
        activeTask = this.schedule(void 0, targetTime - now);
        subscriber.add(activeTask);
        return;
      }
      emit();
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      lastValue = value;
      lastTime = scheduler.now();
      if (!activeTask) {
        activeTask = scheduler.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = activeTask = null;
    }));
  });
}
var init_debounceTime = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js"() {
    init_define_ngDevMode();
    init_async();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js
function defaultIfEmpty(defaultValue) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}
var init_defaultIfEmpty = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js"() {
    init_define_ngDevMode();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/take.js
function take(count2) {
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count2) {
        subscriber.next(value);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}
var init_take = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/take.js"() {
    init_define_ngDevMode();
    init_empty();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/ignoreElements.js
function ignoreElements() {
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, noop));
  });
}
var init_ignoreElements = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/ignoreElements.js"() {
    init_define_ngDevMode();
    init_lift();
    init_OperatorSubscriber();
    init_noop();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/mapTo.js
function mapTo(value) {
  return map(function() {
    return value;
  });
}
var init_mapTo = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/mapTo.js"() {
    init_define_ngDevMode();
    init_map();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/delayWhen.js
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source) {
      return concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
    };
  }
  return mergeMap(function(value, index) {
    return delayDurationSelector(value, index).pipe(take(1), mapTo(value));
  });
}
var init_delayWhen = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/delayWhen.js"() {
    init_define_ngDevMode();
    init_concat();
    init_take();
    init_ignoreElements();
    init_mapTo();
    init_mergeMap();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/delay.js
function delay(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  var duration = timer(due, scheduler);
  return delayWhen(function() {
    return duration;
  });
}
var init_delay = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/delay.js"() {
    init_define_ngDevMode();
    init_async();
    init_delayWhen();
    init_timer();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/dematerialize.js
function dematerialize() {
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(notification) {
      return observeNotification(notification, subscriber);
    }));
  });
}
var init_dematerialize = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/dematerialize.js"() {
    init_define_ngDevMode();
    init_Notification();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/distinct.js
function distinct(keySelector, flushes) {
  return operate(function(source, subscriber) {
    var distinctKeys = /* @__PURE__ */ new Set();
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var key = keySelector ? keySelector(value) : value;
      if (!distinctKeys.has(key)) {
        distinctKeys.add(key);
        subscriber.next(value);
      }
    }));
    flushes === null || flushes === void 0 ? void 0 : flushes.subscribe(createOperatorSubscriber(subscriber, function() {
      return distinctKeys.clear();
    }, noop));
  });
}
var init_distinct = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/distinct.js"() {
    init_define_ngDevMode();
    init_lift();
    init_OperatorSubscriber();
    init_noop();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first2 = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a, b) {
  return a === b;
}
var init_distinctUntilChanged = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js"() {
    init_define_ngDevMode();
    init_identity();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilKeyChanged.js
function distinctUntilKeyChanged(key, compare) {
  return distinctUntilChanged(function(x, y) {
    return compare ? compare(x[key], y[key]) : x[key] === y[key];
  });
}
var init_distinctUntilKeyChanged = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/distinctUntilKeyChanged.js"() {
    init_define_ngDevMode();
    init_distinctUntilChanged();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
    }));
  });
}
function defaultErrorFactory() {
  return new EmptyError();
}
var init_throwIfEmpty = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js"() {
    init_define_ngDevMode();
    init_EmptyError();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/elementAt.js
function elementAt(index, defaultValue) {
  if (index < 0) {
    throw new ArgumentOutOfRangeError();
  }
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(filter(function(v, i) {
      return i === index;
    }), take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
var init_elementAt = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/elementAt.js"() {
    init_define_ngDevMode();
    init_ArgumentOutOfRangeError();
    init_filter();
    init_throwIfEmpty();
    init_defaultIfEmpty();
    init_take();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/endWith.js
function endWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  return function(source) {
    return concat(source, of.apply(void 0, __spreadArray([], __read(values))));
  };
}
var init_endWith = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/endWith.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_concat();
    init_of();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/every.js
function every(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (!predicate.call(thisArg, value, index++, source)) {
        subscriber.next(false);
        subscriber.complete();
      }
    }, function() {
      subscriber.next(true);
      subscriber.complete();
    }));
  });
}
var init_every = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/every.js"() {
    init_define_ngDevMode();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/exhaustMap.js
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a, i) {
        return innerFrom(project(a, i)).pipe(map(function(b, ii) {
          return resultSelector(a, b, i, ii);
        }));
      }));
    };
  }
  return operate(function(source, subscriber) {
    var index = 0;
    var innerSub = null;
    var isComplete = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(outerValue) {
      if (!innerSub) {
        innerSub = createOperatorSubscriber(subscriber, void 0, function() {
          innerSub = null;
          isComplete && subscriber.complete();
        });
        innerFrom(project(outerValue, index++)).subscribe(innerSub);
      }
    }, function() {
      isComplete = true;
      !innerSub && subscriber.complete();
    }));
  });
}
var init_exhaustMap = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/exhaustMap.js"() {
    init_define_ngDevMode();
    init_map();
    init_innerFrom();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/exhaustAll.js
function exhaustAll() {
  return exhaustMap(identity);
}
var init_exhaustAll = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/exhaustAll.js"() {
    init_define_ngDevMode();
    init_exhaustMap();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/exhaust.js
var exhaust;
var init_exhaust = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/exhaust.js"() {
    init_define_ngDevMode();
    init_exhaustAll();
    exhaust = exhaustAll;
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/expand.js
function expand(project, concurrent, scheduler) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent, void 0, true, scheduler);
  });
}
var init_expand = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/expand.js"() {
    init_define_ngDevMode();
    init_lift();
    init_mergeInternals();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/finalize.js
function finalize(callback) {
  return operate(function(source, subscriber) {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}
var init_finalize = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/finalize.js"() {
    init_define_ngDevMode();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/find.js
function find(predicate, thisArg) {
  return operate(createFind(predicate, thisArg, "value"));
}
function createFind(predicate, thisArg, emit) {
  var findIndex2 = emit === "index";
  return function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var i = index++;
      if (predicate.call(thisArg, value, i, source)) {
        subscriber.next(findIndex2 ? i : value);
        subscriber.complete();
      }
    }, function() {
      subscriber.next(findIndex2 ? -1 : void 0);
      subscriber.complete();
    }));
  };
}
var init_find = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/find.js"() {
    init_define_ngDevMode();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/findIndex.js
function findIndex(predicate, thisArg) {
  return operate(createFind(predicate, thisArg, "index"));
}
var init_findIndex = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/findIndex.js"() {
    init_define_ngDevMode();
    init_lift();
    init_find();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/first.js
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v, i) {
      return predicate(v, i, source);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var init_first = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/first.js"() {
    init_define_ngDevMode();
    init_EmptyError();
    init_filter();
    init_take();
    init_defaultIfEmpty();
    init_throwIfEmpty();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/groupBy.js
function groupBy(keySelector, elementOrOptions, duration, connector) {
  return operate(function(source, subscriber) {
    var element;
    if (!elementOrOptions || typeof elementOrOptions === "function") {
      element = elementOrOptions;
    } else {
      duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
    }
    var groups = /* @__PURE__ */ new Map();
    var notify = function(cb) {
      groups.forEach(cb);
      cb(subscriber);
    };
    var handleError2 = function(err) {
      return notify(function(consumer) {
        return consumer.error(err);
      });
    };
    var activeGroups = 0;
    var teardownAttempted = false;
    var groupBySourceSubscriber = new OperatorSubscriber(subscriber, function(value) {
      try {
        var key_1 = keySelector(value);
        var group_1 = groups.get(key_1);
        if (!group_1) {
          groups.set(key_1, group_1 = connector ? connector() : new Subject());
          var grouped = createGroupedObservable(key_1, group_1);
          subscriber.next(grouped);
          if (duration) {
            var durationSubscriber_1 = createOperatorSubscriber(group_1, function() {
              group_1.complete();
              durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
            }, void 0, void 0, function() {
              return groups.delete(key_1);
            });
            groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
          }
        }
        group_1.next(element ? element(value) : value);
      } catch (err) {
        handleError2(err);
      }
    }, function() {
      return notify(function(consumer) {
        return consumer.complete();
      });
    }, handleError2, function() {
      return groups.clear();
    }, function() {
      teardownAttempted = true;
      return activeGroups === 0;
    });
    source.subscribe(groupBySourceSubscriber);
    function createGroupedObservable(key, groupSubject) {
      var result = new Observable(function(groupSubscriber) {
        activeGroups++;
        var innerSub = groupSubject.subscribe(groupSubscriber);
        return function() {
          innerSub.unsubscribe();
          --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
        };
      });
      result.key = key;
      return result;
    }
  });
}
var init_groupBy = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/groupBy.js"() {
    init_define_ngDevMode();
    init_Observable();
    init_innerFrom();
    init_Subject();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/isEmpty.js
function isEmpty() {
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function() {
      subscriber.next(false);
      subscriber.complete();
    }, function() {
      subscriber.next(true);
      subscriber.complete();
    }));
  });
}
var init_isEmpty = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/isEmpty.js"() {
    init_define_ngDevMode();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/takeLast.js
function takeLast(count2) {
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var buffer2 = [];
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      buffer2.push(value);
      count2 < buffer2.length && buffer2.shift();
    }, function() {
      var e_1, _a;
      try {
        for (var buffer_1 = __values(buffer2), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
          var value = buffer_1_1.value;
          subscriber.next(value);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
            _a.call(buffer_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    }, void 0, function() {
      buffer2 = null;
    }));
  });
}
var init_takeLast = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/takeLast.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_empty();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/last.js
function last2(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v, i) {
      return predicate(v, i, source);
    }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var init_last = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/last.js"() {
    init_define_ngDevMode();
    init_EmptyError();
    init_filter();
    init_takeLast();
    init_throwIfEmpty();
    init_defaultIfEmpty();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/materialize.js
function materialize() {
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(Notification.createNext(value));
    }, function() {
      subscriber.next(Notification.createComplete());
      subscriber.complete();
    }, function(err) {
      subscriber.next(Notification.createError(err));
      subscriber.complete();
    }));
  });
}
var init_materialize = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/materialize.js"() {
    init_define_ngDevMode();
    init_Notification();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/max.js
function max(comparer) {
  return reduce(isFunction(comparer) ? function(x, y) {
    return comparer(x, y) > 0 ? x : y;
  } : function(x, y) {
    return x > y ? x : y;
  });
}
var init_max = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/max.js"() {
    init_define_ngDevMode();
    init_reduce();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/flatMap.js
var flatMap;
var init_flatMap = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/flatMap.js"() {
    init_define_ngDevMode();
    init_mergeMap();
    flatMap = mergeMap;
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/mergeMapTo.js
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function() {
      return innerObservable;
    }, resultSelector, concurrent);
  }
  if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return mergeMap(function() {
    return innerObservable;
  }, concurrent);
}
var init_mergeMapTo = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/mergeMapTo.js"() {
    init_define_ngDevMode();
    init_mergeMap();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/mergeScan.js
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return operate(function(source, subscriber) {
    var state = seed;
    return mergeInternals(source, subscriber, function(value, index) {
      return accumulator(state, value, index);
    }, concurrent, function(value) {
      state = value;
    }, false, void 0, function() {
      return state = null;
    });
  });
}
var init_mergeScan = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/mergeScan.js"() {
    init_define_ngDevMode();
    init_lift();
    init_mergeInternals();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/merge.js
function merge2() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  args = argsOrArgArray(args);
  return operate(function(source, subscriber) {
    mergeAll(concurrent)(from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
  });
}
var init_merge2 = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/merge.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_lift();
    init_argsOrArgArray();
    init_mergeAll();
    init_args();
    init_from();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/mergeWith.js
function mergeWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return merge2.apply(void 0, __spreadArray([], __read(otherSources)));
}
var init_mergeWith = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/mergeWith.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_merge2();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/min.js
function min(comparer) {
  return reduce(isFunction(comparer) ? function(x, y) {
    return comparer(x, y) < 0 ? x : y;
  } : function(x, y) {
    return x < y ? x : y;
  });
}
var init_min = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/min.js"() {
    init_define_ngDevMode();
    init_reduce();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/multicast.js
function multicast(subjectOrSubjectFactory, selector) {
  var subjectFactory = isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
    return subjectOrSubjectFactory;
  };
  if (isFunction(selector)) {
    return connect(selector, {
      connector: subjectFactory
    });
  }
  return function(source) {
    return new ConnectableObservable(source, subjectFactory);
  };
}
var init_multicast = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/multicast.js"() {
    init_define_ngDevMode();
    init_ConnectableObservable();
    init_isFunction();
    init_connect();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/pairwise.js
function pairwise() {
  return operate(function(source, subscriber) {
    var prev;
    var hasPrev = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var p = prev;
      prev = value;
      hasPrev && subscriber.next([p, value]);
      hasPrev = true;
    }));
  });
}
var init_pairwise = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/pairwise.js"() {
    init_define_ngDevMode();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/pluck.js
function pluck() {
  var properties = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }
  var length = properties.length;
  if (length === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return map(function(x) {
    var currentProp = x;
    for (var i = 0; i < length; i++) {
      var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
      if (typeof p !== "undefined") {
        currentProp = p;
      } else {
        return void 0;
      }
    }
    return currentProp;
  });
}
var init_pluck = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/pluck.js"() {
    init_define_ngDevMode();
    init_map();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/publish.js
function publish(selector) {
  return selector ? function(source) {
    return connect(selector)(source);
  } : function(source) {
    return multicast(new Subject())(source);
  };
}
var init_publish = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/publish.js"() {
    init_define_ngDevMode();
    init_Subject();
    init_multicast();
    init_connect();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/publishBehavior.js
function publishBehavior(initialValue) {
  return function(source) {
    var subject = new BehaviorSubject(initialValue);
    return new ConnectableObservable(source, function() {
      return subject;
    });
  };
}
var init_publishBehavior = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/publishBehavior.js"() {
    init_define_ngDevMode();
    init_BehaviorSubject();
    init_ConnectableObservable();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/publishLast.js
function publishLast() {
  return function(source) {
    var subject = new AsyncSubject();
    return new ConnectableObservable(source, function() {
      return subject;
    });
  };
}
var init_publishLast = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/publishLast.js"() {
    init_define_ngDevMode();
    init_AsyncSubject();
    init_ConnectableObservable();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/publishReplay.js
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, timestampProvider) {
  if (selectorOrScheduler && !isFunction(selectorOrScheduler)) {
    timestampProvider = selectorOrScheduler;
  }
  var selector = isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
  return function(source) {
    return multicast(new ReplaySubject(bufferSize, windowTime2, timestampProvider), selector)(source);
  };
}
var init_publishReplay = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/publishReplay.js"() {
    init_define_ngDevMode();
    init_ReplaySubject();
    init_multicast();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/raceWith.js
function raceWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return !otherSources.length ? identity : operate(function(source, subscriber) {
    raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
  });
}
var init_raceWith = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/raceWith.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_race();
    init_lift();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/repeat.js
function repeat(countOrConfig) {
  var _a;
  var count2 = Infinity;
  var delay2;
  if (countOrConfig != null) {
    if (typeof countOrConfig === "object") {
      _a = countOrConfig.count, count2 = _a === void 0 ? Infinity : _a, delay2 = countOrConfig.delay;
    } else {
      count2 = countOrConfig;
    }
  }
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var soFar = 0;
    var sourceSub;
    var resubscribe = function() {
      sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
      sourceSub = null;
      if (delay2 != null) {
        var notifier = typeof delay2 === "number" ? timer(delay2) : innerFrom(delay2(soFar));
        var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
          notifierSubscriber_1.unsubscribe();
          subscribeToSource();
        });
        notifier.subscribe(notifierSubscriber_1);
      } else {
        subscribeToSource();
      }
    };
    var subscribeToSource = function() {
      var syncUnsub = false;
      sourceSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, function() {
        if (++soFar < count2) {
          if (sourceSub) {
            resubscribe();
          } else {
            syncUnsub = true;
          }
        } else {
          subscriber.complete();
        }
      }));
      if (syncUnsub) {
        resubscribe();
      }
    };
    subscribeToSource();
  });
}
var init_repeat = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/repeat.js"() {
    init_define_ngDevMode();
    init_empty();
    init_lift();
    init_OperatorSubscriber();
    init_innerFrom();
    init_timer();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/repeatWhen.js
function repeatWhen(notifier) {
  return operate(function(source, subscriber) {
    var innerSub;
    var syncResub = false;
    var completions$;
    var isNotifierComplete = false;
    var isMainComplete = false;
    var checkComplete = function() {
      return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
    };
    var getCompletionSubject = function() {
      if (!completions$) {
        completions$ = new Subject();
        notifier(completions$).subscribe(createOperatorSubscriber(subscriber, function() {
          if (innerSub) {
            subscribeForRepeatWhen();
          } else {
            syncResub = true;
          }
        }, function() {
          isNotifierComplete = true;
          checkComplete();
        }));
      }
      return completions$;
    };
    var subscribeForRepeatWhen = function() {
      isMainComplete = false;
      innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, function() {
        isMainComplete = true;
        !checkComplete() && getCompletionSubject().next();
      }));
      if (syncResub) {
        innerSub.unsubscribe();
        innerSub = null;
        syncResub = false;
        subscribeForRepeatWhen();
      }
    };
    subscribeForRepeatWhen();
  });
}
var init_repeatWhen = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/repeatWhen.js"() {
    init_define_ngDevMode();
    init_Subject();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/retry.js
function retry(configOrCount) {
  if (configOrCount === void 0) {
    configOrCount = Infinity;
  }
  var config2;
  if (configOrCount && typeof configOrCount === "object") {
    config2 = configOrCount;
  } else {
    config2 = {
      count: configOrCount
    };
  }
  var _a = config2.count, count2 = _a === void 0 ? Infinity : _a, delay2 = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
  return count2 <= 0 ? identity : operate(function(source, subscriber) {
    var soFar = 0;
    var innerSub;
    var subscribeForRetry = function() {
      var syncUnsub = false;
      innerSub = source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (resetOnSuccess) {
          soFar = 0;
        }
        subscriber.next(value);
      }, void 0, function(err) {
        if (soFar++ < count2) {
          var resub_1 = function() {
            if (innerSub) {
              innerSub.unsubscribe();
              innerSub = null;
              subscribeForRetry();
            } else {
              syncUnsub = true;
            }
          };
          if (delay2 != null) {
            var notifier = typeof delay2 === "number" ? timer(delay2) : innerFrom(delay2(err, soFar));
            var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              resub_1();
            }, function() {
              subscriber.complete();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            resub_1();
          }
        } else {
          subscriber.error(err);
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        subscribeForRetry();
      }
    };
    subscribeForRetry();
  });
}
var init_retry = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/retry.js"() {
    init_define_ngDevMode();
    init_lift();
    init_OperatorSubscriber();
    init_identity();
    init_timer();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/retryWhen.js
function retryWhen(notifier) {
  return operate(function(source, subscriber) {
    var innerSub;
    var syncResub = false;
    var errors$;
    var subscribeForRetryWhen = function() {
      innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
        if (!errors$) {
          errors$ = new Subject();
          notifier(errors$).subscribe(createOperatorSubscriber(subscriber, function() {
            return innerSub ? subscribeForRetryWhen() : syncResub = true;
          }));
        }
        if (errors$) {
          errors$.next(err);
        }
      }));
      if (syncResub) {
        innerSub.unsubscribe();
        innerSub = null;
        syncResub = false;
        subscribeForRetryWhen();
      }
    };
    subscribeForRetryWhen();
  });
}
var init_retryWhen = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/retryWhen.js"() {
    init_define_ngDevMode();
    init_Subject();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/sample.js
function sample(notifier) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    var lastValue = null;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      lastValue = value;
    }));
    notifier.subscribe(createOperatorSubscriber(subscriber, function() {
      if (hasValue) {
        hasValue = false;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    }, noop));
  });
}
var init_sample = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/sample.js"() {
    init_define_ngDevMode();
    init_lift();
    init_noop();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/sampleTime.js
function sampleTime(period, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return sample(interval(period, scheduler));
}
var init_sampleTime = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/sampleTime.js"() {
    init_define_ngDevMode();
    init_async();
    init_sample();
    init_interval();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/scan.js
function scan(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
}
var init_scan = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/scan.js"() {
    init_define_ngDevMode();
    init_lift();
    init_scanInternals();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/sequenceEqual.js
function sequenceEqual(compareTo, comparator) {
  if (comparator === void 0) {
    comparator = function(a, b) {
      return a === b;
    };
  }
  return operate(function(source, subscriber) {
    var aState = createState();
    var bState = createState();
    var emit = function(isEqual) {
      subscriber.next(isEqual);
      subscriber.complete();
    };
    var createSubscriber = function(selfState, otherState) {
      var sequenceEqualSubscriber = createOperatorSubscriber(subscriber, function(a) {
        var buffer2 = otherState.buffer, complete = otherState.complete;
        if (buffer2.length === 0) {
          complete ? emit(false) : selfState.buffer.push(a);
        } else {
          !comparator(a, buffer2.shift()) && emit(false);
        }
      }, function() {
        selfState.complete = true;
        var complete = otherState.complete, buffer2 = otherState.buffer;
        complete && emit(buffer2.length === 0);
        sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
      });
      return sequenceEqualSubscriber;
    };
    source.subscribe(createSubscriber(aState, bState));
    compareTo.subscribe(createSubscriber(bState, aState));
  });
}
function createState() {
  return {
    buffer: [],
    complete: false
  };
}
var init_sequenceEqual = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/sequenceEqual.js"() {
    init_define_ngDevMode();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/share.js
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.connector, connector = _a === void 0 ? function() {
    return new Subject();
  } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return on.apply(void 0, __spreadArray([], __read(args))).subscribe(onSubscriber);
}
var init_share = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/share.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_innerFrom();
    init_Subject();
    init_Subscriber();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var _a, _b, _c;
  var bufferSize;
  var refCount2 = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount2 = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: function() {
      return new ReplaySubject(bufferSize, windowTime2, scheduler);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount2
  });
}
var init_shareReplay = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js"() {
    init_define_ngDevMode();
    init_ReplaySubject();
    init_share();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/single.js
function single(predicate) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    var singleValue;
    var seenValue = false;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      seenValue = true;
      if (!predicate || predicate(value, index++, source)) {
        hasValue && subscriber.error(new SequenceError("Too many matching values"));
        hasValue = true;
        singleValue = value;
      }
    }, function() {
      if (hasValue) {
        subscriber.next(singleValue);
        subscriber.complete();
      } else {
        subscriber.error(seenValue ? new NotFoundError("No matching values") : new EmptyError());
      }
    }));
  });
}
var init_single = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/single.js"() {
    init_define_ngDevMode();
    init_EmptyError();
    init_SequenceError();
    init_NotFoundError();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/skip.js
function skip(count2) {
  return filter(function(_, index) {
    return count2 <= index;
  });
}
var init_skip = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/skip.js"() {
    init_define_ngDevMode();
    init_filter();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/skipLast.js
function skipLast(skipCount) {
  return skipCount <= 0 ? identity : operate(function(source, subscriber) {
    var ring = new Array(skipCount);
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var valueIndex = seen++;
      if (valueIndex < skipCount) {
        ring[valueIndex] = value;
      } else {
        var index = valueIndex % skipCount;
        var oldValue = ring[index];
        ring[index] = value;
        subscriber.next(oldValue);
      }
    }));
    return function() {
      ring = null;
    };
  });
}
var init_skipLast = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/skipLast.js"() {
    init_define_ngDevMode();
    init_identity();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/skipUntil.js
function skipUntil(notifier) {
  return operate(function(source, subscriber) {
    var taking = false;
    var skipSubscriber = createOperatorSubscriber(subscriber, function() {
      skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
      taking = true;
    }, noop);
    innerFrom(notifier).subscribe(skipSubscriber);
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return taking && subscriber.next(value);
    }));
  });
}
var init_skipUntil = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/skipUntil.js"() {
    init_define_ngDevMode();
    init_lift();
    init_OperatorSubscriber();
    init_innerFrom();
    init_noop();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/skipWhile.js
function skipWhile(predicate) {
  return operate(function(source, subscriber) {
    var taking = false;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
    }));
  });
}
var init_skipWhile = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/skipWhile.js"() {
    init_define_ngDevMode();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/startWith.js
function startWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler = popScheduler(values);
  return operate(function(source, subscriber) {
    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
  });
}
var init_startWith = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/startWith.js"() {
    init_define_ngDevMode();
    init_concat();
    init_args();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}
var init_switchMap = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/switchMap.js"() {
    init_define_ngDevMode();
    init_innerFrom();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/switchAll.js
function switchAll() {
  return switchMap(identity);
}
var init_switchAll = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/switchAll.js"() {
    init_define_ngDevMode();
    init_switchMap();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/switchMapTo.js
function switchMapTo(innerObservable, resultSelector) {
  return isFunction(resultSelector) ? switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap(function() {
    return innerObservable;
  });
}
var init_switchMapTo = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/switchMapTo.js"() {
    init_define_ngDevMode();
    init_switchMap();
    init_isFunction();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/switchScan.js
function switchScan(accumulator, seed) {
  return operate(function(source, subscriber) {
    var state = seed;
    switchMap(function(value, index) {
      return accumulator(state, value, index);
    }, function(_, innerValue) {
      return state = innerValue, innerValue;
    })(source).subscribe(subscriber);
    return function() {
      state = null;
    };
  });
}
var init_switchScan = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/switchScan.js"() {
    init_define_ngDevMode();
    init_switchMap();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}
var init_takeUntil = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js"() {
    init_define_ngDevMode();
    init_lift();
    init_OperatorSubscriber();
    init_innerFrom();
    init_noop();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var result = predicate(value, index++);
      (result || inclusive) && subscriber.next(value);
      !result && subscriber.complete();
    }));
  });
}
var init_takeWhile = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js"() {
    init_define_ngDevMode();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/tap.js
function tap(observerOrNext, error2, complete) {
  var tapObserver = isFunction(observerOrNext) || error2 || complete ? {
    next: observerOrNext,
    error: error2,
    complete
  } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}
var init_tap = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/tap.js"() {
    init_define_ngDevMode();
    init_isFunction();
    init_lift();
    init_OperatorSubscriber();
    init_identity();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/throttle.js
function throttle(durationSelector, config2) {
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return operate(function(source, subscriber) {
    var leading = config2.leading, trailing = config2.trailing;
    var hasValue = false;
    var sendValue = null;
    var throttled = null;
    var isComplete = false;
    var endThrottling = function() {
      throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
      throttled = null;
      if (trailing) {
        send();
        isComplete && subscriber.complete();
      }
    };
    var cleanupThrottling = function() {
      throttled = null;
      isComplete && subscriber.complete();
    };
    var startThrottle = function(value) {
      return throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
    };
    var send = function() {
      if (hasValue) {
        hasValue = false;
        var value = sendValue;
        sendValue = null;
        subscriber.next(value);
        !isComplete && startThrottle(value);
      }
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      sendValue = value;
      !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
    }, function() {
      isComplete = true;
      !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
    }));
  });
}
var defaultThrottleConfig;
var init_throttle = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/throttle.js"() {
    init_define_ngDevMode();
    init_lift();
    init_OperatorSubscriber();
    init_innerFrom();
    defaultThrottleConfig = {
      leading: true,
      trailing: false
    };
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/throttleTime.js
function throttleTime(duration, scheduler, config2) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  var duration$ = timer(duration, scheduler);
  return throttle(function() {
    return duration$;
  }, config2);
}
var init_throttleTime = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/throttleTime.js"() {
    init_define_ngDevMode();
    init_async();
    init_throttle();
    init_timer();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/timeInterval.js
function timeInterval(scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return operate(function(source, subscriber) {
    var last3 = scheduler.now();
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var now = scheduler.now();
      var interval2 = now - last3;
      last3 = now;
      subscriber.next(new TimeInterval(value, interval2));
    }));
  });
}
var TimeInterval;
var init_timeInterval = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/timeInterval.js"() {
    init_define_ngDevMode();
    init_async();
    init_lift();
    init_OperatorSubscriber();
    TimeInterval = function() {
      function TimeInterval2(value, interval2) {
        this.value = value;
        this.interval = interval2;
      }
      return TimeInterval2;
    }();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/timeoutWith.js
function timeoutWith(due, withObservable, scheduler) {
  var first2;
  var each;
  var _with;
  scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async;
  if (isValidDate(due)) {
    first2 = due;
  } else if (typeof due === "number") {
    each = due;
  }
  if (withObservable) {
    _with = function() {
      return withObservable;
    };
  } else {
    throw new TypeError("No observable provided to switch to");
  }
  if (first2 == null && each == null) {
    throw new TypeError("No timeout provided.");
  }
  return timeout({
    first: first2,
    each,
    scheduler,
    with: _with
  });
}
var init_timeoutWith = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/timeoutWith.js"() {
    init_define_ngDevMode();
    init_async();
    init_isDate();
    init_timeout();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/timestamp.js
function timestamp(timestampProvider) {
  if (timestampProvider === void 0) {
    timestampProvider = dateTimestampProvider;
  }
  return map(function(value) {
    return {
      value,
      timestamp: timestampProvider.now()
    };
  });
}
var init_timestamp = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/timestamp.js"() {
    init_define_ngDevMode();
    init_dateTimestampProvider();
    init_map();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/window.js
function window2(windowBoundaries) {
  return operate(function(source, subscriber) {
    var windowSubject = new Subject();
    subscriber.next(windowSubject.asObservable());
    var errorHandler2 = function(err) {
      windowSubject.error(err);
      subscriber.error(err);
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
    }, function() {
      windowSubject.complete();
      subscriber.complete();
    }, errorHandler2));
    windowBoundaries.subscribe(createOperatorSubscriber(subscriber, function() {
      windowSubject.complete();
      subscriber.next(windowSubject = new Subject());
    }, noop, errorHandler2));
    return function() {
      windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
      windowSubject = null;
    };
  });
}
var init_window = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/window.js"() {
    init_define_ngDevMode();
    init_Subject();
    init_lift();
    init_OperatorSubscriber();
    init_noop();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/windowCount.js
function windowCount(windowSize, startWindowEvery) {
  if (startWindowEvery === void 0) {
    startWindowEvery = 0;
  }
  var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
  return operate(function(source, subscriber) {
    var windows = [new Subject()];
    var starts = [];
    var count2 = 0;
    subscriber.next(windows[0].asObservable());
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a;
      try {
        for (var windows_1 = __values(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
          var window_1 = windows_1_1.value;
          window_1.next(value);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return))
            _a.call(windows_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      var c = count2 - windowSize + 1;
      if (c >= 0 && c % startEvery === 0) {
        windows.shift().complete();
      }
      if (++count2 % startEvery === 0) {
        var window_2 = new Subject();
        windows.push(window_2);
        subscriber.next(window_2.asObservable());
      }
    }, function() {
      while (windows.length > 0) {
        windows.shift().complete();
      }
      subscriber.complete();
    }, function(err) {
      while (windows.length > 0) {
        windows.shift().error(err);
      }
      subscriber.error(err);
    }, function() {
      starts = null;
      windows = null;
    }));
  });
}
var init_windowCount = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/windowCount.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_Subject();
    init_lift();
    init_OperatorSubscriber();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/windowTime.js
function windowTime(windowTimeSpan) {
  var _a, _b;
  var otherArgs = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    otherArgs[_i - 1] = arguments[_i];
  }
  var scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;
  var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
  var maxWindowSize = otherArgs[1] || Infinity;
  return operate(function(source, subscriber) {
    var windowRecords = [];
    var restartOnClose = false;
    var closeWindow = function(record) {
      var window3 = record.window, subs = record.subs;
      window3.complete();
      subs.unsubscribe();
      arrRemove(windowRecords, record);
      restartOnClose && startWindow();
    };
    var startWindow = function() {
      if (windowRecords) {
        var subs = new Subscription();
        subscriber.add(subs);
        var window_1 = new Subject();
        var record_1 = {
          window: window_1,
          subs,
          seen: 0
        };
        windowRecords.push(record_1);
        subscriber.next(window_1.asObservable());
        executeSchedule(subs, scheduler, function() {
          return closeWindow(record_1);
        }, windowTimeSpan);
      }
    };
    if (windowCreationInterval !== null && windowCreationInterval >= 0) {
      executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
    } else {
      restartOnClose = true;
    }
    startWindow();
    var loop = function(cb) {
      return windowRecords.slice().forEach(cb);
    };
    var terminate = function(cb) {
      loop(function(_a2) {
        var window3 = _a2.window;
        return cb(window3);
      });
      cb(subscriber);
      subscriber.unsubscribe();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      loop(function(record) {
        record.window.next(value);
        maxWindowSize <= ++record.seen && closeWindow(record);
      });
    }, function() {
      return terminate(function(consumer) {
        return consumer.complete();
      });
    }, function(err) {
      return terminate(function(consumer) {
        return consumer.error(err);
      });
    }));
    return function() {
      windowRecords = null;
    };
  });
}
var init_windowTime = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/windowTime.js"() {
    init_define_ngDevMode();
    init_Subject();
    init_async();
    init_Subscription();
    init_lift();
    init_OperatorSubscriber();
    init_arrRemove();
    init_args();
    init_executeSchedule();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/windowToggle.js
function windowToggle(openings, closingSelector) {
  return operate(function(source, subscriber) {
    var windows = [];
    var handleError2 = function(err) {
      while (0 < windows.length) {
        windows.shift().error(err);
      }
      subscriber.error(err);
    };
    innerFrom(openings).subscribe(createOperatorSubscriber(subscriber, function(openValue) {
      var window3 = new Subject();
      windows.push(window3);
      var closingSubscription = new Subscription();
      var closeWindow = function() {
        arrRemove(windows, window3);
        window3.complete();
        closingSubscription.unsubscribe();
      };
      var closingNotifier;
      try {
        closingNotifier = innerFrom(closingSelector(openValue));
      } catch (err) {
        handleError2(err);
        return;
      }
      subscriber.next(window3.asObservable());
      closingSubscription.add(closingNotifier.subscribe(createOperatorSubscriber(subscriber, closeWindow, noop, handleError2)));
    }, noop));
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a;
      var windowsCopy = windows.slice();
      try {
        for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
          var window_1 = windowsCopy_1_1.value;
          window_1.next(value);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return))
            _a.call(windowsCopy_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }, function() {
      while (0 < windows.length) {
        windows.shift().complete();
      }
      subscriber.complete();
    }, handleError2, function() {
      while (0 < windows.length) {
        windows.shift().unsubscribe();
      }
    }));
  });
}
var init_windowToggle = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/windowToggle.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_Subject();
    init_Subscription();
    init_lift();
    init_innerFrom();
    init_OperatorSubscriber();
    init_noop();
    init_arrRemove();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/windowWhen.js
function windowWhen(closingSelector) {
  return operate(function(source, subscriber) {
    var window3;
    var closingSubscriber;
    var handleError2 = function(err) {
      window3.error(err);
      subscriber.error(err);
    };
    var openWindow = function() {
      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
      window3 === null || window3 === void 0 ? void 0 : window3.complete();
      window3 = new Subject();
      subscriber.next(window3.asObservable());
      var closingNotifier;
      try {
        closingNotifier = innerFrom(closingSelector());
      } catch (err) {
        handleError2(err);
        return;
      }
      closingNotifier.subscribe(closingSubscriber = createOperatorSubscriber(subscriber, openWindow, openWindow, handleError2));
    };
    openWindow();
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return window3.next(value);
    }, function() {
      window3.complete();
      subscriber.complete();
    }, handleError2, function() {
      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
      window3 = null;
    }));
  });
}
var init_windowWhen = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/windowWhen.js"() {
    init_define_ngDevMode();
    init_Subject();
    init_lift();
    init_OperatorSubscriber();
    init_innerFrom();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/withLatestFrom.js
function withLatestFrom() {
  var inputs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    inputs[_i] = arguments[_i];
  }
  var project = popResultSelector(inputs);
  return operate(function(source, subscriber) {
    var len = inputs.length;
    var otherValues = new Array(len);
    var hasValue = inputs.map(function() {
      return false;
    });
    var ready = false;
    var _loop_1 = function(i2) {
      innerFrom(inputs[i2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        otherValues[i2] = value;
        if (!ready && !hasValue[i2]) {
          hasValue[i2] = true;
          (ready = hasValue.every(identity)) && (hasValue = null);
        }
      }, noop));
    };
    for (var i = 0; i < len; i++) {
      _loop_1(i);
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (ready) {
        var values = __spreadArray([value], __read(otherValues));
        subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
      }
    }));
  });
}
var init_withLatestFrom = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/withLatestFrom.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_lift();
    init_OperatorSubscriber();
    init_innerFrom();
    init_identity();
    init_noop();
    init_args();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/zipAll.js
function zipAll(project) {
  return joinAllInternals(zip, project);
}
var init_zipAll = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/zipAll.js"() {
    init_define_ngDevMode();
    init_zip();
    init_joinAllInternals();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/zip.js
function zip2() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  return operate(function(source, subscriber) {
    zip.apply(void 0, __spreadArray([source], __read(sources))).subscribe(subscriber);
  });
}
var init_zip2 = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/zip.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_zip();
    init_lift();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/zipWith.js
function zipWith() {
  var otherInputs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherInputs[_i] = arguments[_i];
  }
  return zip2.apply(void 0, __spreadArray([], __read(otherInputs)));
}
var init_zipWith = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/zipWith.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_zip2();
  }
});

// node_modules/rxjs/dist/esm5/index.js
var init_esm5 = __esm({
  "node_modules/rxjs/dist/esm5/index.js"() {
    init_define_ngDevMode();
    init_Observable();
    init_ConnectableObservable();
    init_observable();
    init_animationFrames();
    init_Subject();
    init_BehaviorSubject();
    init_ReplaySubject();
    init_AsyncSubject();
    init_asap();
    init_async();
    init_queue();
    init_animationFrame();
    init_VirtualTimeScheduler();
    init_Scheduler();
    init_Subscription();
    init_Subscriber();
    init_Notification();
    init_pipe();
    init_noop();
    init_identity();
    init_isObservable();
    init_lastValueFrom();
    init_firstValueFrom();
    init_ArgumentOutOfRangeError();
    init_EmptyError();
    init_NotFoundError();
    init_ObjectUnsubscribedError();
    init_SequenceError();
    init_timeout();
    init_UnsubscriptionError();
    init_bindCallback();
    init_bindNodeCallback();
    init_combineLatest();
    init_concat();
    init_connectable();
    init_defer();
    init_empty();
    init_forkJoin();
    init_from();
    init_fromEvent();
    init_fromEventPattern();
    init_generate();
    init_iif();
    init_interval();
    init_merge();
    init_never();
    init_of();
    init_onErrorResumeNext2();
    init_pairs();
    init_partition();
    init_race();
    init_range();
    init_throwError();
    init_timer();
    init_using();
    init_zip();
    init_scheduled();
    init_empty();
    init_never();
    init_types();
    init_config();
    init_audit();
    init_auditTime();
    init_buffer();
    init_bufferCount();
    init_bufferTime();
    init_bufferToggle();
    init_bufferWhen();
    init_catchError();
    init_combineAll();
    init_combineLatestAll();
    init_combineLatestWith();
    init_concatAll();
    init_concatMap();
    init_concatMapTo();
    init_concatWith();
    init_connect();
    init_count();
    init_debounce();
    init_debounceTime();
    init_defaultIfEmpty();
    init_delay();
    init_delayWhen();
    init_dematerialize();
    init_distinct();
    init_distinctUntilChanged();
    init_distinctUntilKeyChanged();
    init_elementAt();
    init_endWith();
    init_every();
    init_exhaust();
    init_exhaustAll();
    init_exhaustMap();
    init_expand();
    init_filter();
    init_finalize();
    init_find();
    init_findIndex();
    init_first();
    init_groupBy();
    init_ignoreElements();
    init_isEmpty();
    init_last();
    init_map();
    init_mapTo();
    init_materialize();
    init_max();
    init_mergeAll();
    init_flatMap();
    init_mergeMap();
    init_mergeMapTo();
    init_mergeScan();
    init_mergeWith();
    init_min();
    init_multicast();
    init_observeOn();
    init_pairwise();
    init_pluck();
    init_publish();
    init_publishBehavior();
    init_publishLast();
    init_publishReplay();
    init_raceWith();
    init_reduce();
    init_repeat();
    init_repeatWhen();
    init_retry();
    init_retryWhen();
    init_refCount();
    init_sample();
    init_sampleTime();
    init_scan();
    init_sequenceEqual();
    init_share();
    init_shareReplay();
    init_single();
    init_skip();
    init_skipLast();
    init_skipUntil();
    init_skipWhile();
    init_startWith();
    init_subscribeOn();
    init_switchAll();
    init_switchMap();
    init_switchMapTo();
    init_switchScan();
    init_take();
    init_takeLast();
    init_takeUntil();
    init_takeWhile();
    init_tap();
    init_throttle();
    init_throttleTime();
    init_throwIfEmpty();
    init_timeInterval();
    init_timeout();
    init_timeoutWith();
    init_timestamp();
    init_toArray();
    init_window();
    init_windowCount();
    init_windowTime();
    init_windowToggle();
    init_windowWhen();
    init_withLatestFrom();
    init_zipAll();
    init_zipWith();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/partition.js
function partition2(predicate, thisArg) {
  return function(source) {
    return [filter(predicate, thisArg)(source), filter(not(predicate, thisArg))(source)];
  };
}
var init_partition2 = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/partition.js"() {
    init_define_ngDevMode();
    init_not();
    init_filter();
  }
});

// node_modules/rxjs/dist/esm5/internal/operators/race.js
function race2() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return raceWith.apply(void 0, __spreadArray([], __read(argsOrArgArray(args))));
}
var init_race2 = __esm({
  "node_modules/rxjs/dist/esm5/internal/operators/race.js"() {
    init_define_ngDevMode();
    init_tslib_es6();
    init_argsOrArgArray();
    init_raceWith();
  }
});

// node_modules/rxjs/dist/esm5/operators/index.js
var operators_exports = {};
__export(operators_exports, {
  audit: () => audit,
  auditTime: () => auditTime,
  buffer: () => buffer,
  bufferCount: () => bufferCount,
  bufferTime: () => bufferTime,
  bufferToggle: () => bufferToggle,
  bufferWhen: () => bufferWhen,
  catchError: () => catchError,
  combineAll: () => combineAll,
  combineLatest: () => combineLatest2,
  combineLatestAll: () => combineLatestAll,
  combineLatestWith: () => combineLatestWith,
  concat: () => concat2,
  concatAll: () => concatAll,
  concatMap: () => concatMap,
  concatMapTo: () => concatMapTo,
  concatWith: () => concatWith,
  connect: () => connect,
  count: () => count,
  debounce: () => debounce,
  debounceTime: () => debounceTime,
  defaultIfEmpty: () => defaultIfEmpty,
  delay: () => delay,
  delayWhen: () => delayWhen,
  dematerialize: () => dematerialize,
  distinct: () => distinct,
  distinctUntilChanged: () => distinctUntilChanged,
  distinctUntilKeyChanged: () => distinctUntilKeyChanged,
  elementAt: () => elementAt,
  endWith: () => endWith,
  every: () => every,
  exhaust: () => exhaust,
  exhaustAll: () => exhaustAll,
  exhaustMap: () => exhaustMap,
  expand: () => expand,
  filter: () => filter,
  finalize: () => finalize,
  find: () => find,
  findIndex: () => findIndex,
  first: () => first,
  flatMap: () => flatMap,
  groupBy: () => groupBy,
  ignoreElements: () => ignoreElements,
  isEmpty: () => isEmpty,
  last: () => last2,
  map: () => map,
  mapTo: () => mapTo,
  materialize: () => materialize,
  max: () => max,
  merge: () => merge2,
  mergeAll: () => mergeAll,
  mergeMap: () => mergeMap,
  mergeMapTo: () => mergeMapTo,
  mergeScan: () => mergeScan,
  mergeWith: () => mergeWith,
  min: () => min,
  multicast: () => multicast,
  observeOn: () => observeOn,
  onErrorResumeNext: () => onErrorResumeNext,
  pairwise: () => pairwise,
  partition: () => partition2,
  pluck: () => pluck,
  publish: () => publish,
  publishBehavior: () => publishBehavior,
  publishLast: () => publishLast,
  publishReplay: () => publishReplay,
  race: () => race2,
  raceWith: () => raceWith,
  reduce: () => reduce,
  refCount: () => refCount,
  repeat: () => repeat,
  repeatWhen: () => repeatWhen,
  retry: () => retry,
  retryWhen: () => retryWhen,
  sample: () => sample,
  sampleTime: () => sampleTime,
  scan: () => scan,
  sequenceEqual: () => sequenceEqual,
  share: () => share,
  shareReplay: () => shareReplay,
  single: () => single,
  skip: () => skip,
  skipLast: () => skipLast,
  skipUntil: () => skipUntil,
  skipWhile: () => skipWhile,
  startWith: () => startWith,
  subscribeOn: () => subscribeOn,
  switchAll: () => switchAll,
  switchMap: () => switchMap,
  switchMapTo: () => switchMapTo,
  switchScan: () => switchScan,
  take: () => take,
  takeLast: () => takeLast,
  takeUntil: () => takeUntil,
  takeWhile: () => takeWhile,
  tap: () => tap,
  throttle: () => throttle,
  throttleTime: () => throttleTime,
  throwIfEmpty: () => throwIfEmpty,
  timeInterval: () => timeInterval,
  timeout: () => timeout,
  timeoutWith: () => timeoutWith,
  timestamp: () => timestamp,
  toArray: () => toArray,
  window: () => window2,
  windowCount: () => windowCount,
  windowTime: () => windowTime,
  windowToggle: () => windowToggle,
  windowWhen: () => windowWhen,
  withLatestFrom: () => withLatestFrom,
  zip: () => zip2,
  zipAll: () => zipAll,
  zipWith: () => zipWith
});
var init_operators = __esm({
  "node_modules/rxjs/dist/esm5/operators/index.js"() {
    init_define_ngDevMode();
    init_audit();
    init_auditTime();
    init_buffer();
    init_bufferCount();
    init_bufferTime();
    init_bufferToggle();
    init_bufferWhen();
    init_catchError();
    init_combineAll();
    init_combineLatestAll();
    init_combineLatest2();
    init_combineLatestWith();
    init_concat2();
    init_concatAll();
    init_concatMap();
    init_concatMapTo();
    init_concatWith();
    init_connect();
    init_count();
    init_debounce();
    init_debounceTime();
    init_defaultIfEmpty();
    init_delay();
    init_delayWhen();
    init_dematerialize();
    init_distinct();
    init_distinctUntilChanged();
    init_distinctUntilKeyChanged();
    init_elementAt();
    init_endWith();
    init_every();
    init_exhaust();
    init_exhaustAll();
    init_exhaustMap();
    init_expand();
    init_filter();
    init_finalize();
    init_find();
    init_findIndex();
    init_first();
    init_groupBy();
    init_ignoreElements();
    init_isEmpty();
    init_last();
    init_map();
    init_mapTo();
    init_materialize();
    init_max();
    init_merge2();
    init_mergeAll();
    init_flatMap();
    init_mergeMap();
    init_mergeMapTo();
    init_mergeScan();
    init_mergeWith();
    init_min();
    init_multicast();
    init_observeOn();
    init_onErrorResumeNext();
    init_pairwise();
    init_partition2();
    init_pluck();
    init_publish();
    init_publishBehavior();
    init_publishLast();
    init_publishReplay();
    init_race2();
    init_raceWith();
    init_reduce();
    init_repeat();
    init_repeatWhen();
    init_retry();
    init_retryWhen();
    init_refCount();
    init_sample();
    init_sampleTime();
    init_scan();
    init_sequenceEqual();
    init_share();
    init_shareReplay();
    init_single();
    init_skip();
    init_skipLast();
    init_skipUntil();
    init_skipWhile();
    init_startWith();
    init_subscribeOn();
    init_switchAll();
    init_switchMap();
    init_switchMapTo();
    init_switchScan();
    init_take();
    init_takeLast();
    init_takeUntil();
    init_takeWhile();
    init_tap();
    init_throttle();
    init_throttleTime();
    init_throwIfEmpty();
    init_timeInterval();
    init_timeout();
    init_timeoutWith();
    init_timestamp();
    init_toArray();
    init_window();
    init_windowCount();
    init_windowTime();
    init_windowToggle();
    init_windowWhen();
    init_withLatestFrom();
    init_zip2();
    init_zipAll();
    init_zipWith();
  }
});

// node_modules/@angular/core/fesm2015/core.mjs
var core_exports = {};
__export(core_exports, {
  ANALYZE_FOR_ENTRY_COMPONENTS: () => ANALYZE_FOR_ENTRY_COMPONENTS,
  ANIMATION_MODULE_TYPE: () => ANIMATION_MODULE_TYPE,
  APP_BOOTSTRAP_LISTENER: () => APP_BOOTSTRAP_LISTENER,
  APP_ID: () => APP_ID,
  APP_INITIALIZER: () => APP_INITIALIZER,
  ApplicationInitStatus: () => ApplicationInitStatus,
  ApplicationModule: () => ApplicationModule,
  ApplicationRef: () => ApplicationRef,
  Attribute: () => Attribute,
  COMPILER_OPTIONS: () => COMPILER_OPTIONS,
  CUSTOM_ELEMENTS_SCHEMA: () => CUSTOM_ELEMENTS_SCHEMA,
  ChangeDetectionStrategy: () => ChangeDetectionStrategy,
  ChangeDetectorRef: () => ChangeDetectorRef,
  Compiler: () => Compiler,
  CompilerFactory: () => CompilerFactory,
  Component: () => Component,
  ComponentFactory: () => ComponentFactory$1,
  ComponentFactoryResolver: () => ComponentFactoryResolver$1,
  ComponentRef: () => ComponentRef$1,
  ContentChild: () => ContentChild,
  ContentChildren: () => ContentChildren,
  DEFAULT_CURRENCY_CODE: () => DEFAULT_CURRENCY_CODE,
  DebugElement: () => DebugElement,
  DebugEventListener: () => DebugEventListener,
  DebugNode: () => DebugNode,
  DefaultIterableDiffer: () => DefaultIterableDiffer,
  Directive: () => Directive,
  ENVIRONMENT_INITIALIZER: () => ENVIRONMENT_INITIALIZER,
  ElementRef: () => ElementRef,
  EmbeddedViewRef: () => EmbeddedViewRef,
  EnvironmentInjector: () => EnvironmentInjector,
  ErrorHandler: () => ErrorHandler,
  EventEmitter: () => EventEmitter,
  Host: () => Host,
  HostBinding: () => HostBinding,
  HostListener: () => HostListener,
  INJECTOR: () => INJECTOR,
  Inject: () => Inject,
  InjectFlags: () => InjectFlags,
  Injectable: () => Injectable,
  InjectionToken: () => InjectionToken,
  Injector: () => Injector,
  Input: () => Input,
  IterableDiffers: () => IterableDiffers,
  KeyValueDiffers: () => KeyValueDiffers,
  LOCALE_ID: () => LOCALE_ID,
  MissingTranslationStrategy: () => MissingTranslationStrategy,
  ModuleWithComponentFactories: () => ModuleWithComponentFactories,
  NO_ERRORS_SCHEMA: () => NO_ERRORS_SCHEMA,
  NgModule: () => NgModule,
  NgModuleFactory: () => NgModuleFactory$1,
  NgModuleRef: () => NgModuleRef$1,
  NgProbeToken: () => NgProbeToken,
  NgZone: () => NgZone,
  Optional: () => Optional,
  Output: () => Output,
  PACKAGE_ROOT_URL: () => PACKAGE_ROOT_URL,
  PLATFORM_ID: () => PLATFORM_ID,
  PLATFORM_INITIALIZER: () => PLATFORM_INITIALIZER,
  Pipe: () => Pipe,
  PlatformRef: () => PlatformRef,
  Query: () => Query,
  QueryList: () => QueryList,
  ReflectiveInjector: () => ReflectiveInjector,
  ReflectiveKey: () => ReflectiveKey,
  Renderer2: () => Renderer2,
  RendererFactory2: () => RendererFactory2,
  RendererStyleFlags2: () => RendererStyleFlags2,
  ResolvedReflectiveFactory: () => ResolvedReflectiveFactory,
  Sanitizer: () => Sanitizer,
  SecurityContext: () => SecurityContext,
  Self: () => Self,
  SimpleChange: () => SimpleChange,
  SkipSelf: () => SkipSelf,
  TRANSLATIONS: () => TRANSLATIONS,
  TRANSLATIONS_FORMAT: () => TRANSLATIONS_FORMAT,
  TemplateRef: () => TemplateRef,
  Testability: () => Testability,
  TestabilityRegistry: () => TestabilityRegistry,
  Type: () => Type,
  VERSION: () => VERSION,
  Version: () => Version,
  ViewChild: () => ViewChild,
  ViewChildren: () => ViewChildren,
  ViewContainerRef: () => ViewContainerRef,
  ViewEncapsulation: () => ViewEncapsulation$1,
  ViewRef: () => ViewRef,
  asNativeElements: () => asNativeElements,
  assertPlatform: () => assertPlatform,
  createComponent: () => createComponent,
  createEnvironmentInjector: () => createEnvironmentInjector,
  createNgModule: () => createNgModule,
  createNgModuleRef: () => createNgModuleRef,
  createPlatform: () => createPlatform,
  createPlatformFactory: () => createPlatformFactory,
  defineInjectable: () => defineInjectable,
  destroyPlatform: () => destroyPlatform,
  enableProdMode: () => enableProdMode,
  forwardRef: () => forwardRef,
  getDebugNode: () => getDebugNode,
  getModuleFactory: () => getModuleFactory,
  getNgModuleById: () => getNgModuleById,
  getPlatform: () => getPlatform,
  importProvidersFrom: () => importProvidersFrom,
  inject: () => inject,
  isDevMode: () => isDevMode,
  platformCore: () => platformCore,
  reflectComponentType: () => reflectComponentType,
  resolveForwardRef: () => resolveForwardRef,
  setTestabilityGetter: () => setTestabilityGetter,
  \u0275ALLOW_MULTIPLE_PLATFORMS: () => ALLOW_MULTIPLE_PLATFORMS,
  \u0275APP_ID_RANDOM_PROVIDER: () => APP_ID_RANDOM_PROVIDER,
  \u0275ChangeDetectorStatus: () => ChangeDetectorStatus,
  \u0275ComponentFactory: () => ComponentFactory$1,
  \u0275Console: () => Console,
  \u0275DEFAULT_LOCALE_ID: () => DEFAULT_LOCALE_ID,
  \u0275INJECTOR_SCOPE: () => INJECTOR_SCOPE,
  \u0275LContext: () => LContext,
  \u0275LifecycleHooksFeature: () => LifecycleHooksFeature,
  \u0275LocaleDataIndex: () => LocaleDataIndex,
  \u0275NG_COMP_DEF: () => NG_COMP_DEF,
  \u0275NG_DIR_DEF: () => NG_DIR_DEF,
  \u0275NG_ELEMENT_ID: () => NG_ELEMENT_ID,
  \u0275NG_INJ_DEF: () => NG_INJ_DEF,
  \u0275NG_MOD_DEF: () => NG_MOD_DEF,
  \u0275NG_PIPE_DEF: () => NG_PIPE_DEF,
  \u0275NG_PROV_DEF: () => NG_PROV_DEF,
  \u0275NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR: () => NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR,
  \u0275NO_CHANGE: () => NO_CHANGE,
  \u0275NgModuleFactory: () => NgModuleFactory,
  \u0275NoopNgZone: () => NoopNgZone,
  \u0275ReflectionCapabilities: () => ReflectionCapabilities,
  \u0275Render3ComponentFactory: () => ComponentFactory,
  \u0275Render3ComponentRef: () => ComponentRef,
  \u0275Render3NgModuleRef: () => NgModuleRef,
  \u0275RuntimeError: () => RuntimeError,
  \u0275TESTABILITY: () => TESTABILITY,
  \u0275TESTABILITY_GETTER: () => TESTABILITY_GETTER,
  \u0275ViewRef: () => ViewRef$1,
  \u0275_sanitizeHtml: () => _sanitizeHtml,
  \u0275_sanitizeUrl: () => _sanitizeUrl,
  \u0275allowSanitizationBypassAndThrow: () => allowSanitizationBypassAndThrow,
  \u0275bypassSanitizationTrustHtml: () => bypassSanitizationTrustHtml,
  \u0275bypassSanitizationTrustResourceUrl: () => bypassSanitizationTrustResourceUrl,
  \u0275bypassSanitizationTrustScript: () => bypassSanitizationTrustScript,
  \u0275bypassSanitizationTrustStyle: () => bypassSanitizationTrustStyle,
  \u0275bypassSanitizationTrustUrl: () => bypassSanitizationTrustUrl,
  \u0275clearResolutionOfComponentResourcesQueue: () => clearResolutionOfComponentResourcesQueue,
  \u0275coerceToBoolean: () => coerceToBoolean,
  \u0275compileComponent: () => compileComponent,
  \u0275compileDirective: () => compileDirective,
  \u0275compileNgModule: () => compileNgModule,
  \u0275compileNgModuleDefs: () => compileNgModuleDefs,
  \u0275compileNgModuleFactory: () => compileNgModuleFactory,
  \u0275compilePipe: () => compilePipe,
  \u0275createInjector: () => createInjector,
  \u0275defaultIterableDiffers: () => defaultIterableDiffers,
  \u0275defaultKeyValueDiffers: () => defaultKeyValueDiffers,
  \u0275detectChanges: () => detectChanges,
  \u0275devModeEqual: () => devModeEqual,
  \u0275findLocaleData: () => findLocaleData,
  \u0275flushModuleScopingQueueAsMuchAsPossible: () => flushModuleScopingQueueAsMuchAsPossible,
  \u0275getDebugNode: () => getDebugNode,
  \u0275getDebugNodeR2: () => getDebugNodeR2,
  \u0275getDirectives: () => getDirectives,
  \u0275getHostElement: () => getHostElement,
  \u0275getInjectableDef: () => getInjectableDef,
  \u0275getLContext: () => getLContext,
  \u0275getLocaleCurrencyCode: () => getLocaleCurrencyCode,
  \u0275getLocalePluralCase: () => getLocalePluralCase,
  \u0275getSanitizationBypassType: () => getSanitizationBypassType,
  \u0275getUnknownElementStrictMode: () => \u0275getUnknownElementStrictMode,
  \u0275getUnknownPropertyStrictMode: () => \u0275getUnknownPropertyStrictMode,
  \u0275global: () => _global,
  \u0275injectChangeDetectorRef: () => injectChangeDetectorRef,
  \u0275internalBootstrapApplication: () => internalBootstrapApplication,
  \u0275isBoundToModule: () => isBoundToModule,
  \u0275isDefaultChangeDetectionStrategy: () => isDefaultChangeDetectionStrategy,
  \u0275isListLikeIterable: () => isListLikeIterable,
  \u0275isObservable: () => isObservable2,
  \u0275isPromise: () => isPromise2,
  \u0275isStandalone: () => isStandalone,
  \u0275isSubscribable: () => isSubscribable,
  \u0275ivyEnabled: () => \u0275ivyEnabled,
  \u0275makeDecorator: () => makeDecorator,
  \u0275markDirty: () => markDirty,
  \u0275noSideEffects: () => noSideEffects,
  \u0275patchComponentDefWithScope: () => patchComponentDefWithScope,
  \u0275publishDefaultGlobalUtils: () => publishDefaultGlobalUtils$1,
  \u0275publishGlobalUtil: () => publishGlobalUtil,
  \u0275registerLocaleData: () => registerLocaleData,
  \u0275resetCompiledComponents: () => resetCompiledComponents,
  \u0275resetJitOptions: () => resetJitOptions,
  \u0275resolveComponentResources: () => resolveComponentResources,
  \u0275setAllowDuplicateNgModuleIdsForTest: () => setAllowDuplicateNgModuleIdsForTest,
  \u0275setClassMetadata: () => setClassMetadata,
  \u0275setCurrentInjector: () => setCurrentInjector,
  \u0275setDocument: () => setDocument,
  \u0275setLocaleId: () => setLocaleId,
  \u0275setUnknownElementStrictMode: () => \u0275setUnknownElementStrictMode,
  \u0275setUnknownPropertyStrictMode: () => \u0275setUnknownPropertyStrictMode,
  \u0275store: () => store,
  \u0275stringify: () => stringify,
  \u0275transitiveScopesFor: () => transitiveScopesFor,
  \u0275unregisterLocaleData: () => unregisterAllLocaleData,
  \u0275unwrapSafeValue: () => unwrapSafeValue,
  \u0275whenRendered: () => whenRendered,
  \u0275\u0275CopyDefinitionFeature: () => \u0275\u0275CopyDefinitionFeature,
  \u0275\u0275FactoryTarget: () => FactoryTarget,
  \u0275\u0275InheritDefinitionFeature: () => \u0275\u0275InheritDefinitionFeature,
  \u0275\u0275NgOnChangesFeature: () => \u0275\u0275NgOnChangesFeature,
  \u0275\u0275ProvidersFeature: () => \u0275\u0275ProvidersFeature,
  \u0275\u0275StandaloneFeature: () => \u0275\u0275StandaloneFeature,
  \u0275\u0275advance: () => \u0275\u0275advance,
  \u0275\u0275attribute: () => \u0275\u0275attribute,
  \u0275\u0275attributeInterpolate1: () => \u0275\u0275attributeInterpolate1,
  \u0275\u0275attributeInterpolate2: () => \u0275\u0275attributeInterpolate2,
  \u0275\u0275attributeInterpolate3: () => \u0275\u0275attributeInterpolate3,
  \u0275\u0275attributeInterpolate4: () => \u0275\u0275attributeInterpolate4,
  \u0275\u0275attributeInterpolate5: () => \u0275\u0275attributeInterpolate5,
  \u0275\u0275attributeInterpolate6: () => \u0275\u0275attributeInterpolate6,
  \u0275\u0275attributeInterpolate7: () => \u0275\u0275attributeInterpolate7,
  \u0275\u0275attributeInterpolate8: () => \u0275\u0275attributeInterpolate8,
  \u0275\u0275attributeInterpolateV: () => \u0275\u0275attributeInterpolateV,
  \u0275\u0275classMap: () => \u0275\u0275classMap,
  \u0275\u0275classMapInterpolate1: () => \u0275\u0275classMapInterpolate1,
  \u0275\u0275classMapInterpolate2: () => \u0275\u0275classMapInterpolate2,
  \u0275\u0275classMapInterpolate3: () => \u0275\u0275classMapInterpolate3,
  \u0275\u0275classMapInterpolate4: () => \u0275\u0275classMapInterpolate4,
  \u0275\u0275classMapInterpolate5: () => \u0275\u0275classMapInterpolate5,
  \u0275\u0275classMapInterpolate6: () => \u0275\u0275classMapInterpolate6,
  \u0275\u0275classMapInterpolate7: () => \u0275\u0275classMapInterpolate7,
  \u0275\u0275classMapInterpolate8: () => \u0275\u0275classMapInterpolate8,
  \u0275\u0275classMapInterpolateV: () => \u0275\u0275classMapInterpolateV,
  \u0275\u0275classProp: () => \u0275\u0275classProp,
  \u0275\u0275contentQuery: () => \u0275\u0275contentQuery,
  \u0275\u0275defineComponent: () => \u0275\u0275defineComponent,
  \u0275\u0275defineDirective: () => \u0275\u0275defineDirective,
  \u0275\u0275defineInjectable: () => \u0275\u0275defineInjectable,
  \u0275\u0275defineInjector: () => \u0275\u0275defineInjector,
  \u0275\u0275defineNgModule: () => \u0275\u0275defineNgModule,
  \u0275\u0275definePipe: () => \u0275\u0275definePipe,
  \u0275\u0275directiveInject: () => \u0275\u0275directiveInject,
  \u0275\u0275disableBindings: () => \u0275\u0275disableBindings,
  \u0275\u0275element: () => \u0275\u0275element,
  \u0275\u0275elementContainer: () => \u0275\u0275elementContainer,
  \u0275\u0275elementContainerEnd: () => \u0275\u0275elementContainerEnd,
  \u0275\u0275elementContainerStart: () => \u0275\u0275elementContainerStart,
  \u0275\u0275elementEnd: () => \u0275\u0275elementEnd,
  \u0275\u0275elementStart: () => \u0275\u0275elementStart,
  \u0275\u0275enableBindings: () => \u0275\u0275enableBindings,
  \u0275\u0275getCurrentView: () => \u0275\u0275getCurrentView,
  \u0275\u0275getInheritedFactory: () => \u0275\u0275getInheritedFactory,
  \u0275\u0275hostProperty: () => \u0275\u0275hostProperty,
  \u0275\u0275i18n: () => \u0275\u0275i18n,
  \u0275\u0275i18nApply: () => \u0275\u0275i18nApply,
  \u0275\u0275i18nAttributes: () => \u0275\u0275i18nAttributes,
  \u0275\u0275i18nEnd: () => \u0275\u0275i18nEnd,
  \u0275\u0275i18nExp: () => \u0275\u0275i18nExp,
  \u0275\u0275i18nPostprocess: () => \u0275\u0275i18nPostprocess,
  \u0275\u0275i18nStart: () => \u0275\u0275i18nStart,
  \u0275\u0275inject: () => \u0275\u0275inject,
  \u0275\u0275injectAttribute: () => \u0275\u0275injectAttribute,
  \u0275\u0275invalidFactory: () => \u0275\u0275invalidFactory,
  \u0275\u0275invalidFactoryDep: () => \u0275\u0275invalidFactoryDep,
  \u0275\u0275listener: () => \u0275\u0275listener,
  \u0275\u0275loadQuery: () => \u0275\u0275loadQuery,
  \u0275\u0275namespaceHTML: () => \u0275\u0275namespaceHTML,
  \u0275\u0275namespaceMathML: () => \u0275\u0275namespaceMathML,
  \u0275\u0275namespaceSVG: () => \u0275\u0275namespaceSVG,
  \u0275\u0275nextContext: () => \u0275\u0275nextContext,
  \u0275\u0275ngDeclareClassMetadata: () => \u0275\u0275ngDeclareClassMetadata,
  \u0275\u0275ngDeclareComponent: () => \u0275\u0275ngDeclareComponent,
  \u0275\u0275ngDeclareDirective: () => \u0275\u0275ngDeclareDirective,
  \u0275\u0275ngDeclareFactory: () => \u0275\u0275ngDeclareFactory,
  \u0275\u0275ngDeclareInjectable: () => \u0275\u0275ngDeclareInjectable,
  \u0275\u0275ngDeclareInjector: () => \u0275\u0275ngDeclareInjector,
  \u0275\u0275ngDeclareNgModule: () => \u0275\u0275ngDeclareNgModule,
  \u0275\u0275ngDeclarePipe: () => \u0275\u0275ngDeclarePipe,
  \u0275\u0275pipe: () => \u0275\u0275pipe,
  \u0275\u0275pipeBind1: () => \u0275\u0275pipeBind1,
  \u0275\u0275pipeBind2: () => \u0275\u0275pipeBind2,
  \u0275\u0275pipeBind3: () => \u0275\u0275pipeBind3,
  \u0275\u0275pipeBind4: () => \u0275\u0275pipeBind4,
  \u0275\u0275pipeBindV: () => \u0275\u0275pipeBindV,
  \u0275\u0275projection: () => \u0275\u0275projection,
  \u0275\u0275projectionDef: () => \u0275\u0275projectionDef,
  \u0275\u0275property: () => \u0275\u0275property,
  \u0275\u0275propertyInterpolate: () => \u0275\u0275propertyInterpolate,
  \u0275\u0275propertyInterpolate1: () => \u0275\u0275propertyInterpolate1,
  \u0275\u0275propertyInterpolate2: () => \u0275\u0275propertyInterpolate2,
  \u0275\u0275propertyInterpolate3: () => \u0275\u0275propertyInterpolate3,
  \u0275\u0275propertyInterpolate4: () => \u0275\u0275propertyInterpolate4,
  \u0275\u0275propertyInterpolate5: () => \u0275\u0275propertyInterpolate5,
  \u0275\u0275propertyInterpolate6: () => \u0275\u0275propertyInterpolate6,
  \u0275\u0275propertyInterpolate7: () => \u0275\u0275propertyInterpolate7,
  \u0275\u0275propertyInterpolate8: () => \u0275\u0275propertyInterpolate8,
  \u0275\u0275propertyInterpolateV: () => \u0275\u0275propertyInterpolateV,
  \u0275\u0275pureFunction0: () => \u0275\u0275pureFunction0,
  \u0275\u0275pureFunction1: () => \u0275\u0275pureFunction1,
  \u0275\u0275pureFunction2: () => \u0275\u0275pureFunction2,
  \u0275\u0275pureFunction3: () => \u0275\u0275pureFunction3,
  \u0275\u0275pureFunction4: () => \u0275\u0275pureFunction4,
  \u0275\u0275pureFunction5: () => \u0275\u0275pureFunction5,
  \u0275\u0275pureFunction6: () => \u0275\u0275pureFunction6,
  \u0275\u0275pureFunction7: () => \u0275\u0275pureFunction7,
  \u0275\u0275pureFunction8: () => \u0275\u0275pureFunction8,
  \u0275\u0275pureFunctionV: () => \u0275\u0275pureFunctionV,
  \u0275\u0275queryRefresh: () => \u0275\u0275queryRefresh,
  \u0275\u0275reference: () => \u0275\u0275reference,
  \u0275\u0275registerNgModuleType: () => registerNgModuleType,
  \u0275\u0275resetView: () => \u0275\u0275resetView,
  \u0275\u0275resolveBody: () => \u0275\u0275resolveBody,
  \u0275\u0275resolveDocument: () => \u0275\u0275resolveDocument,
  \u0275\u0275resolveWindow: () => \u0275\u0275resolveWindow,
  \u0275\u0275restoreView: () => \u0275\u0275restoreView,
  \u0275\u0275sanitizeHtml: () => \u0275\u0275sanitizeHtml,
  \u0275\u0275sanitizeResourceUrl: () => \u0275\u0275sanitizeResourceUrl,
  \u0275\u0275sanitizeScript: () => \u0275\u0275sanitizeScript,
  \u0275\u0275sanitizeStyle: () => \u0275\u0275sanitizeStyle,
  \u0275\u0275sanitizeUrl: () => \u0275\u0275sanitizeUrl,
  \u0275\u0275sanitizeUrlOrResourceUrl: () => \u0275\u0275sanitizeUrlOrResourceUrl,
  \u0275\u0275setComponentScope: () => \u0275\u0275setComponentScope,
  \u0275\u0275setNgModuleScope: () => \u0275\u0275setNgModuleScope,
  \u0275\u0275styleMap: () => \u0275\u0275styleMap,
  \u0275\u0275styleMapInterpolate1: () => \u0275\u0275styleMapInterpolate1,
  \u0275\u0275styleMapInterpolate2: () => \u0275\u0275styleMapInterpolate2,
  \u0275\u0275styleMapInterpolate3: () => \u0275\u0275styleMapInterpolate3,
  \u0275\u0275styleMapInterpolate4: () => \u0275\u0275styleMapInterpolate4,
  \u0275\u0275styleMapInterpolate5: () => \u0275\u0275styleMapInterpolate5,
  \u0275\u0275styleMapInterpolate6: () => \u0275\u0275styleMapInterpolate6,
  \u0275\u0275styleMapInterpolate7: () => \u0275\u0275styleMapInterpolate7,
  \u0275\u0275styleMapInterpolate8: () => \u0275\u0275styleMapInterpolate8,
  \u0275\u0275styleMapInterpolateV: () => \u0275\u0275styleMapInterpolateV,
  \u0275\u0275styleProp: () => \u0275\u0275styleProp,
  \u0275\u0275stylePropInterpolate1: () => \u0275\u0275stylePropInterpolate1,
  \u0275\u0275stylePropInterpolate2: () => \u0275\u0275stylePropInterpolate2,
  \u0275\u0275stylePropInterpolate3: () => \u0275\u0275stylePropInterpolate3,
  \u0275\u0275stylePropInterpolate4: () => \u0275\u0275stylePropInterpolate4,
  \u0275\u0275stylePropInterpolate5: () => \u0275\u0275stylePropInterpolate5,
  \u0275\u0275stylePropInterpolate6: () => \u0275\u0275stylePropInterpolate6,
  \u0275\u0275stylePropInterpolate7: () => \u0275\u0275stylePropInterpolate7,
  \u0275\u0275stylePropInterpolate8: () => \u0275\u0275stylePropInterpolate8,
  \u0275\u0275stylePropInterpolateV: () => \u0275\u0275stylePropInterpolateV,
  \u0275\u0275syntheticHostListener: () => \u0275\u0275syntheticHostListener,
  \u0275\u0275syntheticHostProperty: () => \u0275\u0275syntheticHostProperty,
  \u0275\u0275template: () => \u0275\u0275template,
  \u0275\u0275templateRefExtractor: () => \u0275\u0275templateRefExtractor,
  \u0275\u0275text: () => \u0275\u0275text,
  \u0275\u0275textInterpolate: () => \u0275\u0275textInterpolate,
  \u0275\u0275textInterpolate1: () => \u0275\u0275textInterpolate1,
  \u0275\u0275textInterpolate2: () => \u0275\u0275textInterpolate2,
  \u0275\u0275textInterpolate3: () => \u0275\u0275textInterpolate3,
  \u0275\u0275textInterpolate4: () => \u0275\u0275textInterpolate4,
  \u0275\u0275textInterpolate5: () => \u0275\u0275textInterpolate5,
  \u0275\u0275textInterpolate6: () => \u0275\u0275textInterpolate6,
  \u0275\u0275textInterpolate7: () => \u0275\u0275textInterpolate7,
  \u0275\u0275textInterpolate8: () => \u0275\u0275textInterpolate8,
  \u0275\u0275textInterpolateV: () => \u0275\u0275textInterpolateV,
  \u0275\u0275trustConstantHtml: () => \u0275\u0275trustConstantHtml,
  \u0275\u0275trustConstantResourceUrl: () => \u0275\u0275trustConstantResourceUrl,
  \u0275\u0275viewQuery: () => \u0275\u0275viewQuery
});
function getClosureSafeProperty(objWithPropertyToExtract) {
  for (let key in objWithPropertyToExtract) {
    if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
      return key;
    }
  }
  throw Error("Could not find renamed property on target object.");
}
function fillProperties(target, source) {
  for (const key in source) {
    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }
}
function stringify(token) {
  if (typeof token === "string") {
    return token;
  }
  if (Array.isArray(token)) {
    return "[" + token.map(stringify).join(", ") + "]";
  }
  if (token == null) {
    return "" + token;
  }
  if (token.overriddenName) {
    return `${token.overriddenName}`;
  }
  if (token.name) {
    return `${token.name}`;
  }
  const res = token.toString();
  if (res == null) {
    return "" + res;
  }
  const newLineIndex = res.indexOf("\n");
  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
}
function concatStringsWithSpace(before, after) {
  return before == null || before === "" ? after === null ? "" : after : after == null || after === "" ? before : before + " " + after;
}
function forwardRef(forwardRefFn) {
  forwardRefFn.__forward_ref__ = forwardRef;
  forwardRefFn.toString = function() {
    return stringify(this());
  };
  return forwardRefFn;
}
function resolveForwardRef(type) {
  return isForwardRef(type) ? type() : type;
}
function isForwardRef(fn2) {
  return typeof fn2 === "function" && fn2.hasOwnProperty(__forward_ref__) && fn2.__forward_ref__ === forwardRef;
}
function formatRuntimeError(code, message) {
  const fullCode = `NG0${Math.abs(code)}`;
  let errorMessage = `${fullCode}${message ? ": " + message.trim() : ""}`;
  if (define_ngDevMode_default && code < 0) {
    const addPeriodSeparator = !errorMessage.match(/[.,;!?]$/);
    const separator = addPeriodSeparator ? "." : "";
    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;
  }
  return errorMessage;
}
function renderStringify(value) {
  if (typeof value === "string")
    return value;
  if (value == null)
    return "";
  return String(value);
}
function stringifyForError(value) {
  if (typeof value === "function")
    return value.name || value.toString();
  if (typeof value === "object" && value != null && typeof value.type === "function") {
    return value.type.name || value.type.toString();
  }
  return renderStringify(value);
}
function throwCyclicDependencyError(token, path) {
  const depPath = path ? `. Dependency path: ${path.join(" > ")} > ${token}` : "";
  throw new RuntimeError(
    -200,
    `Circular dependency in DI detected for ${token}${depPath}`
  );
}
function throwMixedMultiProviderError() {
  throw new Error(`Cannot mix multi providers and regular providers`);
}
function throwInvalidProviderError(ngModuleType, providers, provider) {
  if (ngModuleType && providers) {
    const providerDetail = providers.map((v) => v == provider ? "?" + provider + "?" : "...");
    throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(", ")}]`);
  } else if (provider.\u0275providers) {
    throw new RuntimeError(
      207,
      `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`
    );
  } else {
    throw new Error("Invalid provider");
  }
}
function throwProviderNotFoundError(token, injectorName) {
  const injectorDetails = injectorName ? ` in ${injectorName}` : "";
  throw new RuntimeError(
    -201,
    define_ngDevMode_default && `No provider for ${stringifyForError(token)} found${injectorDetails}`
  );
}
function assertNumber(actual, msg) {
  if (!(typeof actual === "number")) {
    throwError2(msg, typeof actual, "number", "===");
  }
}
function assertNumberInRange(actual, minInclusive, maxInclusive) {
  assertNumber(actual, "Expected a number");
  assertLessThanOrEqual(actual, maxInclusive, "Expected number to be less than or equal to");
  assertGreaterThanOrEqual(actual, minInclusive, "Expected number to be greater than or equal to");
}
function assertString(actual, msg) {
  if (!(typeof actual === "string")) {
    throwError2(msg, actual === null ? "null" : typeof actual, "string", "===");
  }
}
function assertFunction(actual, msg) {
  if (!(typeof actual === "function")) {
    throwError2(msg, actual === null ? "null" : typeof actual, "function", "===");
  }
}
function assertEqual(actual, expected, msg) {
  if (!(actual == expected)) {
    throwError2(msg, actual, expected, "==");
  }
}
function assertNotEqual(actual, expected, msg) {
  if (!(actual != expected)) {
    throwError2(msg, actual, expected, "!=");
  }
}
function assertSame(actual, expected, msg) {
  if (!(actual === expected)) {
    throwError2(msg, actual, expected, "===");
  }
}
function assertNotSame(actual, expected, msg) {
  if (!(actual !== expected)) {
    throwError2(msg, actual, expected, "!==");
  }
}
function assertLessThan(actual, expected, msg) {
  if (!(actual < expected)) {
    throwError2(msg, actual, expected, "<");
  }
}
function assertLessThanOrEqual(actual, expected, msg) {
  if (!(actual <= expected)) {
    throwError2(msg, actual, expected, "<=");
  }
}
function assertGreaterThan(actual, expected, msg) {
  if (!(actual > expected)) {
    throwError2(msg, actual, expected, ">");
  }
}
function assertGreaterThanOrEqual(actual, expected, msg) {
  if (!(actual >= expected)) {
    throwError2(msg, actual, expected, ">=");
  }
}
function assertDefined(actual, msg) {
  if (actual == null) {
    throwError2(msg, actual, null, "!=");
  }
}
function throwError2(msg, actual, expected, comparison) {
  throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? "" : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));
}
function assertDomNode(node) {
  if (!(typeof Node !== "undefined" && node instanceof Node) && !(typeof node === "object" && node != null && node.constructor.name === "WebWorkerRenderNode")) {
    throwError2(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);
  }
}
function assertIndexInRange(arr, index) {
  assertDefined(arr, "Array must be defined.");
  const maxLen = arr.length;
  if (index < 0 || index >= maxLen) {
    throwError2(`Index expected to be less than ${maxLen} but got ${index}`);
  }
}
function assertOneOf(value, ...validValues) {
  if (validValues.indexOf(value) !== -1)
    return true;
  throwError2(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);
}
function \u0275\u0275defineInjectable(opts) {
  return {
    token: opts.token,
    providedIn: opts.providedIn || null,
    factory: opts.factory,
    value: void 0
  };
}
function \u0275\u0275defineInjector(options) {
  return {
    providers: options.providers || [],
    imports: options.imports || []
  };
}
function getInjectableDef(type) {
  return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF);
}
function getOwnDefinition(type, field) {
  return type.hasOwnProperty(field) ? type[field] : null;
}
function getInheritedInjectableDef(type) {
  const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);
  if (def) {
    const typeName = getTypeName(type);
    console.warn(`DEPRECATED: DI is instantiating a token "${typeName}" that inherits its @Injectable decorator but does not provide one itself.
This will become an error in a future version of Angular. Please add @Injectable() to the "${typeName}" class.`);
    return def;
  } else {
    return null;
  }
}
function getTypeName(type) {
  if (type.hasOwnProperty("name")) {
    return type.name;
  }
  const match = ("" + type).match(/^function\s*([^\s(]+)/);
  return match === null ? "" : match[1];
}
function getInjectorDef(type) {
  return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ? type[NG_INJ_DEF] : null;
}
function getInjectImplementation() {
  return _injectImplementation;
}
function setInjectImplementation(impl) {
  const previous = _injectImplementation;
  _injectImplementation = impl;
  return previous;
}
function injectRootLimpMode(token, notFoundValue, flags) {
  const injectableDef = getInjectableDef(token);
  if (injectableDef && injectableDef.providedIn == "root") {
    return injectableDef.value === void 0 ? injectableDef.value = injectableDef.factory() : injectableDef.value;
  }
  if (flags & InjectFlags.Optional)
    return null;
  if (notFoundValue !== void 0)
    return notFoundValue;
  throwProviderNotFoundError(stringify(token), "Injector");
}
function assertInjectImplementationNotEqual(fn2) {
  define_ngDevMode_default && assertNotEqual(_injectImplementation, fn2, "Calling \u0275\u0275inject would cause infinite recursion");
}
function noSideEffects(fn2) {
  return {
    toString: fn2
  }.toString();
}
function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
  return changeDetectionStrategy == null || changeDetectionStrategy === ChangeDetectionStrategy.Default;
}
function ngDevModeResetPerfCounters() {
  const locationString = typeof location !== "undefined" ? location.toString() : "";
  const newCounters = {
    namedConstructors: locationString.indexOf("ngDevMode=namedConstructors") != -1,
    firstCreatePass: 0,
    tNode: 0,
    tView: 0,
    rendererCreateTextNode: 0,
    rendererSetText: 0,
    rendererCreateElement: 0,
    rendererAddEventListener: 0,
    rendererSetAttribute: 0,
    rendererRemoveAttribute: 0,
    rendererSetProperty: 0,
    rendererSetClassName: 0,
    rendererAddClass: 0,
    rendererRemoveClass: 0,
    rendererSetStyle: 0,
    rendererRemoveStyle: 0,
    rendererDestroy: 0,
    rendererDestroyNode: 0,
    rendererMoveNode: 0,
    rendererRemoveNode: 0,
    rendererAppendChild: 0,
    rendererInsertBefore: 0,
    rendererCreateComment: 0
  };
  const allowNgDevModeTrue = locationString.indexOf("ngDevMode=false") === -1;
  _global["ngDevMode"] = allowNgDevModeTrue && newCounters;
  return newCounters;
}
function initNgDevMode() {
  if (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) {
    if (typeof define_ngDevMode_default !== "object") {
      ngDevModeResetPerfCounters();
    }
    return typeof define_ngDevMode_default !== "undefined" && !!define_ngDevMode_default;
  }
  return false;
}
function \u0275\u0275defineComponent(componentDefinition) {
  return noSideEffects(() => {
    (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && initNgDevMode();
    const type = componentDefinition.type;
    const standalone = componentDefinition.standalone === true;
    const declaredInputs = {};
    const def = {
      type,
      providersResolver: null,
      decls: componentDefinition.decls,
      vars: componentDefinition.vars,
      factory: null,
      template: componentDefinition.template || null,
      consts: componentDefinition.consts || null,
      ngContentSelectors: componentDefinition.ngContentSelectors,
      hostBindings: componentDefinition.hostBindings || null,
      hostVars: componentDefinition.hostVars || 0,
      hostAttrs: componentDefinition.hostAttrs || null,
      contentQueries: componentDefinition.contentQueries || null,
      declaredInputs,
      inputs: null,
      outputs: null,
      exportAs: componentDefinition.exportAs || null,
      onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
      directiveDefs: null,
      pipeDefs: null,
      standalone,
      dependencies: standalone && componentDefinition.dependencies || null,
      getStandaloneInjector: null,
      selectors: componentDefinition.selectors || EMPTY_ARRAY,
      viewQuery: componentDefinition.viewQuery || null,
      features: componentDefinition.features || null,
      data: componentDefinition.data || {},
      encapsulation: componentDefinition.encapsulation || ViewEncapsulation$1.Emulated,
      id: `c${componentDefCount++}`,
      styles: componentDefinition.styles || EMPTY_ARRAY,
      _: null,
      setInput: null,
      schemas: componentDefinition.schemas || null,
      tView: null
    };
    const dependencies = componentDefinition.dependencies;
    const feature = componentDefinition.features;
    def.inputs = invertObject(componentDefinition.inputs, declaredInputs), def.outputs = invertObject(componentDefinition.outputs), feature && feature.forEach((fn2) => fn2(def));
    def.directiveDefs = dependencies ? () => (typeof dependencies === "function" ? dependencies() : dependencies).map(extractDirectiveDef).filter(nonNull) : null;
    def.pipeDefs = dependencies ? () => (typeof dependencies === "function" ? dependencies() : dependencies).map(getPipeDef$1).filter(nonNull) : null;
    return def;
  });
}
function \u0275\u0275setComponentScope(type, directives, pipes) {
  const def = type.\u0275cmp;
  def.directiveDefs = () => (typeof directives === "function" ? directives() : directives).map(extractDirectiveDef);
  def.pipeDefs = () => (typeof pipes === "function" ? pipes() : pipes).map(getPipeDef$1);
}
function extractDirectiveDef(type) {
  return getComponentDef(type) || getDirectiveDef(type);
}
function nonNull(value) {
  return value !== null;
}
function \u0275\u0275defineNgModule(def) {
  return noSideEffects(() => {
    const res = {
      type: def.type,
      bootstrap: def.bootstrap || EMPTY_ARRAY,
      declarations: def.declarations || EMPTY_ARRAY,
      imports: def.imports || EMPTY_ARRAY,
      exports: def.exports || EMPTY_ARRAY,
      transitiveCompileScopes: null,
      schemas: def.schemas || null,
      id: def.id || null
    };
    if (def.id != null) {
      autoRegisterModuleById[def.id] = def.type;
    }
    return res;
  });
}
function \u0275\u0275setNgModuleScope(type, scope) {
  return noSideEffects(() => {
    const ngModuleDef = getNgModuleDef(type, true);
    ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY;
    ngModuleDef.imports = scope.imports || EMPTY_ARRAY;
    ngModuleDef.exports = scope.exports || EMPTY_ARRAY;
  });
}
function invertObject(obj, secondary) {
  if (obj == null)
    return EMPTY_OBJ;
  const newLookup = {};
  for (const minifiedKey in obj) {
    if (obj.hasOwnProperty(minifiedKey)) {
      let publicName = obj[minifiedKey];
      let declaredName = publicName;
      if (Array.isArray(publicName)) {
        declaredName = publicName[1];
        publicName = publicName[0];
      }
      newLookup[publicName] = minifiedKey;
      if (secondary) {
        secondary[publicName] = declaredName;
      }
    }
  }
  return newLookup;
}
function \u0275\u0275definePipe(pipeDef) {
  return {
    type: pipeDef.type,
    name: pipeDef.name,
    factory: null,
    pure: pipeDef.pure !== false,
    standalone: pipeDef.standalone === true,
    onDestroy: pipeDef.type.prototype.ngOnDestroy || null
  };
}
function getComponentDef(type) {
  return type[NG_COMP_DEF] || null;
}
function getDirectiveDef(type) {
  return type[NG_DIR_DEF] || null;
}
function getPipeDef$1(type) {
  return type[NG_PIPE_DEF] || null;
}
function getNgModuleDef(type, throwNotFound) {
  const ngModuleDef = type[NG_MOD_DEF] || null;
  if (!ngModuleDef && throwNotFound === true) {
    throw new Error(`Type ${stringify(type)} does not have '\u0275mod' property.`);
  }
  return ngModuleDef;
}
function isLView(value) {
  return Array.isArray(value) && typeof value[TYPE] === "object";
}
function isLContainer(value) {
  return Array.isArray(value) && value[TYPE] === true;
}
function isContentQueryHost(tNode) {
  return (tNode.flags & 8) !== 0;
}
function isComponentHost(tNode) {
  return (tNode.flags & 2) === 2;
}
function isDirectiveHost(tNode) {
  return (tNode.flags & 1) === 1;
}
function isComponentDef(def) {
  return def.template !== null;
}
function isRootView(target) {
  return (target[FLAGS] & 256) !== 0;
}
function assertTNodeForLView(tNode, lView) {
  assertTNodeForTView(tNode, lView[TVIEW]);
}
function assertTNodeForTView(tNode, tView) {
  assertTNode(tNode);
  tNode.hasOwnProperty("tView_") && assertEqual(tNode.tView_, tView, "This TNode does not belong to this TView.");
}
function assertTNode(tNode) {
  assertDefined(tNode, "TNode must be defined");
  if (!(tNode && typeof tNode === "object" && tNode.hasOwnProperty("directiveStylingLast"))) {
    throwError2("Not of type TNode, got: " + tNode);
  }
}
function assertTIcu(tIcu) {
  assertDefined(tIcu, "Expected TIcu to be defined");
  if (!(typeof tIcu.currentCaseLViewIndex === "number")) {
    throwError2("Object is not of TIcu type.");
  }
}
function assertComponentType(actual, msg = "Type passed in is not ComponentType, it does not have '\u0275cmp' property.") {
  if (!getComponentDef(actual)) {
    throwError2(msg);
  }
}
function assertNgModuleType(actual, msg = "Type passed in is not NgModuleType, it does not have '\u0275mod' property.") {
  if (!getNgModuleDef(actual)) {
    throwError2(msg);
  }
}
function assertHasParent(tNode) {
  assertDefined(tNode, "currentTNode should exist!");
  assertDefined(tNode.parent, "currentTNode should have a parent");
}
function assertLContainer(value) {
  assertDefined(value, "LContainer must be defined");
  assertEqual(isLContainer(value), true, "Expecting LContainer");
}
function assertLViewOrUndefined(value) {
  value && assertEqual(isLView(value), true, "Expecting LView or undefined or null");
}
function assertLView(value) {
  assertDefined(value, "LView must be defined");
  assertEqual(isLView(value), true, "Expecting LView");
}
function assertFirstCreatePass(tView, errMessage) {
  assertEqual(tView.firstCreatePass, true, errMessage || "Should only be called in first create pass.");
}
function assertFirstUpdatePass(tView, errMessage) {
  assertEqual(tView.firstUpdatePass, true, errMessage || "Should only be called in first update pass.");
}
function assertDirectiveDef(obj) {
  if (obj.type === void 0 || obj.selectors == void 0 || obj.inputs === void 0) {
    throwError2(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);
  }
}
function assertIndexInDeclRange(lView, index) {
  const tView = lView[1];
  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);
}
function assertIndexInExpandoRange(lView, index) {
  const tView = lView[1];
  assertBetween(tView.expandoStartIndex, lView.length, index);
}
function assertBetween(lower, upper, index) {
  if (!(lower <= index && index < upper)) {
    throwError2(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);
  }
}
function assertProjectionSlots(lView, errMessage) {
  assertDefined(lView[DECLARATION_COMPONENT_VIEW], "Component views should exist.");
  assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, errMessage || "Components with projection nodes (<ng-content>) must have projection slots defined.");
}
function assertParentView(lView, errMessage) {
  assertDefined(lView, errMessage || "Component views should always have a parent view (component's host view)");
}
function assertNodeInjector(lView, injectorIndex) {
  assertIndexInExpandoRange(lView, injectorIndex);
  assertIndexInExpandoRange(
    lView,
    injectorIndex + 8
  );
  assertNumber(lView[injectorIndex + 0], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 1], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 2], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 3], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 4], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 5], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 6], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 7], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 8], "injectorIndex should point to parent injector");
}
function getFactoryDef(type, throwNotFound) {
  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);
  if (!hasFactoryDef && throwNotFound === true && define_ngDevMode_default) {
    throw new Error(`Type ${stringify(type)} does not have '\u0275fac' property.`);
  }
  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;
}
function \u0275\u0275NgOnChangesFeature() {
  return NgOnChangesFeatureImpl;
}
function NgOnChangesFeatureImpl(definition) {
  if (definition.type.prototype.ngOnChanges) {
    definition.setInput = ngOnChangesSetInput;
  }
  return rememberChangeHistoryAndInvokeOnChangesHook;
}
function rememberChangeHistoryAndInvokeOnChangesHook() {
  const simpleChangesStore = getSimpleChangesStore(this);
  const current = simpleChangesStore === null || simpleChangesStore === void 0 ? void 0 : simpleChangesStore.current;
  if (current) {
    const previous = simpleChangesStore.previous;
    if (previous === EMPTY_OBJ) {
      simpleChangesStore.previous = current;
    } else {
      for (let key in current) {
        previous[key] = current[key];
      }
    }
    simpleChangesStore.current = null;
    this.ngOnChanges(current);
  }
}
function ngOnChangesSetInput(instance, value, publicName, privateName) {
  const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, {
    previous: EMPTY_OBJ,
    current: null
  });
  const current = simpleChangesStore.current || (simpleChangesStore.current = {});
  const previous = simpleChangesStore.previous;
  const declaredName = this.declaredInputs[publicName];
  const previousChange = previous[declaredName];
  current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);
  instance[privateName] = value;
}
function getSimpleChangesStore(instance) {
  return instance[SIMPLE_CHANGES_STORE] || null;
}
function setSimpleChangesStore(instance, store2) {
  return instance[SIMPLE_CHANGES_STORE] = store2;
}
function unwrapRNode(value) {
  while (Array.isArray(value)) {
    value = value[HOST];
  }
  return value;
}
function unwrapLView(value) {
  while (Array.isArray(value)) {
    if (typeof value[TYPE] === "object")
      return value;
    value = value[HOST];
  }
  return null;
}
function getNativeByIndex(index, lView) {
  define_ngDevMode_default && assertIndexInRange(lView, index);
  define_ngDevMode_default && assertGreaterThanOrEqual(index, HEADER_OFFSET, "Expected to be past HEADER_OFFSET");
  return unwrapRNode(lView[index]);
}
function getNativeByTNode(tNode, lView) {
  define_ngDevMode_default && assertTNodeForLView(tNode, lView);
  define_ngDevMode_default && assertIndexInRange(lView, tNode.index);
  const node = unwrapRNode(lView[tNode.index]);
  return node;
}
function getNativeByTNodeOrNull(tNode, lView) {
  const index = tNode === null ? -1 : tNode.index;
  if (index !== -1) {
    define_ngDevMode_default && assertTNodeForLView(tNode, lView);
    const node = unwrapRNode(lView[index]);
    return node;
  }
  return null;
}
function getTNode(tView, index) {
  define_ngDevMode_default && assertGreaterThan(index, -1, "wrong index for TNode");
  define_ngDevMode_default && assertLessThan(index, tView.data.length, "wrong index for TNode");
  const tNode = tView.data[index];
  define_ngDevMode_default && tNode !== null && assertTNode(tNode);
  return tNode;
}
function load(view, index) {
  define_ngDevMode_default && assertIndexInRange(view, index);
  return view[index];
}
function getComponentLViewByIndex(nodeIndex, hostView) {
  define_ngDevMode_default && assertIndexInRange(hostView, nodeIndex);
  const slotValue = hostView[nodeIndex];
  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];
  return lView;
}
function isCreationMode(view) {
  return (view[FLAGS] & 4) === 4;
}
function viewAttachedToChangeDetector(view) {
  return (view[FLAGS] & 64) === 64;
}
function viewAttachedToContainer(view) {
  return isLContainer(view[PARENT]);
}
function getConstant(consts, index) {
  if (index === null || index === void 0)
    return null;
  define_ngDevMode_default && assertIndexInRange(consts, index);
  return consts[index];
}
function resetPreOrderHookFlags(lView) {
  lView[PREORDER_HOOK_FLAGS] = 0;
}
function updateTransplantedViewCount(lContainer, amount) {
  lContainer[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;
  let viewOrContainer = lContainer;
  let parent = lContainer[PARENT];
  while (parent !== null && (amount === 1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 1 || amount === -1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 0)) {
    parent[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;
    viewOrContainer = parent;
    parent = parent[PARENT];
  }
}
function getElementDepthCount() {
  return instructionState.lFrame.elementDepthCount;
}
function increaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount++;
}
function decreaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount--;
}
function getBindingsEnabled() {
  return instructionState.bindingsEnabled;
}
function \u0275\u0275enableBindings() {
  instructionState.bindingsEnabled = true;
}
function \u0275\u0275disableBindings() {
  instructionState.bindingsEnabled = false;
}
function getLView() {
  return instructionState.lFrame.lView;
}
function getTView() {
  return instructionState.lFrame.tView;
}
function \u0275\u0275restoreView(viewToRestore) {
  instructionState.lFrame.contextLView = viewToRestore;
  return viewToRestore[CONTEXT];
}
function \u0275\u0275resetView(value) {
  instructionState.lFrame.contextLView = null;
  return value;
}
function getCurrentTNode() {
  let currentTNode = getCurrentTNodePlaceholderOk();
  while (currentTNode !== null && currentTNode.type === 64) {
    currentTNode = currentTNode.parent;
  }
  return currentTNode;
}
function getCurrentTNodePlaceholderOk() {
  return instructionState.lFrame.currentTNode;
}
function getCurrentParentTNode() {
  const lFrame = instructionState.lFrame;
  const currentTNode = lFrame.currentTNode;
  return lFrame.isParent ? currentTNode : currentTNode.parent;
}
function setCurrentTNode(tNode, isParent) {
  define_ngDevMode_default && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);
  const lFrame = instructionState.lFrame;
  lFrame.currentTNode = tNode;
  lFrame.isParent = isParent;
}
function isCurrentTNodeParent() {
  return instructionState.lFrame.isParent;
}
function setCurrentTNodeAsNotParent() {
  instructionState.lFrame.isParent = false;
}
function getContextLView() {
  const contextLView = instructionState.lFrame.contextLView;
  define_ngDevMode_default && assertDefined(contextLView, "contextLView must be defined.");
  return contextLView;
}
function isInCheckNoChangesMode() {
  !define_ngDevMode_default && throwError2("Must never be called in production mode");
  return _isInCheckNoChangesMode;
}
function setIsInCheckNoChangesMode(mode) {
  !define_ngDevMode_default && throwError2("Must never be called in production mode");
  _isInCheckNoChangesMode = mode;
}
function getBindingRoot() {
  const lFrame = instructionState.lFrame;
  let index = lFrame.bindingRootIndex;
  if (index === -1) {
    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;
  }
  return index;
}
function getBindingIndex() {
  return instructionState.lFrame.bindingIndex;
}
function setBindingIndex(value) {
  return instructionState.lFrame.bindingIndex = value;
}
function nextBindingIndex() {
  return instructionState.lFrame.bindingIndex++;
}
function incrementBindingIndex(count2) {
  const lFrame = instructionState.lFrame;
  const index = lFrame.bindingIndex;
  lFrame.bindingIndex = lFrame.bindingIndex + count2;
  return index;
}
function isInI18nBlock() {
  return instructionState.lFrame.inI18n;
}
function setInI18nBlock(isInI18nBlock2) {
  instructionState.lFrame.inI18n = isInI18nBlock2;
}
function setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {
  const lFrame = instructionState.lFrame;
  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;
  setCurrentDirectiveIndex(currentDirectiveIndex);
}
function getCurrentDirectiveIndex() {
  return instructionState.lFrame.currentDirectiveIndex;
}
function setCurrentDirectiveIndex(currentDirectiveIndex) {
  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;
}
function getCurrentDirectiveDef(tData) {
  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;
  return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];
}
function getCurrentQueryIndex() {
  return instructionState.lFrame.currentQueryIndex;
}
function setCurrentQueryIndex(value) {
  instructionState.lFrame.currentQueryIndex = value;
}
function getDeclarationTNode(lView) {
  const tView = lView[TVIEW];
  if (tView.type === 2) {
    define_ngDevMode_default && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
    return tView.declTNode;
  }
  if (tView.type === 1) {
    return lView[T_HOST];
  }
  return null;
}
function enterDI(lView, tNode, flags) {
  define_ngDevMode_default && assertLViewOrUndefined(lView);
  if (flags & InjectFlags.SkipSelf) {
    define_ngDevMode_default && assertTNodeForTView(tNode, lView[TVIEW]);
    let parentTNode = tNode;
    let parentLView = lView;
    while (true) {
      define_ngDevMode_default && assertDefined(parentTNode, "Parent TNode should be defined");
      parentTNode = parentTNode.parent;
      if (parentTNode === null && !(flags & InjectFlags.Host)) {
        parentTNode = getDeclarationTNode(parentLView);
        if (parentTNode === null)
          break;
        define_ngDevMode_default && assertDefined(parentLView, "Parent LView should be defined");
        parentLView = parentLView[DECLARATION_VIEW];
        if (parentTNode.type & (2 | 8)) {
          break;
        }
      } else {
        break;
      }
    }
    if (parentTNode === null) {
      return false;
    } else {
      tNode = parentTNode;
      lView = parentLView;
    }
  }
  define_ngDevMode_default && assertTNodeForLView(tNode, lView);
  const lFrame = instructionState.lFrame = allocLFrame();
  lFrame.currentTNode = tNode;
  lFrame.lView = lView;
  return true;
}
function enterView(newView) {
  define_ngDevMode_default && assertNotEqual(newView[0], newView[1], "????");
  define_ngDevMode_default && assertLViewOrUndefined(newView);
  const newLFrame = allocLFrame();
  if (define_ngDevMode_default) {
    assertEqual(newLFrame.isParent, true, "Expected clean LFrame");
    assertEqual(newLFrame.lView, null, "Expected clean LFrame");
    assertEqual(newLFrame.tView, null, "Expected clean LFrame");
    assertEqual(newLFrame.selectedIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.elementDepthCount, 0, "Expected clean LFrame");
    assertEqual(newLFrame.currentDirectiveIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.currentNamespace, null, "Expected clean LFrame");
    assertEqual(newLFrame.bindingRootIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.currentQueryIndex, 0, "Expected clean LFrame");
  }
  const tView = newView[TVIEW];
  instructionState.lFrame = newLFrame;
  define_ngDevMode_default && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);
  newLFrame.currentTNode = tView.firstChild;
  newLFrame.lView = newView;
  newLFrame.tView = tView;
  newLFrame.contextLView = newView;
  newLFrame.bindingIndex = tView.bindingStartIndex;
  newLFrame.inI18n = false;
}
function allocLFrame() {
  const currentLFrame = instructionState.lFrame;
  const childLFrame = currentLFrame === null ? null : currentLFrame.child;
  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;
  return newLFrame;
}
function createLFrame(parent) {
  const lFrame = {
    currentTNode: null,
    isParent: true,
    lView: null,
    tView: null,
    selectedIndex: -1,
    contextLView: null,
    elementDepthCount: 0,
    currentNamespace: null,
    currentDirectiveIndex: -1,
    bindingRootIndex: -1,
    bindingIndex: -1,
    currentQueryIndex: 0,
    parent,
    child: null,
    inI18n: false
  };
  parent !== null && (parent.child = lFrame);
  return lFrame;
}
function leaveViewLight() {
  const oldLFrame = instructionState.lFrame;
  instructionState.lFrame = oldLFrame.parent;
  oldLFrame.currentTNode = null;
  oldLFrame.lView = null;
  return oldLFrame;
}
function leaveView() {
  const oldLFrame = leaveViewLight();
  oldLFrame.isParent = true;
  oldLFrame.tView = null;
  oldLFrame.selectedIndex = -1;
  oldLFrame.contextLView = null;
  oldLFrame.elementDepthCount = 0;
  oldLFrame.currentDirectiveIndex = -1;
  oldLFrame.currentNamespace = null;
  oldLFrame.bindingRootIndex = -1;
  oldLFrame.bindingIndex = -1;
  oldLFrame.currentQueryIndex = 0;
}
function nextContextImpl(level) {
  const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);
  return contextLView[CONTEXT];
}
function walkUpViews(nestingLevel, currentView) {
  while (nestingLevel > 0) {
    define_ngDevMode_default && assertDefined(currentView[DECLARATION_VIEW], "Declaration view should be defined if nesting level is greater than 0.");
    currentView = currentView[DECLARATION_VIEW];
    nestingLevel--;
  }
  return currentView;
}
function getSelectedIndex() {
  return instructionState.lFrame.selectedIndex;
}
function setSelectedIndex(index) {
  define_ngDevMode_default && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, "Index must be past HEADER_OFFSET (or -1).");
  define_ngDevMode_default && assertLessThan(index, instructionState.lFrame.lView.length, "Can't set index passed end of LView");
  instructionState.lFrame.selectedIndex = index;
}
function getSelectedTNode() {
  const lFrame = instructionState.lFrame;
  return getTNode(lFrame.tView, lFrame.selectedIndex);
}
function \u0275\u0275namespaceSVG() {
  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;
}
function \u0275\u0275namespaceMathML() {
  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;
}
function \u0275\u0275namespaceHTML() {
  namespaceHTMLInternal();
}
function namespaceHTMLInternal() {
  instructionState.lFrame.currentNamespace = null;
}
function getNamespace$1() {
  return instructionState.lFrame.currentNamespace;
}
function registerPreOrderHooks(directiveIndex, directiveDef, tView) {
  define_ngDevMode_default && assertFirstCreatePass(tView);
  const {
    ngOnChanges,
    ngOnInit,
    ngDoCheck
  } = directiveDef.type.prototype;
  if (ngOnChanges) {
    const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);
    (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, wrappedOnChanges);
    (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, wrappedOnChanges);
  }
  if (ngOnInit) {
    (tView.preOrderHooks || (tView.preOrderHooks = [])).push(0 - directiveIndex, ngOnInit);
  }
  if (ngDoCheck) {
    (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, ngDoCheck);
    (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, ngDoCheck);
  }
}
function registerPostOrderHooks(tView, tNode) {
  define_ngDevMode_default && assertFirstCreatePass(tView);
  for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
    const directiveDef = tView.data[i];
    define_ngDevMode_default && assertDefined(directiveDef, "Expecting DirectiveDef");
    const lifecycleHooks = directiveDef.type.prototype;
    const {
      ngAfterContentInit,
      ngAfterContentChecked,
      ngAfterViewInit,
      ngAfterViewChecked,
      ngOnDestroy
    } = lifecycleHooks;
    if (ngAfterContentInit) {
      (tView.contentHooks || (tView.contentHooks = [])).push(-i, ngAfterContentInit);
    }
    if (ngAfterContentChecked) {
      (tView.contentHooks || (tView.contentHooks = [])).push(i, ngAfterContentChecked);
      (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, ngAfterContentChecked);
    }
    if (ngAfterViewInit) {
      (tView.viewHooks || (tView.viewHooks = [])).push(-i, ngAfterViewInit);
    }
    if (ngAfterViewChecked) {
      (tView.viewHooks || (tView.viewHooks = [])).push(i, ngAfterViewChecked);
      (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, ngAfterViewChecked);
    }
    if (ngOnDestroy != null) {
      (tView.destroyHooks || (tView.destroyHooks = [])).push(i, ngOnDestroy);
    }
  }
}
function executeCheckHooks(lView, hooks, nodeIndex) {
  callHooks(
    lView,
    hooks,
    3,
    nodeIndex
  );
}
function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
  define_ngDevMode_default && assertNotEqual(
    initPhase,
    3,
    "Init pre-order hooks should not be called more than once"
  );
  if ((lView[FLAGS] & 3) === initPhase) {
    callHooks(lView, hooks, initPhase, nodeIndex);
  }
}
function incrementInitPhaseFlags(lView, initPhase) {
  define_ngDevMode_default && assertNotEqual(
    initPhase,
    3,
    "Init hooks phase should not be incremented after all init hooks have been run."
  );
  let flags = lView[FLAGS];
  if ((flags & 3) === initPhase) {
    flags &= 2047;
    flags += 1;
    lView[FLAGS] = flags;
  }
}
function callHooks(currentView, arr, initPhase, currentNodeIndex) {
  define_ngDevMode_default && assertEqual(isInCheckNoChangesMode(), false, "Hooks should never be run when in check no changes mode.");
  const startIndex = currentNodeIndex !== void 0 ? currentView[PREORDER_HOOK_FLAGS] & 65535 : 0;
  const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;
  const max2 = arr.length - 1;
  let lastNodeIndexFound = 0;
  for (let i = startIndex; i < max2; i++) {
    const hook = arr[i + 1];
    if (typeof hook === "number") {
      lastNodeIndexFound = arr[i];
      if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {
        break;
      }
    } else {
      const isInitHook = arr[i] < 0;
      if (isInitHook)
        currentView[PREORDER_HOOK_FLAGS] += 65536;
      if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {
        callHook(currentView, initPhase, arr, i);
        currentView[PREORDER_HOOK_FLAGS] = (currentView[PREORDER_HOOK_FLAGS] & 4294901760) + i + 2;
      }
      i++;
    }
  }
}
function callHook(currentView, initPhase, arr, i) {
  const isInitHook = arr[i] < 0;
  const hook = arr[i + 1];
  const directiveIndex = isInitHook ? -arr[i] : arr[i];
  const directive = currentView[directiveIndex];
  if (isInitHook) {
    const indexWithintInitPhase = currentView[FLAGS] >> 11;
    if (indexWithintInitPhase < currentView[PREORDER_HOOK_FLAGS] >> 16 && (currentView[FLAGS] & 3) === initPhase) {
      currentView[FLAGS] += 2048;
      profiler(
        4,
        directive,
        hook
      );
      try {
        hook.call(directive);
      } finally {
        profiler(
          5,
          directive,
          hook
        );
      }
    }
  } else {
    profiler(
      4,
      directive,
      hook
    );
    try {
      hook.call(directive);
    } finally {
      profiler(
        5,
        directive,
        hook
      );
    }
  }
}
function isFactory(obj) {
  return obj instanceof NodeInjectorFactory;
}
function toTNodeTypeAsString(tNodeType) {
  let text = "";
  tNodeType & 1 && (text += "|Text");
  tNodeType & 2 && (text += "|Element");
  tNodeType & 4 && (text += "|Container");
  tNodeType & 8 && (text += "|ElementContainer");
  tNodeType & 16 && (text += "|Projection");
  tNodeType & 32 && (text += "|IcuContainer");
  tNodeType & 64 && (text += "|Placeholder");
  return text.length > 0 ? text.substring(1) : text;
}
function hasClassInput(tNode) {
  return (tNode.flags & 16) !== 0;
}
function hasStyleInput(tNode) {
  return (tNode.flags & 32) !== 0;
}
function assertTNodeType(tNode, expectedTypes, message) {
  assertDefined(tNode, "should be called with a TNode");
  if ((tNode.type & expectedTypes) === 0) {
    throwError2(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);
  }
}
function assertPureTNodeType(type) {
  if (!(type === 2 || type === 1 || type === 4 || type === 8 || type === 32 || type === 16 || type === 64)) {
    throwError2(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);
  }
}
function setUpAttributes(renderer, native, attrs) {
  let i = 0;
  while (i < attrs.length) {
    const value = attrs[i];
    if (typeof value === "number") {
      if (value !== 0) {
        break;
      }
      i++;
      const namespaceURI = attrs[i++];
      const attrName = attrs[i++];
      const attrVal = attrs[i++];
      define_ngDevMode_default && define_ngDevMode_default.rendererSetAttribute++;
      renderer.setAttribute(native, attrName, attrVal, namespaceURI);
    } else {
      const attrName = value;
      const attrVal = attrs[++i];
      define_ngDevMode_default && define_ngDevMode_default.rendererSetAttribute++;
      if (isAnimationProp(attrName)) {
        renderer.setProperty(native, attrName, attrVal);
      } else {
        renderer.setAttribute(native, attrName, attrVal);
      }
      i++;
    }
  }
  return i;
}
function isNameOnlyAttributeMarker(marker) {
  return marker === 3 || marker === 4 || marker === 6;
}
function isAnimationProp(name) {
  return name.charCodeAt(0) === 64;
}
function mergeHostAttrs(dst, src) {
  if (src === null || src.length === 0) {
  } else if (dst === null || dst.length === 0) {
    dst = src.slice();
  } else {
    let srcMarker = -1;
    for (let i = 0; i < src.length; i++) {
      const item = src[i];
      if (typeof item === "number") {
        srcMarker = item;
      } else {
        if (srcMarker === 0) {
        } else if (srcMarker === -1 || srcMarker === 2) {
          mergeHostAttribute(dst, srcMarker, item, null, src[++i]);
        } else {
          mergeHostAttribute(dst, srcMarker, item, null, null);
        }
      }
    }
  }
  return dst;
}
function mergeHostAttribute(dst, marker, key1, key2, value) {
  let i = 0;
  let markerInsertPosition = dst.length;
  if (marker === -1) {
    markerInsertPosition = -1;
  } else {
    while (i < dst.length) {
      const dstValue = dst[i++];
      if (typeof dstValue === "number") {
        if (dstValue === marker) {
          markerInsertPosition = -1;
          break;
        } else if (dstValue > marker) {
          markerInsertPosition = i - 1;
          break;
        }
      }
    }
  }
  while (i < dst.length) {
    const item = dst[i];
    if (typeof item === "number") {
      break;
    } else if (item === key1) {
      if (key2 === null) {
        if (value !== null) {
          dst[i + 1] = value;
        }
        return;
      } else if (key2 === dst[i + 1]) {
        dst[i + 2] = value;
        return;
      }
    }
    i++;
    if (key2 !== null)
      i++;
    if (value !== null)
      i++;
  }
  if (markerInsertPosition !== -1) {
    dst.splice(markerInsertPosition, 0, marker);
    i = markerInsertPosition + 1;
  }
  dst.splice(i++, 0, key1);
  if (key2 !== null) {
    dst.splice(i++, 0, key2);
  }
  if (value !== null) {
    dst.splice(i++, 0, value);
  }
}
function hasParentInjector(parentLocation) {
  return parentLocation !== NO_PARENT_INJECTOR;
}
function getParentInjectorIndex(parentLocation) {
  define_ngDevMode_default && assertNumber(parentLocation, "Number expected");
  define_ngDevMode_default && assertNotEqual(parentLocation, -1, "Not a valid state.");
  const parentInjectorIndex = parentLocation & 32767;
  define_ngDevMode_default && assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, "Parent injector must be pointing past HEADER_OFFSET.");
  return parentLocation & 32767;
}
function getParentInjectorViewOffset(parentLocation) {
  return parentLocation >> 16;
}
function getParentInjectorView(location2, startView) {
  let viewOffset = getParentInjectorViewOffset(location2);
  let parentView = startView;
  while (viewOffset > 0) {
    parentView = parentView[DECLARATION_VIEW];
    viewOffset--;
  }
  return parentView;
}
function setIncludeViewProviders(v) {
  const oldValue = includeViewProviders;
  includeViewProviders = v;
  return oldValue;
}
function bloomAdd(injectorIndex, tView, type) {
  define_ngDevMode_default && assertEqual(tView.firstCreatePass, true, "expected firstCreatePass to be true");
  let id;
  if (typeof type === "string") {
    id = type.charCodeAt(0) || 0;
  } else if (type.hasOwnProperty(NG_ELEMENT_ID)) {
    id = type[NG_ELEMENT_ID];
  }
  if (id == null) {
    id = type[NG_ELEMENT_ID] = nextNgElementId++;
  }
  const bloomHash = id & BLOOM_MASK;
  const mask = 1 << bloomHash;
  tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;
}
function getOrCreateNodeInjectorForNode(tNode, lView) {
  const existingInjectorIndex = getInjectorIndex(tNode, lView);
  if (existingInjectorIndex !== -1) {
    return existingInjectorIndex;
  }
  const tView = lView[TVIEW];
  if (tView.firstCreatePass) {
    tNode.injectorIndex = lView.length;
    insertBloom(tView.data, tNode);
    insertBloom(lView, null);
    insertBloom(tView.blueprint, null);
  }
  const parentLoc = getParentInjectorLocation(tNode, lView);
  const injectorIndex = tNode.injectorIndex;
  if (hasParentInjector(parentLoc)) {
    const parentIndex = getParentInjectorIndex(parentLoc);
    const parentLView = getParentInjectorView(parentLoc, lView);
    const parentData = parentLView[TVIEW].data;
    for (let i = 0; i < 8; i++) {
      lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
    }
  }
  lView[injectorIndex + 8] = parentLoc;
  return injectorIndex;
}
function insertBloom(arr, footer) {
  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
}
function getInjectorIndex(tNode, lView) {
  if (tNode.injectorIndex === -1 || tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || lView[tNode.injectorIndex + 8] === null) {
    return -1;
  } else {
    define_ngDevMode_default && assertIndexInRange(lView, tNode.injectorIndex);
    return tNode.injectorIndex;
  }
}
function getParentInjectorLocation(tNode, lView) {
  if (tNode.parent && tNode.parent.injectorIndex !== -1) {
    return tNode.parent.injectorIndex;
  }
  let declarationViewOffset = 0;
  let parentTNode = null;
  let lViewCursor = lView;
  while (lViewCursor !== null) {
    parentTNode = getTNodeFromLView(lViewCursor);
    if (parentTNode === null) {
      return NO_PARENT_INJECTOR;
    }
    define_ngDevMode_default && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);
    declarationViewOffset++;
    lViewCursor = lViewCursor[DECLARATION_VIEW];
    if (parentTNode.injectorIndex !== -1) {
      return parentTNode.injectorIndex | declarationViewOffset << 16;
    }
  }
  return NO_PARENT_INJECTOR;
}
function diPublicInInjector(injectorIndex, tView, token) {
  bloomAdd(injectorIndex, tView, token);
}
function injectAttributeImpl(tNode, attrNameToInject) {
  define_ngDevMode_default && assertTNodeType(
    tNode,
    12 | 3
  );
  define_ngDevMode_default && assertDefined(tNode, "expecting tNode");
  if (attrNameToInject === "class") {
    return tNode.classes;
  }
  if (attrNameToInject === "style") {
    return tNode.styles;
  }
  const attrs = tNode.attrs;
  if (attrs) {
    const attrsLength = attrs.length;
    let i = 0;
    while (i < attrsLength) {
      const value = attrs[i];
      if (isNameOnlyAttributeMarker(value))
        break;
      if (value === 0) {
        i = i + 2;
      } else if (typeof value === "number") {
        i++;
        while (i < attrsLength && typeof attrs[i] === "string") {
          i++;
        }
      } else if (value === attrNameToInject) {
        return attrs[i + 1];
      } else {
        i = i + 2;
      }
    }
  }
  return null;
}
function notFoundValueOrThrow(notFoundValue, token, flags) {
  if (flags & InjectFlags.Optional) {
    return notFoundValue;
  } else {
    throwProviderNotFoundError(token, "NodeInjector");
  }
}
function lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {
  if (flags & InjectFlags.Optional && notFoundValue === void 0) {
    notFoundValue = null;
  }
  if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {
    const moduleInjector = lView[INJECTOR$1];
    const previousInjectImplementation = setInjectImplementation(void 0);
    try {
      if (moduleInjector) {
        return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);
      } else {
        return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);
      }
    } finally {
      setInjectImplementation(previousInjectImplementation);
    }
  }
  return notFoundValueOrThrow(notFoundValue, token, flags);
}
function getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {
  if (tNode !== null) {
    if (lView[FLAGS] & 1024) {
      const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND);
      if (embeddedInjectorValue !== NOT_FOUND) {
        return embeddedInjectorValue;
      }
    }
    const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);
    if (value !== NOT_FOUND) {
      return value;
    }
  }
  return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
}
function lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {
  const bloomHash = bloomHashBitOrFactory(token);
  if (typeof bloomHash === "function") {
    if (!enterDI(lView, tNode, flags)) {
      return flags & InjectFlags.Host ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
    }
    try {
      const value = bloomHash(flags);
      if (value == null && !(flags & InjectFlags.Optional)) {
        throwProviderNotFoundError(token);
      } else {
        return value;
      }
    } finally {
      leaveDI();
    }
  } else if (typeof bloomHash === "number") {
    let previousTView = null;
    let injectorIndex = getInjectorIndex(tNode, lView);
    let parentLocation = NO_PARENT_INJECTOR;
    let hostTElementNode = flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;
    if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {
      parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[injectorIndex + 8];
      if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {
        injectorIndex = -1;
      } else {
        previousTView = lView[TVIEW];
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      }
    }
    while (injectorIndex !== -1) {
      define_ngDevMode_default && assertNodeInjector(lView, injectorIndex);
      const tView = lView[TVIEW];
      define_ngDevMode_default && assertTNodeForLView(tView.data[injectorIndex + 8], lView);
      if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
        const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
        if (instance !== NOT_FOUND) {
          return instance;
        }
      }
      parentLocation = lView[injectorIndex + 8];
      if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + 8] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {
        previousTView = tView;
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      } else {
        injectorIndex = -1;
      }
    }
  }
  return notFoundValue;
}
function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
  const currentTView = lView[TVIEW];
  const tNode = currentTView.data[injectorIndex + 8];
  const canAccessViewProviders = previousTView == null ? isComponentHost(tNode) && includeViewProviders : previousTView != currentTView && (tNode.type & 3) !== 0;
  const isHostSpecialCase = flags & InjectFlags.Host && hostTElementNode === tNode;
  const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);
  if (injectableIdx !== null) {
    return getNodeInjectable(lView, currentTView, injectableIdx, tNode);
  } else {
    return NOT_FOUND;
  }
}
function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
  const nodeProviderIndexes = tNode.providerIndexes;
  const tInjectables = tView.data;
  const injectablesStart = nodeProviderIndexes & 1048575;
  const directivesStart = tNode.directiveStart;
  const directiveEnd = tNode.directiveEnd;
  const cptViewProvidersCount = nodeProviderIndexes >> 20;
  const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;
  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
  for (let i = startingIndex; i < endIndex; i++) {
    const providerTokenOrDef = tInjectables[i];
    if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) {
      return i;
    }
  }
  if (isHostSpecialCase) {
    const dirDef = tInjectables[directivesStart];
    if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {
      return directivesStart;
    }
  }
  return null;
}
function getNodeInjectable(lView, tView, index, tNode) {
  let value = lView[index];
  const tData = tView.data;
  if (isFactory(value)) {
    const factory = value;
    if (factory.resolving) {
      throwCyclicDependencyError(stringifyForError(tData[index]));
    }
    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
    factory.resolving = true;
    const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;
    const success = enterDI(lView, tNode, InjectFlags.Default);
    define_ngDevMode_default && assertEqual(success, true, "Because flags do not contain `SkipSelf' we expect this to always succeed.");
    try {
      value = lView[index] = factory.factory(void 0, tData, lView, tNode);
      if (tView.firstCreatePass && index >= tNode.directiveStart) {
        define_ngDevMode_default && assertDirectiveDef(tData[index]);
        registerPreOrderHooks(index, tData[index], tView);
      }
    } finally {
      previousInjectImplementation !== null && setInjectImplementation(previousInjectImplementation);
      setIncludeViewProviders(previousIncludeViewProviders);
      factory.resolving = false;
      leaveDI();
    }
  }
  return value;
}
function bloomHashBitOrFactory(token) {
  define_ngDevMode_default && assertDefined(token, "token must be defined");
  if (typeof token === "string") {
    return token.charCodeAt(0) || 0;
  }
  const tokenId = token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : void 0;
  if (typeof tokenId === "number") {
    if (tokenId >= 0) {
      return tokenId & BLOOM_MASK;
    } else {
      define_ngDevMode_default && assertEqual(
        tokenId,
        -1,
        "Expecting to get Special Injector Id"
      );
      return createNodeInjector;
    }
  } else {
    return tokenId;
  }
}
function bloomHasToken(bloomHash, injectorIndex, injectorView) {
  const mask = 1 << bloomHash;
  const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];
  return !!(value & mask);
}
function shouldSearchParent(flags, isFirstHostTNode) {
  return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);
}
function createNodeInjector() {
  return new NodeInjector(getCurrentTNode(), getLView());
}
function \u0275\u0275getInheritedFactory(type) {
  return noSideEffects(() => {
    const ownConstructor = type.prototype.constructor;
    const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);
    const objectPrototype = Object.prototype;
    let parent = Object.getPrototypeOf(type.prototype).constructor;
    while (parent && parent !== objectPrototype) {
      const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);
      if (factory && factory !== ownFactory) {
        return factory;
      }
      parent = Object.getPrototypeOf(parent);
    }
    return (t) => new t();
  });
}
function getFactoryOf(type) {
  if (isForwardRef(type)) {
    return () => {
      const factory = getFactoryOf(resolveForwardRef(type));
      return factory && factory();
    };
  }
  return getFactoryDef(type);
}
function lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {
  let currentTNode = tNode;
  let currentLView = lView;
  while (currentTNode !== null && currentLView !== null && currentLView[FLAGS] & 1024 && !(currentLView[FLAGS] & 256)) {
    define_ngDevMode_default && assertTNodeForLView(currentTNode, currentLView);
    const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | InjectFlags.Self, NOT_FOUND);
    if (nodeInjectorValue !== NOT_FOUND) {
      return nodeInjectorValue;
    }
    let parentTNode = currentTNode.parent;
    if (!parentTNode) {
      const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];
      if (embeddedViewInjector) {
        const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND, flags);
        if (embeddedViewInjectorValue !== NOT_FOUND) {
          return embeddedViewInjectorValue;
        }
      }
      parentTNode = getTNodeFromLView(currentLView);
      currentLView = currentLView[DECLARATION_VIEW];
    }
    currentTNode = parentTNode;
  }
  return notFoundValue;
}
function getTNodeFromLView(lView) {
  const tView = lView[TVIEW];
  const tViewType = tView.type;
  if (tViewType === 2) {
    define_ngDevMode_default && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
    return tView.declTNode;
  } else if (tViewType === 1) {
    return lView[T_HOST];
  }
  return null;
}
function \u0275\u0275injectAttribute(attrNameToInject) {
  return injectAttributeImpl(getCurrentTNode(), attrNameToInject);
}
function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function DecoratorFactory(...args) {
      if (this instanceof DecoratorFactory) {
        metaCtor.call(this, ...args);
        return this;
      }
      const annotationInstance = new DecoratorFactory(...args);
      return function TypeDecorator(cls) {
        if (typeFn)
          typeFn(cls, ...args);
        const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, {
          value: []
        })[ANNOTATIONS];
        annotations.push(annotationInstance);
        if (additionalProcessing)
          additionalProcessing(cls);
        return cls;
      };
    }
    if (parentClass) {
      DecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    DecoratorFactory.prototype.ngMetadataName = name;
    DecoratorFactory.annotationCls = DecoratorFactory;
    return DecoratorFactory;
  });
}
function makeMetadataCtor(props) {
  return function ctor(...args) {
    if (props) {
      const values = props(...args);
      for (const propName in values) {
        this[propName] = values[propName];
      }
    }
  };
}
function makeParamDecorator(name, props, parentClass) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function ParamDecoratorFactory(...args) {
      if (this instanceof ParamDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const annotationInstance = new ParamDecoratorFactory(...args);
      ParamDecorator.annotation = annotationInstance;
      return ParamDecorator;
      function ParamDecorator(cls, unusedKey, index) {
        const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, {
          value: []
        })[PARAMETERS];
        while (parameters.length <= index) {
          parameters.push(null);
        }
        (parameters[index] = parameters[index] || []).push(annotationInstance);
        return cls;
      }
    }
    if (parentClass) {
      ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    ParamDecoratorFactory.prototype.ngMetadataName = name;
    ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
    return ParamDecoratorFactory;
  });
}
function makePropDecorator(name, props, parentClass, additionalProcessing) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function PropDecoratorFactory(...args) {
      if (this instanceof PropDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const decoratorInstance = new PropDecoratorFactory(...args);
      function PropDecorator(target, name2) {
        const constructor = target.constructor;
        const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, {
          value: {}
        })[PROP_METADATA];
        meta[name2] = meta.hasOwnProperty(name2) && meta[name2] || [];
        meta[name2].unshift(decoratorInstance);
        if (additionalProcessing)
          additionalProcessing(target, name2, ...args);
      }
      return PropDecorator;
    }
    if (parentClass) {
      PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    PropDecoratorFactory.prototype.ngMetadataName = name;
    PropDecoratorFactory.annotationCls = PropDecoratorFactory;
    return PropDecoratorFactory;
  });
}
function getCompilerFacade(request) {
  const globalNg = _global["ng"];
  if (globalNg && globalNg.\u0275compilerFacade) {
    return globalNg.\u0275compilerFacade;
  }
  if (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) {
    console.error(`JIT compilation failed for ${request.kind}`, request.type);
    let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.

`;
    if (request.usage === 1) {
      message += `The ${request.kind} is part of a library that has been partially compiled.
`;
      message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.
`;
      message += "\n";
      message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.
`;
    } else {
      message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.
`;
    }
    message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',
`;
    message += `or manually provide the compiler with 'import "@angular/compiler";' before bootstrapping.`;
    throw new Error(message);
  } else {
    throw new Error("JIT compiler unavailable");
  }
}
function isType(v) {
  return typeof v === "function";
}
function arrayEquals(a, b, identityAccessor) {
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i++) {
    let valueA = a[i];
    let valueB = b[i];
    if (identityAccessor) {
      valueA = identityAccessor(valueA);
      valueB = identityAccessor(valueB);
    }
    if (valueB !== valueA) {
      return false;
    }
  }
  return true;
}
function flatten(list, dst) {
  if (dst === void 0)
    dst = list;
  for (let i = 0; i < list.length; i++) {
    let item = list[i];
    if (Array.isArray(item)) {
      if (dst === list) {
        dst = list.slice(0, i);
      }
      flatten(item, dst);
    } else if (dst !== list) {
      dst.push(item);
    }
  }
  return dst;
}
function deepForEach(input, fn2) {
  input.forEach((value) => Array.isArray(value) ? deepForEach(value, fn2) : fn2(value));
}
function addToArray(arr, index, value) {
  if (index >= arr.length) {
    arr.push(value);
  } else {
    arr.splice(index, 0, value);
  }
}
function removeFromArray(arr, index) {
  if (index >= arr.length - 1) {
    return arr.pop();
  } else {
    return arr.splice(index, 1)[0];
  }
}
function newArray(size, value) {
  const list = [];
  for (let i = 0; i < size; i++) {
    list.push(value);
  }
  return list;
}
function arrayInsert2(array, index, value1, value2) {
  define_ngDevMode_default && assertLessThanOrEqual(index, array.length, "Can't insert past array end.");
  let end = array.length;
  if (end == index) {
    array.push(value1, value2);
  } else if (end === 1) {
    array.push(value2, array[0]);
    array[0] = value1;
  } else {
    end--;
    array.push(array[end - 1], array[end]);
    while (end > index) {
      const previousEnd = end - 2;
      array[end] = array[previousEnd];
      end--;
    }
    array[index] = value1;
    array[index + 1] = value2;
  }
}
function keyValueArraySet(keyValueArray, key, value) {
  let index = keyValueArrayIndexOf(keyValueArray, key);
  if (index >= 0) {
    keyValueArray[index | 1] = value;
  } else {
    index = ~index;
    arrayInsert2(keyValueArray, index, key, value);
  }
  return index;
}
function keyValueArrayGet(keyValueArray, key) {
  const index = keyValueArrayIndexOf(keyValueArray, key);
  if (index >= 0) {
    return keyValueArray[index | 1];
  }
  return void 0;
}
function keyValueArrayIndexOf(keyValueArray, key) {
  return _arrayIndexOfSorted(keyValueArray, key, 1);
}
function _arrayIndexOfSorted(array, value, shift) {
  define_ngDevMode_default && assertEqual(Array.isArray(array), true, "Expecting an array");
  let start = 0;
  let end = array.length >> shift;
  while (end !== start) {
    const middle = start + (end - start >> 1);
    const current = array[middle << shift];
    if (value === current) {
      return middle << shift;
    } else if (current > value) {
      end = middle;
    } else {
      start = middle + 1;
    }
  }
  return ~(end << shift);
}
function isDelegateCtor(typeStr) {
  return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);
}
function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
  if (!decoratorInvocations) {
    return [];
  }
  return decoratorInvocations.map((decoratorInvocation) => {
    const decoratorType = decoratorInvocation.type;
    const annotationCls = decoratorType.annotationCls;
    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
    return new annotationCls(...annotationArgs);
  });
}
function getParentCtor(ctor) {
  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
  const parentCtor = parentProto ? parentProto.constructor : null;
  return parentCtor || Object;
}
function setCurrentInjector(injector) {
  const former = _currentInjector;
  _currentInjector = injector;
  return former;
}
function injectInjectorOnly(token, flags = InjectFlags.Default) {
  if (_currentInjector === void 0) {
    throw new RuntimeError(
      -203,
      define_ngDevMode_default && `inject() must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \`EnvironmentInjector#runInContext\`.`
    );
  } else if (_currentInjector === null) {
    return injectRootLimpMode(token, void 0, flags);
  } else {
    return _currentInjector.get(token, flags & InjectFlags.Optional ? null : void 0, flags);
  }
}
function \u0275\u0275inject(token, flags = InjectFlags.Default) {
  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);
}
function \u0275\u0275invalidFactoryDep(index) {
  throw new RuntimeError(
    202,
    define_ngDevMode_default && `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.
This can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.

Please check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`
  );
}
function inject(token, flags = InjectFlags.Default) {
  if (typeof flags !== "number") {
    flags = 0 | (flags.optional && 8) | (flags.host && 1) | (flags.self && 2) | (flags.skipSelf && 4);
  }
  return \u0275\u0275inject(token, flags);
}
function injectArgs(types) {
  const args = [];
  for (let i = 0; i < types.length; i++) {
    const arg = resolveForwardRef(types[i]);
    if (Array.isArray(arg)) {
      if (arg.length === 0) {
        throw new RuntimeError(
          900,
          define_ngDevMode_default && "Arguments array must have arguments."
        );
      }
      let type = void 0;
      let flags = InjectFlags.Default;
      for (let j = 0; j < arg.length; j++) {
        const meta = arg[j];
        const flag = getInjectFlag(meta);
        if (typeof flag === "number") {
          if (flag === -1) {
            type = meta.token;
          } else {
            flags |= flag;
          }
        } else {
          type = meta;
        }
      }
      args.push(\u0275\u0275inject(type, flags));
    } else {
      args.push(\u0275\u0275inject(arg));
    }
  }
  return args;
}
function attachInjectFlag(decorator, flag) {
  decorator[DI_DECORATOR_FLAG] = flag;
  decorator.prototype[DI_DECORATOR_FLAG] = flag;
  return decorator;
}
function getInjectFlag(token) {
  return token[DI_DECORATOR_FLAG];
}
function catchInjectorError(e, token, injectorErrorName, source) {
  const tokenPath = e[NG_TEMP_TOKEN_PATH];
  if (token[SOURCE]) {
    tokenPath.unshift(token[SOURCE]);
  }
  e.message = formatError("\n" + e.message, tokenPath, injectorErrorName, source);
  e[NG_TOKEN_PATH] = tokenPath;
  e[NG_TEMP_TOKEN_PATH] = null;
  throw e;
}
function formatError(text, obj, injectorErrorName, source = null) {
  text = text && text.charAt(0) === "\n" && text.charAt(1) == NO_NEW_LINE ? text.slice(2) : text;
  let context2 = stringify(obj);
  if (Array.isArray(obj)) {
    context2 = obj.map(stringify).join(" -> ");
  } else if (typeof obj === "object") {
    let parts = [];
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        let value = obj[key];
        parts.push(key + ":" + (typeof value === "string" ? JSON.stringify(value) : stringify(value)));
      }
    }
    context2 = `{${parts.join(", ")}}`;
  }
  return `${injectorErrorName}${source ? "(" + source + ")" : ""}[${context2}]: ${text.replace(NEW_LINE, "\n  ")}`;
}
function getReflect() {
  return _reflect = _reflect || new ReflectionCapabilities();
}
function reflectDependencies(type) {
  return convertDependencies(getReflect().parameters(type));
}
function convertDependencies(deps) {
  return deps.map((dep) => reflectDependency(dep));
}
function reflectDependency(dep) {
  const meta = {
    token: null,
    attribute: null,
    host: false,
    optional: false,
    self: false,
    skipSelf: false
  };
  if (Array.isArray(dep) && dep.length > 0) {
    for (let j = 0; j < dep.length; j++) {
      const param = dep[j];
      if (param === void 0) {
        continue;
      }
      const proto = Object.getPrototypeOf(param);
      if (param instanceof Optional || proto.ngMetadataName === "Optional") {
        meta.optional = true;
      } else if (param instanceof SkipSelf || proto.ngMetadataName === "SkipSelf") {
        meta.skipSelf = true;
      } else if (param instanceof Self || proto.ngMetadataName === "Self") {
        meta.self = true;
      } else if (param instanceof Host || proto.ngMetadataName === "Host") {
        meta.host = true;
      } else if (param instanceof Inject) {
        meta.token = param.token;
      } else if (param instanceof Attribute) {
        if (param.attributeName === void 0) {
          throw new RuntimeError(
            204,
            define_ngDevMode_default && `Attribute name must be defined.`
          );
        }
        meta.attribute = param.attributeName;
      } else {
        meta.token = param;
      }
    }
  } else if (dep === void 0 || Array.isArray(dep) && dep.length === 0) {
    meta.token = null;
  } else {
    meta.token = dep;
  }
  return meta;
}
function resolveComponentResources(resourceResolver) {
  const componentResolved = [];
  const urlMap = /* @__PURE__ */ new Map();
  function cachedResourceResolve(url) {
    let promise2 = urlMap.get(url);
    if (!promise2) {
      const resp = resourceResolver(url);
      urlMap.set(url, promise2 = resp.then(unwrapResponse));
    }
    return promise2;
  }
  componentResourceResolutionQueue.forEach((component, type) => {
    const promises = [];
    if (component.templateUrl) {
      promises.push(cachedResourceResolve(component.templateUrl).then((template) => {
        component.template = template;
      }));
    }
    const styleUrls = component.styleUrls;
    const styles = component.styles || (component.styles = []);
    const styleOffset = component.styles.length;
    styleUrls && styleUrls.forEach((styleUrl, index) => {
      styles.push("");
      promises.push(cachedResourceResolve(styleUrl).then((style) => {
        styles[styleOffset + index] = style;
        styleUrls.splice(styleUrls.indexOf(styleUrl), 1);
        if (styleUrls.length == 0) {
          component.styleUrls = void 0;
        }
      }));
    });
    const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));
    componentResolved.push(fullyResolved);
  });
  clearResolutionOfComponentResourcesQueue();
  return Promise.all(componentResolved).then(() => void 0);
}
function maybeQueueResolutionOfComponentResources(type, metadata) {
  if (componentNeedsResolution(metadata)) {
    componentResourceResolutionQueue.set(type, metadata);
    componentDefPendingResolution.add(type);
  }
}
function componentNeedsResolution(component) {
  return !!(component.templateUrl && !component.hasOwnProperty("template") || component.styleUrls && component.styleUrls.length);
}
function clearResolutionOfComponentResourcesQueue() {
  const old = componentResourceResolutionQueue;
  componentResourceResolutionQueue = /* @__PURE__ */ new Map();
  return old;
}
function isComponentResourceResolutionQueueEmpty() {
  return componentResourceResolutionQueue.size === 0;
}
function unwrapResponse(response) {
  return typeof response == "string" ? response : response.text();
}
function componentDefResolved(type) {
  componentDefPendingResolution.delete(type);
}
function assertSameOrNotExisting(id, type, incoming) {
  if (type && type !== incoming && checkForDuplicateNgModules) {
    throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);
  }
}
function registerNgModuleType(ngModuleType, id) {
  const existing = modules.get(id) || null;
  assertSameOrNotExisting(id, existing, ngModuleType);
  modules.set(id, ngModuleType);
}
function getRegisteredNgModuleType(id) {
  return modules.get(id);
}
function setAllowDuplicateNgModuleIdsForTest(allowDuplicates) {
  checkForDuplicateNgModules = !allowDuplicates;
}
function setDocument(document2) {
  DOCUMENT = document2;
}
function getDocument() {
  if (DOCUMENT !== void 0) {
    return DOCUMENT;
  } else if (typeof document !== "undefined") {
    return document;
  }
  return void 0;
}
function getPolicy$1() {
  if (policy$1 === void 0) {
    policy$1 = null;
    if (_global.trustedTypes) {
      try {
        policy$1 = _global.trustedTypes.createPolicy("angular", {
          createHTML: (s) => s,
          createScript: (s) => s,
          createScriptURL: (s) => s
        });
      } catch (_a) {
      }
    }
  }
  return policy$1;
}
function trustedHTMLFromString(html) {
  var _a;
  return ((_a = getPolicy$1()) === null || _a === void 0 ? void 0 : _a.createHTML(html)) || html;
}
function trustedScriptFromString(script) {
  var _a;
  return ((_a = getPolicy$1()) === null || _a === void 0 ? void 0 : _a.createScript(script)) || script;
}
function trustedScriptURLFromString(url) {
  var _a;
  return ((_a = getPolicy$1()) === null || _a === void 0 ? void 0 : _a.createScriptURL(url)) || url;
}
function newTrustedFunctionForDev(...args) {
  if (typeof define_ngDevMode_default === "undefined") {
    throw new Error("newTrustedFunctionForDev should never be called in production");
  }
  if (!_global.trustedTypes) {
    return new Function(...args);
  }
  const fnArgs = args.slice(0, -1).join(",");
  const fnBody = args[args.length - 1];
  const body = `(function anonymous(${fnArgs}
) { ${fnBody}
})`;
  const fn2 = _global["eval"](trustedScriptFromString(body));
  if (fn2.bind === void 0) {
    return new Function(...args);
  }
  fn2.toString = () => body;
  return fn2.bind(_global);
}
function getPolicy() {
  if (policy === void 0) {
    policy = null;
    if (_global.trustedTypes) {
      try {
        policy = _global.trustedTypes.createPolicy("angular#unsafe-bypass", {
          createHTML: (s) => s,
          createScript: (s) => s,
          createScriptURL: (s) => s
        });
      } catch (_a) {
      }
    }
  }
  return policy;
}
function trustedHTMLFromStringBypass(html) {
  var _a;
  return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createHTML(html)) || html;
}
function trustedScriptFromStringBypass(script) {
  var _a;
  return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createScript(script)) || script;
}
function trustedScriptURLFromStringBypass(url) {
  var _a;
  return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createScriptURL(url)) || url;
}
function unwrapSafeValue(value) {
  return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;
}
function allowSanitizationBypassAndThrow(value, type) {
  const actualType = getSanitizationBypassType(value);
  if (actualType != null && actualType !== type) {
    if (actualType === "ResourceURL" && type === "URL")
      return true;
    throw new Error(`Required a safe ${type}, got a ${actualType} (see https://g.co/ng/security#xss)`);
  }
  return actualType === type;
}
function getSanitizationBypassType(value) {
  return value instanceof SafeValueImpl && value.getTypeName() || null;
}
function bypassSanitizationTrustHtml(trustedHtml) {
  return new SafeHtmlImpl(trustedHtml);
}
function bypassSanitizationTrustStyle(trustedStyle) {
  return new SafeStyleImpl(trustedStyle);
}
function bypassSanitizationTrustScript(trustedScript) {
  return new SafeScriptImpl(trustedScript);
}
function bypassSanitizationTrustUrl(trustedUrl) {
  return new SafeUrlImpl(trustedUrl);
}
function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
  return new SafeResourceUrlImpl(trustedResourceUrl);
}
function getInertBodyHelper(defaultDoc) {
  const inertDocumentHelper = new InertDocumentHelper(defaultDoc);
  return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;
}
function isDOMParserAvailable() {
  try {
    return !!new window.DOMParser().parseFromString(trustedHTMLFromString(""), "text/html");
  } catch (_a) {
    return false;
  }
}
function _sanitizeUrl(url) {
  url = String(url);
  if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))
    return url;
  if (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) {
    console.warn(`WARNING: sanitizing unsafe URL value ${url} (see https://g.co/ng/security#xss)`);
  }
  return "unsafe:" + url;
}
function sanitizeSrcset(srcset) {
  srcset = String(srcset);
  return srcset.split(",").map((srcset2) => _sanitizeUrl(srcset2.trim())).join(", ");
}
function tagSet(tags) {
  const res = {};
  for (const t of tags.split(","))
    res[t] = true;
  return res;
}
function merge3(...sets) {
  const res = {};
  for (const s of sets) {
    for (const v in s) {
      if (s.hasOwnProperty(v))
        res[v] = true;
    }
  }
  return res;
}
function encodeEntities(value) {
  return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(match) {
    const hi = match.charCodeAt(0);
    const low = match.charCodeAt(1);
    return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
  }).replace(NON_ALPHANUMERIC_REGEXP, function(match) {
    return "&#" + match.charCodeAt(0) + ";";
  }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
  let inertBodyElement = null;
  try {
    inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);
    let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : "";
    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    let mXSSAttempts = 5;
    let parsedHtml = unsafeHtml;
    do {
      if (mXSSAttempts === 0) {
        throw new Error("Failed to sanitize html because the input is unstable");
      }
      mXSSAttempts--;
      unsafeHtml = parsedHtml;
      parsedHtml = inertBodyElement.innerHTML;
      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    } while (unsafeHtml !== parsedHtml);
    const sanitizer = new SanitizingHtmlSerializer();
    const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
    if ((typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && sanitizer.sanitizedSomething) {
      console.warn("WARNING: sanitizing HTML stripped some content, see https://g.co/ng/security#xss");
    }
    return trustedHTMLFromString(safeHtml);
  } finally {
    if (inertBodyElement) {
      const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
      while (parent.firstChild) {
        parent.removeChild(parent.firstChild);
      }
    }
  }
}
function getTemplateContent(el) {
  return "content" in el && isTemplateElement(el) ? el.content : null;
}
function isTemplateElement(el) {
  return el.nodeType === Node.ELEMENT_NODE && el.nodeName === "TEMPLATE";
}
function \u0275\u0275sanitizeHtml(unsafeHtml) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeHtml,
    "HTML"
  )) {
    return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));
  }
  return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));
}
function \u0275\u0275sanitizeStyle(unsafeStyle) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || "";
  }
  if (allowSanitizationBypassAndThrow(
    unsafeStyle,
    "Style"
  )) {
    return unwrapSafeValue(unsafeStyle);
  }
  return renderStringify(unsafeStyle);
}
function \u0275\u0275sanitizeUrl(unsafeUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || "";
  }
  if (allowSanitizationBypassAndThrow(
    unsafeUrl,
    "URL"
  )) {
    return unwrapSafeValue(unsafeUrl);
  }
  return _sanitizeUrl(renderStringify(unsafeUrl));
}
function \u0275\u0275sanitizeResourceUrl(unsafeResourceUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeResourceUrl,
    "ResourceURL"
  )) {
    return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));
  }
  throw new RuntimeError(
    904,
    define_ngDevMode_default && "unsafe value used in a resource URL context (see https://g.co/ng/security#xss)"
  );
}
function \u0275\u0275sanitizeScript(unsafeScript) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeScript,
    "Script"
  )) {
    return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));
  }
  throw new RuntimeError(
    905,
    define_ngDevMode_default && "unsafe value used in a script context"
  );
}
function \u0275\u0275trustConstantHtml(html) {
  if (define_ngDevMode_default && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join("?")}`);
  }
  return trustedHTMLFromString(html[0]);
}
function \u0275\u0275trustConstantResourceUrl(url) {
  if (define_ngDevMode_default && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join("?")}`);
  }
  return trustedScriptURLFromString(url[0]);
}
function getUrlSanitizer(tag, prop) {
  if (prop === "src" && (tag === "embed" || tag === "frame" || tag === "iframe" || tag === "media" || tag === "script") || prop === "href" && (tag === "base" || tag === "link")) {
    return \u0275\u0275sanitizeResourceUrl;
  }
  return \u0275\u0275sanitizeUrl;
}
function \u0275\u0275sanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {
  return getUrlSanitizer(tag, prop)(unsafeUrl);
}
function validateAgainstEventProperties(name) {
  if (name.toLowerCase().startsWith("on")) {
    const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...
If '${name}' is a directive input, make sure the directive is imported by the current module.`;
    throw new RuntimeError(
      306,
      errorMessage
    );
  }
}
function validateAgainstEventAttributes(name) {
  if (name.toLowerCase().startsWith("on")) {
    const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...`;
    throw new RuntimeError(
      306,
      errorMessage
    );
  }
}
function getSanitizer() {
  const lView = getLView();
  return lView && lView[SANITIZER];
}
function importProvidersFrom(...sources) {
  return {
    \u0275providers: internalImportProvidersFrom(true, sources)
  };
}
function internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {
  const providersOut = [];
  const dedup = /* @__PURE__ */ new Set();
  let injectorTypesWithProviders;
  deepForEach(sources, (source) => {
    if ((typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && checkForStandaloneCmp) {
      const cmpDef = getComponentDef(source);
      if (cmpDef === null || cmpDef === void 0 ? void 0 : cmpDef.standalone) {
        throw new RuntimeError(
          800,
          `Importing providers supports NgModule or ModuleWithProviders but got a standalone component "${stringifyForError(source)}"`
        );
      }
    }
    const internalSource = source;
    if (walkProviderTree(internalSource, providersOut, [], dedup)) {
      injectorTypesWithProviders || (injectorTypesWithProviders = []);
      injectorTypesWithProviders.push(internalSource);
    }
  });
  if (injectorTypesWithProviders !== void 0) {
    processInjectorTypesWithProviders(injectorTypesWithProviders, providersOut);
  }
  return providersOut;
}
function processInjectorTypesWithProviders(typesWithProviders, providersOut) {
  for (let i = 0; i < typesWithProviders.length; i++) {
    const {
      ngModule,
      providers
    } = typesWithProviders[i];
    deepForEach(providers, (provider) => {
      define_ngDevMode_default && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);
      providersOut.push(provider);
    });
  }
}
function walkProviderTree(container, providersOut, parents, dedup) {
  container = resolveForwardRef(container);
  if (!container)
    return false;
  let defType = null;
  let injDef = getInjectorDef(container);
  const cmpDef = !injDef && getComponentDef(container);
  if (!injDef && !cmpDef) {
    const ngModule = container.ngModule;
    injDef = getInjectorDef(ngModule);
    if (injDef) {
      defType = ngModule;
    } else {
      return false;
    }
  } else if (cmpDef && !cmpDef.standalone) {
    return false;
  } else {
    defType = container;
  }
  if (define_ngDevMode_default && parents.indexOf(defType) !== -1) {
    const defName = stringify(defType);
    const path = parents.map(stringify);
    throwCyclicDependencyError(defName, path);
  }
  const isDuplicate = dedup.has(defType);
  if (cmpDef) {
    if (isDuplicate) {
      return false;
    }
    dedup.add(defType);
    if (cmpDef.dependencies) {
      const deps = typeof cmpDef.dependencies === "function" ? cmpDef.dependencies() : cmpDef.dependencies;
      for (const dep of deps) {
        walkProviderTree(dep, providersOut, parents, dedup);
      }
    }
  } else if (injDef) {
    if (injDef.imports != null && !isDuplicate) {
      define_ngDevMode_default && parents.push(defType);
      dedup.add(defType);
      let importTypesWithProviders;
      try {
        deepForEach(injDef.imports, (imported) => {
          if (walkProviderTree(imported, providersOut, parents, dedup)) {
            importTypesWithProviders || (importTypesWithProviders = []);
            importTypesWithProviders.push(imported);
          }
        });
      } finally {
        define_ngDevMode_default && parents.pop();
      }
      if (importTypesWithProviders !== void 0) {
        processInjectorTypesWithProviders(importTypesWithProviders, providersOut);
      }
    }
    if (!isDuplicate) {
      const factory = getFactoryDef(defType) || (() => new defType());
      providersOut.push(
        {
          provide: defType,
          useFactory: factory,
          deps: EMPTY_ARRAY
        },
        {
          provide: INJECTOR_DEF_TYPES,
          useValue: defType,
          multi: true
        },
        {
          provide: ENVIRONMENT_INITIALIZER,
          useValue: () => \u0275\u0275inject(defType),
          multi: true
        }
      );
    }
    const defProviders = injDef.providers;
    if (defProviders != null && !isDuplicate) {
      const injectorType = container;
      deepForEach(defProviders, (provider) => {
        define_ngDevMode_default && validateProvider(provider, defProviders, injectorType);
        providersOut.push(provider);
      });
    }
  } else {
    return false;
  }
  return defType !== container && container.providers !== void 0;
}
function validateProvider(provider, providers, containerType) {
  if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) {
    return;
  }
  const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
  if (!classRef) {
    throwInvalidProviderError(containerType, providers, provider);
  }
}
function isValueProvider(value) {
  return value !== null && typeof value == "object" && USE_VALUE$1 in value;
}
function isExistingProvider(value) {
  return !!(value && value.useExisting);
}
function isFactoryProvider(value) {
  return !!(value && value.useFactory);
}
function isTypeProvider(value) {
  return typeof value === "function";
}
function isClassProvider(value) {
  return !!value.useClass;
}
function getNullInjector() {
  if (NULL_INJECTOR$1 === void 0) {
    NULL_INJECTOR$1 = new NullInjector();
  }
  return NULL_INJECTOR$1;
}
function injectableDefOrInjectorDefFactory(token) {
  const injectableDef = getInjectableDef(token);
  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);
  if (factory !== null) {
    return factory;
  }
  if (token instanceof InjectionToken) {
    throw new RuntimeError(
      204,
      define_ngDevMode_default && `Token ${stringify(token)} is missing a \u0275prov definition.`
    );
  }
  if (token instanceof Function) {
    return getUndecoratedInjectableFactory(token);
  }
  throw new RuntimeError(
    204,
    define_ngDevMode_default && "unreachable"
  );
}
function getUndecoratedInjectableFactory(token) {
  const paramLength = token.length;
  if (paramLength > 0) {
    const args = newArray(paramLength, "?");
    throw new RuntimeError(
      204,
      define_ngDevMode_default && `Can't resolve all parameters for ${stringify(token)}: (${args.join(", ")}).`
    );
  }
  const inheritedInjectableDef = getInheritedInjectableDef(token);
  if (inheritedInjectableDef !== null) {
    return () => inheritedInjectableDef.factory(token);
  } else {
    return () => new token();
  }
}
function providerToRecord(provider) {
  if (isValueProvider(provider)) {
    return makeRecord(void 0, provider.useValue);
  } else {
    const factory = providerToFactory(provider);
    return makeRecord(factory, NOT_YET);
  }
}
function providerToFactory(provider, ngModuleType, providers) {
  let factory = void 0;
  if (define_ngDevMode_default && isImportedNgModuleProviders(provider)) {
    throwInvalidProviderError(void 0, providers, provider);
  }
  if (isTypeProvider(provider)) {
    const unwrappedProvider = resolveForwardRef(provider);
    return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);
  } else {
    if (isValueProvider(provider)) {
      factory = () => resolveForwardRef(provider.useValue);
    } else if (isFactoryProvider(provider)) {
      factory = () => provider.useFactory(...injectArgs(provider.deps || []));
    } else if (isExistingProvider(provider)) {
      factory = () => \u0275\u0275inject(resolveForwardRef(provider.useExisting));
    } else {
      const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
      if (define_ngDevMode_default && !classRef) {
        throwInvalidProviderError(ngModuleType, providers, provider);
      }
      if (hasDeps(provider)) {
        factory = () => new classRef(...injectArgs(provider.deps));
      } else {
        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);
      }
    }
  }
  return factory;
}
function makeRecord(factory, value, multi = false) {
  return {
    factory,
    value,
    multi: multi ? [] : void 0
  };
}
function hasDeps(value) {
  return !!value.deps;
}
function hasOnDestroy(value) {
  return value !== null && typeof value === "object" && typeof value.ngOnDestroy === "function";
}
function couldBeInjectableType(value) {
  return typeof value === "function" || typeof value === "object" && value instanceof InjectionToken;
}
function isImportedNgModuleProviders(provider) {
  return !!provider.\u0275providers;
}
function forEachSingleProvider(providers, fn2) {
  for (const provider of providers) {
    if (Array.isArray(provider)) {
      forEachSingleProvider(provider, fn2);
    } else if (isImportedNgModuleProviders(provider)) {
      forEachSingleProvider(provider.\u0275providers, fn2);
    } else {
      fn2(provider);
    }
  }
}
function noComponentFactoryError(component) {
  const error2 = Error(`No component factory found for ${stringify(component)}. Did you add it to @NgModule.entryComponents?`);
  error2[ERROR_COMPONENT] = component;
  return error2;
}
function injectElementRef() {
  return createElementRef(getCurrentTNode(), getLView());
}
function createElementRef(tNode, lView) {
  return new ElementRef(getNativeByTNode(tNode, lView));
}
function unwrapElementRef(value) {
  return value instanceof ElementRef ? value.nativeElement : value;
}
function injectRenderer2() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);
  return (isLView(nodeAtIndex) ? nodeAtIndex : lView)[RENDERER];
}
function \u0275setUnknownElementStrictMode(shouldThrow) {
  shouldThrowErrorOnUnknownElement = shouldThrow;
}
function \u0275getUnknownElementStrictMode() {
  return shouldThrowErrorOnUnknownElement;
}
function \u0275setUnknownPropertyStrictMode(shouldThrow) {
  shouldThrowErrorOnUnknownProperty = shouldThrow;
}
function \u0275getUnknownPropertyStrictMode() {
  return shouldThrowErrorOnUnknownProperty;
}
function validateElementIsKnown(element, lView, tagName, schemas, hasDirectives) {
  if (schemas === null)
    return;
  if (!hasDirectives && tagName !== null) {
    const isUnknown = typeof HTMLUnknownElement !== "undefined" && HTMLUnknownElement && element instanceof HTMLUnknownElement || typeof customElements !== "undefined" && tagName.indexOf("-") > -1 && !customElements.get(tagName);
    if (isUnknown && !matchingSchemas(schemas, tagName)) {
      const isHostStandalone = isHostComponentStandalone(lView);
      const templateLocation = getTemplateLocationDetails(lView);
      const schemas2 = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
      let message = `'${tagName}' is not a known element${templateLocation}:
`;
      message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared"}.
`;
      if (tagName && tagName.indexOf("-") > -1) {
        message += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas2} of this component to suppress this message.`;
      } else {
        message += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas2} of this component.`;
      }
      if (shouldThrowErrorOnUnknownElement) {
        throw new RuntimeError(
          304,
          message
        );
      } else {
        console.error(formatRuntimeError(
          304,
          message
        ));
      }
    }
  }
}
function isPropertyValid(element, propName, tagName, schemas) {
  if (schemas === null)
    return true;
  if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {
    return true;
  }
  return typeof Node === "undefined" || Node === null || !(element instanceof Node);
}
function handleUnknownPropertyError(propName, tagName, nodeType, lView) {
  if (!tagName && nodeType === 4) {
    tagName = "ng-template";
  }
  const isHostStandalone = isHostComponentStandalone(lView);
  const templateLocation = getTemplateLocationDetails(lView);
  let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;
  const schemas = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
  const importLocation = isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared";
  if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {
    const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);
    message += `
If the '${propName}' is an Angular control flow directive, please make sure that either the '${correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;
  } else {
    message += `
1. If '${tagName}' is an Angular component and it has the '${propName}' input, then verify that it is ${importLocation}.`;
    if (tagName && tagName.indexOf("-") > -1) {
      message += `
2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;
      message += `
3. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
    } else {
      message += `
2. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
    }
  }
  reportUnknownPropertyError(message);
}
function reportUnknownPropertyError(message) {
  if (shouldThrowErrorOnUnknownProperty) {
    throw new RuntimeError(
      303,
      message
    );
  } else {
    console.error(formatRuntimeError(
      303,
      message
    ));
  }
}
function getDeclarationComponentDef(lView) {
  !define_ngDevMode_default && throwError2("Must never be called in production mode");
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context2 = declarationLView[CONTEXT];
  if (!context2)
    return null;
  return context2.constructor ? getComponentDef(context2.constructor) : null;
}
function isHostComponentStandalone(lView) {
  !define_ngDevMode_default && throwError2("Must never be called in production mode");
  const componentDef = getDeclarationComponentDef(lView);
  return !!(componentDef === null || componentDef === void 0 ? void 0 : componentDef.standalone);
}
function getTemplateLocationDetails(lView) {
  var _a;
  !define_ngDevMode_default && throwError2("Must never be called in production mode");
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = (_a = hostComponentDef === null || hostComponentDef === void 0 ? void 0 : hostComponentDef.type) === null || _a === void 0 ? void 0 : _a.name;
  return componentClassName ? ` (used in the '${componentClassName}' component template)` : "";
}
function matchingSchemas(schemas, tagName) {
  if (schemas !== null) {
    for (let i = 0; i < schemas.length; i++) {
      const schema = schemas[i];
      if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf("-") > -1) {
        return true;
      }
    }
  }
  return false;
}
function wrappedError(message, originalError) {
  const msg = `${message} caused by: ${originalError instanceof Error ? originalError.message : originalError}`;
  const error2 = Error(msg);
  error2[ERROR_ORIGINAL_ERROR] = originalError;
  return error2;
}
function getOriginalError(error2) {
  return error2[ERROR_ORIGINAL_ERROR];
}
function escapeCommentText(value) {
  return value.replace(COMMENT_DISALLOWED, (text) => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));
}
function normalizeDebugBindingName(name) {
  name = camelCaseToDashCase(name.replace(/[$@]/g, "_"));
  return `ng-reflect-${name}`;
}
function camelCaseToDashCase(input) {
  return input.replace(CAMEL_CASE_REGEXP, (...m) => "-" + m[1].toLowerCase());
}
function normalizeDebugBindingValue(value) {
  try {
    return value != null ? value.toString().slice(0, 30) : value;
  } catch (e) {
    return "[ERROR] Exception while trying to serialize the value";
  }
}
function getUniqueLViewId() {
  return uniqueIdCounter++;
}
function registerLView(lView) {
  define_ngDevMode_default && assertNumber(lView[ID], "LView must have an ID in order to be registered");
  TRACKED_LVIEWS.set(lView[ID], lView);
}
function getLViewById(id) {
  define_ngDevMode_default && assertNumber(id, "ID used for LView lookup must be a number");
  return TRACKED_LVIEWS.get(id) || null;
}
function unregisterLView(lView) {
  define_ngDevMode_default && assertNumber(lView[ID], "Cannot stop tracking an LView that does not have an ID");
  TRACKED_LVIEWS.delete(lView[ID]);
}
function getLContext(target) {
  let mpValue = readPatchedData(target);
  if (mpValue) {
    if (isLView(mpValue)) {
      const lView = mpValue;
      let nodeIndex;
      let component = void 0;
      let directives = void 0;
      if (isComponentInstance(target)) {
        nodeIndex = findViaComponent(lView, target);
        if (nodeIndex == -1) {
          throw new Error("The provided component was not found in the application");
        }
        component = target;
      } else if (isDirectiveInstance(target)) {
        nodeIndex = findViaDirective(lView, target);
        if (nodeIndex == -1) {
          throw new Error("The provided directive was not found in the application");
        }
        directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);
      } else {
        nodeIndex = findViaNativeElement(lView, target);
        if (nodeIndex == -1) {
          return null;
        }
      }
      const native = unwrapRNode(lView[nodeIndex]);
      const existingCtx = readPatchedData(native);
      const context2 = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);
      if (component && context2.component === void 0) {
        context2.component = component;
        attachPatchData(context2.component, context2);
      }
      if (directives && context2.directives === void 0) {
        context2.directives = directives;
        for (let i = 0; i < directives.length; i++) {
          attachPatchData(directives[i], context2);
        }
      }
      attachPatchData(context2.native, context2);
      mpValue = context2;
    }
  } else {
    const rElement = target;
    define_ngDevMode_default && assertDomNode(rElement);
    let parent = rElement;
    while (parent = parent.parentNode) {
      const parentContext = readPatchedData(parent);
      if (parentContext) {
        const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;
        if (!lView) {
          return null;
        }
        const index = findViaNativeElement(lView, rElement);
        if (index >= 0) {
          const native = unwrapRNode(lView[index]);
          const context2 = createLContext(lView, index, native);
          attachPatchData(native, context2);
          mpValue = context2;
          break;
        }
      }
    }
  }
  return mpValue || null;
}
function createLContext(lView, nodeIndex, native) {
  return new LContext(lView[ID], nodeIndex, native);
}
function getComponentViewByInstance(componentInstance) {
  let patchedData = readPatchedData(componentInstance);
  let lView;
  if (isLView(patchedData)) {
    const contextLView = patchedData;
    const nodeIndex = findViaComponent(contextLView, componentInstance);
    lView = getComponentLViewByIndex(nodeIndex, contextLView);
    const context2 = createLContext(contextLView, nodeIndex, lView[HOST]);
    context2.component = componentInstance;
    attachPatchData(componentInstance, context2);
    attachPatchData(context2.native, context2);
  } else {
    const context2 = patchedData;
    const contextLView = context2.lView;
    define_ngDevMode_default && assertLView(contextLView);
    lView = getComponentLViewByIndex(context2.nodeIndex, contextLView);
  }
  return lView;
}
function attachPatchData(target, data) {
  define_ngDevMode_default && assertDefined(target, "Target expected");
  if (isLView(data)) {
    target[MONKEY_PATCH_KEY_NAME] = data[ID];
    registerLView(data);
  } else {
    target[MONKEY_PATCH_KEY_NAME] = data;
  }
}
function readPatchedData(target) {
  define_ngDevMode_default && assertDefined(target, "Target expected");
  const data = target[MONKEY_PATCH_KEY_NAME];
  return typeof data === "number" ? getLViewById(data) : data || null;
}
function readPatchedLView(target) {
  const value = readPatchedData(target);
  if (value) {
    return isLView(value) ? value : value.lView;
  }
  return null;
}
function isComponentInstance(instance) {
  return instance && instance.constructor && instance.constructor.\u0275cmp;
}
function isDirectiveInstance(instance) {
  return instance && instance.constructor && instance.constructor.\u0275dir;
}
function findViaNativeElement(lView, target) {
  const tView = lView[TVIEW];
  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if (unwrapRNode(lView[i]) === target) {
      return i;
    }
  }
  return -1;
}
function traverseNextElement(tNode) {
  if (tNode.child) {
    return tNode.child;
  } else if (tNode.next) {
    return tNode.next;
  } else {
    while (tNode.parent && !tNode.parent.next) {
      tNode = tNode.parent;
    }
    return tNode.parent && tNode.parent.next;
  }
}
function findViaComponent(lView, componentInstance) {
  const componentIndices = lView[TVIEW].components;
  if (componentIndices) {
    for (let i = 0; i < componentIndices.length; i++) {
      const elementComponentIndex = componentIndices[i];
      const componentView = getComponentLViewByIndex(elementComponentIndex, lView);
      if (componentView[CONTEXT] === componentInstance) {
        return elementComponentIndex;
      }
    }
  } else {
    const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);
    const rootComponent = rootComponentView[CONTEXT];
    if (rootComponent === componentInstance) {
      return HEADER_OFFSET;
    }
  }
  return -1;
}
function findViaDirective(lView, directiveInstance) {
  let tNode = lView[TVIEW].firstChild;
  while (tNode) {
    const directiveIndexStart = tNode.directiveStart;
    const directiveIndexEnd = tNode.directiveEnd;
    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {
      if (lView[i] === directiveInstance) {
        return tNode.index;
      }
    }
    tNode = traverseNextElement(tNode);
  }
  return -1;
}
function getDirectivesAtNodeIndex(nodeIndex, lView, includeComponents) {
  const tNode = lView[TVIEW].data[nodeIndex];
  let directiveStartIndex = tNode.directiveStart;
  if (directiveStartIndex == 0)
    return EMPTY_ARRAY;
  const directiveEndIndex = tNode.directiveEnd;
  if (!includeComponents && tNode.flags & 2)
    directiveStartIndex++;
  return lView.slice(directiveStartIndex, directiveEndIndex);
}
function getComponentAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[TVIEW].data[nodeIndex];
  let directiveStartIndex = tNode.directiveStart;
  return tNode.flags & 2 ? lView[directiveStartIndex] : null;
}
function discoverLocalRefs(lView, nodeIndex) {
  const tNode = lView[TVIEW].data[nodeIndex];
  if (tNode && tNode.localNames) {
    const result = {};
    let localIndex = tNode.index + 1;
    for (let i = 0; i < tNode.localNames.length; i += 2) {
      result[tNode.localNames[i]] = lView[localIndex];
      localIndex++;
    }
    return result;
  }
  return null;
}
function \u0275\u0275resolveWindow(element) {
  return element.ownerDocument.defaultView;
}
function \u0275\u0275resolveDocument(element) {
  return element.ownerDocument;
}
function \u0275\u0275resolveBody(element) {
  return element.ownerDocument.body;
}
function maybeUnwrapFn(value) {
  if (value instanceof Function) {
    return value();
  } else {
    return value;
  }
}
function assertStandaloneComponentType(type) {
  assertComponentDef(type);
  const componentDef = getComponentDef(type);
  if (!componentDef.standalone) {
    throw new RuntimeError(
      907,
      `The ${stringifyForError(type)} component is not marked as standalone, but Angular expects to have a standalone component here. Please make sure the ${stringifyForError(type)} component has the \`standalone: true\` flag in the decorator.`
    );
  }
}
function assertComponentDef(type) {
  if (!getComponentDef(type)) {
    throw new RuntimeError(
      906,
      `The ${stringifyForError(type)} is not an Angular component, make sure it has the \`@Component\` decorator.`
    );
  }
}
function throwMultipleComponentError(tNode, first2, second) {
  throw new RuntimeError(
    -300,
    `Multiple components match node with tagname ${tNode.value}: ${stringifyForError(first2)} and ${stringifyForError(second)}`
  );
}
function throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName) {
  const field = propName ? ` for '${propName}'` : "";
  let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${oldValue}'. Current value: '${currValue}'.`;
  if (creationMode) {
    msg += ` It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook?`;
  }
  throw new RuntimeError(
    -100,
    msg
  );
}
function constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {
  const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);
  let oldValue = prefix, newValue = prefix;
  for (let i = 0; i < chunks.length; i++) {
    const slotIdx = rootIndex + i;
    oldValue += `${lView[slotIdx]}${chunks[i]}`;
    newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;
  }
  return {
    propName,
    oldValue,
    newValue
  };
}
function getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {
  const tData = lView[TVIEW].data;
  const metadata = tData[bindingIndex];
  if (typeof metadata === "string") {
    if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {
      return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);
    }
    return {
      propName: metadata,
      oldValue,
      newValue
    };
  }
  if (metadata === null) {
    let idx = bindingIndex - 1;
    while (typeof tData[idx] !== "string" && tData[idx + 1] === null) {
      idx--;
    }
    const meta = tData[idx];
    if (typeof meta === "string") {
      const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, "g"));
      if (matches && matches.length - 1 > bindingIndex - idx) {
        return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);
      }
    }
  }
  return {
    propName: void 0,
    oldValue,
    newValue
  };
}
function icuContainerIterate(tIcuContainerNode, lView) {
  return _icuContainerIterate(tIcuContainerNode, lView);
}
function ensureIcuContainerVisitorLoaded(loader) {
  if (_icuContainerIterate === void 0) {
    _icuContainerIterate = loader();
  }
}
function getLViewParent(lView) {
  define_ngDevMode_default && assertLView(lView);
  const parent = lView[PARENT];
  return isLContainer(parent) ? parent[PARENT] : parent;
}
function getRootView(componentOrLView) {
  define_ngDevMode_default && assertDefined(componentOrLView, "component");
  let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);
  while (lView && !(lView[FLAGS] & 256)) {
    lView = getLViewParent(lView);
  }
  define_ngDevMode_default && assertLView(lView);
  return lView;
}
function getRootContext(viewOrComponent) {
  const rootView = getRootView(viewOrComponent);
  define_ngDevMode_default && assertDefined(rootView[CONTEXT], "RootView has no context. Perhaps it is disconnected?");
  return rootView[CONTEXT];
}
function getFirstLContainer(lView) {
  return getNearestLContainer(lView[CHILD_HEAD]);
}
function getNextLContainer(container) {
  return getNearestLContainer(container[NEXT]);
}
function getNearestLContainer(viewOrContainer) {
  while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {
    viewOrContainer = viewOrContainer[NEXT];
  }
  return viewOrContainer;
}
function applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {
  if (lNodeToHandle != null) {
    let lContainer;
    let isComponent = false;
    if (isLContainer(lNodeToHandle)) {
      lContainer = lNodeToHandle;
    } else if (isLView(lNodeToHandle)) {
      isComponent = true;
      define_ngDevMode_default && assertDefined(lNodeToHandle[HOST], "HOST must be defined for a component LView");
      lNodeToHandle = lNodeToHandle[HOST];
    }
    const rNode = unwrapRNode(lNodeToHandle);
    if (action === 0 && parent !== null) {
      if (beforeNode == null) {
        nativeAppendChild(renderer, parent, rNode);
      } else {
        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
      }
    } else if (action === 1 && parent !== null) {
      nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
    } else if (action === 2) {
      nativeRemoveNode(renderer, rNode, isComponent);
    } else if (action === 3) {
      define_ngDevMode_default && define_ngDevMode_default.rendererDestroyNode++;
      renderer.destroyNode(rNode);
    }
    if (lContainer != null) {
      applyContainer(renderer, action, lContainer, parent, beforeNode);
    }
  }
}
function createTextNode(renderer, value) {
  define_ngDevMode_default && define_ngDevMode_default.rendererCreateTextNode++;
  define_ngDevMode_default && define_ngDevMode_default.rendererSetText++;
  return renderer.createText(value);
}
function updateTextNode(renderer, rNode, value) {
  define_ngDevMode_default && define_ngDevMode_default.rendererSetText++;
  renderer.setValue(rNode, value);
}
function createCommentNode(renderer, value) {
  define_ngDevMode_default && define_ngDevMode_default.rendererCreateComment++;
  return renderer.createComment(escapeCommentText(value));
}
function createElementNode(renderer, name, namespace) {
  define_ngDevMode_default && define_ngDevMode_default.rendererCreateElement++;
  return renderer.createElement(name, namespace);
}
function removeViewFromContainer(tView, lView) {
  const renderer = lView[RENDERER];
  applyView(
    tView,
    lView,
    renderer,
    2,
    null,
    null
  );
  lView[HOST] = null;
  lView[T_HOST] = null;
}
function addViewToContainer(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {
  lView[HOST] = parentNativeNode;
  lView[T_HOST] = parentTNode;
  applyView(
    tView,
    lView,
    renderer,
    1,
    parentNativeNode,
    beforeNode
  );
}
function renderDetachView(tView, lView) {
  applyView(
    tView,
    lView,
    lView[RENDERER],
    2,
    null,
    null
  );
}
function destroyViewTree(rootView) {
  let lViewOrLContainer = rootView[CHILD_HEAD];
  if (!lViewOrLContainer) {
    return cleanUpView(rootView[TVIEW], rootView);
  }
  while (lViewOrLContainer) {
    let next = null;
    if (isLView(lViewOrLContainer)) {
      next = lViewOrLContainer[CHILD_HEAD];
    } else {
      define_ngDevMode_default && assertLContainer(lViewOrLContainer);
      const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];
      if (firstView)
        next = firstView;
    }
    if (!next) {
      while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {
        if (isLView(lViewOrLContainer)) {
          cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
        }
        lViewOrLContainer = lViewOrLContainer[PARENT];
      }
      if (lViewOrLContainer === null)
        lViewOrLContainer = rootView;
      if (isLView(lViewOrLContainer)) {
        cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
      }
      next = lViewOrLContainer && lViewOrLContainer[NEXT];
    }
    lViewOrLContainer = next;
  }
}
function insertView(tView, lView, lContainer, index) {
  define_ngDevMode_default && assertLView(lView);
  define_ngDevMode_default && assertLContainer(lContainer);
  const indexInContainer = CONTAINER_HEADER_OFFSET + index;
  const containerLength = lContainer.length;
  if (index > 0) {
    lContainer[indexInContainer - 1][NEXT] = lView;
  }
  if (index < containerLength - CONTAINER_HEADER_OFFSET) {
    lView[NEXT] = lContainer[indexInContainer];
    addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);
  } else {
    lContainer.push(lView);
    lView[NEXT] = null;
  }
  lView[PARENT] = lContainer;
  const declarationLContainer = lView[DECLARATION_LCONTAINER];
  if (declarationLContainer !== null && lContainer !== declarationLContainer) {
    trackMovedView(declarationLContainer, lView);
  }
  const lQueries = lView[QUERIES];
  if (lQueries !== null) {
    lQueries.insertView(tView);
  }
  lView[FLAGS] |= 64;
}
function trackMovedView(declarationContainer, lView) {
  define_ngDevMode_default && assertDefined(lView, "LView required");
  define_ngDevMode_default && assertLContainer(declarationContainer);
  const movedViews = declarationContainer[MOVED_VIEWS];
  const insertedLContainer = lView[PARENT];
  define_ngDevMode_default && assertLContainer(insertedLContainer);
  const insertedComponentLView = insertedLContainer[PARENT][DECLARATION_COMPONENT_VIEW];
  define_ngDevMode_default && assertDefined(insertedComponentLView, "Missing insertedComponentLView");
  const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];
  define_ngDevMode_default && assertDefined(declaredComponentLView, "Missing declaredComponentLView");
  if (declaredComponentLView !== insertedComponentLView) {
    declarationContainer[HAS_TRANSPLANTED_VIEWS] = true;
  }
  if (movedViews === null) {
    declarationContainer[MOVED_VIEWS] = [lView];
  } else {
    movedViews.push(lView);
  }
}
function detachMovedView(declarationContainer, lView) {
  define_ngDevMode_default && assertLContainer(declarationContainer);
  define_ngDevMode_default && assertDefined(declarationContainer[MOVED_VIEWS], "A projected view should belong to a non-empty projected views collection");
  const movedViews = declarationContainer[MOVED_VIEWS];
  const declarationViewIndex = movedViews.indexOf(lView);
  const insertionLContainer = lView[PARENT];
  define_ngDevMode_default && assertLContainer(insertionLContainer);
  if (lView[FLAGS] & 512) {
    lView[FLAGS] &= ~512;
    updateTransplantedViewCount(insertionLContainer, -1);
  }
  movedViews.splice(declarationViewIndex, 1);
}
function detachView(lContainer, removeIndex) {
  if (lContainer.length <= CONTAINER_HEADER_OFFSET)
    return;
  const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;
  const viewToDetach = lContainer[indexInContainer];
  if (viewToDetach) {
    const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];
    if (declarationLContainer !== null && declarationLContainer !== lContainer) {
      detachMovedView(declarationLContainer, viewToDetach);
    }
    if (removeIndex > 0) {
      lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];
    }
    const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);
    removeViewFromContainer(viewToDetach[TVIEW], viewToDetach);
    const lQueries = removedLView[QUERIES];
    if (lQueries !== null) {
      lQueries.detachView(removedLView[TVIEW]);
    }
    viewToDetach[PARENT] = null;
    viewToDetach[NEXT] = null;
    viewToDetach[FLAGS] &= ~64;
  }
  return viewToDetach;
}
function destroyLView(tView, lView) {
  if (!(lView[FLAGS] & 128)) {
    const renderer = lView[RENDERER];
    if (renderer.destroyNode) {
      applyView(
        tView,
        lView,
        renderer,
        3,
        null,
        null
      );
    }
    destroyViewTree(lView);
  }
}
function cleanUpView(tView, lView) {
  if (!(lView[FLAGS] & 128)) {
    lView[FLAGS] &= ~64;
    lView[FLAGS] |= 128;
    executeOnDestroys(tView, lView);
    processCleanups(tView, lView);
    if (lView[TVIEW].type === 1) {
      define_ngDevMode_default && define_ngDevMode_default.rendererDestroy++;
      lView[RENDERER].destroy();
    }
    const declarationContainer = lView[DECLARATION_LCONTAINER];
    if (declarationContainer !== null && isLContainer(lView[PARENT])) {
      if (declarationContainer !== lView[PARENT]) {
        detachMovedView(declarationContainer, lView);
      }
      const lQueries = lView[QUERIES];
      if (lQueries !== null) {
        lQueries.detachView(tView);
      }
    }
    unregisterLView(lView);
  }
}
function processCleanups(tView, lView) {
  const tCleanup = tView.cleanup;
  const lCleanup = lView[CLEANUP];
  let lastLCleanupIndex = -1;
  if (tCleanup !== null) {
    for (let i = 0; i < tCleanup.length - 1; i += 2) {
      if (typeof tCleanup[i] === "string") {
        const idxOrTargetGetter = tCleanup[i + 1];
        const target = typeof idxOrTargetGetter === "function" ? idxOrTargetGetter(lView) : unwrapRNode(lView[idxOrTargetGetter]);
        const listener = lCleanup[lastLCleanupIndex = tCleanup[i + 2]];
        const useCaptureOrSubIdx = tCleanup[i + 3];
        if (typeof useCaptureOrSubIdx === "boolean") {
          target.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx);
        } else {
          if (useCaptureOrSubIdx >= 0) {
            lCleanup[lastLCleanupIndex = useCaptureOrSubIdx]();
          } else {
            lCleanup[lastLCleanupIndex = -useCaptureOrSubIdx].unsubscribe();
          }
        }
        i += 2;
      } else {
        const context2 = lCleanup[lastLCleanupIndex = tCleanup[i + 1]];
        tCleanup[i].call(context2);
      }
    }
  }
  if (lCleanup !== null) {
    for (let i = lastLCleanupIndex + 1; i < lCleanup.length; i++) {
      const instanceCleanupFn = lCleanup[i];
      define_ngDevMode_default && assertFunction(instanceCleanupFn, "Expecting instance cleanup function.");
      instanceCleanupFn();
    }
    lView[CLEANUP] = null;
  }
}
function executeOnDestroys(tView, lView) {
  let destroyHooks;
  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {
    for (let i = 0; i < destroyHooks.length; i += 2) {
      const context2 = lView[destroyHooks[i]];
      if (!(context2 instanceof NodeInjectorFactory)) {
        const toCall = destroyHooks[i + 1];
        if (Array.isArray(toCall)) {
          for (let j = 0; j < toCall.length; j += 2) {
            const callContext = context2[toCall[j]];
            const hook = toCall[j + 1];
            profiler(
              4,
              callContext,
              hook
            );
            try {
              hook.call(callContext);
            } finally {
              profiler(
                5,
                callContext,
                hook
              );
            }
          }
        } else {
          profiler(
            4,
            context2,
            toCall
          );
          try {
            toCall.call(context2);
          } finally {
            profiler(
              5,
              context2,
              toCall
            );
          }
        }
      }
    }
  }
}
function getParentRElement(tView, tNode, lView) {
  return getClosestRElement(tView, tNode.parent, lView);
}
function getClosestRElement(tView, tNode, lView) {
  let parentTNode = tNode;
  while (parentTNode !== null && parentTNode.type & (8 | 32)) {
    tNode = parentTNode;
    parentTNode = tNode.parent;
  }
  if (parentTNode === null) {
    return lView[HOST];
  } else {
    define_ngDevMode_default && assertTNodeType(
      parentTNode,
      3 | 4
    );
    if (parentTNode.flags & 2) {
      define_ngDevMode_default && assertTNodeForLView(parentTNode, lView);
      const encapsulation = tView.data[parentTNode.directiveStart].encapsulation;
      if (encapsulation === ViewEncapsulation$1.None || encapsulation === ViewEncapsulation$1.Emulated) {
        return null;
      }
    }
    return getNativeByTNode(parentTNode, lView);
  }
}
function nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {
  define_ngDevMode_default && define_ngDevMode_default.rendererInsertBefore++;
  renderer.insertBefore(parent, child, beforeNode, isMove);
}
function nativeAppendChild(renderer, parent, child) {
  define_ngDevMode_default && define_ngDevMode_default.rendererAppendChild++;
  define_ngDevMode_default && assertDefined(parent, "parent node must be defined");
  renderer.appendChild(parent, child);
}
function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {
  if (beforeNode !== null) {
    nativeInsertBefore(renderer, parent, child, beforeNode, isMove);
  } else {
    nativeAppendChild(renderer, parent, child);
  }
}
function nativeRemoveChild(renderer, parent, child, isHostElement) {
  renderer.removeChild(parent, child, isHostElement);
}
function nativeParentNode(renderer, node) {
  return renderer.parentNode(node);
}
function nativeNextSibling(renderer, node) {
  return renderer.nextSibling(node);
}
function getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {
  return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);
}
function getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {
  if (parentTNode.type & (8 | 32)) {
    return getNativeByTNode(parentTNode, lView);
  }
  return null;
}
function setI18nHandling(getInsertInFrontOfRNodeWithI18n2, processI18nInsertBefore2) {
  _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n2;
  _processI18nInsertBefore = processI18nInsertBefore2;
}
function appendChild(tView, lView, childRNode, childTNode) {
  const parentRNode = getParentRElement(tView, childTNode, lView);
  const renderer = lView[RENDERER];
  const parentTNode = childTNode.parent || lView[T_HOST];
  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);
  if (parentRNode != null) {
    if (Array.isArray(childRNode)) {
      for (let i = 0; i < childRNode.length; i++) {
        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);
      }
    } else {
      nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);
    }
  }
  _processI18nInsertBefore !== void 0 && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);
}
function getFirstNativeNode(lView, tNode) {
  if (tNode !== null) {
    define_ngDevMode_default && assertTNodeType(
      tNode,
      3 | 12 | 32 | 16
    );
    const tNodeType = tNode.type;
    if (tNodeType & 3) {
      return getNativeByTNode(tNode, lView);
    } else if (tNodeType & 4) {
      return getBeforeNodeForView(-1, lView[tNode.index]);
    } else if (tNodeType & 8) {
      const elIcuContainerChild = tNode.child;
      if (elIcuContainerChild !== null) {
        return getFirstNativeNode(lView, elIcuContainerChild);
      } else {
        const rNodeOrLContainer = lView[tNode.index];
        if (isLContainer(rNodeOrLContainer)) {
          return getBeforeNodeForView(-1, rNodeOrLContainer);
        } else {
          return unwrapRNode(rNodeOrLContainer);
        }
      }
    } else if (tNodeType & 32) {
      let nextRNode = icuContainerIterate(tNode, lView);
      let rNode = nextRNode();
      return rNode || unwrapRNode(lView[tNode.index]);
    } else {
      const projectionNodes = getProjectionNodes(lView, tNode);
      if (projectionNodes !== null) {
        if (Array.isArray(projectionNodes)) {
          return projectionNodes[0];
        }
        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
        define_ngDevMode_default && assertParentView(parentView);
        return getFirstNativeNode(parentView, projectionNodes);
      } else {
        return getFirstNativeNode(lView, tNode.next);
      }
    }
  }
  return null;
}
function getProjectionNodes(lView, tNode) {
  if (tNode !== null) {
    const componentView = lView[DECLARATION_COMPONENT_VIEW];
    const componentHost = componentView[T_HOST];
    const slotIdx = tNode.projection;
    define_ngDevMode_default && assertProjectionSlots(lView);
    return componentHost.projection[slotIdx];
  }
  return null;
}
function getBeforeNodeForView(viewIndexInContainer, lContainer) {
  const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;
  if (nextViewIndex < lContainer.length) {
    const lView = lContainer[nextViewIndex];
    const firstTNodeOfView = lView[TVIEW].firstChild;
    if (firstTNodeOfView !== null) {
      return getFirstNativeNode(lView, firstTNodeOfView);
    }
  }
  return lContainer[NATIVE];
}
function nativeRemoveNode(renderer, rNode, isHostElement) {
  define_ngDevMode_default && define_ngDevMode_default.rendererRemoveNode++;
  const nativeParent = nativeParentNode(renderer, rNode);
  if (nativeParent) {
    nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);
  }
}
function applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {
  while (tNode != null) {
    define_ngDevMode_default && assertTNodeForLView(tNode, lView);
    define_ngDevMode_default && assertTNodeType(
      tNode,
      3 | 12 | 16 | 32
    );
    const rawSlotValue = lView[tNode.index];
    const tNodeType = tNode.type;
    if (isProjection) {
      if (action === 0) {
        rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);
        tNode.flags |= 4;
      }
    }
    if ((tNode.flags & 64) !== 64) {
      if (tNodeType & 8) {
        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      } else if (tNodeType & 32) {
        const nextRNode = icuContainerIterate(tNode, lView);
        let rNode;
        while (rNode = nextRNode()) {
          applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
        }
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      } else if (tNodeType & 16) {
        applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);
      } else {
        define_ngDevMode_default && assertTNodeType(
          tNode,
          3 | 4
        );
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
}
function applyView(tView, lView, renderer, action, parentRElement, beforeNode) {
  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);
}
function applyProjection(tView, lView, tProjectionNode) {
  const renderer = lView[RENDERER];
  const parentRNode = getParentRElement(tView, tProjectionNode, lView);
  const parentTNode = tProjectionNode.parent || lView[T_HOST];
  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);
  applyProjectionRecursive(
    renderer,
    0,
    lView,
    tProjectionNode,
    parentRNode,
    beforeNode
  );
}
function applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {
  const componentLView = lView[DECLARATION_COMPONENT_VIEW];
  const componentNode = componentLView[T_HOST];
  define_ngDevMode_default && assertEqual(typeof tProjectionNode.projection, "number", "expecting projection index");
  const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];
  if (Array.isArray(nodeToProjectOrRNodes)) {
    for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {
      const rNode = nodeToProjectOrRNodes[i];
      applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
    }
  } else {
    let nodeToProject = nodeToProjectOrRNodes;
    const projectedComponentLView = componentLView[PARENT];
    applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);
  }
}
function applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {
  define_ngDevMode_default && assertLContainer(lContainer);
  const anchor = lContainer[NATIVE];
  const native = unwrapRNode(lContainer);
  if (anchor !== native) {
    applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);
  }
  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const lView = lContainer[i];
    applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);
  }
}
function applyStyling(renderer, isClassBased, rNode, prop, value) {
  if (isClassBased) {
    if (!value) {
      define_ngDevMode_default && define_ngDevMode_default.rendererRemoveClass++;
      renderer.removeClass(rNode, prop);
    } else {
      define_ngDevMode_default && define_ngDevMode_default.rendererAddClass++;
      renderer.addClass(rNode, prop);
    }
  } else {
    let flags = prop.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
    if (value == null) {
      define_ngDevMode_default && define_ngDevMode_default.rendererRemoveStyle++;
      renderer.removeStyle(rNode, prop, flags);
    } else {
      const isImportant = typeof value === "string" ? value.endsWith("!important") : false;
      if (isImportant) {
        value = value.slice(0, -10);
        flags |= RendererStyleFlags2.Important;
      }
      define_ngDevMode_default && define_ngDevMode_default.rendererSetStyle++;
      renderer.setStyle(rNode, prop, value, flags);
    }
  }
}
function writeDirectStyle(renderer, element, newValue) {
  define_ngDevMode_default && assertString(newValue, "'newValue' should be a string");
  renderer.setAttribute(element, "style", newValue);
  define_ngDevMode_default && define_ngDevMode_default.rendererSetStyle++;
}
function writeDirectClass(renderer, element, newValue) {
  define_ngDevMode_default && assertString(newValue, "'newValue' should be a string");
  if (newValue === "") {
    renderer.removeAttribute(element, "class");
  } else {
    renderer.setAttribute(element, "class", newValue);
  }
  define_ngDevMode_default && define_ngDevMode_default.rendererSetClassName++;
}
function classIndexOf(className, classToSearch, startingIndex) {
  define_ngDevMode_default && assertNotEqual(classToSearch, "", 'can not look for "" string.');
  let end = className.length;
  while (true) {
    const foundIndex = className.indexOf(classToSearch, startingIndex);
    if (foundIndex === -1)
      return foundIndex;
    if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32) {
      const length = classToSearch.length;
      if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32) {
        return foundIndex;
      }
    }
    startingIndex = foundIndex + 1;
  }
}
function isCssClassMatching(attrs, cssClassToMatch, isProjectionMode) {
  define_ngDevMode_default && assertEqual(cssClassToMatch, cssClassToMatch.toLowerCase(), "Class name expected to be lowercase.");
  let i = 0;
  while (i < attrs.length) {
    let item = attrs[i++];
    if (isProjectionMode && item === "class") {
      item = attrs[i];
      if (classIndexOf(item.toLowerCase(), cssClassToMatch, 0) !== -1) {
        return true;
      }
    } else if (item === 1) {
      while (i < attrs.length && typeof (item = attrs[i++]) == "string") {
        if (item.toLowerCase() === cssClassToMatch)
          return true;
      }
      return false;
    }
  }
  return false;
}
function isInlineTemplate(tNode) {
  return tNode.type === 4 && tNode.value !== NG_TEMPLATE_SELECTOR;
}
function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
  const tagNameToCompare = tNode.type === 4 && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;
  return currentSelector === tagNameToCompare;
}
function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
  define_ngDevMode_default && assertDefined(selector[0], "Selector should have a tag name");
  let mode = 4;
  const nodeAttrs = tNode.attrs || [];
  const nameOnlyMarkerIdx = getNameOnlyMarkerIndex(nodeAttrs);
  let skipToNextSelector = false;
  for (let i = 0; i < selector.length; i++) {
    const current = selector[i];
    if (typeof current === "number") {
      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {
        return false;
      }
      if (skipToNextSelector && isPositive(current))
        continue;
      skipToNextSelector = false;
      mode = current | mode & 1;
      continue;
    }
    if (skipToNextSelector)
      continue;
    if (mode & 4) {
      mode = 2 | mode & 1;
      if (current !== "" && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === "" && selector.length === 1) {
        if (isPositive(mode))
          return false;
        skipToNextSelector = true;
      }
    } else {
      const selectorAttrValue = mode & 8 ? current : selector[++i];
      if (mode & 8 && tNode.attrs !== null) {
        if (!isCssClassMatching(tNode.attrs, selectorAttrValue, isProjectionMode)) {
          if (isPositive(mode))
            return false;
          skipToNextSelector = true;
        }
        continue;
      }
      const attrName = mode & 8 ? "class" : current;
      const attrIndexInNode = findAttrIndexInNode(attrName, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);
      if (attrIndexInNode === -1) {
        if (isPositive(mode))
          return false;
        skipToNextSelector = true;
        continue;
      }
      if (selectorAttrValue !== "") {
        let nodeAttrValue;
        if (attrIndexInNode > nameOnlyMarkerIdx) {
          nodeAttrValue = "";
        } else {
          define_ngDevMode_default && assertNotEqual(
            nodeAttrs[attrIndexInNode],
            0,
            "We do not match directives on namespaced attributes"
          );
          nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();
        }
        const compareAgainstClassName = mode & 8 ? nodeAttrValue : null;
        if (compareAgainstClassName && classIndexOf(compareAgainstClassName, selectorAttrValue, 0) !== -1 || mode & 2 && selectorAttrValue !== nodeAttrValue) {
          if (isPositive(mode))
            return false;
          skipToNextSelector = true;
        }
      }
    }
  }
  return isPositive(mode) || skipToNextSelector;
}
function isPositive(mode) {
  return (mode & 1) === 0;
}
function findAttrIndexInNode(name, attrs, isInlineTemplate2, isProjectionMode) {
  if (attrs === null)
    return -1;
  let i = 0;
  if (isProjectionMode || !isInlineTemplate2) {
    let bindingsMode = false;
    while (i < attrs.length) {
      const maybeAttrName = attrs[i];
      if (maybeAttrName === name) {
        return i;
      } else if (maybeAttrName === 3 || maybeAttrName === 6) {
        bindingsMode = true;
      } else if (maybeAttrName === 1 || maybeAttrName === 2) {
        let value = attrs[++i];
        while (typeof value === "string") {
          value = attrs[++i];
        }
        continue;
      } else if (maybeAttrName === 4) {
        break;
      } else if (maybeAttrName === 0) {
        i += 4;
        continue;
      }
      i += bindingsMode ? 1 : 2;
    }
    return -1;
  } else {
    return matchTemplateAttribute(attrs, name);
  }
}
function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {
  for (let i = 0; i < selector.length; i++) {
    if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {
      return true;
    }
  }
  return false;
}
function getProjectAsAttrValue(tNode) {
  const nodeAttrs = tNode.attrs;
  if (nodeAttrs != null) {
    const ngProjectAsAttrIdx = nodeAttrs.indexOf(
      5
    );
    if ((ngProjectAsAttrIdx & 1) === 0) {
      return nodeAttrs[ngProjectAsAttrIdx + 1];
    }
  }
  return null;
}
function getNameOnlyMarkerIndex(nodeAttrs) {
  for (let i = 0; i < nodeAttrs.length; i++) {
    const nodeAttr = nodeAttrs[i];
    if (isNameOnlyAttributeMarker(nodeAttr)) {
      return i;
    }
  }
  return nodeAttrs.length;
}
function matchTemplateAttribute(attrs, name) {
  let i = attrs.indexOf(
    4
  );
  if (i > -1) {
    i++;
    while (i < attrs.length) {
      const attr = attrs[i];
      if (typeof attr === "number")
        return -1;
      if (attr === name)
        return i;
      i++;
    }
  }
  return -1;
}
function isSelectorInSelectorList(selector, list) {
  selectorListLoop:
    for (let i = 0; i < list.length; i++) {
      const currentSelectorInList = list[i];
      if (selector.length !== currentSelectorInList.length) {
        continue;
      }
      for (let j = 0; j < selector.length; j++) {
        if (selector[j] !== currentSelectorInList[j]) {
          continue selectorListLoop;
        }
      }
      return true;
    }
  return false;
}
function maybeWrapInNotSelector(isNegativeMode, chunk) {
  return isNegativeMode ? ":not(" + chunk.trim() + ")" : chunk;
}
function stringifyCSSSelector(selector) {
  let result = selector[0];
  let i = 1;
  let mode = 2;
  let currentChunk = "";
  let isNegativeMode = false;
  while (i < selector.length) {
    let valueOrMarker = selector[i];
    if (typeof valueOrMarker === "string") {
      if (mode & 2) {
        const attrValue = selector[++i];
        currentChunk += "[" + valueOrMarker + (attrValue.length > 0 ? '="' + attrValue + '"' : "") + "]";
      } else if (mode & 8) {
        currentChunk += "." + valueOrMarker;
      } else if (mode & 4) {
        currentChunk += " " + valueOrMarker;
      }
    } else {
      if (currentChunk !== "" && !isPositive(valueOrMarker)) {
        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
        currentChunk = "";
      }
      mode = valueOrMarker;
      isNegativeMode = isNegativeMode || !isPositive(mode);
    }
    i++;
  }
  if (currentChunk !== "") {
    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
  }
  return result;
}
function stringifyCSSSelectorList(selectorList) {
  return selectorList.map(stringifyCSSSelector).join(",");
}
function extractAttrsAndClassesFromSelector(selector) {
  const attrs = [];
  const classes = [];
  let i = 1;
  let mode = 2;
  while (i < selector.length) {
    let valueOrMarker = selector[i];
    if (typeof valueOrMarker === "string") {
      if (mode === 2) {
        if (valueOrMarker !== "") {
          attrs.push(valueOrMarker, selector[++i]);
        }
      } else if (mode === 8) {
        classes.push(valueOrMarker);
      }
    } else {
      if (!isPositive(mode))
        break;
      mode = valueOrMarker;
    }
    i++;
  }
  return {
    attrs,
    classes
  };
}
function \u0275\u0275advance(delta) {
  define_ngDevMode_default && assertGreaterThan(delta, 0, "Can only advance forward");
  selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, !!define_ngDevMode_default && isInCheckNoChangesMode());
}
function selectIndexInternal(tView, lView, index, checkNoChangesMode) {
  define_ngDevMode_default && assertIndexInDeclRange(lView, index);
  if (!checkNoChangesMode) {
    const hooksInitPhaseCompleted = (lView[FLAGS] & 3) === 3;
    if (hooksInitPhaseCompleted) {
      const preOrderCheckHooks = tView.preOrderCheckHooks;
      if (preOrderCheckHooks !== null) {
        executeCheckHooks(lView, preOrderCheckHooks, index);
      }
    } else {
      const preOrderHooks = tView.preOrderHooks;
      if (preOrderHooks !== null) {
        executeInitAndCheckHooks(
          lView,
          preOrderHooks,
          0,
          index
        );
      }
    }
  }
  setSelectedIndex(index);
}
function compileInjectable(type, meta) {
  let ngInjectableDef = null;
  let ngFactoryDef = null;
  if (!type.hasOwnProperty(NG_PROV_DEF)) {
    Object.defineProperty(type, NG_PROV_DEF, {
      get: () => {
        if (ngInjectableDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: "injectable",
            type
          });
          ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/\u0275prov.js`, getInjectableMetadata(type, meta));
        }
        return ngInjectableDef;
      }
    });
  }
  if (!type.hasOwnProperty(NG_FACTORY_DEF)) {
    Object.defineProperty(type, NG_FACTORY_DEF, {
      get: () => {
        if (ngFactoryDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: "injectable",
            type
          });
          ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/\u0275fac.js`, {
            name: type.name,
            type,
            typeArgumentCount: 0,
            deps: reflectDependencies(type),
            target: compiler.FactoryTarget.Injectable
          });
        }
        return ngFactoryDef;
      },
      configurable: true
    });
  }
}
function isUseClassProvider(meta) {
  return meta.useClass !== void 0;
}
function isUseValueProvider(meta) {
  return USE_VALUE in meta;
}
function isUseFactoryProvider(meta) {
  return meta.useFactory !== void 0;
}
function isUseExistingProvider(meta) {
  return meta.useExisting !== void 0;
}
function getInjectableMetadata(type, srcMeta) {
  const meta = srcMeta || {
    providedIn: null
  };
  const compilerMeta = {
    name: type.name,
    type,
    typeArgumentCount: 0,
    providedIn: meta.providedIn
  };
  if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== void 0) {
    compilerMeta.deps = convertDependencies(meta.deps);
  }
  if (isUseClassProvider(meta)) {
    compilerMeta.useClass = meta.useClass;
  } else if (isUseValueProvider(meta)) {
    compilerMeta.useValue = meta.useValue;
  } else if (isUseFactoryProvider(meta)) {
    compilerMeta.useFactory = meta.useFactory;
  } else if (isUseExistingProvider(meta)) {
    compilerMeta.useExisting = meta.useExisting;
  }
  return compilerMeta;
}
function createInjector(defType, parent = null, additionalProviders = null, name) {
  const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);
  injector.resolveInjectorInitializers();
  return injector;
}
function createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = /* @__PURE__ */ new Set()) {
  const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];
  name = name || (typeof defType === "object" ? void 0 : stringify(defType));
  return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);
}
function findFirstClosedCycle(keys) {
  const res = [];
  for (let i = 0; i < keys.length; ++i) {
    if (res.indexOf(keys[i]) > -1) {
      res.push(keys[i]);
      return res;
    }
    res.push(keys[i]);
  }
  return res;
}
function constructResolvingPath(keys) {
  if (keys.length > 1) {
    const reversed = findFirstClosedCycle(keys.slice().reverse());
    const tokenStrs = reversed.map((k) => stringify(k.token));
    return " (" + tokenStrs.join(" -> ") + ")";
  }
  return "";
}
function injectionError(injector, key, constructResolvingMessage, originalError) {
  const keys = [key];
  const errMsg = constructResolvingMessage(keys);
  const error2 = originalError ? wrappedError(errMsg, originalError) : Error(errMsg);
  error2.addKey = addKey;
  error2.keys = keys;
  error2.injectors = [injector];
  error2.constructResolvingMessage = constructResolvingMessage;
  error2[ERROR_ORIGINAL_ERROR] = originalError;
  return error2;
}
function addKey(injector, key) {
  this.injectors.push(injector);
  this.keys.push(key);
  this.message = this.constructResolvingMessage(this.keys);
}
function noProviderError(injector, key) {
  return injectionError(injector, key, function(keys) {
    const first2 = stringify(keys[0].token);
    return `No provider for ${first2}!${constructResolvingPath(keys)}`;
  });
}
function cyclicDependencyError(injector, key) {
  return injectionError(injector, key, function(keys) {
    return `Cannot instantiate cyclic dependency!${constructResolvingPath(keys)}`;
  });
}
function instantiationError(injector, originalException, originalStack, key) {
  return injectionError(injector, key, function(keys) {
    const first2 = stringify(keys[0].token);
    return `${originalException.message}: Error during instantiation of ${first2}!${constructResolvingPath(keys)}.`;
  }, originalException);
}
function invalidProviderError(provider) {
  return Error(`Invalid provider - only instances of Provider and Type are allowed, got: ${provider}`);
}
function noAnnotationError(typeOrFunc, params) {
  const signature = [];
  for (let i = 0, ii = params.length; i < ii; i++) {
    const parameter = params[i];
    if (!parameter || parameter.length == 0) {
      signature.push("?");
    } else {
      signature.push(parameter.map(stringify).join(" "));
    }
  }
  return Error("Cannot resolve all parameters for '" + stringify(typeOrFunc) + "'(" + signature.join(", ") + "). Make sure that all the parameters are decorated with Inject or have valid type annotations and that '" + stringify(typeOrFunc) + "' is decorated with Injectable.");
}
function outOfBoundsError(index) {
  return Error(`Index ${index} is out-of-bounds.`);
}
function mixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
  return Error(`Cannot mix multi providers and regular providers, got: ${provider1} ${provider2}`);
}
function resolveReflectiveFactory(provider) {
  let factoryFn;
  let resolvedDeps;
  if (provider.useClass) {
    const useClass = resolveForwardRef(provider.useClass);
    factoryFn = getReflect().factory(useClass);
    resolvedDeps = _dependenciesFor(useClass);
  } else if (provider.useExisting) {
    factoryFn = (aliasInstance) => aliasInstance;
    resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];
  } else if (provider.useFactory) {
    factoryFn = provider.useFactory;
    resolvedDeps = constructDependencies(provider.useFactory, provider.deps);
  } else {
    factoryFn = () => provider.useValue;
    resolvedDeps = _EMPTY_LIST;
  }
  return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
}
function resolveReflectiveProvider(provider) {
  return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi || false);
}
function resolveReflectiveProviders(providers) {
  const normalized = _normalizeProviders(providers, []);
  const resolved2 = normalized.map(resolveReflectiveProvider);
  const resolvedProviderMap = mergeResolvedReflectiveProviders(resolved2, /* @__PURE__ */ new Map());
  return Array.from(resolvedProviderMap.values());
}
function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
  for (let i = 0; i < providers.length; i++) {
    const provider = providers[i];
    const existing = normalizedProvidersMap.get(provider.key.id);
    if (existing) {
      if (provider.multiProvider !== existing.multiProvider) {
        throw mixingMultiProvidersWithRegularProvidersError(existing, provider);
      }
      if (provider.multiProvider) {
        for (let j = 0; j < provider.resolvedFactories.length; j++) {
          existing.resolvedFactories.push(provider.resolvedFactories[j]);
        }
      } else {
        normalizedProvidersMap.set(provider.key.id, provider);
      }
    } else {
      let resolvedProvider;
      if (provider.multiProvider) {
        resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);
      } else {
        resolvedProvider = provider;
      }
      normalizedProvidersMap.set(provider.key.id, resolvedProvider);
    }
  }
  return normalizedProvidersMap;
}
function _normalizeProviders(providers, res) {
  providers.forEach((b) => {
    if (b instanceof Type) {
      res.push({
        provide: b,
        useClass: b
      });
    } else if (b && typeof b == "object" && b.provide !== void 0) {
      res.push(b);
    } else if (Array.isArray(b)) {
      _normalizeProviders(b, res);
    } else {
      throw invalidProviderError(b);
    }
  });
  return res;
}
function constructDependencies(typeOrFunc, dependencies) {
  if (!dependencies) {
    return _dependenciesFor(typeOrFunc);
  } else {
    const params = dependencies.map((t) => [t]);
    return dependencies.map((t) => _extractToken(typeOrFunc, t, params));
  }
}
function _dependenciesFor(typeOrFunc) {
  const params = getReflect().parameters(typeOrFunc);
  if (!params)
    return [];
  if (params.some((p) => p == null)) {
    throw noAnnotationError(typeOrFunc, params);
  }
  return params.map((p) => _extractToken(typeOrFunc, p, params));
}
function _extractToken(typeOrFunc, metadata, params) {
  let token = null;
  let optional = false;
  if (!Array.isArray(metadata)) {
    if (metadata instanceof Inject) {
      return _createDependency(metadata.token, optional, null);
    } else {
      return _createDependency(metadata, optional, null);
    }
  }
  let visibility = null;
  for (let i = 0; i < metadata.length; ++i) {
    const paramMetadata = metadata[i];
    if (paramMetadata instanceof Type) {
      token = paramMetadata;
    } else if (paramMetadata instanceof Inject) {
      token = paramMetadata.token;
    } else if (paramMetadata instanceof Optional) {
      optional = true;
    } else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {
      visibility = paramMetadata;
    } else if (paramMetadata instanceof InjectionToken) {
      token = paramMetadata;
    }
  }
  token = resolveForwardRef(token);
  if (token != null) {
    return _createDependency(token, optional, visibility);
  } else {
    throw noAnnotationError(typeOrFunc, params);
  }
}
function _createDependency(token, optional, visibility) {
  return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);
}
function _mapProviders(injector, fn2) {
  const res = [];
  for (let i = 0; i < injector._providers.length; ++i) {
    res[i] = fn2(injector.getProviderAtIndex(i));
  }
  return res;
}
function \u0275\u0275directiveInject(token, flags = InjectFlags.Default) {
  const lView = getLView();
  if (lView === null) {
    define_ngDevMode_default && assertInjectImplementationNotEqual(\u0275\u0275directiveInject);
    return \u0275\u0275inject(token, flags);
  }
  const tNode = getCurrentTNode();
  return getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);
}
function \u0275\u0275invalidFactory() {
  const msg = define_ngDevMode_default ? `This constructor was not compatible with Dependency Injection.` : "invalid";
  throw new Error(msg);
}
function createNamedArrayType(name) {
  if (define_ngDevMode_default) {
    try {
      return newTrustedFunctionForDev("Array", `return class ${name} extends Array{}`)(Array);
    } catch (e) {
      return Array;
    }
  } else {
    throw new Error("Looks like we are in 'prod mode', but we are creating a named Array type, which is wrong! Check your code");
  }
}
function toTStylingRange(prev, next) {
  define_ngDevMode_default && assertNumberInRange(
    prev,
    0,
    32767
  );
  define_ngDevMode_default && assertNumberInRange(
    next,
    0,
    32767
  );
  return prev << 17 | next << 2;
}
function getTStylingRangePrev(tStylingRange) {
  define_ngDevMode_default && assertNumber(tStylingRange, "expected number");
  return tStylingRange >> 17 & 32767;
}
function getTStylingRangePrevDuplicate(tStylingRange) {
  define_ngDevMode_default && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 2) == 2;
}
function setTStylingRangePrev(tStylingRange, previous) {
  define_ngDevMode_default && assertNumber(tStylingRange, "expected number");
  define_ngDevMode_default && assertNumberInRange(
    previous,
    0,
    32767
  );
  return tStylingRange & ~4294836224 | previous << 17;
}
function setTStylingRangePrevDuplicate(tStylingRange) {
  define_ngDevMode_default && assertNumber(tStylingRange, "expected number");
  return tStylingRange | 2;
}
function getTStylingRangeNext(tStylingRange) {
  define_ngDevMode_default && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 131068) >> 2;
}
function setTStylingRangeNext(tStylingRange, next) {
  define_ngDevMode_default && assertNumber(tStylingRange, "expected number");
  define_ngDevMode_default && assertNumberInRange(
    next,
    0,
    32767
  );
  return tStylingRange & ~131068 | next << 2;
}
function getTStylingRangeNextDuplicate(tStylingRange) {
  define_ngDevMode_default && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 1) === 1;
}
function setTStylingRangeNextDuplicate(tStylingRange) {
  define_ngDevMode_default && assertNumber(tStylingRange, "expected number");
  return tStylingRange | 1;
}
function attachDebugObject(obj, debug) {
  if (define_ngDevMode_default) {
    Object.defineProperty(obj, "debug", {
      value: debug,
      enumerable: false
    });
  } else {
    throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");
  }
}
function attachDebugGetter(obj, debugGetter) {
  if (define_ngDevMode_default) {
    Object.defineProperty(obj, "debug", {
      get: debugGetter,
      enumerable: false
    });
  } else {
    throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");
  }
}
function cloneToLViewFromTViewBlueprint(tView) {
  const debugTView = tView;
  const lView = getLViewToClone(debugTView.type, tView.template && tView.template.name);
  return lView.concat(tView.blueprint);
}
function getLViewToClone(type, name) {
  switch (type) {
    case 0:
      if (LVIEW_ROOT === void 0)
        LVIEW_ROOT = new LRootView();
      return LVIEW_ROOT;
    case 1:
      if (!define_ngDevMode_default || !define_ngDevMode_default.namedConstructors) {
        if (LVIEW_COMPONENT === void 0)
          LVIEW_COMPONENT = new LComponentView();
        return LVIEW_COMPONENT;
      }
      if (LVIEW_COMPONENT_CACHE === void 0)
        LVIEW_COMPONENT_CACHE = /* @__PURE__ */ new Map();
      let componentArray = LVIEW_COMPONENT_CACHE.get(name);
      if (componentArray === void 0) {
        componentArray = new (createNamedArrayType("LComponentView" + nameSuffix(name)))();
        LVIEW_COMPONENT_CACHE.set(name, componentArray);
      }
      return componentArray;
    case 2:
      if (!define_ngDevMode_default || !define_ngDevMode_default.namedConstructors) {
        if (LVIEW_EMBEDDED === void 0)
          LVIEW_EMBEDDED = new LEmbeddedView();
        return LVIEW_EMBEDDED;
      }
      if (LVIEW_EMBEDDED_CACHE === void 0)
        LVIEW_EMBEDDED_CACHE = /* @__PURE__ */ new Map();
      let embeddedArray = LVIEW_EMBEDDED_CACHE.get(name);
      if (embeddedArray === void 0) {
        embeddedArray = new (createNamedArrayType("LEmbeddedView" + nameSuffix(name)))();
        LVIEW_EMBEDDED_CACHE.set(name, embeddedArray);
      }
      return embeddedArray;
  }
}
function nameSuffix(text) {
  if (text == null)
    return "";
  const index = text.lastIndexOf("_Template");
  return "_" + (index === -1 ? text : text.slice(0, index));
}
function toDebugStyleBinding(tNode, isClassBased) {
  const tData = tNode.tView_.data;
  const bindings = [];
  const range2 = isClassBased ? tNode.classBindings : tNode.styleBindings;
  const prev = getTStylingRangePrev(range2);
  const next = getTStylingRangeNext(range2);
  let isTemplate = next !== 0;
  let cursor = isTemplate ? next : prev;
  while (cursor !== 0) {
    const itemKey = tData[cursor];
    const itemRange = tData[cursor + 1];
    bindings.unshift({
      key: itemKey,
      index: cursor,
      isTemplate,
      prevDuplicate: getTStylingRangePrevDuplicate(itemRange),
      nextDuplicate: getTStylingRangeNextDuplicate(itemRange),
      nextIndex: getTStylingRangeNext(itemRange),
      prevIndex: getTStylingRangePrev(itemRange)
    });
    if (cursor === prev)
      isTemplate = false;
    cursor = getTStylingRangePrev(itemRange);
  }
  bindings.push((isClassBased ? tNode.residualClasses : tNode.residualStyles) || null);
  return bindings;
}
function processTNodeChildren(tNode, buf) {
  while (tNode) {
    buf.push(tNode.template_);
    tNode = tNode.next;
  }
}
function cloneToTViewData(list) {
  if (TVIEWDATA_EMPTY === void 0)
    TVIEWDATA_EMPTY = new TViewData();
  return TVIEWDATA_EMPTY.concat(list);
}
function attachLViewDebug(lView) {
  attachDebugObject(lView, new LViewDebug(lView));
}
function attachLContainerDebug(lContainer) {
  attachDebugObject(lContainer, new LContainerDebug(lContainer));
}
function toDebug(obj) {
  if (obj) {
    const debug = obj.debug;
    assertDefined(debug, "Object does not have a debug representation.");
    return debug;
  } else {
    return obj;
  }
}
function toHtml(value, includeChildren = false) {
  const node = unwrapRNode(value);
  if (node) {
    switch (node.nodeType) {
      case Node.TEXT_NODE:
        return node.textContent;
      case Node.COMMENT_NODE:
        return `<!--${node.textContent}-->`;
      case Node.ELEMENT_NODE:
        const outerHTML = node.outerHTML;
        if (includeChildren) {
          return outerHTML;
        } else {
          const innerHTML = ">" + node.innerHTML + "<";
          return outerHTML.split(innerHTML)[0] + ">";
        }
    }
  }
  return null;
}
function mapToHTML(node) {
  if (node.type === "ElementContainer") {
    return (node.children || []).map(mapToHTML).join("");
  } else if (node.type === "IcuContainer") {
    throw new Error("Not implemented");
  } else {
    return toHtml(node.native, true) || "";
  }
}
function toLViewRange(tView, lView, start, end) {
  let content = [];
  for (let index = start; index < end; index++) {
    content.push({
      index,
      t: tView.data[index],
      l: lView[index]
    });
  }
  return {
    start,
    end,
    length: end - start,
    content
  };
}
function toDebugNodes(tNode, lView) {
  if (tNode) {
    const debugNodes = [];
    let tNodeCursor = tNode;
    while (tNodeCursor) {
      debugNodes.push(buildDebugNode(tNodeCursor, lView));
      tNodeCursor = tNodeCursor.next;
    }
    return debugNodes;
  } else {
    return [];
  }
}
function buildDebugNode(tNode, lView) {
  const rawValue = lView[tNode.index];
  const native = unwrapRNode(rawValue);
  const factories = [];
  const instances = [];
  const tView = lView[TVIEW];
  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {
    const def = tView.data[i];
    factories.push(def.type);
    instances.push(lView[i]);
  }
  return {
    html: toHtml(native),
    type: toTNodeTypeAsString(tNode.type),
    tNode,
    native,
    children: toDebugNodes(tNode.child, lView),
    factories,
    instances,
    injector: buildNodeInjectorDebug(tNode, tView, lView),
    get injectorResolutionPath() {
      return tNode.debugNodeInjectorPath(lView);
    }
  };
}
function buildNodeInjectorDebug(tNode, tView, lView) {
  const viewProviders = [];
  for (let i = tNode.providerIndexStart_; i < tNode.providerIndexEnd_; i++) {
    viewProviders.push(tView.data[i]);
  }
  const providers = [];
  for (let i = tNode.providerIndexEnd_; i < tNode.directiveEnd; i++) {
    providers.push(tView.data[i]);
  }
  const nodeInjectorDebug = {
    bloom: toBloom(lView, tNode.injectorIndex),
    cumulativeBloom: toBloom(tView.data, tNode.injectorIndex),
    providers,
    viewProviders,
    parentInjectorIndex: lView[tNode.providerIndexStart_ - 1]
  };
  return nodeInjectorDebug;
}
function binary(array, idx) {
  const value = array[idx];
  if (typeof value !== "number")
    return "????????";
  const text = "00000000" + value.toString(2);
  return text.substring(text.length - 8);
}
function toBloom(array, idx) {
  if (idx < 0) {
    return "NO_NODE_INJECTOR";
  }
  return `${binary(array, idx + 7)}_${binary(array, idx + 6)}_${binary(array, idx + 5)}_${binary(array, idx + 4)}_${binary(array, idx + 3)}_${binary(array, idx + 2)}_${binary(array, idx + 1)}_${binary(array, idx + 0)}`;
}
function processHostBindingOpCodes(tView, lView) {
  const hostBindingOpCodes = tView.hostBindingOpCodes;
  if (hostBindingOpCodes === null)
    return;
  try {
    for (let i = 0; i < hostBindingOpCodes.length; i++) {
      const opCode = hostBindingOpCodes[i];
      if (opCode < 0) {
        setSelectedIndex(~opCode);
      } else {
        const directiveIdx = opCode;
        const bindingRootIndx = hostBindingOpCodes[++i];
        const hostBindingFn = hostBindingOpCodes[++i];
        setBindingRootForHostBindings(bindingRootIndx, directiveIdx);
        const context2 = lView[directiveIdx];
        hostBindingFn(
          2,
          context2
        );
      }
    }
  } finally {
    setSelectedIndex(-1);
  }
}
function refreshContentQueries(tView, lView) {
  const contentQueries = tView.contentQueries;
  if (contentQueries !== null) {
    for (let i = 0; i < contentQueries.length; i += 2) {
      const queryStartIdx = contentQueries[i];
      const directiveDefIdx = contentQueries[i + 1];
      if (directiveDefIdx !== -1) {
        const directiveDef = tView.data[directiveDefIdx];
        define_ngDevMode_default && assertDefined(directiveDef, "DirectiveDef not found.");
        define_ngDevMode_default && assertDefined(directiveDef.contentQueries, "contentQueries function should be defined");
        setCurrentQueryIndex(queryStartIdx);
        directiveDef.contentQueries(
          2,
          lView[directiveDefIdx],
          directiveDefIdx
        );
      }
    }
  }
}
function refreshChildComponents(hostLView, components) {
  for (let i = 0; i < components.length; i++) {
    refreshComponent(hostLView, components[i]);
  }
}
function renderChildComponents(hostLView, components) {
  for (let i = 0; i < components.length; i++) {
    renderComponent(hostLView, components[i]);
  }
}
function createLView(parentLView, tView, context2, flags, host, tHostNode, rendererFactory, renderer, sanitizer, injector, embeddedViewInjector) {
  const lView = define_ngDevMode_default ? cloneToLViewFromTViewBlueprint(tView) : tView.blueprint.slice();
  lView[HOST] = host;
  lView[FLAGS] = flags | 4 | 64 | 8;
  if (embeddedViewInjector !== null || parentLView && parentLView[FLAGS] & 1024) {
    lView[FLAGS] |= 1024;
  }
  resetPreOrderHookFlags(lView);
  define_ngDevMode_default && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);
  lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;
  lView[CONTEXT] = context2;
  lView[RENDERER_FACTORY] = rendererFactory || parentLView && parentLView[RENDERER_FACTORY];
  define_ngDevMode_default && assertDefined(lView[RENDERER_FACTORY], "RendererFactory is required");
  lView[RENDERER] = renderer || parentLView && parentLView[RENDERER];
  define_ngDevMode_default && assertDefined(lView[RENDERER], "Renderer is required");
  lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null;
  lView[INJECTOR$1] = injector || parentLView && parentLView[INJECTOR$1] || null;
  lView[T_HOST] = tHostNode;
  lView[ID] = getUniqueLViewId();
  lView[EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;
  define_ngDevMode_default && assertEqual(tView.type == 2 ? parentLView !== null : true, true, "Embedded views must have parentLView");
  lView[DECLARATION_COMPONENT_VIEW] = tView.type == 2 ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;
  define_ngDevMode_default && attachLViewDebug(lView);
  return lView;
}
function getOrCreateTNode(tView, index, type, name, attrs) {
  define_ngDevMode_default && index !== 0 && assertGreaterThanOrEqual(index, HEADER_OFFSET, "TNodes can't be in the LView header.");
  define_ngDevMode_default && assertPureTNodeType(type);
  let tNode = tView.data[index];
  if (tNode === null) {
    tNode = createTNodeAtIndex(tView, index, type, name, attrs);
    if (isInI18nBlock()) {
      tNode.flags |= 64;
    }
  } else if (tNode.type & 64) {
    tNode.type = type;
    tNode.value = name;
    tNode.attrs = attrs;
    const parent = getCurrentParentTNode();
    tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;
    define_ngDevMode_default && assertTNodeForTView(tNode, tView);
    define_ngDevMode_default && assertEqual(index, tNode.index, "Expecting same index");
  }
  setCurrentTNode(tNode, true);
  return tNode;
}
function createTNodeAtIndex(tView, index, type, name, attrs) {
  const currentTNode = getCurrentTNodePlaceholderOk();
  const isParent = isCurrentTNodeParent();
  const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;
  const tNode = tView.data[index] = createTNode(tView, parent, type, index, name, attrs);
  if (tView.firstChild === null) {
    tView.firstChild = tNode;
  }
  if (currentTNode !== null) {
    if (isParent) {
      if (currentTNode.child == null && tNode.parent !== null) {
        currentTNode.child = tNode;
      }
    } else {
      if (currentTNode.next === null) {
        currentTNode.next = tNode;
      }
    }
  }
  return tNode;
}
function allocExpando(tView, lView, numSlotsToAlloc, initialValue) {
  if (numSlotsToAlloc === 0)
    return -1;
  if (define_ngDevMode_default) {
    assertFirstCreatePass(tView);
    assertSame(tView, lView[TVIEW], "`LView` must be associated with `TView`!");
    assertEqual(tView.data.length, lView.length, "Expecting LView to be same size as TView");
    assertEqual(tView.data.length, tView.blueprint.length, "Expecting Blueprint to be same size as TView");
    assertFirstUpdatePass(tView);
  }
  const allocIdx = lView.length;
  for (let i = 0; i < numSlotsToAlloc; i++) {
    lView.push(initialValue);
    tView.blueprint.push(initialValue);
    tView.data.push(null);
  }
  return allocIdx;
}
function renderView(tView, lView, context2) {
  define_ngDevMode_default && assertEqual(isCreationMode(lView), true, "Should be run in creation mode");
  enterView(lView);
  try {
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(
        1,
        viewQuery,
        context2
      );
    }
    const templateFn = tView.template;
    if (templateFn !== null) {
      executeTemplate(
        tView,
        lView,
        templateFn,
        1,
        context2
      );
    }
    if (tView.firstCreatePass) {
      tView.firstCreatePass = false;
    }
    if (tView.staticContentQueries) {
      refreshContentQueries(tView, lView);
    }
    if (tView.staticViewQueries) {
      executeViewQueryFn(
        2,
        tView.viewQuery,
        context2
      );
    }
    const components = tView.components;
    if (components !== null) {
      renderChildComponents(lView, components);
    }
  } catch (error2) {
    if (tView.firstCreatePass) {
      tView.incompleteFirstPass = true;
      tView.firstCreatePass = false;
    }
    throw error2;
  } finally {
    lView[FLAGS] &= ~4;
    leaveView();
  }
}
function refreshView(tView, lView, templateFn, context2) {
  define_ngDevMode_default && assertEqual(isCreationMode(lView), false, "Should be run in update mode");
  const flags = lView[FLAGS];
  if ((flags & 128) === 128)
    return;
  enterView(lView);
  const isInCheckNoChangesPass = define_ngDevMode_default && isInCheckNoChangesMode();
  try {
    resetPreOrderHookFlags(lView);
    setBindingIndex(tView.bindingStartIndex);
    if (templateFn !== null) {
      executeTemplate(
        tView,
        lView,
        templateFn,
        2,
        context2
      );
    }
    const hooksInitPhaseCompleted = (flags & 3) === 3;
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const preOrderCheckHooks = tView.preOrderCheckHooks;
        if (preOrderCheckHooks !== null) {
          executeCheckHooks(lView, preOrderCheckHooks, null);
        }
      } else {
        const preOrderHooks = tView.preOrderHooks;
        if (preOrderHooks !== null) {
          executeInitAndCheckHooks(
            lView,
            preOrderHooks,
            0,
            null
          );
        }
        incrementInitPhaseFlags(
          lView,
          0
        );
      }
    }
    markTransplantedViewsForRefresh(lView);
    refreshEmbeddedViews(lView);
    if (tView.contentQueries !== null) {
      refreshContentQueries(tView, lView);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const contentCheckHooks = tView.contentCheckHooks;
        if (contentCheckHooks !== null) {
          executeCheckHooks(lView, contentCheckHooks);
        }
      } else {
        const contentHooks = tView.contentHooks;
        if (contentHooks !== null) {
          executeInitAndCheckHooks(
            lView,
            contentHooks,
            1
          );
        }
        incrementInitPhaseFlags(
          lView,
          1
        );
      }
    }
    processHostBindingOpCodes(tView, lView);
    const components = tView.components;
    if (components !== null) {
      refreshChildComponents(lView, components);
    }
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(
        2,
        viewQuery,
        context2
      );
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const viewCheckHooks = tView.viewCheckHooks;
        if (viewCheckHooks !== null) {
          executeCheckHooks(lView, viewCheckHooks);
        }
      } else {
        const viewHooks = tView.viewHooks;
        if (viewHooks !== null) {
          executeInitAndCheckHooks(
            lView,
            viewHooks,
            2
          );
        }
        incrementInitPhaseFlags(
          lView,
          2
        );
      }
    }
    if (tView.firstUpdatePass === true) {
      tView.firstUpdatePass = false;
    }
    if (!isInCheckNoChangesPass) {
      lView[FLAGS] &= ~(32 | 8);
    }
    if (lView[FLAGS] & 512) {
      lView[FLAGS] &= ~512;
      updateTransplantedViewCount(lView[PARENT], -1);
    }
  } finally {
    leaveView();
  }
}
function renderComponentOrTemplate(tView, lView, templateFn, context2) {
  const rendererFactory = lView[RENDERER_FACTORY];
  const checkNoChangesMode = !!define_ngDevMode_default && isInCheckNoChangesMode();
  const creationModeIsActive = isCreationMode(lView);
  try {
    if (!checkNoChangesMode && !creationModeIsActive && rendererFactory.begin) {
      rendererFactory.begin();
    }
    if (creationModeIsActive) {
      renderView(tView, lView, context2);
    }
    refreshView(tView, lView, templateFn, context2);
  } finally {
    if (!checkNoChangesMode && !creationModeIsActive && rendererFactory.end) {
      rendererFactory.end();
    }
  }
}
function executeTemplate(tView, lView, templateFn, rf, context2) {
  const prevSelectedIndex = getSelectedIndex();
  const isUpdatePhase = rf & 2;
  try {
    setSelectedIndex(-1);
    if (isUpdatePhase && lView.length > HEADER_OFFSET) {
      selectIndexInternal(tView, lView, HEADER_OFFSET, !!define_ngDevMode_default && isInCheckNoChangesMode());
    }
    const preHookType = isUpdatePhase ? 2 : 0;
    profiler(preHookType, context2);
    templateFn(rf, context2);
  } finally {
    setSelectedIndex(prevSelectedIndex);
    const postHookType = isUpdatePhase ? 3 : 1;
    profiler(postHookType, context2);
  }
}
function executeContentQueries(tView, tNode, lView) {
  if (isContentQueryHost(tNode)) {
    const start = tNode.directiveStart;
    const end = tNode.directiveEnd;
    for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {
      const def = tView.data[directiveIndex];
      if (def.contentQueries) {
        def.contentQueries(
          1,
          lView[directiveIndex],
          directiveIndex
        );
      }
    }
  }
}
function createDirectivesInstances(tView, lView, tNode) {
  if (!getBindingsEnabled())
    return;
  instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));
  if ((tNode.flags & 128) === 128) {
    invokeDirectivesHostBindings(tView, lView, tNode);
  }
}
function saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    let localIndex = tNode.index + 1;
    for (let i = 0; i < localNames.length; i += 2) {
      const index = localNames[i + 1];
      const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];
      viewData[localIndex++] = value;
    }
  }
}
function getOrCreateTComponentView(def) {
  const tView = def.tView;
  if (tView === null || tView.incompleteFirstPass) {
    const declTNode = null;
    return def.tView = createTView(
      1,
      declTNode,
      def.template,
      def.decls,
      def.vars,
      def.directiveDefs,
      def.pipeDefs,
      def.viewQuery,
      def.schemas,
      def.consts
    );
  }
  return tView;
}
function createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory) {
  define_ngDevMode_default && define_ngDevMode_default.tView++;
  const bindingStartIndex = HEADER_OFFSET + decls;
  const initialViewLength = bindingStartIndex + vars;
  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
  const consts = typeof constsOrFactory === "function" ? constsOrFactory() : constsOrFactory;
  const tView = blueprint[TVIEW] = define_ngDevMode_default ? new TViewConstructor(
    type,
    blueprint,
    templateFn,
    null,
    viewQuery,
    declTNode,
    cloneToTViewData(blueprint).fill(null, bindingStartIndex),
    bindingStartIndex,
    initialViewLength,
    null,
    true,
    true,
    false,
    false,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    typeof directives === "function" ? directives() : directives,
    typeof pipes === "function" ? pipes() : pipes,
    null,
    schemas,
    consts,
    false,
    decls,
    vars
  ) : {
    type,
    blueprint,
    template: templateFn,
    queries: null,
    viewQuery,
    declTNode,
    data: blueprint.slice().fill(null, bindingStartIndex),
    bindingStartIndex,
    expandoStartIndex: initialViewLength,
    hostBindingOpCodes: null,
    firstCreatePass: true,
    firstUpdatePass: true,
    staticViewQueries: false,
    staticContentQueries: false,
    preOrderHooks: null,
    preOrderCheckHooks: null,
    contentHooks: null,
    contentCheckHooks: null,
    viewHooks: null,
    viewCheckHooks: null,
    destroyHooks: null,
    cleanup: null,
    contentQueries: null,
    components: null,
    directiveRegistry: typeof directives === "function" ? directives() : directives,
    pipeRegistry: typeof pipes === "function" ? pipes() : pipes,
    firstChild: null,
    schemas,
    consts,
    incompleteFirstPass: false
  };
  if (define_ngDevMode_default) {
    Object.seal(tView);
  }
  return tView;
}
function createViewBlueprint(bindingStartIndex, initialViewLength) {
  const blueprint = define_ngDevMode_default ? new LViewBlueprint() : [];
  for (let i = 0; i < initialViewLength; i++) {
    blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
  }
  return blueprint;
}
function locateHostElement(renderer, elementOrSelector, encapsulation) {
  const preserveContent = encapsulation === ViewEncapsulation$1.ShadowDom;
  return renderer.selectRootElement(elementOrSelector, preserveContent);
}
function storeCleanupWithContext(tView, lView, context2, cleanupFn) {
  const lCleanup = getOrCreateLViewCleanup(lView);
  if (context2 === null) {
    if (define_ngDevMode_default) {
      Object.freeze(getOrCreateTViewCleanup(tView));
    }
    lCleanup.push(cleanupFn);
  } else {
    lCleanup.push(context2);
    if (tView.firstCreatePass) {
      getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);
    }
  }
}
function createTNode(tView, tParent, type, index, value, attrs) {
  define_ngDevMode_default && index !== 0 && assertGreaterThanOrEqual(index, HEADER_OFFSET, "TNodes can't be in the LView header.");
  define_ngDevMode_default && assertNotSame(attrs, void 0, "'undefined' is not valid value for 'attrs'");
  define_ngDevMode_default && define_ngDevMode_default.tNode++;
  define_ngDevMode_default && tParent && assertTNodeForTView(tParent, tView);
  let injectorIndex = tParent ? tParent.injectorIndex : -1;
  const tNode = define_ngDevMode_default ? new TNodeDebug(
    tView,
    type,
    index,
    null,
    injectorIndex,
    -1,
    -1,
    -1,
    null,
    0,
    0,
    value,
    attrs,
    null,
    null,
    void 0,
    null,
    null,
    null,
    null,
    null,
    null,
    tParent,
    null,
    null,
    null,
    void 0,
    null,
    null,
    void 0,
    0,
    0
  ) : {
    type,
    index,
    insertBeforeIndex: null,
    injectorIndex,
    directiveStart: -1,
    directiveEnd: -1,
    directiveStylingLast: -1,
    propertyBindings: null,
    flags: 0,
    providerIndexes: 0,
    value,
    attrs,
    mergedAttrs: null,
    localNames: null,
    initialInputs: void 0,
    inputs: null,
    outputs: null,
    tViews: null,
    next: null,
    projectionNext: null,
    child: null,
    parent: tParent,
    projection: null,
    styles: null,
    stylesWithoutHost: null,
    residualStyles: void 0,
    classes: null,
    classesWithoutHost: null,
    residualClasses: void 0,
    classBindings: 0,
    styleBindings: 0
  };
  if (define_ngDevMode_default) {
    Object.seal(tNode);
  }
  return tNode;
}
function generatePropertyAliases(inputAliasMap, directiveDefIdx, propStore) {
  for (let publicName in inputAliasMap) {
    if (inputAliasMap.hasOwnProperty(publicName)) {
      propStore = propStore === null ? {} : propStore;
      const internalName = inputAliasMap[publicName];
      if (propStore.hasOwnProperty(publicName)) {
        propStore[publicName].push(directiveDefIdx, internalName);
      } else {
        propStore[publicName] = [directiveDefIdx, internalName];
      }
    }
  }
  return propStore;
}
function initializeInputAndOutputAliases(tView, tNode) {
  define_ngDevMode_default && assertFirstCreatePass(tView);
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  const tViewData = tView.data;
  const tNodeAttrs = tNode.attrs;
  const inputsFromAttrs = define_ngDevMode_default ? new TNodeInitialInputs() : [];
  let inputsStore = null;
  let outputsStore = null;
  for (let i = start; i < end; i++) {
    const directiveDef = tViewData[i];
    const directiveInputs = directiveDef.inputs;
    const initialInputs = tNodeAttrs !== null && !isInlineTemplate(tNode) ? generateInitialInputs(directiveInputs, tNodeAttrs) : null;
    inputsFromAttrs.push(initialInputs);
    inputsStore = generatePropertyAliases(directiveInputs, i, inputsStore);
    outputsStore = generatePropertyAliases(directiveDef.outputs, i, outputsStore);
  }
  if (inputsStore !== null) {
    if (inputsStore.hasOwnProperty("class")) {
      tNode.flags |= 16;
    }
    if (inputsStore.hasOwnProperty("style")) {
      tNode.flags |= 32;
    }
  }
  tNode.initialInputs = inputsFromAttrs;
  tNode.inputs = inputsStore;
  tNode.outputs = outputsStore;
}
function mapPropName(name) {
  if (name === "class")
    return "className";
  if (name === "for")
    return "htmlFor";
  if (name === "formaction")
    return "formAction";
  if (name === "innerHtml")
    return "innerHTML";
  if (name === "readonly")
    return "readOnly";
  if (name === "tabindex")
    return "tabIndex";
  return name;
}
function elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, nativeOnly) {
  define_ngDevMode_default && assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
  const element = getNativeByTNode(tNode, lView);
  let inputData = tNode.inputs;
  let dataValue;
  if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {
    setInputsForProperty(tView, lView, dataValue, propName, value);
    if (isComponentHost(tNode))
      markDirtyIfOnPush(lView, tNode.index);
    if (define_ngDevMode_default) {
      setNgReflectProperties(lView, element, tNode.type, dataValue, value);
    }
  } else if (tNode.type & 3) {
    propName = mapPropName(propName);
    if (define_ngDevMode_default) {
      validateAgainstEventProperties(propName);
      if (!isPropertyValid(element, propName, tNode.value, tView.schemas)) {
        handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
      }
      define_ngDevMode_default.rendererSetProperty++;
    }
    value = sanitizer != null ? sanitizer(value, tNode.value || "", propName) : value;
    renderer.setProperty(element, propName, value);
  } else if (tNode.type & 12) {
    if (define_ngDevMode_default && !matchingSchemas(tView.schemas, tNode.value)) {
      handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
    }
  }
}
function markDirtyIfOnPush(lView, viewIndex) {
  define_ngDevMode_default && assertLView(lView);
  const childComponentLView = getComponentLViewByIndex(viewIndex, lView);
  if (!(childComponentLView[FLAGS] & 16)) {
    childComponentLView[FLAGS] |= 32;
  }
}
function setNgReflectProperty(lView, element, type, attrName, value) {
  const renderer = lView[RENDERER];
  attrName = normalizeDebugBindingName(attrName);
  const debugValue = normalizeDebugBindingValue(value);
  if (type & 3) {
    if (value == null) {
      renderer.removeAttribute(element, attrName);
    } else {
      renderer.setAttribute(element, attrName, debugValue);
    }
  } else {
    const textContent = escapeCommentText(`bindings=${JSON.stringify({
      [attrName]: debugValue
    }, null, 2)}`);
    renderer.setValue(element, textContent);
  }
}
function setNgReflectProperties(lView, element, type, dataValue, value) {
  if (type & (3 | 4)) {
    for (let i = 0; i < dataValue.length; i += 2) {
      setNgReflectProperty(lView, element, type, dataValue[i + 1], value);
    }
  }
}
function instantiateRootComponent(tView, lView, def) {
  const rootTNode = getCurrentTNode();
  if (tView.firstCreatePass) {
    if (def.providersResolver)
      def.providersResolver(def);
    const directiveIndex = allocExpando(tView, lView, 1, null);
    define_ngDevMode_default && assertEqual(directiveIndex, rootTNode.directiveStart, "Because this is a root component the allocated expando should match the TNode component.");
    configureViewWithDirective(tView, rootTNode, lView, directiveIndex, def);
    initializeInputAndOutputAliases(tView, rootTNode);
  }
  const directive = getNodeInjectable(lView, tView, rootTNode.directiveStart, rootTNode);
  attachPatchData(directive, lView);
  const native = getNativeByTNode(rootTNode, lView);
  if (native) {
    attachPatchData(native, lView);
  }
  return directive;
}
function resolveDirectives(tView, lView, tNode, localRefs) {
  define_ngDevMode_default && assertFirstCreatePass(tView);
  let hasDirectives = false;
  if (getBindingsEnabled()) {
    const directiveDefs = findDirectiveDefMatches(tView, lView, tNode);
    const exportsMap = localRefs === null ? null : {
      "": -1
    };
    if (directiveDefs !== null) {
      hasDirectives = true;
      initTNodeFlags(tNode, tView.data.length, directiveDefs.length);
      for (let i = 0; i < directiveDefs.length; i++) {
        const def = directiveDefs[i];
        if (def.providersResolver)
          def.providersResolver(def);
      }
      let preOrderHooksFound = false;
      let preOrderCheckHooksFound = false;
      let directiveIdx = allocExpando(tView, lView, directiveDefs.length, null);
      define_ngDevMode_default && assertSame(directiveIdx, tNode.directiveStart, "TNode.directiveStart should point to just allocated space");
      for (let i = 0; i < directiveDefs.length; i++) {
        const def = directiveDefs[i];
        tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
        configureViewWithDirective(tView, tNode, lView, directiveIdx, def);
        saveNameToExportMap(directiveIdx, def, exportsMap);
        if (def.contentQueries !== null)
          tNode.flags |= 8;
        if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0)
          tNode.flags |= 128;
        const lifeCycleHooks = def.type.prototype;
        if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {
          (tView.preOrderHooks || (tView.preOrderHooks = [])).push(tNode.index);
          preOrderHooksFound = true;
        }
        if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {
          (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(tNode.index);
          preOrderCheckHooksFound = true;
        }
        directiveIdx++;
      }
      initializeInputAndOutputAliases(tView, tNode);
    }
    if (exportsMap)
      cacheMatchingLocalNames(tNode, localRefs, exportsMap);
  }
  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
  return hasDirectives;
}
function registerHostBindingOpCodes(tView, tNode, lView, directiveIdx, directiveVarsIdx, def) {
  define_ngDevMode_default && assertFirstCreatePass(tView);
  const hostBindings = def.hostBindings;
  if (hostBindings) {
    let hostBindingOpCodes = tView.hostBindingOpCodes;
    if (hostBindingOpCodes === null) {
      hostBindingOpCodes = tView.hostBindingOpCodes = [];
    }
    const elementIndx = ~tNode.index;
    if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {
      hostBindingOpCodes.push(elementIndx);
    }
    hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);
  }
}
function lastSelectedElementIdx(hostBindingOpCodes) {
  let i = hostBindingOpCodes.length;
  while (i > 0) {
    const value = hostBindingOpCodes[--i];
    if (typeof value === "number" && value < 0) {
      return value;
    }
  }
  return 0;
}
function instantiateAllDirectives(tView, lView, tNode, native) {
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  if (!tView.firstCreatePass) {
    getOrCreateNodeInjectorForNode(tNode, lView);
  }
  attachPatchData(native, lView);
  const initialInputs = tNode.initialInputs;
  for (let i = start; i < end; i++) {
    const def = tView.data[i];
    const isComponent = isComponentDef(def);
    if (isComponent) {
      define_ngDevMode_default && assertTNodeType(
        tNode,
        3
      );
      addComponentLogic(lView, tNode, def);
    }
    const directive = getNodeInjectable(lView, tView, i, tNode);
    attachPatchData(directive, lView);
    if (initialInputs !== null) {
      setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);
    }
    if (isComponent) {
      const componentView = getComponentLViewByIndex(tNode.index, lView);
      componentView[CONTEXT] = directive;
    }
  }
}
function invokeDirectivesHostBindings(tView, lView, tNode) {
  const start = tNode.directiveStart;
  const end = tNode.directiveEnd;
  const elementIndex = tNode.index;
  const currentDirectiveIndex = getCurrentDirectiveIndex();
  try {
    setSelectedIndex(elementIndex);
    for (let dirIndex = start; dirIndex < end; dirIndex++) {
      const def = tView.data[dirIndex];
      const directive = lView[dirIndex];
      setCurrentDirectiveIndex(dirIndex);
      if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {
        invokeHostBindingsInCreationMode(def, directive);
      }
    }
  } finally {
    setSelectedIndex(-1);
    setCurrentDirectiveIndex(currentDirectiveIndex);
  }
}
function invokeHostBindingsInCreationMode(def, directive) {
  if (def.hostBindings !== null) {
    def.hostBindings(
      1,
      directive
    );
  }
}
function findDirectiveDefMatches(tView, viewData, tNode) {
  define_ngDevMode_default && assertFirstCreatePass(tView);
  define_ngDevMode_default && assertTNodeType(
    tNode,
    3 | 12
  );
  const registry = tView.directiveRegistry;
  let matches = null;
  if (registry) {
    for (let i = 0; i < registry.length; i++) {
      const def = registry[i];
      if (isNodeMatchingSelectorList(
        tNode,
        def.selectors,
        false
      )) {
        matches || (matches = define_ngDevMode_default ? new MatchesArray() : []);
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, viewData), tView, def.type);
        if (isComponentDef(def)) {
          if (define_ngDevMode_default) {
            assertTNodeType(
              tNode,
              2,
              `"${tNode.value}" tags cannot be used as component hosts. Please use a different tag to activate the ${stringify(def.type)} component.`
            );
            if (tNode.flags & 2) {
              throwMultipleComponentError(tNode, matches[0].type, def.type);
            }
          }
          markAsComponentHost(tView, tNode);
          matches.unshift(def);
        } else {
          matches.push(def);
        }
      }
    }
  }
  return matches;
}
function markAsComponentHost(tView, hostTNode) {
  define_ngDevMode_default && assertFirstCreatePass(tView);
  hostTNode.flags |= 2;
  (tView.components || (tView.components = define_ngDevMode_default ? new TViewComponents() : [])).push(hostTNode.index);
}
function cacheMatchingLocalNames(tNode, localRefs, exportsMap) {
  if (localRefs) {
    const localNames = tNode.localNames = define_ngDevMode_default ? new TNodeLocalNames() : [];
    for (let i = 0; i < localRefs.length; i += 2) {
      const index = exportsMap[localRefs[i + 1]];
      if (index == null)
        throw new RuntimeError(
          -301,
          define_ngDevMode_default && `Export of name '${localRefs[i + 1]}' not found!`
        );
      localNames.push(localRefs[i], index);
    }
  }
}
function saveNameToExportMap(directiveIdx, def, exportsMap) {
  if (exportsMap) {
    if (def.exportAs) {
      for (let i = 0; i < def.exportAs.length; i++) {
        exportsMap[def.exportAs[i]] = directiveIdx;
      }
    }
    if (isComponentDef(def))
      exportsMap[""] = directiveIdx;
  }
}
function initTNodeFlags(tNode, index, numberOfDirectives) {
  define_ngDevMode_default && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, "Reached the max number of directives");
  tNode.flags |= 1;
  tNode.directiveStart = index;
  tNode.directiveEnd = index + numberOfDirectives;
  tNode.providerIndexes = index;
}
function configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {
  define_ngDevMode_default && assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, "Must be in Expando section");
  tView.data[directiveIndex] = def;
  const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));
  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), \u0275\u0275directiveInject);
  tView.blueprint[directiveIndex] = nodeInjectorFactory;
  lView[directiveIndex] = nodeInjectorFactory;
  registerHostBindingOpCodes(tView, tNode, lView, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);
}
function addComponentLogic(lView, hostTNode, def) {
  const native = getNativeByTNode(hostTNode, lView);
  const tView = getOrCreateTComponentView(def);
  const rendererFactory = lView[RENDERER_FACTORY];
  const componentView = addToViewTree(lView, createLView(
    lView,
    tView,
    null,
    def.onPush ? 32 : 16,
    native,
    hostTNode,
    rendererFactory,
    rendererFactory.createRenderer(native, def),
    null,
    null,
    null
  ));
  lView[hostTNode.index] = componentView;
}
function elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {
  if (define_ngDevMode_default) {
    assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
    validateAgainstEventAttributes(name);
    assertTNodeType(
      tNode,
      2,
      `Attempted to set attribute \`${name}\` on a container node. Host bindings are not valid on ng-container or ng-template.`
    );
  }
  const element = getNativeByTNode(tNode, lView);
  setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);
}
function setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {
  if (value == null) {
    define_ngDevMode_default && define_ngDevMode_default.rendererRemoveAttribute++;
    renderer.removeAttribute(element, name, namespace);
  } else {
    define_ngDevMode_default && define_ngDevMode_default.rendererSetAttribute++;
    const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || "", name);
    renderer.setAttribute(element, name, strValue, namespace);
  }
}
function setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {
  const initialInputs = initialInputData[directiveIndex];
  if (initialInputs !== null) {
    const setInput = def.setInput;
    for (let i = 0; i < initialInputs.length; ) {
      const publicName = initialInputs[i++];
      const privateName = initialInputs[i++];
      const value = initialInputs[i++];
      if (setInput !== null) {
        def.setInput(instance, value, publicName, privateName);
      } else {
        instance[privateName] = value;
      }
      if (define_ngDevMode_default) {
        const nativeElement = getNativeByTNode(tNode, lView);
        setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);
      }
    }
  }
}
function generateInitialInputs(inputs, attrs) {
  let inputsToStore = null;
  let i = 0;
  while (i < attrs.length) {
    const attrName = attrs[i];
    if (attrName === 0) {
      i += 4;
      continue;
    } else if (attrName === 5) {
      i += 2;
      continue;
    }
    if (typeof attrName === "number")
      break;
    if (inputs.hasOwnProperty(attrName)) {
      if (inputsToStore === null)
        inputsToStore = [];
      inputsToStore.push(attrName, inputs[attrName], attrs[i + 1]);
    }
    i += 2;
  }
  return inputsToStore;
}
function createLContainer(hostNative, currentView, native, tNode) {
  define_ngDevMode_default && assertLView(currentView);
  const lContainer = new (define_ngDevMode_default ? LContainerArray : Array)(
    hostNative,
    true,
    false,
    currentView,
    null,
    0,
    tNode,
    native,
    null,
    null
  );
  define_ngDevMode_default && assertEqual(lContainer.length, CONTAINER_HEADER_OFFSET, "Should allocate correct number of slots for LContainer header.");
  define_ngDevMode_default && attachLContainerDebug(lContainer);
  return lContainer;
}
function refreshEmbeddedViews(lView) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
      const embeddedLView = lContainer[i];
      const embeddedTView = embeddedLView[TVIEW];
      define_ngDevMode_default && assertDefined(embeddedTView, "TView must be allocated");
      if (viewAttachedToChangeDetector(embeddedLView)) {
        refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);
      }
    }
  }
}
function markTransplantedViewsForRefresh(lView) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    if (!lContainer[HAS_TRANSPLANTED_VIEWS])
      continue;
    const movedViews = lContainer[MOVED_VIEWS];
    define_ngDevMode_default && assertDefined(movedViews, "Transplanted View flags set but missing MOVED_VIEWS");
    for (let i = 0; i < movedViews.length; i++) {
      const movedLView = movedViews[i];
      const insertionLContainer = movedLView[PARENT];
      define_ngDevMode_default && assertLContainer(insertionLContainer);
      if ((movedLView[FLAGS] & 512) === 0) {
        updateTransplantedViewCount(insertionLContainer, 1);
      }
      movedLView[FLAGS] |= 512;
    }
  }
}
function refreshComponent(hostLView, componentHostIdx) {
  define_ngDevMode_default && assertEqual(isCreationMode(hostLView), false, "Should be run in update mode");
  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
  if (viewAttachedToChangeDetector(componentView)) {
    const tView = componentView[TVIEW];
    if (componentView[FLAGS] & (16 | 32)) {
      refreshView(tView, componentView, tView.template, componentView[CONTEXT]);
    } else if (componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {
      refreshContainsDirtyView(componentView);
    }
  }
}
function refreshContainsDirtyView(lView) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
      const embeddedLView = lContainer[i];
      if (embeddedLView[FLAGS] & 512) {
        const embeddedTView = embeddedLView[TVIEW];
        define_ngDevMode_default && assertDefined(embeddedTView, "TView must be allocated");
        refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);
      } else if (embeddedLView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {
        refreshContainsDirtyView(embeddedLView);
      }
    }
  }
  const tView = lView[TVIEW];
  const components = tView.components;
  if (components !== null) {
    for (let i = 0; i < components.length; i++) {
      const componentView = getComponentLViewByIndex(components[i], lView);
      if (viewAttachedToChangeDetector(componentView) && componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {
        refreshContainsDirtyView(componentView);
      }
    }
  }
}
function renderComponent(hostLView, componentHostIdx) {
  define_ngDevMode_default && assertEqual(isCreationMode(hostLView), true, "Should be run in creation mode");
  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
  const componentTView = componentView[TVIEW];
  syncViewWithBlueprint(componentTView, componentView);
  renderView(componentTView, componentView, componentView[CONTEXT]);
}
function syncViewWithBlueprint(tView, lView) {
  for (let i = lView.length; i < tView.blueprint.length; i++) {
    lView.push(tView.blueprint[i]);
  }
}
function addToViewTree(lView, lViewOrLContainer) {
  if (lView[CHILD_HEAD]) {
    lView[CHILD_TAIL][NEXT] = lViewOrLContainer;
  } else {
    lView[CHILD_HEAD] = lViewOrLContainer;
  }
  lView[CHILD_TAIL] = lViewOrLContainer;
  return lViewOrLContainer;
}
function markViewDirty(lView) {
  while (lView) {
    lView[FLAGS] |= 32;
    const parent = getLViewParent(lView);
    if (isRootView(lView) && !parent) {
      return lView;
    }
    lView = parent;
  }
  return null;
}
function scheduleTick(rootContext, flags) {
  const nothingScheduled = rootContext.flags === 0;
  if (nothingScheduled && rootContext.clean == _CLEAN_PROMISE) {
    rootContext.flags |= flags;
    let res;
    rootContext.clean = new Promise((r) => res = r);
    rootContext.scheduler(() => {
      if (rootContext.flags & 1) {
        rootContext.flags &= ~1;
        tickRootContext(rootContext);
      }
      if (rootContext.flags & 2) {
        rootContext.flags &= ~2;
        const playerHandler = rootContext.playerHandler;
        if (playerHandler) {
          playerHandler.flushPlayers();
        }
      }
      rootContext.clean = _CLEAN_PROMISE;
      res(null);
    });
  }
}
function tickRootContext(rootContext) {
  for (let i = 0; i < rootContext.components.length; i++) {
    const rootComponent = rootContext.components[i];
    const lView = readPatchedLView(rootComponent);
    if (lView !== null) {
      const tView = lView[TVIEW];
      renderComponentOrTemplate(tView, lView, tView.template, rootComponent);
    }
  }
}
function detectChangesInternal(tView, lView, context2) {
  const rendererFactory = lView[RENDERER_FACTORY];
  if (rendererFactory.begin)
    rendererFactory.begin();
  try {
    refreshView(tView, lView, tView.template, context2);
  } catch (error2) {
    handleError(lView, error2);
    throw error2;
  } finally {
    if (rendererFactory.end)
      rendererFactory.end();
  }
}
function detectChangesInRootView(lView) {
  tickRootContext(lView[CONTEXT]);
}
function checkNoChangesInternal(tView, view, context2) {
  setIsInCheckNoChangesMode(true);
  try {
    detectChangesInternal(tView, view, context2);
  } finally {
    setIsInCheckNoChangesMode(false);
  }
}
function checkNoChangesInRootView(lView) {
  setIsInCheckNoChangesMode(true);
  try {
    detectChangesInRootView(lView);
  } finally {
    setIsInCheckNoChangesMode(false);
  }
}
function executeViewQueryFn(flags, viewQueryFn, component) {
  define_ngDevMode_default && assertDefined(viewQueryFn, "View queries function to execute must be defined.");
  setCurrentQueryIndex(0);
  viewQueryFn(flags, component);
}
function storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {
  if (tData[bindingIndex] === null) {
    if (tNode.inputs == null || !tNode.inputs[propertyName]) {
      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);
      propBindingIdxs.push(bindingIndex);
      let bindingMetadata = propertyName;
      if (interpolationParts.length > 0) {
        bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);
      }
      tData[bindingIndex] = bindingMetadata;
    }
  }
}
function getOrCreateLViewCleanup(view) {
  return view[CLEANUP] || (view[CLEANUP] = define_ngDevMode_default ? new LCleanup() : []);
}
function getOrCreateTViewCleanup(tView) {
  return tView.cleanup || (tView.cleanup = define_ngDevMode_default ? new TCleanup() : []);
}
function loadComponentRenderer(currentDef, tNode, lView) {
  if (currentDef === null || isComponentDef(currentDef)) {
    lView = unwrapLView(lView[tNode.index]);
  }
  return lView[RENDERER];
}
function handleError(lView, error2) {
  const injector = lView[INJECTOR$1];
  const errorHandler2 = injector ? injector.get(ErrorHandler, null) : null;
  errorHandler2 && errorHandler2.handleError(error2);
}
function setInputsForProperty(tView, lView, inputs, publicName, value) {
  for (let i = 0; i < inputs.length; ) {
    const index = inputs[i++];
    const privateName = inputs[i++];
    const instance = lView[index];
    define_ngDevMode_default && assertIndexInRange(lView, index);
    const def = tView.data[index];
    if (def.setInput !== null) {
      def.setInput(instance, value, publicName, privateName);
    } else {
      instance[privateName] = value;
    }
  }
}
function textBindingInternal(lView, index, value) {
  define_ngDevMode_default && assertString(value, "Value should be a string");
  define_ngDevMode_default && assertNotSame(value, NO_CHANGE, "value should not be NO_CHANGE");
  define_ngDevMode_default && assertIndexInRange(lView, index);
  const element = getNativeByIndex(index, lView);
  define_ngDevMode_default && assertDefined(element, "native element should exist");
  updateTextNode(lView[RENDERER], element, value);
}
function computeStaticStyling(tNode, attrs, writeToHost) {
  define_ngDevMode_default && assertFirstCreatePass(getTView(), "Expecting to be called in first template pass only");
  let styles = writeToHost ? tNode.styles : null;
  let classes = writeToHost ? tNode.classes : null;
  let mode = 0;
  if (attrs !== null) {
    for (let i = 0; i < attrs.length; i++) {
      const value = attrs[i];
      if (typeof value === "number") {
        mode = value;
      } else if (mode == 1) {
        classes = concatStringsWithSpace(classes, value);
      } else if (mode == 2) {
        const style = value;
        const styleValue = attrs[++i];
        styles = concatStringsWithSpace(styles, style + ": " + styleValue + ";");
      }
    }
  }
  writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;
  writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;
}
function collectNativeNodes(tView, lView, tNode, result, isProjection = false) {
  while (tNode !== null) {
    define_ngDevMode_default && assertTNodeType(
      tNode,
      3 | 12 | 16 | 32
    );
    const lNode = lView[tNode.index];
    if (lNode !== null) {
      result.push(unwrapRNode(lNode));
    }
    if (isLContainer(lNode)) {
      for (let i = CONTAINER_HEADER_OFFSET; i < lNode.length; i++) {
        const lViewInAContainer = lNode[i];
        const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;
        if (lViewFirstChildTNode !== null) {
          collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);
        }
      }
    }
    const tNodeType = tNode.type;
    if (tNodeType & 8) {
      collectNativeNodes(tView, lView, tNode.child, result);
    } else if (tNodeType & 32) {
      const nextRNode = icuContainerIterate(tNode, lView);
      let rNode;
      while (rNode = nextRNode()) {
        result.push(rNode);
      }
    } else if (tNodeType & 16) {
      const nodesInSlot = getProjectionNodes(lView, tNode);
      if (Array.isArray(nodesInSlot)) {
        result.push(...nodesInSlot);
      } else {
        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
        define_ngDevMode_default && assertParentView(parentView);
        collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
  return result;
}
function toRefArray(map2) {
  const array = [];
  for (let nonMinified in map2) {
    if (map2.hasOwnProperty(nonMinified)) {
      const minified = map2[nonMinified];
      array.push({
        propName: minified,
        templateName: nonMinified
      });
    }
  }
  return array;
}
function getNamespace(elementName) {
  const name = elementName.toLowerCase();
  return name === "svg" ? SVG_NAMESPACE : name === "math" ? MATH_ML_NAMESPACE : null;
}
function createRootComponentView(rNode, def, rootView, rendererFactory, hostRenderer, sanitizer) {
  const tView = rootView[TVIEW];
  const index = HEADER_OFFSET;
  define_ngDevMode_default && assertIndexInRange(rootView, index);
  rootView[index] = rNode;
  const tNode = getOrCreateTNode(
    tView,
    index,
    2,
    "#host",
    null
  );
  const mergedAttrs = tNode.mergedAttrs = def.hostAttrs;
  if (mergedAttrs !== null) {
    computeStaticStyling(tNode, mergedAttrs, true);
    if (rNode !== null) {
      setUpAttributes(hostRenderer, rNode, mergedAttrs);
      if (tNode.classes !== null) {
        writeDirectClass(hostRenderer, rNode, tNode.classes);
      }
      if (tNode.styles !== null) {
        writeDirectStyle(hostRenderer, rNode, tNode.styles);
      }
    }
  }
  const viewRenderer = rendererFactory.createRenderer(rNode, def);
  const componentView = createLView(
    rootView,
    getOrCreateTComponentView(def),
    null,
    def.onPush ? 32 : 16,
    rootView[index],
    tNode,
    rendererFactory,
    viewRenderer,
    sanitizer || null,
    null,
    null
  );
  if (tView.firstCreatePass) {
    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), tView, def.type);
    markAsComponentHost(tView, tNode);
    initTNodeFlags(tNode, rootView.length, 1);
  }
  addToViewTree(rootView, componentView);
  return rootView[index] = componentView;
}
function createRootComponent(componentView, componentDef, rootLView, rootContext, hostFeatures) {
  const tView = rootLView[TVIEW];
  const component = instantiateRootComponent(tView, rootLView, componentDef);
  rootContext.components.push(component);
  componentView[CONTEXT] = component;
  if (hostFeatures !== null) {
    for (const feature of hostFeatures) {
      feature(component, componentDef);
    }
  }
  if (componentDef.contentQueries) {
    const tNode = getCurrentTNode();
    define_ngDevMode_default && assertDefined(tNode, "TNode expected");
    componentDef.contentQueries(
      1,
      component,
      tNode.directiveStart
    );
  }
  const rootTNode = getCurrentTNode();
  define_ngDevMode_default && assertDefined(rootTNode, "tNode should have been already created");
  if (tView.firstCreatePass && (componentDef.hostBindings !== null || componentDef.hostAttrs !== null)) {
    setSelectedIndex(rootTNode.index);
    const rootTView = rootLView[TVIEW];
    registerHostBindingOpCodes(rootTView, rootTNode, rootLView, rootTNode.directiveStart, rootTNode.directiveEnd, componentDef);
    invokeHostBindingsInCreationMode(componentDef, component);
  }
  return component;
}
function createRootContext(scheduler, playerHandler) {
  return {
    components: [],
    scheduler: scheduler || defaultScheduler,
    clean: CLEAN_PROMISE,
    playerHandler: playerHandler || null,
    flags: 0
  };
}
function LifecycleHooksFeature() {
  const tNode = getCurrentTNode();
  define_ngDevMode_default && assertDefined(tNode, "TNode is required");
  registerPostOrderHooks(getLView()[TVIEW], tNode);
}
function whenRendered(component) {
  return getRootContext(component).clean;
}
function getSuperType(type) {
  return Object.getPrototypeOf(type.prototype).constructor;
}
function \u0275\u0275InheritDefinitionFeature(definition) {
  let superType = getSuperType(definition.type);
  let shouldInheritFields = true;
  const inheritanceChain = [definition];
  while (superType) {
    let superDef = void 0;
    if (isComponentDef(definition)) {
      superDef = superType.\u0275cmp || superType.\u0275dir;
    } else {
      if (superType.\u0275cmp) {
        throw new RuntimeError(
          903,
          define_ngDevMode_default && `Directives cannot inherit Components. Directive ${stringifyForError(definition.type)} is attempting to extend component ${stringifyForError(superType)}`
        );
      }
      superDef = superType.\u0275dir;
    }
    if (superDef) {
      if (shouldInheritFields) {
        inheritanceChain.push(superDef);
        const writeableDef = definition;
        writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);
        writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);
        writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
        const superHostBindings = superDef.hostBindings;
        superHostBindings && inheritHostBindings(definition, superHostBindings);
        const superViewQuery = superDef.viewQuery;
        const superContentQueries = superDef.contentQueries;
        superViewQuery && inheritViewQuery(definition, superViewQuery);
        superContentQueries && inheritContentQueries(definition, superContentQueries);
        fillProperties(definition.inputs, superDef.inputs);
        fillProperties(definition.declaredInputs, superDef.declaredInputs);
        fillProperties(definition.outputs, superDef.outputs);
        if (isComponentDef(superDef) && superDef.data.animation) {
          const defData = definition.data;
          defData.animation = (defData.animation || []).concat(superDef.data.animation);
        }
      }
      const features = superDef.features;
      if (features) {
        for (let i = 0; i < features.length; i++) {
          const feature = features[i];
          if (feature && feature.ngInherit) {
            feature(definition);
          }
          if (feature === \u0275\u0275InheritDefinitionFeature) {
            shouldInheritFields = false;
          }
        }
      }
    }
    superType = Object.getPrototypeOf(superType);
  }
  mergeHostAttrsAcrossInheritance(inheritanceChain);
}
function mergeHostAttrsAcrossInheritance(inheritanceChain) {
  let hostVars = 0;
  let hostAttrs = null;
  for (let i = inheritanceChain.length - 1; i >= 0; i--) {
    const def = inheritanceChain[i];
    def.hostVars = hostVars += def.hostVars;
    def.hostAttrs = mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));
  }
}
function maybeUnwrapEmpty(value) {
  if (value === EMPTY_OBJ) {
    return {};
  } else if (value === EMPTY_ARRAY) {
    return [];
  } else {
    return value;
  }
}
function inheritViewQuery(definition, superViewQuery) {
  const prevViewQuery = definition.viewQuery;
  if (prevViewQuery) {
    definition.viewQuery = (rf, ctx) => {
      superViewQuery(rf, ctx);
      prevViewQuery(rf, ctx);
    };
  } else {
    definition.viewQuery = superViewQuery;
  }
}
function inheritContentQueries(definition, superContentQueries) {
  const prevContentQueries = definition.contentQueries;
  if (prevContentQueries) {
    definition.contentQueries = (rf, ctx, directiveIndex) => {
      superContentQueries(rf, ctx, directiveIndex);
      prevContentQueries(rf, ctx, directiveIndex);
    };
  } else {
    definition.contentQueries = superContentQueries;
  }
}
function inheritHostBindings(definition, superHostBindings) {
  const prevHostBindings = definition.hostBindings;
  if (prevHostBindings) {
    definition.hostBindings = (rf, ctx) => {
      superHostBindings(rf, ctx);
      prevHostBindings(rf, ctx);
    };
  } else {
    definition.hostBindings = superHostBindings;
  }
}
function \u0275\u0275CopyDefinitionFeature(definition) {
  let superType = getSuperType(definition.type);
  let superDef = void 0;
  if (isComponentDef(definition)) {
    superDef = superType.\u0275cmp;
  } else {
    superDef = superType.\u0275dir;
  }
  const defAny = definition;
  for (const field of COPY_DIRECTIVE_FIELDS) {
    defAny[field] = superDef[field];
  }
  if (isComponentDef(superDef)) {
    for (const field of COPY_COMPONENT_FIELDS) {
      defAny[field] = superDef[field];
    }
  }
}
function getSymbolIterator2() {
  if (!_symbolIterator) {
    const Symbol2 = _global["Symbol"];
    if (Symbol2 && Symbol2.iterator) {
      _symbolIterator = Symbol2.iterator;
    } else {
      const keys = Object.getOwnPropertyNames(Map.prototype);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key !== "entries" && key !== "size" && Map.prototype[key] === Map.prototype["entries"]) {
          _symbolIterator = key;
        }
      }
    }
  }
  return _symbolIterator;
}
function isListLikeIterable(obj) {
  if (!isJsObject(obj))
    return false;
  return Array.isArray(obj) || !(obj instanceof Map) && getSymbolIterator2() in obj;
}
function areIterablesEqual(a, b, comparator) {
  const iterator1 = a[getSymbolIterator2()]();
  const iterator2 = b[getSymbolIterator2()]();
  while (true) {
    const item1 = iterator1.next();
    const item2 = iterator2.next();
    if (item1.done && item2.done)
      return true;
    if (item1.done || item2.done)
      return false;
    if (!comparator(item1.value, item2.value))
      return false;
  }
}
function iterateListLike(obj, fn2) {
  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      fn2(obj[i]);
    }
  } else {
    const iterator2 = obj[getSymbolIterator2()]();
    let item;
    while (!(item = iterator2.next()).done) {
      fn2(item.value);
    }
  }
}
function isJsObject(o) {
  return o !== null && (typeof o === "function" || typeof o === "object");
}
function devModeEqual(a, b) {
  const isListLikeIterableA = isListLikeIterable(a);
  const isListLikeIterableB = isListLikeIterable(b);
  if (isListLikeIterableA && isListLikeIterableB) {
    return areIterablesEqual(a, b, devModeEqual);
  } else {
    const isAObject = a && (typeof a === "object" || typeof a === "function");
    const isBObject = b && (typeof b === "object" || typeof b === "function");
    if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
      return true;
    } else {
      return Object.is(a, b);
    }
  }
}
function updateBinding(lView, bindingIndex, value) {
  return lView[bindingIndex] = value;
}
function getBinding(lView, bindingIndex) {
  define_ngDevMode_default && assertIndexInRange(lView, bindingIndex);
  define_ngDevMode_default && assertNotSame(lView[bindingIndex], NO_CHANGE, "Stored value should never be NO_CHANGE.");
  return lView[bindingIndex];
}
function bindingUpdated(lView, bindingIndex, value) {
  define_ngDevMode_default && assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
  define_ngDevMode_default && assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);
  const oldValue = lView[bindingIndex];
  if (Object.is(oldValue, value)) {
    return false;
  } else {
    if (define_ngDevMode_default && isInCheckNoChangesMode()) {
      const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : void 0;
      if (!devModeEqual(oldValueToCompare, value)) {
        const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);
        throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName);
      }
      return false;
    }
    lView[bindingIndex] = value;
    return true;
  }
}
function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
  const different = bindingUpdated(lView, bindingIndex, exp1);
  return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
}
function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated(lView, bindingIndex + 2, exp3) || different;
}
function bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;
}
function \u0275\u0275attribute(name, value, sanitizer, namespace) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);
    define_ngDevMode_default && storePropertyBindingMetadata(tView.data, tNode, "attr." + name, bindingIndex);
  }
  return \u0275\u0275attribute;
}
function interpolationV(lView, values) {
  define_ngDevMode_default && assertLessThan(2, values.length, "should have at least 3 values");
  define_ngDevMode_default && assertEqual(values.length % 2, 1, "should have an odd number of values");
  let isBindingUpdated = false;
  let bindingIndex = getBindingIndex();
  for (let i = 1; i < values.length; i += 2) {
    isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;
  }
  setBindingIndex(bindingIndex);
  if (!isBindingUpdated) {
    return NO_CHANGE;
  }
  let content = values[0];
  for (let i = 1; i < values.length; i += 2) {
    content += renderStringify(values[i]) + values[i + 1];
  }
  return content;
}
function interpolation1(lView, prefix, v0, suffix) {
  const different = bindingUpdated(lView, nextBindingIndex(), v0);
  return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;
}
function interpolation2(lView, prefix, v0, i0, v1, suffix) {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated2(lView, bindingIndex, v0, v1);
  incrementBindingIndex(2);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;
}
function interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix) {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);
  incrementBindingIndex(3);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix : NO_CHANGE;
}
function interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  incrementBindingIndex(4);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + suffix : NO_CHANGE;
}
function interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;
  incrementBindingIndex(5);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix : NO_CHANGE;
}
function interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;
  incrementBindingIndex(6);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix : NO_CHANGE;
}
function interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;
  incrementBindingIndex(7);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + suffix : NO_CHANGE;
}
function interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;
  incrementBindingIndex(8);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix : NO_CHANGE;
}
function \u0275\u0275attributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    define_ngDevMode_default && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 1, prefix, suffix);
  }
  return \u0275\u0275attributeInterpolate1;
}
function \u0275\u0275attributeInterpolate2(attrName, prefix, v0, i0, v1, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    define_ngDevMode_default && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 2, prefix, i0, suffix);
  }
  return \u0275\u0275attributeInterpolate2;
}
function \u0275\u0275attributeInterpolate3(attrName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    define_ngDevMode_default && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 3, prefix, i0, i1, suffix);
  }
  return \u0275\u0275attributeInterpolate3;
}
function \u0275\u0275attributeInterpolate4(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    define_ngDevMode_default && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);
  }
  return \u0275\u0275attributeInterpolate4;
}
function \u0275\u0275attributeInterpolate5(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    define_ngDevMode_default && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);
  }
  return \u0275\u0275attributeInterpolate5;
}
function \u0275\u0275attributeInterpolate6(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    define_ngDevMode_default && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);
  }
  return \u0275\u0275attributeInterpolate6;
}
function \u0275\u0275attributeInterpolate7(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    define_ngDevMode_default && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);
  }
  return \u0275\u0275attributeInterpolate7;
}
function \u0275\u0275attributeInterpolate8(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer, namespace) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
    define_ngDevMode_default && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);
  }
  return \u0275\u0275attributeInterpolate8;
}
function \u0275\u0275attributeInterpolateV(attrName, values, sanitizer, namespace) {
  const lView = getLView();
  const interpolated = interpolationV(lView, values);
  if (interpolated !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);
    if (define_ngDevMode_default) {
      const interpolationInBetween = [values[0]];
      for (let i = 2; i < values.length; i += 2) {
        interpolationInBetween.push(values[i]);
      }
      storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
    }
  }
  return \u0275\u0275attributeInterpolateV;
}
function detectChanges(component) {
  const view = getComponentViewByInstance(component);
  detectChangesInternal(view[TVIEW], view, component);
}
function markDirty(component) {
  define_ngDevMode_default && assertDefined(component, "component");
  const rootView = markViewDirty(getComponentViewByInstance(component));
  define_ngDevMode_default && assertDefined(rootView[CONTEXT], "rootContext should be defined");
  scheduleTick(
    rootView[CONTEXT],
    1
  );
}
function templateFirstCreatePass(index, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) {
  define_ngDevMode_default && assertFirstCreatePass(tView);
  define_ngDevMode_default && define_ngDevMode_default.firstCreatePass++;
  const tViewConsts = tView.consts;
  const tNode = getOrCreateTNode(
    tView,
    index,
    4,
    tagName || null,
    getConstant(tViewConsts, attrsIndex)
  );
  resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
  registerPostOrderHooks(tView, tNode);
  const embeddedTView = tNode.tViews = createTView(
    2,
    tNode,
    templateFn,
    decls,
    vars,
    tView.directiveRegistry,
    tView.pipeRegistry,
    null,
    tView.schemas,
    tViewConsts
  );
  if (tView.queries !== null) {
    tView.queries.template(tView, tNode);
    embeddedTView.queries = tView.queries.embeddedTView(tNode);
  }
  return tNode;
}
function \u0275\u0275template(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = tView.firstCreatePass ? templateFirstCreatePass(adjustedIndex, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  setCurrentTNode(tNode, false);
  const comment = lView[RENDERER].createComment(define_ngDevMode_default ? "container" : "");
  appendChild(tView, lView, comment, tNode);
  attachPatchData(comment, lView);
  addToViewTree(lView, lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode));
  if (isDirectiveHost(tNode)) {
    createDirectivesInstances(tView, lView, tNode);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode, localRefExtractor);
  }
}
function store(tView, lView, index, value) {
  if (index >= tView.data.length) {
    tView.data[index] = null;
    tView.blueprint[index] = null;
  }
  lView[index] = value;
}
function \u0275\u0275reference(index) {
  const contextLView = getContextLView();
  return load(contextLView, HEADER_OFFSET + index);
}
function \u0275\u0275property(propName, value, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);
    define_ngDevMode_default && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275property;
}
function setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {
  const inputs = tNode.inputs;
  const property = isClassBased ? "class" : "style";
  setInputsForProperty(tView, lView, inputs[property], property, value);
}
function elementStartFirstCreatePass(index, tView, lView, native, name, attrsIndex, localRefsIndex) {
  define_ngDevMode_default && assertFirstCreatePass(tView);
  define_ngDevMode_default && define_ngDevMode_default.firstCreatePass++;
  const tViewConsts = tView.consts;
  const attrs = getConstant(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(
    tView,
    index,
    2,
    name,
    attrs
  );
  const hasDirectives = resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
  if (define_ngDevMode_default) {
    validateElementIsKnown(native, lView, tNode.value, tView.schemas, hasDirectives);
  }
  if (tNode.attrs !== null) {
    computeStaticStyling(tNode, tNode.attrs, false);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
  }
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function \u0275\u0275elementStart(index, name, attrsIndex, localRefsIndex) {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = HEADER_OFFSET + index;
  define_ngDevMode_default && assertEqual(getBindingIndex(), tView.bindingStartIndex, "elements should be created before any bindings");
  define_ngDevMode_default && assertIndexInRange(lView, adjustedIndex);
  const renderer = lView[RENDERER];
  const native = lView[adjustedIndex] = createElementNode(renderer, name, getNamespace$1());
  const tNode = tView.firstCreatePass ? elementStartFirstCreatePass(adjustedIndex, tView, lView, native, name, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  setCurrentTNode(tNode, true);
  const mergedAttrs = tNode.mergedAttrs;
  if (mergedAttrs !== null) {
    setUpAttributes(renderer, native, mergedAttrs);
  }
  const classes = tNode.classes;
  if (classes !== null) {
    writeDirectClass(renderer, native, classes);
  }
  const styles = tNode.styles;
  if (styles !== null) {
    writeDirectStyle(renderer, native, styles);
  }
  if ((tNode.flags & 64) !== 64) {
    appendChild(tView, lView, native, tNode);
  }
  if (getElementDepthCount() === 0) {
    attachPatchData(native, lView);
  }
  increaseElementDepthCount();
  if (isDirectiveHost(tNode)) {
    createDirectivesInstances(tView, lView, tNode);
    executeContentQueries(tView, tNode, lView);
  }
  if (localRefsIndex !== null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return \u0275\u0275elementStart;
}
function \u0275\u0275elementEnd() {
  let currentTNode = getCurrentTNode();
  define_ngDevMode_default && assertDefined(currentTNode, "No parent node to close.");
  if (isCurrentTNodeParent()) {
    setCurrentTNodeAsNotParent();
  } else {
    define_ngDevMode_default && assertHasParent(getCurrentTNode());
    currentTNode = currentTNode.parent;
    setCurrentTNode(currentTNode, false);
  }
  const tNode = currentTNode;
  define_ngDevMode_default && assertTNodeType(
    tNode,
    3
  );
  decreaseElementDepthCount();
  const tView = getTView();
  if (tView.firstCreatePass) {
    registerPostOrderHooks(tView, currentTNode);
    if (isContentQueryHost(currentTNode)) {
      tView.queries.elementEnd(currentTNode);
    }
  }
  if (tNode.classesWithoutHost != null && hasClassInput(tNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.classesWithoutHost, true);
  }
  if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.stylesWithoutHost, false);
  }
  return \u0275\u0275elementEnd;
}
function \u0275\u0275element(index, name, attrsIndex, localRefsIndex) {
  \u0275\u0275elementStart(index, name, attrsIndex, localRefsIndex);
  \u0275\u0275elementEnd();
  return \u0275\u0275element;
}
function elementContainerStartFirstCreatePass(index, tView, lView, attrsIndex, localRefsIndex) {
  define_ngDevMode_default && define_ngDevMode_default.firstCreatePass++;
  const tViewConsts = tView.consts;
  const attrs = getConstant(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(
    tView,
    index,
    8,
    "ng-container",
    attrs
  );
  if (attrs !== null) {
    computeStaticStyling(tNode, attrs, true);
  }
  const localRefs = getConstant(tViewConsts, localRefsIndex);
  resolveDirectives(tView, lView, tNode, localRefs);
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex) {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index + HEADER_OFFSET;
  define_ngDevMode_default && assertIndexInRange(lView, adjustedIndex);
  define_ngDevMode_default && assertEqual(getBindingIndex(), tView.bindingStartIndex, "element containers should be created before any bindings");
  const tNode = tView.firstCreatePass ? elementContainerStartFirstCreatePass(adjustedIndex, tView, lView, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  setCurrentTNode(tNode, true);
  define_ngDevMode_default && define_ngDevMode_default.rendererCreateComment++;
  const native = lView[adjustedIndex] = lView[RENDERER].createComment(define_ngDevMode_default ? "ng-container" : "");
  appendChild(tView, lView, native, tNode);
  attachPatchData(native, lView);
  if (isDirectiveHost(tNode)) {
    createDirectivesInstances(tView, lView, tNode);
    executeContentQueries(tView, tNode, lView);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return \u0275\u0275elementContainerStart;
}
function \u0275\u0275elementContainerEnd() {
  let currentTNode = getCurrentTNode();
  const tView = getTView();
  if (isCurrentTNodeParent()) {
    setCurrentTNodeAsNotParent();
  } else {
    define_ngDevMode_default && assertHasParent(currentTNode);
    currentTNode = currentTNode.parent;
    setCurrentTNode(currentTNode, false);
  }
  define_ngDevMode_default && assertTNodeType(
    currentTNode,
    8
  );
  if (tView.firstCreatePass) {
    registerPostOrderHooks(tView, currentTNode);
    if (isContentQueryHost(currentTNode)) {
      tView.queries.elementEnd(currentTNode);
    }
  }
  return \u0275\u0275elementContainerEnd;
}
function \u0275\u0275elementContainer(index, attrsIndex, localRefsIndex) {
  \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex);
  \u0275\u0275elementContainerEnd();
  return \u0275\u0275elementContainer;
}
function \u0275\u0275getCurrentView() {
  return getLView();
}
function isPromise2(obj) {
  return !!obj && typeof obj.then === "function";
}
function isSubscribable(obj) {
  return !!obj && typeof obj.subscribe === "function";
}
function \u0275\u0275listener(eventName, listenerFn, useCapture, eventTargetResolver) {
  const lView = getLView();
  const tView = getTView();
  const tNode = getCurrentTNode();
  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn, !!useCapture, eventTargetResolver);
  return \u0275\u0275listener;
}
function \u0275\u0275syntheticHostListener(eventName, listenerFn) {
  const tNode = getCurrentTNode();
  const lView = getLView();
  const tView = getTView();
  const currentDef = getCurrentDirectiveDef(tView.data);
  const renderer = loadComponentRenderer(currentDef, tNode, lView);
  listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, false);
  return \u0275\u0275syntheticHostListener;
}
function findExistingListener(tView, lView, eventName, tNodeIdx) {
  const tCleanup = tView.cleanup;
  if (tCleanup != null) {
    for (let i = 0; i < tCleanup.length - 1; i += 2) {
      const cleanupEventName = tCleanup[i];
      if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {
        const lCleanup = lView[CLEANUP];
        const listenerIdxInLCleanup = tCleanup[i + 2];
        return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
      }
      if (typeof cleanupEventName === "string") {
        i += 2;
      }
    }
  }
  return null;
}
function listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, useCapture, eventTargetResolver) {
  const isTNodeDirectiveHost = isDirectiveHost(tNode);
  const firstCreatePass = tView.firstCreatePass;
  const tCleanup = firstCreatePass && getOrCreateTViewCleanup(tView);
  const context2 = lView[CONTEXT];
  const lCleanup = getOrCreateLViewCleanup(lView);
  define_ngDevMode_default && assertTNodeType(
    tNode,
    3 | 12
  );
  let processOutputs = true;
  if (tNode.type & 3 || eventTargetResolver) {
    const native = getNativeByTNode(tNode, lView);
    const target = eventTargetResolver ? eventTargetResolver(native) : native;
    const lCleanupIndex = lCleanup.length;
    const idxOrTargetGetter = eventTargetResolver ? (_lView) => eventTargetResolver(unwrapRNode(_lView[tNode.index])) : tNode.index;
    let existingListener = null;
    if (!eventTargetResolver && isTNodeDirectiveHost) {
      existingListener = findExistingListener(tView, lView, eventName, tNode.index);
    }
    if (existingListener !== null) {
      const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;
      lastListenerFn.__ngNextListenerFn__ = listenerFn;
      existingListener.__ngLastListenerFn__ = listenerFn;
      processOutputs = false;
    } else {
      listenerFn = wrapListener(
        tNode,
        lView,
        context2,
        listenerFn,
        false
      );
      const cleanupFn = renderer.listen(target, eventName, listenerFn);
      define_ngDevMode_default && define_ngDevMode_default.rendererAddEventListener++;
      lCleanup.push(listenerFn, cleanupFn);
      tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);
    }
  } else {
    listenerFn = wrapListener(
      tNode,
      lView,
      context2,
      listenerFn,
      false
    );
  }
  const outputs = tNode.outputs;
  let props;
  if (processOutputs && outputs !== null && (props = outputs[eventName])) {
    const propsLength = props.length;
    if (propsLength) {
      for (let i = 0; i < propsLength; i += 2) {
        const index = props[i];
        define_ngDevMode_default && assertIndexInRange(lView, index);
        const minifiedName = props[i + 1];
        const directiveInstance = lView[index];
        const output = directiveInstance[minifiedName];
        if (define_ngDevMode_default && !isObservable2(output)) {
          throw new Error(`@Output ${minifiedName} not initialized in '${directiveInstance.constructor.name}'.`);
        }
        const subscription = output.subscribe(listenerFn);
        const idx = lCleanup.length;
        lCleanup.push(listenerFn, subscription);
        tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));
      }
    }
  }
}
function executeListenerWithErrorHandling(lView, context2, listenerFn, e) {
  try {
    profiler(
      6,
      context2,
      listenerFn
    );
    return listenerFn(e) !== false;
  } catch (error2) {
    handleError(lView, error2);
    return false;
  } finally {
    profiler(
      7,
      context2,
      listenerFn
    );
  }
}
function wrapListener(tNode, lView, context2, listenerFn, wrapWithPreventDefault) {
  return function wrapListenerIn_markDirtyAndPreventDefault(e) {
    if (e === Function) {
      return listenerFn;
    }
    const startView = tNode.flags & 2 ? getComponentLViewByIndex(tNode.index, lView) : lView;
    markViewDirty(startView);
    let result = executeListenerWithErrorHandling(lView, context2, listenerFn, e);
    let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
    while (nextListenerFn) {
      result = executeListenerWithErrorHandling(lView, context2, nextListenerFn, e) && result;
      nextListenerFn = nextListenerFn.__ngNextListenerFn__;
    }
    if (wrapWithPreventDefault && result === false) {
      e.preventDefault();
      e.returnValue = false;
    }
    return result;
  };
}
function \u0275\u0275nextContext(level = 1) {
  return nextContextImpl(level);
}
function matchingProjectionSlotIndex(tNode, projectionSlots) {
  let wildcardNgContentIndex = null;
  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);
  for (let i = 0; i < projectionSlots.length; i++) {
    const slotValue = projectionSlots[i];
    if (slotValue === "*") {
      wildcardNgContentIndex = i;
      continue;
    }
    if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(
      tNode,
      slotValue,
      true
    ) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {
      return i;
    }
  }
  return wildcardNgContentIndex;
}
function \u0275\u0275projectionDef(projectionSlots) {
  const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];
  if (!componentNode.projection) {
    const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;
    const projectionHeads = componentNode.projection = newArray(numProjectionSlots, null);
    const tails = projectionHeads.slice();
    let componentChild = componentNode.child;
    while (componentChild !== null) {
      const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;
      if (slotIndex !== null) {
        if (tails[slotIndex]) {
          tails[slotIndex].projectionNext = componentChild;
        } else {
          projectionHeads[slotIndex] = componentChild;
        }
        tails[slotIndex] = componentChild;
      }
      componentChild = componentChild.next;
    }
  }
}
function \u0275\u0275projection(nodeIndex, selectorIndex = 0, attrs) {
  const lView = getLView();
  const tView = getTView();
  const tProjectionNode = getOrCreateTNode(
    tView,
    HEADER_OFFSET + nodeIndex,
    16,
    null,
    attrs || null
  );
  if (tProjectionNode.projection === null)
    tProjectionNode.projection = selectorIndex;
  setCurrentTNodeAsNotParent();
  if ((tProjectionNode.flags & 64) !== 64) {
    applyProjection(tView, lView, tProjectionNode);
  }
}
function \u0275\u0275propertyInterpolate(propName, v0, sanitizer) {
  \u0275\u0275propertyInterpolate1(propName, "", v0, "", sanitizer);
  return \u0275\u0275propertyInterpolate;
}
function \u0275\u0275propertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    define_ngDevMode_default && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);
  }
  return \u0275\u0275propertyInterpolate1;
}
function \u0275\u0275propertyInterpolate2(propName, prefix, v0, i0, v1, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    define_ngDevMode_default && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);
  }
  return \u0275\u0275propertyInterpolate2;
}
function \u0275\u0275propertyInterpolate3(propName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    define_ngDevMode_default && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);
  }
  return \u0275\u0275propertyInterpolate3;
}
function \u0275\u0275propertyInterpolate4(propName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    define_ngDevMode_default && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);
  }
  return \u0275\u0275propertyInterpolate4;
}
function \u0275\u0275propertyInterpolate5(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    define_ngDevMode_default && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);
  }
  return \u0275\u0275propertyInterpolate5;
}
function \u0275\u0275propertyInterpolate6(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    define_ngDevMode_default && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);
  }
  return \u0275\u0275propertyInterpolate6;
}
function \u0275\u0275propertyInterpolate7(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    define_ngDevMode_default && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);
  }
  return \u0275\u0275propertyInterpolate7;
}
function \u0275\u0275propertyInterpolate8(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    define_ngDevMode_default && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);
  }
  return \u0275\u0275propertyInterpolate8;
}
function \u0275\u0275propertyInterpolateV(propName, values, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    if (define_ngDevMode_default) {
      const interpolationInBetween = [values[0]];
      for (let i = 2; i < values.length; i += 2) {
        interpolationInBetween.push(values[i]);
      }
      storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
    }
  }
  return \u0275\u0275propertyInterpolateV;
}
function insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding2, isClassBinding) {
  define_ngDevMode_default && assertFirstUpdatePass(getTView());
  let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;
  let tmplHead = getTStylingRangePrev(tBindings);
  let tmplTail = getTStylingRangeNext(tBindings);
  tData[index] = tStylingKeyWithStatic;
  let isKeyDuplicateOfStatic = false;
  let tStylingKey;
  if (Array.isArray(tStylingKeyWithStatic)) {
    const staticKeyValueArray = tStylingKeyWithStatic;
    tStylingKey = staticKeyValueArray[1];
    if (tStylingKey === null || keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) {
      isKeyDuplicateOfStatic = true;
    }
  } else {
    tStylingKey = tStylingKeyWithStatic;
  }
  if (isHostBinding2) {
    const hasTemplateBindings = tmplTail !== 0;
    if (hasTemplateBindings) {
      const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);
      tData[index + 1] = toTStylingRange(previousNode, tmplHead);
      if (previousNode !== 0) {
        tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index);
      }
      tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);
    } else {
      tData[index + 1] = toTStylingRange(tmplHead, 0);
      if (tmplHead !== 0) {
        tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);
      }
      tmplHead = index;
    }
  } else {
    tData[index + 1] = toTStylingRange(tmplTail, 0);
    define_ngDevMode_default && assertEqual(tmplHead !== 0 && tmplTail === 0, false, "Adding template bindings after hostBindings is not allowed.");
    if (tmplHead === 0) {
      tmplHead = index;
    } else {
      tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);
    }
    tmplTail = index;
  }
  if (isKeyDuplicateOfStatic) {
    tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);
  }
  markDuplicates(tData, tStylingKey, index, true, isClassBinding);
  markDuplicates(tData, tStylingKey, index, false, isClassBinding);
  markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);
  tBindings = toTStylingRange(tmplHead, tmplTail);
  if (isClassBinding) {
    tNode.classBindings = tBindings;
  } else {
    tNode.styleBindings = tBindings;
  }
}
function markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {
  const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;
  if (residual != null && typeof tStylingKey == "string" && keyValueArrayIndexOf(residual, tStylingKey) >= 0) {
    tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);
  }
}
function markDuplicates(tData, tStylingKey, index, isPrevDir, isClassBinding) {
  const tStylingAtIndex = tData[index + 1];
  const isMap = tStylingKey === null;
  let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);
  let foundDuplicate = false;
  while (cursor !== 0 && (foundDuplicate === false || isMap)) {
    define_ngDevMode_default && assertIndexInRange(tData, cursor);
    const tStylingValueAtCursor = tData[cursor];
    const tStyleRangeAtCursor = tData[cursor + 1];
    if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {
      foundDuplicate = true;
      tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);
    }
    cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) : getTStylingRangeNext(tStyleRangeAtCursor);
  }
  if (foundDuplicate) {
    tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) : setTStylingRangeNextDuplicate(tStylingAtIndex);
  }
}
function isStylingMatch(tStylingKeyCursor, tStylingKey) {
  define_ngDevMode_default && assertNotEqual(Array.isArray(tStylingKey), true, "Expected that 'tStylingKey' has been unwrapped");
  if (tStylingKeyCursor === null || tStylingKey == null || (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey) {
    return true;
  } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === "string") {
    return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >= 0;
  }
  return false;
}
function getLastParsedKey(text) {
  return text.substring(parserState.key, parserState.keyEnd);
}
function getLastParsedValue(text) {
  return text.substring(parserState.value, parserState.valueEnd);
}
function parseClassName(text) {
  resetParserState(text);
  return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseClassNameNext(text, index) {
  const end = parserState.textEnd;
  if (end === index) {
    return -1;
  }
  index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);
  return consumeWhitespace(text, index, end);
}
function parseStyle(text) {
  resetParserState(text);
  return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));
}
function parseStyleNext(text, startIndex) {
  const end = parserState.textEnd;
  let index = parserState.key = consumeWhitespace(text, startIndex, end);
  if (end === index) {
    return -1;
  }
  index = parserState.keyEnd = consumeStyleKey(text, index, end);
  index = consumeSeparator(
    text,
    index,
    end,
    58
  );
  index = parserState.value = consumeWhitespace(text, index, end);
  index = parserState.valueEnd = consumeStyleValue(text, index, end);
  return consumeSeparator(
    text,
    index,
    end,
    59
  );
}
function resetParserState(text) {
  parserState.key = 0;
  parserState.keyEnd = 0;
  parserState.value = 0;
  parserState.valueEnd = 0;
  parserState.textEnd = text.length;
}
function consumeWhitespace(text, startIndex, endIndex) {
  while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeClassToken(text, startIndex, endIndex) {
  while (startIndex < endIndex && text.charCodeAt(startIndex) > 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeStyleKey(text, startIndex, endIndex) {
  let ch;
  while (startIndex < endIndex && ((ch = text.charCodeAt(startIndex)) === 45 || ch === 95 || (ch & -33) >= 65 && (ch & -33) <= 90 || ch >= 48 && ch <= 57)) {
    startIndex++;
  }
  return startIndex;
}
function consumeSeparator(text, startIndex, endIndex, separator) {
  startIndex = consumeWhitespace(text, startIndex, endIndex);
  if (startIndex < endIndex) {
    if (define_ngDevMode_default && text.charCodeAt(startIndex) !== separator) {
      malformedStyleError(text, String.fromCharCode(separator), startIndex);
    }
    startIndex++;
  }
  return startIndex;
}
function consumeStyleValue(text, startIndex, endIndex) {
  let ch1 = -1;
  let ch2 = -1;
  let ch3 = -1;
  let i = startIndex;
  let lastChIndex = i;
  while (i < endIndex) {
    const ch = text.charCodeAt(i++);
    if (ch === 59) {
      return lastChIndex;
    } else if (ch === 34 || ch === 39) {
      lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);
    } else if (startIndex === i - 4 && ch3 === 85 && ch2 === 82 && ch1 === 76 && ch === 40) {
      lastChIndex = i = consumeQuotedText(
        text,
        41,
        i,
        endIndex
      );
    } else if (ch > 32) {
      lastChIndex = i;
    }
    ch3 = ch2;
    ch2 = ch1;
    ch1 = ch & -33;
  }
  return lastChIndex;
}
function consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {
  let ch1 = -1;
  let index = startIndex;
  while (index < endIndex) {
    const ch = text.charCodeAt(index++);
    if (ch == quoteCharCode && ch1 !== 92) {
      return index;
    }
    if (ch == 92 && ch1 === 92) {
      ch1 = 0;
    } else {
      ch1 = ch;
    }
  }
  throw define_ngDevMode_default ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) : new Error();
}
function malformedStyleError(text, expecting, index) {
  define_ngDevMode_default && assertEqual(typeof text === "string", true, "String expected here");
  throw throwError2(`Malformed style at location ${index} in string '` + text.substring(0, index) + "[>>" + text.substring(index, index + 1) + "<<]" + text.slice(index + 1) + `'. Expecting '${expecting}'.`);
}
function \u0275\u0275styleProp(prop, value, suffix) {
  checkStylingProperty(prop, value, suffix, false);
  return \u0275\u0275styleProp;
}
function \u0275\u0275classProp(className, value) {
  checkStylingProperty(className, value, null, true);
  return \u0275\u0275classProp;
}
function \u0275\u0275styleMap(styles) {
  checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);
}
function styleStringParser(keyValueArray, text) {
  for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {
    styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));
  }
}
function \u0275\u0275classMap(classes) {
  checkStylingMap(keyValueArraySet, classStringParser, classes, true);
}
function classStringParser(keyValueArray, text) {
  for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {
    keyValueArraySet(keyValueArray, getLastParsedKey(text), true);
  }
}
function checkStylingProperty(prop, value, suffix, isClassBased) {
  const lView = getLView();
  const tView = getTView();
  const bindingIndex = incrementBindingIndex(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);
  }
  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
    const tNode = tView.data[getSelectedIndex()];
    updateStyling(tView, tNode, lView, lView[RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);
  }
}
function checkStylingMap(keyValueArraySet2, stringParser, value, isClassBased) {
  const tView = getTView();
  const bindingIndex = incrementBindingIndex(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);
  }
  const lView = getLView();
  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
    const tNode = tView.data[getSelectedIndex()];
    if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {
      if (define_ngDevMode_default) {
        const tStylingKey = tView.data[bindingIndex];
        assertEqual(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, "Styling linked list shadow input should be marked as 'false'");
      }
      let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;
      define_ngDevMode_default && isClassBased === false && staticPrefix !== null && assertEqual(staticPrefix.endsWith(";"), true, "Expecting static portion to end with ';'");
      if (staticPrefix !== null) {
        value = concatStringsWithSpace(staticPrefix, value ? value : "");
      }
      setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);
    } else {
      updateStylingMap(tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet2, stringParser, value), isClassBased, bindingIndex);
    }
  }
}
function isInHostBindings(tView, bindingIndex) {
  return bindingIndex >= tView.expandoStartIndex;
}
function stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {
  define_ngDevMode_default && assertFirstUpdatePass(tView);
  const tData = tView.data;
  if (tData[bindingIndex + 1] === null) {
    const tNode = tData[getSelectedIndex()];
    define_ngDevMode_default && assertDefined(tNode, "TNode expected");
    const isHostBindings = isInHostBindings(tView, bindingIndex);
    if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {
      tStylingKey = false;
    }
    tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);
    insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);
  }
}
function wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {
  const hostDirectiveDef = getCurrentDirectiveDef(tData);
  let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
  if (hostDirectiveDef === null) {
    const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;
    if (isFirstStylingInstructionInTemplate) {
      stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);
      stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);
      residual = null;
    }
  } else {
    const directiveStylingLast = tNode.directiveStylingLast;
    const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;
    if (isFirstStylingInstructionInHostBinding) {
      stylingKey = collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);
      if (residual === null) {
        let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);
        if (templateStylingKey !== void 0 && Array.isArray(templateStylingKey)) {
          templateStylingKey = collectStylingFromDirectives(
            null,
            tData,
            tNode,
            templateStylingKey[1],
            isClassBased
          );
          templateStylingKey = collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);
          setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);
        }
      } else {
        residual = collectResidual(tData, tNode, isClassBased);
      }
    }
  }
  if (residual !== void 0) {
    isClassBased ? tNode.residualClasses = residual : tNode.residualStyles = residual;
  }
  return stylingKey;
}
function getTemplateHeadTStylingKey(tData, tNode, isClassBased) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  if (getTStylingRangeNext(bindings) === 0) {
    return void 0;
  }
  return tData[getTStylingRangePrev(bindings)];
}
function setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  define_ngDevMode_default && assertNotEqual(getTStylingRangeNext(bindings), 0, "Expecting to have at least one template styling binding.");
  tData[getTStylingRangePrev(bindings)] = tStylingKey;
}
function collectResidual(tData, tNode, isClassBased) {
  let residual = void 0;
  const directiveEnd = tNode.directiveEnd;
  define_ngDevMode_default && assertNotEqual(tNode.directiveStylingLast, -1, "By the time this function gets called at least one hostBindings-node styling instruction must have executed.");
  for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {
    const attrs = tData[i].hostAttrs;
    residual = collectStylingFromTAttrs(residual, attrs, isClassBased);
  }
  return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);
}
function collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {
  let currentDirective = null;
  const directiveEnd = tNode.directiveEnd;
  let directiveStylingLast = tNode.directiveStylingLast;
  if (directiveStylingLast === -1) {
    directiveStylingLast = tNode.directiveStart;
  } else {
    directiveStylingLast++;
  }
  while (directiveStylingLast < directiveEnd) {
    currentDirective = tData[directiveStylingLast];
    define_ngDevMode_default && assertDefined(currentDirective, "expected to be defined");
    stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);
    if (currentDirective === hostDirectiveDef)
      break;
    directiveStylingLast++;
  }
  if (hostDirectiveDef !== null) {
    tNode.directiveStylingLast = directiveStylingLast;
  }
  return stylingKey;
}
function collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {
  const desiredMarker = isClassBased ? 1 : 2;
  let currentMarker = -1;
  if (attrs !== null) {
    for (let i = 0; i < attrs.length; i++) {
      const item = attrs[i];
      if (typeof item === "number") {
        currentMarker = item;
      } else {
        if (currentMarker === desiredMarker) {
          if (!Array.isArray(stylingKey)) {
            stylingKey = stylingKey === void 0 ? [] : ["", stylingKey];
          }
          keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i]);
        }
      }
    }
  }
  return stylingKey === void 0 ? null : stylingKey;
}
function toStylingKeyValueArray(keyValueArraySet2, stringParser, value) {
  if (value == null || value === "")
    return EMPTY_ARRAY;
  const styleKeyValueArray = [];
  const unwrappedValue = unwrapSafeValue(value);
  if (Array.isArray(unwrappedValue)) {
    for (let i = 0; i < unwrappedValue.length; i++) {
      keyValueArraySet2(styleKeyValueArray, unwrappedValue[i], true);
    }
  } else if (typeof unwrappedValue === "object") {
    for (const key in unwrappedValue) {
      if (unwrappedValue.hasOwnProperty(key)) {
        keyValueArraySet2(styleKeyValueArray, key, unwrappedValue[key]);
      }
    }
  } else if (typeof unwrappedValue === "string") {
    stringParser(styleKeyValueArray, unwrappedValue);
  } else {
    define_ngDevMode_default && throwError2("Unsupported styling type " + typeof unwrappedValue + ": " + unwrappedValue);
  }
  return styleKeyValueArray;
}
function styleKeyValueArraySet(keyValueArray, key, value) {
  keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));
}
function updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {
  if (oldKeyValueArray === NO_CHANGE) {
    oldKeyValueArray = EMPTY_ARRAY;
  }
  let oldIndex = 0;
  let newIndex = 0;
  let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;
  let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;
  while (oldKey !== null || newKey !== null) {
    define_ngDevMode_default && assertLessThan(oldIndex, 999, "Are we stuck in infinite loop?");
    define_ngDevMode_default && assertLessThan(newIndex, 999, "Are we stuck in infinite loop?");
    const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : void 0;
    const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : void 0;
    let setKey = null;
    let setValue = void 0;
    if (oldKey === newKey) {
      oldIndex += 2;
      newIndex += 2;
      if (oldValue !== newValue) {
        setKey = newKey;
        setValue = newValue;
      }
    } else if (newKey === null || oldKey !== null && oldKey < newKey) {
      oldIndex += 2;
      setKey = oldKey;
    } else {
      define_ngDevMode_default && assertDefined(newKey, "Expecting to have a valid key");
      newIndex += 2;
      setKey = newKey;
      setValue = newValue;
    }
    if (setKey !== null) {
      updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);
    }
    oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;
    newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;
  }
}
function updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {
  if (!(tNode.type & 3)) {
    return;
  }
  const tData = tView.data;
  const tRange = tData[bindingIndex + 1];
  const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) : void 0;
  if (!isStylingValuePresent(higherPriorityValue)) {
    if (!isStylingValuePresent(value)) {
      if (getTStylingRangePrevDuplicate(tRange)) {
        value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);
      }
    }
    const rNode = getNativeByIndex(getSelectedIndex(), lView);
    applyStyling(renderer, isClassBased, rNode, prop, value);
  }
}
function findStylingValue(tData, tNode, lView, prop, index, isClassBased) {
  const isPrevDirection = tNode === null;
  let value = void 0;
  while (index > 0) {
    const rawKey = tData[index];
    const containsStatics = Array.isArray(rawKey);
    const key = containsStatics ? rawKey[1] : rawKey;
    const isStylingMap = key === null;
    let valueAtLViewIndex = lView[index + 1];
    if (valueAtLViewIndex === NO_CHANGE) {
      valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : void 0;
    }
    let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) : key === prop ? valueAtLViewIndex : void 0;
    if (containsStatics && !isStylingValuePresent(currentValue)) {
      currentValue = keyValueArrayGet(rawKey, prop);
    }
    if (isStylingValuePresent(currentValue)) {
      value = currentValue;
      if (isPrevDirection) {
        return value;
      }
    }
    const tRange = tData[index + 1];
    index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);
  }
  if (tNode !== null) {
    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
    if (residual != null) {
      value = keyValueArrayGet(residual, prop);
    }
  }
  return value;
}
function isStylingValuePresent(value) {
  return value !== void 0;
}
function normalizeSuffix(value, suffix) {
  if (value == null) {
  } else if (typeof suffix === "string") {
    value = value + suffix;
  } else if (typeof value === "object") {
    value = stringify(unwrapSafeValue(value));
  }
  return value;
}
function hasStylingInputShadow(tNode, isClassBased) {
  return (tNode.flags & (isClassBased ? 16 : 32)) !== 0;
}
function \u0275\u0275text(index, value = "") {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index + HEADER_OFFSET;
  define_ngDevMode_default && assertEqual(getBindingIndex(), tView.bindingStartIndex, "text nodes should be created before any bindings");
  define_ngDevMode_default && assertIndexInRange(lView, adjustedIndex);
  const tNode = tView.firstCreatePass ? getOrCreateTNode(
    tView,
    adjustedIndex,
    1,
    value,
    null
  ) : tView.data[adjustedIndex];
  const textNative = lView[adjustedIndex] = createTextNode(lView[RENDERER], value);
  appendChild(tView, lView, textNative, tNode);
  setCurrentTNode(tNode, false);
}
function \u0275\u0275textInterpolate(v0) {
  \u0275\u0275textInterpolate1("", v0, "");
  return \u0275\u0275textInterpolate;
}
function \u0275\u0275textInterpolate1(prefix, v0, suffix) {
  const lView = getLView();
  const interpolated = interpolation1(lView, prefix, v0, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate1;
}
function \u0275\u0275textInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = getLView();
  const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate2;
}
function \u0275\u0275textInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
  const lView = getLView();
  const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate3;
}
function \u0275\u0275textInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const lView = getLView();
  const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate4;
}
function \u0275\u0275textInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const lView = getLView();
  const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate5;
}
function \u0275\u0275textInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const lView = getLView();
  const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate6;
}
function \u0275\u0275textInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = getLView();
  const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate7;
}
function \u0275\u0275textInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = getLView();
  const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate8;
}
function \u0275\u0275textInterpolateV(values) {
  const lView = getLView();
  const interpolated = interpolationV(lView, values);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolateV;
}
function \u0275\u0275classMapInterpolate1(prefix, v0, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolateV(values) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275styleMapInterpolate1(prefix, v0, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolateV(values) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275stylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate1;
}
function \u0275\u0275stylePropInterpolate2(prop, prefix, v0, i0, v1, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate2;
}
function \u0275\u0275stylePropInterpolate3(prop, prefix, v0, i0, v1, i1, v2, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate3;
}
function \u0275\u0275stylePropInterpolate4(prop, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate4;
}
function \u0275\u0275stylePropInterpolate5(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate5;
}
function \u0275\u0275stylePropInterpolate6(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate6;
}
function \u0275\u0275stylePropInterpolate7(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate7;
}
function \u0275\u0275stylePropInterpolate8(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate8;
}
function \u0275\u0275stylePropInterpolateV(prop, values, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolateV;
}
function \u0275\u0275hostProperty(propName, value, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, true);
    define_ngDevMode_default && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275hostProperty;
}
function \u0275\u0275syntheticHostProperty(propName, value, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    const currentDef = getCurrentDirectiveDef(tView.data);
    const renderer = loadComponentRenderer(currentDef, tNode, lView);
    elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, true);
    define_ngDevMode_default && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275syntheticHostProperty;
}
function plural(val) {
  const n = val, i = Math.floor(Math.abs(val)), v = val.toString().replace(/^[^.]*\.?/, "").length;
  if (i === 1 && v === 0)
    return 1;
  return 5;
}
function registerLocaleData(data, localeId, extraData) {
  if (typeof localeId !== "string") {
    extraData = localeId;
    localeId = data[LocaleDataIndex.LocaleId];
  }
  localeId = localeId.toLowerCase().replace(/_/g, "-");
  LOCALE_DATA[localeId] = data;
  if (extraData) {
    LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData;
  }
}
function findLocaleData(locale) {
  const normalizedLocale = normalizeLocale(locale);
  let match = getLocaleData(normalizedLocale);
  if (match) {
    return match;
  }
  const parentLocale = normalizedLocale.split("-")[0];
  match = getLocaleData(parentLocale);
  if (match) {
    return match;
  }
  if (parentLocale === "en") {
    return localeEn;
  }
  throw new RuntimeError(
    701,
    define_ngDevMode_default && `Missing locale data for the locale "${locale}".`
  );
}
function getLocaleCurrencyCode(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.CurrencyCode] || null;
}
function getLocalePluralCase(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.PluralCase];
}
function getLocaleData(normalizedLocale) {
  if (!(normalizedLocale in LOCALE_DATA)) {
    LOCALE_DATA[normalizedLocale] = _global.ng && _global.ng.common && _global.ng.common.locales && _global.ng.common.locales[normalizedLocale];
  }
  return LOCALE_DATA[normalizedLocale];
}
function unregisterAllLocaleData() {
  LOCALE_DATA = {};
}
function normalizeLocale(locale) {
  return locale.toLowerCase().replace(/_/g, "-");
}
function getPluralCase(value, locale) {
  const plural2 = getLocalePluralCase(locale)(parseInt(value, 10));
  const result = pluralMapping[plural2];
  return result !== void 0 ? result : "other";
}
function setLocaleId(localeId) {
  assertDefined(localeId, `Expected localeId to be defined`);
  if (typeof localeId === "string") {
    LOCALE_ID$1 = localeId.toLowerCase().replace(/_/g, "-");
  }
}
function getLocaleId() {
  return LOCALE_ID$1;
}
function getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {
  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;
  const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;
  if (insertBeforeIndex === null) {
    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);
  } else {
    define_ngDevMode_default && assertIndexInRange(lView, insertBeforeIndex);
    return unwrapRNode(lView[insertBeforeIndex]);
  }
}
function processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {
  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;
  if (Array.isArray(tNodeInsertBeforeIndex)) {
    define_ngDevMode_default && assertDomNode(childRNode);
    let i18nParent = childRNode;
    let anchorRNode = null;
    if (!(childTNode.type & 3)) {
      anchorRNode = i18nParent;
      i18nParent = parentRElement;
    }
    if (i18nParent !== null && (childTNode.flags & 2) === 0) {
      for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {
        const i18nChild = lView[tNodeInsertBeforeIndex[i]];
        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);
      }
    }
  }
}
function addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {
  define_ngDevMode_default && assertEqual(newTNode.insertBeforeIndex, null, "We expect that insertBeforeIndex is not set");
  previousTNodes.push(newTNode);
  if (previousTNodes.length > 1) {
    for (let i = previousTNodes.length - 2; i >= 0; i--) {
      const existingTNode = previousTNodes[i];
      if (!isI18nText(existingTNode)) {
        if (isNewTNodeCreatedBefore(existingTNode, newTNode) && getInsertBeforeIndex(existingTNode) === null) {
          setInsertBeforeIndex(existingTNode, newTNode.index);
        }
      }
    }
  }
}
function isI18nText(tNode) {
  return !(tNode.type & 64);
}
function isNewTNodeCreatedBefore(existingTNode, newTNode) {
  return isI18nText(newTNode) || existingTNode.index > newTNode.index;
}
function getInsertBeforeIndex(tNode) {
  const index = tNode.insertBeforeIndex;
  return Array.isArray(index) ? index[0] : index;
}
function setInsertBeforeIndex(tNode, value) {
  const index = tNode.insertBeforeIndex;
  if (Array.isArray(index)) {
    index[0] = value;
  } else {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    tNode.insertBeforeIndex = value;
  }
}
function getTIcu(tView, index) {
  const value = tView.data[index];
  if (value === null || typeof value === "string")
    return null;
  if (define_ngDevMode_default && !(value.hasOwnProperty("tViews") || value.hasOwnProperty("currentCaseLViewIndex"))) {
    throwError2("We expect to get 'null'|'TIcu'|'TIcuContainer', but got: " + value);
  }
  const tIcu = value.hasOwnProperty("currentCaseLViewIndex") ? value : value.value;
  define_ngDevMode_default && assertTIcu(tIcu);
  return tIcu;
}
function setTIcu(tView, index, tIcu) {
  const tNode = tView.data[index];
  define_ngDevMode_default && assertEqual(tNode === null || tNode.hasOwnProperty("tViews"), true, "We expect to get 'null'|'TIcuContainer'");
  if (tNode === null) {
    tView.data[index] = tIcu;
  } else {
    define_ngDevMode_default && assertTNodeType(
      tNode,
      32
    );
    tNode.value = tIcu;
  }
}
function setTNodeInsertBeforeIndex(tNode, index) {
  define_ngDevMode_default && assertTNode(tNode);
  let insertBeforeIndex = tNode.insertBeforeIndex;
  if (insertBeforeIndex === null) {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    insertBeforeIndex = tNode.insertBeforeIndex = [
      null,
      index
    ];
  } else {
    assertEqual(Array.isArray(insertBeforeIndex), true, "Expecting array here");
    insertBeforeIndex.push(index);
  }
}
function createTNodePlaceholder(tView, previousTNodes, index) {
  const tNode = createTNodeAtIndex(
    tView,
    index,
    64,
    null,
    null
  );
  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);
  return tNode;
}
function getCurrentICUCaseIndex(tIcu, lView) {
  const currentCase = lView[tIcu.currentCaseLViewIndex];
  return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;
}
function getParentFromIcuCreateOpCode(mergedCode) {
  return mergedCode >>> 17;
}
function getRefFromIcuCreateOpCode(mergedCode) {
  return (mergedCode & 131070) >>> 1;
}
function getInstructionFromIcuCreateOpCode(mergedCode) {
  return mergedCode & 1;
}
function icuCreateOpCode(opCode, parentIdx, refIdx) {
  define_ngDevMode_default && assertGreaterThanOrEqual(parentIdx, 0, "Missing parent index");
  define_ngDevMode_default && assertGreaterThan(refIdx, 0, "Missing ref index");
  return opCode | parentIdx << 17 | refIdx << 1;
}
function setMaskBit(hasChange) {
  if (hasChange) {
    changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);
  }
  changeMaskCounter++;
}
function applyI18n(tView, lView, index) {
  if (changeMaskCounter > 0) {
    define_ngDevMode_default && assertDefined(tView, `tView should be defined`);
    const tI18n = tView.data[index];
    const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;
    const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;
    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);
  }
  changeMask = 0;
  changeMaskCounter = 0;
}
function applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {
  const renderer = lView[RENDERER];
  for (let i = 0; i < createOpCodes.length; i++) {
    const opCode = createOpCodes[i++];
    const text = createOpCodes[i];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index = opCode >>> I18nCreateOpCode.SHIFT;
    let rNode = lView[index];
    if (rNode === null) {
      rNode = lView[index] = isComment ? renderer.createComment(text) : createTextNode(renderer, text);
    }
    if (appendNow && parentRNode !== null) {
      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);
    }
  }
}
function applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {
  define_ngDevMode_default && assertDomNode(anchorRNode);
  const renderer = lView[RENDERER];
  let rootIdx = null;
  let rootRNode;
  for (let i = 0; i < mutableOpCodes.length; i++) {
    const opCode = mutableOpCodes[i];
    if (typeof opCode == "string") {
      const textNodeIndex = mutableOpCodes[++i];
      if (lView[textNodeIndex] === null) {
        define_ngDevMode_default && define_ngDevMode_default.rendererCreateTextNode++;
        define_ngDevMode_default && assertIndexInRange(lView, textNodeIndex);
        lView[textNodeIndex] = createTextNode(renderer, opCode);
      }
    } else if (typeof opCode == "number") {
      switch (opCode & 1) {
        case 0:
          const parentIdx = getParentFromIcuCreateOpCode(opCode);
          if (rootIdx === null) {
            rootIdx = parentIdx;
            rootRNode = nativeParentNode(renderer, anchorRNode);
          }
          let insertInFrontOf;
          let parentRNode;
          if (parentIdx === rootIdx) {
            insertInFrontOf = anchorRNode;
            parentRNode = rootRNode;
          } else {
            insertInFrontOf = null;
            parentRNode = unwrapRNode(lView[parentIdx]);
          }
          if (parentRNode !== null) {
            define_ngDevMode_default && assertDomNode(parentRNode);
            const refIdx = getRefFromIcuCreateOpCode(opCode);
            define_ngDevMode_default && assertGreaterThan(refIdx, HEADER_OFFSET, "Missing ref");
            const child = lView[refIdx];
            define_ngDevMode_default && assertDomNode(child);
            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);
            const tIcu = getTIcu(tView, refIdx);
            if (tIcu !== null && typeof tIcu === "object") {
              define_ngDevMode_default && assertTIcu(tIcu);
              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);
              if (caseIndex !== null) {
                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);
              }
            }
          }
          break;
        case 1:
          const elementNodeIndex = opCode >>> 1;
          const attrName = mutableOpCodes[++i];
          const attrValue = mutableOpCodes[++i];
          setElementAttribute(renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName, attrValue, null);
          break;
        default:
          if (define_ngDevMode_default) {
            throw new RuntimeError(
              700,
              `Unable to determine the type of mutate operation for "${opCode}"`
            );
          }
      }
    } else {
      switch (opCode) {
        case ICU_MARKER:
          const commentValue = mutableOpCodes[++i];
          const commentNodeIndex = mutableOpCodes[++i];
          if (lView[commentNodeIndex] === null) {
            define_ngDevMode_default && assertEqual(typeof commentValue, "string", `Expected "${commentValue}" to be a comment node value`);
            define_ngDevMode_default && define_ngDevMode_default.rendererCreateComment++;
            define_ngDevMode_default && assertIndexInExpandoRange(lView, commentNodeIndex);
            const commentRNode = lView[commentNodeIndex] = createCommentNode(renderer, commentValue);
            attachPatchData(commentRNode, lView);
          }
          break;
        case ELEMENT_MARKER:
          const tagName = mutableOpCodes[++i];
          const elementNodeIndex = mutableOpCodes[++i];
          if (lView[elementNodeIndex] === null) {
            define_ngDevMode_default && assertEqual(typeof tagName, "string", `Expected "${tagName}" to be an element node tag name`);
            define_ngDevMode_default && define_ngDevMode_default.rendererCreateElement++;
            define_ngDevMode_default && assertIndexInExpandoRange(lView, elementNodeIndex);
            const elementRNode = lView[elementNodeIndex] = createElementNode(renderer, tagName, null);
            attachPatchData(elementRNode, lView);
          }
          break;
        default:
          define_ngDevMode_default && throwError2(`Unable to determine the type of mutate operation for "${opCode}"`);
      }
    }
  }
}
function applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask2) {
  for (let i = 0; i < updateOpCodes.length; i++) {
    const checkBit = updateOpCodes[i];
    const skipCodes = updateOpCodes[++i];
    if (checkBit & changeMask2) {
      let value = "";
      for (let j = i + 1; j <= i + skipCodes; j++) {
        const opCode = updateOpCodes[j];
        if (typeof opCode == "string") {
          value += opCode;
        } else if (typeof opCode == "number") {
          if (opCode < 0) {
            value += renderStringify(lView[bindingsStartIndex - opCode]);
          } else {
            const nodeIndex = opCode >>> 2;
            switch (opCode & 3) {
              case 1:
                const propName = updateOpCodes[++j];
                const sanitizeFn = updateOpCodes[++j];
                const tNodeOrTagName = tView.data[nodeIndex];
                define_ngDevMode_default && assertDefined(tNodeOrTagName, "Experting TNode or string");
                if (typeof tNodeOrTagName === "string") {
                  setElementAttribute(lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);
                } else {
                  elementPropertyInternal(tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn, false);
                }
                break;
              case 0:
                const rText = lView[nodeIndex];
                rText !== null && updateTextNode(lView[RENDERER], rText, value);
                break;
              case 2:
                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);
                break;
              case 3:
                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);
                break;
            }
          }
        }
      }
    } else {
      const opCode = updateOpCodes[i + 1];
      if (opCode > 0 && (opCode & 3) === 3) {
        const nodeIndex = opCode >>> 2;
        const tIcu = getTIcu(tView, nodeIndex);
        const currentIndex = lView[tIcu.currentCaseLViewIndex];
        if (currentIndex < 0) {
          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);
        }
      }
    }
    i += skipCodes;
  }
}
function applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {
  define_ngDevMode_default && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);
  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];
  if (activeCaseIndex !== null) {
    let mask = changeMask;
    if (activeCaseIndex < 0) {
      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;
      mask = -1;
    }
    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);
  }
}
function applyIcuSwitchCase(tView, tIcu, lView, value) {
  const caseIndex = getCaseIndex(tIcu, value);
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== caseIndex) {
    applyIcuSwitchCaseRemove(tView, tIcu, lView);
    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;
    if (caseIndex !== null) {
      const anchorRNode = lView[tIcu.anchorIdx];
      if (anchorRNode) {
        define_ngDevMode_default && assertDomNode(anchorRNode);
        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);
      }
    }
  }
}
function applyIcuSwitchCaseRemove(tView, tIcu, lView) {
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== null) {
    const removeCodes = tIcu.remove[activeCaseIndex];
    for (let i = 0; i < removeCodes.length; i++) {
      const nodeOrIcuIndex = removeCodes[i];
      if (nodeOrIcuIndex > 0) {
        const rNode = getNativeByIndex(nodeOrIcuIndex, lView);
        rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);
      } else {
        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);
      }
    }
  }
}
function getCaseIndex(icuExpression, bindingValue) {
  let index = icuExpression.cases.indexOf(bindingValue);
  if (index === -1) {
    switch (icuExpression.type) {
      case 1: {
        const resolvedCase = getPluralCase(bindingValue, getLocaleId());
        index = icuExpression.cases.indexOf(resolvedCase);
        if (index === -1 && resolvedCase !== "other") {
          index = icuExpression.cases.indexOf("other");
        }
        break;
      }
      case 0: {
        index = icuExpression.cases.indexOf("other");
        break;
      }
    }
  }
  return index === -1 ? null : index;
}
function loadIcuContainerVisitor() {
  const _stack = [];
  let _index = -1;
  let _lView;
  let _removes;
  function icuContainerIteratorStart(tIcuContainerNode, lView) {
    _lView = lView;
    while (_stack.length)
      _stack.pop();
    define_ngDevMode_default && assertTNodeForLView(tIcuContainerNode, lView);
    enterIcu(tIcuContainerNode.value, lView);
    return icuContainerIteratorNext;
  }
  function enterIcu(tIcu, lView) {
    _index = 0;
    const currentCase = getCurrentICUCaseIndex(tIcu, lView);
    if (currentCase !== null) {
      define_ngDevMode_default && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);
      _removes = tIcu.remove[currentCase];
    } else {
      _removes = EMPTY_ARRAY;
    }
  }
  function icuContainerIteratorNext() {
    if (_index < _removes.length) {
      const removeOpCode = _removes[_index++];
      define_ngDevMode_default && assertNumber(removeOpCode, "Expecting OpCode number");
      if (removeOpCode > 0) {
        const rNode = _lView[removeOpCode];
        define_ngDevMode_default && assertDomNode(rNode);
        return rNode;
      } else {
        _stack.push(_index, _removes);
        const tIcuIndex = ~removeOpCode;
        const tIcu = _lView[TVIEW].data[tIcuIndex];
        define_ngDevMode_default && assertTIcu(tIcu);
        enterIcu(tIcu, _lView);
        return icuContainerIteratorNext();
      }
    } else {
      if (_stack.length === 0) {
        return null;
      } else {
        _removes = _stack.pop();
        _index = _stack.pop();
        return icuContainerIteratorNext();
      }
    }
  }
  return icuContainerIteratorStart;
}
function i18nCreateOpCodesToString(opcodes) {
  const createOpCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i = 0; i < createOpCodes.length; i++) {
    const opCode = createOpCodes[i++];
    const text = createOpCodes[i];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index = opCode >>> I18nCreateOpCode.SHIFT;
    lines.push(`lView[${index}] = document.${isComment ? "createComment" : "createText"}(${JSON.stringify(text)});`);
    if (appendNow) {
      lines.push(`parent.appendChild(lView[${index}]);`);
    }
  }
  return lines;
}
function i18nUpdateOpCodesToString(opcodes) {
  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(value) {
    const ref = value >>> 2;
    const opCode = value & 3;
    switch (opCode) {
      case 0:
        return `(lView[${ref}] as Text).textContent = $$$`;
      case 1:
        const attrName = parser.consumeString();
        const sanitizationFn = parser.consumeFunction();
        const value2 = sanitizationFn ? `(${sanitizationFn})($$$)` : "$$$";
        return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value2})`;
      case 2:
        return `icuSwitchCase(${ref}, $$$)`;
      case 3:
        return `icuUpdateCase(${ref})`;
    }
    throw new Error("unexpected OpCode");
  }
  while (parser.hasMore()) {
    let mask = parser.consumeNumber();
    let size = parser.consumeNumber();
    const end = parser.i + size;
    const statements = [];
    let statement = "";
    while (parser.i < end) {
      let value = parser.consumeNumberOrString();
      if (typeof value === "string") {
        statement += value;
      } else if (value < 0) {
        statement += "${lView[i" + value + "]}";
      } else {
        const opCodeText = consumeOpCode(value);
        statements.push(opCodeText.replace("$$$", "`" + statement + "`") + ";");
        statement = "";
      }
    }
    lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(" ")} }`);
  }
  return lines;
}
function icuCreateOpCodesToString(opcodes) {
  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(opCode) {
    const parent = getParentFromIcuCreateOpCode(opCode);
    const ref = getRefFromIcuCreateOpCode(opCode);
    switch (getInstructionFromIcuCreateOpCode(opCode)) {
      case 0:
        return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;
      case 1:
        return `(lView[${ref}] as Element).setAttribute("${parser.consumeString()}", "${parser.consumeString()}")`;
    }
    throw new Error("Unexpected OpCode: " + getInstructionFromIcuCreateOpCode(opCode));
  }
  let lastRef = -1;
  while (parser.hasMore()) {
    let value = parser.consumeNumberStringOrMarker();
    if (value === ICU_MARKER) {
      const text = parser.consumeString();
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createComment("${text}")`);
    } else if (value === ELEMENT_MARKER) {
      const text = parser.consumeString();
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createElement("${text}")`);
    } else if (typeof value === "string") {
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createTextNode("${value}")`);
    } else if (typeof value === "number") {
      const line = consumeOpCode(value);
      line && lines.push(line);
    } else {
      throw new Error("Unexpected value");
    }
  }
  return lines;
}
function i18nRemoveOpCodesToString(opcodes) {
  const removeCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i = 0; i < removeCodes.length; i++) {
    const nodeOrIcuIndex = removeCodes[i];
    if (nodeOrIcuIndex > 0) {
      lines.push(`remove(lView[${nodeOrIcuIndex}])`);
    } else {
      lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);
    }
  }
  return lines;
}
function replaceNgsp(value) {
  return value.replace(NGSP_UNICODE_REGEXP, " ");
}
function i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {
  const rootTNode = getCurrentParentTNode();
  const createOpCodes = [];
  const updateOpCodes = [];
  const existingTNodeStack = [[]];
  if (define_ngDevMode_default) {
    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  message = getTranslationForTemplate(message, subTemplateIndex);
  const msgParts = replaceNgsp(message).split(PH_REGEXP);
  for (let i = 0; i < msgParts.length; i++) {
    let value = msgParts[i];
    if ((i & 1) === 0) {
      const parts = i18nParseTextIntoPartsAndICU(value);
      for (let j = 0; j < parts.length; j++) {
        let part = parts[j];
        if ((j & 1) === 0) {
          const text = part;
          define_ngDevMode_default && assertString(text, "Parsed ICU part should be string");
          if (text !== "") {
            i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);
          }
        } else {
          const icuExpression = part;
          if (typeof icuExpression !== "object") {
            throw new Error(`Unable to parse ICU expression in "${message}" message.`);
          }
          const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, define_ngDevMode_default ? `ICU ${index}:${icuExpression.mainBinding}` : "", true);
          const icuNodeIndex = icuContainerTNode.index;
          define_ngDevMode_default && assertGreaterThanOrEqual(icuNodeIndex, HEADER_OFFSET, "Index must be in absolute LView offset");
          icuStart(tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);
        }
      }
    } else {
      const isClosing = value.charCodeAt(0) === 47;
      const type = value.charCodeAt(isClosing ? 1 : 0);
      define_ngDevMode_default && assertOneOf(
        type,
        42,
        35
      );
      const index2 = HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));
      if (isClosing) {
        existingTNodeStack.shift();
        setCurrentTNode(getCurrentParentTNode(), false);
      } else {
        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index2);
        existingTNodeStack.unshift([]);
        setCurrentTNode(tNode, true);
      }
    }
  }
  tView.data[index] = {
    create: createOpCodes,
    update: updateOpCodes
  };
}
function createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {
  const i18nNodeIdx = allocExpando(tView, lView, 1, null);
  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;
  let parentTNode = getCurrentParentTNode();
  if (rootTNode === parentTNode) {
    parentTNode = null;
  }
  if (parentTNode === null) {
    opCode |= I18nCreateOpCode.APPEND_EAGERLY;
  }
  if (isICU) {
    opCode |= I18nCreateOpCode.COMMENT;
    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);
  }
  createOpCodes.push(opCode, text === null ? "" : text);
  const tNode = createTNodeAtIndex(
    tView,
    i18nNodeIdx,
    isICU ? 32 : 1,
    text === null ? define_ngDevMode_default ? "{{?}}" : "" : text,
    null
  );
  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);
  const tNodeIdx = tNode.index;
  setCurrentTNode(
    tNode,
    false
  );
  if (parentTNode !== null && rootTNode !== parentTNode) {
    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);
  }
  return tNode;
}
function i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {
  const hasBinding = text.match(BINDING_REGEXP);
  const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);
  if (hasBinding) {
    generateBindingUpdateOpCodes(updateOpCodes, text, tNode.index, null, 0, null);
  }
}
function i18nAttributesFirstPass(tView, index, values) {
  const previousElement = getCurrentTNode();
  const previousElementIndex = previousElement.index;
  const updateOpCodes = [];
  if (define_ngDevMode_default) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  if (tView.firstCreatePass && tView.data[index] === null) {
    for (let i = 0; i < values.length; i += 2) {
      const attrName = values[i];
      const message = values[i + 1];
      if (message !== "") {
        if (ICU_REGEXP.test(message)) {
          throw new Error(`ICU expressions are not supported in attributes. Message: "${message}".`);
        }
        generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);
      }
    }
    tView.data[index] = updateOpCodes;
  }
}
function generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {
  define_ngDevMode_default && assertGreaterThanOrEqual(destinationNode, HEADER_OFFSET, "Index must be in absolute LView offset");
  const maskIndex = updateOpCodes.length;
  const sizeIndex = maskIndex + 1;
  updateOpCodes.push(null, null);
  const startIndex = maskIndex + 2;
  if (define_ngDevMode_default) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  const textParts = str.split(BINDING_REGEXP);
  let mask = 0;
  for (let j = 0; j < textParts.length; j++) {
    const textValue = textParts[j];
    if (j & 1) {
      const bindingIndex = bindingStart + parseInt(textValue, 10);
      updateOpCodes.push(-1 - bindingIndex);
      mask = mask | toMaskBit(bindingIndex);
    } else if (textValue !== "") {
      updateOpCodes.push(textValue);
    }
  }
  updateOpCodes.push(destinationNode << 2 | (attrName ? 1 : 0));
  if (attrName) {
    updateOpCodes.push(attrName, sanitizeFn);
  }
  updateOpCodes[maskIndex] = mask;
  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;
  return mask;
}
function countBindings(opCodes) {
  let count2 = 0;
  for (let i = 0; i < opCodes.length; i++) {
    const opCode = opCodes[i];
    if (typeof opCode === "number" && opCode < 0) {
      count2++;
    }
  }
  return count2;
}
function toMaskBit(bindingIndex) {
  return 1 << Math.min(bindingIndex, 31);
}
function isRootTemplateMessage(subTemplateIndex) {
  return subTemplateIndex === -1;
}
function removeInnerTemplateTranslation(message) {
  let match;
  let res = "";
  let index = 0;
  let inTemplate = false;
  let tagMatched;
  while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {
    if (!inTemplate) {
      res += message.substring(index, match.index + match[0].length);
      tagMatched = match[1];
      inTemplate = true;
    } else {
      if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {
        index = match.index;
        inTemplate = false;
      }
    }
  }
  define_ngDevMode_default && assertEqual(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation "${message}"`);
  res += message.slice(index);
  return res;
}
function getTranslationForTemplate(message, subTemplateIndex) {
  if (isRootTemplateMessage(subTemplateIndex)) {
    return removeInnerTemplateTranslation(message);
  } else {
    const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;
    const end = message.search(new RegExp(`${MARKER}\\/\\*\\d+:${subTemplateIndex}${MARKER}`));
    return removeInnerTemplateTranslation(message.substring(start, end));
  }
}
function icuStart(tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {
  define_ngDevMode_default && assertDefined(icuExpression, "ICU expression must be defined");
  let bindingMask = 0;
  const tIcu = {
    type: icuExpression.type,
    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),
    anchorIdx,
    cases: [],
    create: [],
    remove: [],
    update: []
  };
  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);
  setTIcu(tView, anchorIdx, tIcu);
  const values = icuExpression.values;
  for (let i = 0; i < values.length; i++) {
    const valueArr = values[i];
    const nestedIcus = [];
    for (let j = 0; j < valueArr.length; j++) {
      const value = valueArr[j];
      if (typeof value !== "string") {
        const icuIndex = nestedIcus.push(value) - 1;
        valueArr[j] = `<!--\uFFFD${icuIndex}\uFFFD-->`;
      }
    }
    bindingMask = parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(""), nestedIcus) | bindingMask;
  }
  if (bindingMask) {
    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);
  }
}
function parseICUBlock(pattern) {
  const cases = [];
  const values = [];
  let icuType = 1;
  let mainBinding = 0;
  pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str, binding, type) {
    if (type === "select") {
      icuType = 0;
    } else {
      icuType = 1;
    }
    mainBinding = parseInt(binding.slice(1), 10);
    return "";
  });
  const parts = i18nParseTextIntoPartsAndICU(pattern);
  for (let pos = 0; pos < parts.length; ) {
    let key = parts[pos++].trim();
    if (icuType === 1) {
      key = key.replace(/\s*(?:=)?(\w+)\s*/, "$1");
    }
    if (key.length) {
      cases.push(key);
    }
    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);
    if (cases.length > values.length) {
      values.push(blocks);
    }
  }
  return {
    type: icuType,
    mainBinding,
    cases,
    values
  };
}
function i18nParseTextIntoPartsAndICU(pattern) {
  if (!pattern) {
    return [];
  }
  let prevPos = 0;
  const braceStack = [];
  const results = [];
  const braces = /[{}]/g;
  braces.lastIndex = 0;
  let match;
  while (match = braces.exec(pattern)) {
    const pos = match.index;
    if (match[0] == "}") {
      braceStack.pop();
      if (braceStack.length == 0) {
        const block = pattern.substring(prevPos, pos);
        if (ICU_BLOCK_REGEXP.test(block)) {
          results.push(parseICUBlock(block));
        } else {
          results.push(block);
        }
        prevPos = pos + 1;
      }
    } else {
      if (braceStack.length == 0) {
        const substring2 = pattern.substring(prevPos, pos);
        results.push(substring2);
        prevPos = pos + 1;
      }
      braceStack.push("{");
    }
  }
  const substring = pattern.substring(prevPos);
  results.push(substring);
  return results;
}
function parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {
  const create = [];
  const remove2 = [];
  const update = [];
  if (define_ngDevMode_default) {
    attachDebugGetter(create, icuCreateOpCodesToString);
    attachDebugGetter(remove2, i18nRemoveOpCodesToString);
    attachDebugGetter(update, i18nUpdateOpCodesToString);
  }
  tIcu.cases.push(caseName);
  tIcu.create.push(create);
  tIcu.remove.push(remove2);
  tIcu.update.push(update);
  const inertBodyHelper2 = getInertBodyHelper(getDocument());
  const inertBodyElement = inertBodyHelper2.getInertBodyElement(unsafeCaseHtml);
  define_ngDevMode_default && assertDefined(inertBodyElement, "Unable to generate inert body element");
  const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;
  if (inertRootNode) {
    return walkIcuTree(tView, tIcu, lView, updateOpCodes, create, remove2, update, inertRootNode, parentIdx, nestedIcus, 0);
  } else {
    return 0;
  }
}
function walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, parentNode, parentIdx, nestedIcus, depth) {
  let bindingMask = 0;
  let currentNode = parentNode.firstChild;
  while (currentNode) {
    const newIndex = allocExpando(tView, lView, 1, null);
    switch (currentNode.nodeType) {
      case Node.ELEMENT_NODE:
        const element = currentNode;
        const tagName = element.tagName.toLowerCase();
        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {
          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);
          tView.data[newIndex] = tagName;
          const elAttrs = element.attributes;
          for (let i = 0; i < elAttrs.length; i++) {
            const attr = elAttrs.item(i);
            const lowerAttrName = attr.name.toLowerCase();
            const hasBinding2 = !!attr.value.match(BINDING_REGEXP);
            if (hasBinding2) {
              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {
                if (URI_ATTRS[lowerAttrName]) {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);
                } else if (SRCSET_ATTRS[lowerAttrName]) {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, sanitizeSrcset);
                } else {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);
                }
              } else {
                define_ngDevMode_default && console.warn(`WARNING: ignoring unsafe attribute value ${lowerAttrName} on element ${tagName} (see https://g.co/ng/security#xss)`);
              }
            } else {
              addCreateAttribute(create, newIndex, attr);
            }
          }
          bindingMask = walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, currentNode, newIndex, nestedIcus, depth + 1) | bindingMask;
          addRemoveNode(remove2, newIndex, depth);
        }
        break;
      case Node.TEXT_NODE:
        const value = currentNode.textContent || "";
        const hasBinding = value.match(BINDING_REGEXP);
        addCreateNodeAndAppend(create, null, hasBinding ? "" : value, parentIdx, newIndex);
        addRemoveNode(remove2, newIndex, depth);
        if (hasBinding) {
          bindingMask = generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;
        }
        break;
      case Node.COMMENT_NODE:
        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || "");
        if (isNestedIcu) {
          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);
          const icuExpression = nestedIcus[nestedIcuIndex];
          addCreateNodeAndAppend(create, ICU_MARKER, define_ngDevMode_default ? `nested ICU ${nestedIcuIndex}` : "", parentIdx, newIndex);
          icuStart(tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);
          addRemoveNestedIcu(remove2, newIndex, depth);
        }
        break;
    }
    currentNode = currentNode.nextSibling;
  }
  return bindingMask;
}
function addRemoveNode(remove2, index, depth) {
  if (depth === 0) {
    remove2.push(index);
  }
}
function addRemoveNestedIcu(remove2, index, depth) {
  if (depth === 0) {
    remove2.push(~index);
    remove2.push(index);
  }
}
function addUpdateIcuSwitch(update, icuExpression, index) {
  update.push(
    toMaskBit(icuExpression.mainBinding),
    2,
    -1 - icuExpression.mainBinding,
    index << 2 | 2
  );
}
function addUpdateIcuUpdate(update, bindingMask, index) {
  update.push(
    bindingMask,
    1,
    index << 2 | 3
  );
}
function addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {
  if (marker !== null) {
    create.push(marker);
  }
  create.push(text, createAtIdx, icuCreateOpCode(
    0,
    appendToParentIdx,
    createAtIdx
  ));
}
function addCreateAttribute(create, newIndex, attr) {
  create.push(
    newIndex << 1 | 1,
    attr.name,
    attr.value
  );
}
function i18nPostprocess(message, replacements = {}) {
  let result = message;
  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {
    const matches = {};
    const templateIdsStack = [ROOT_TEMPLATE_ID];
    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {
      const content = phs || tmpl;
      const placeholders = matches[content] || [];
      if (!placeholders.length) {
        content.split("|").forEach((placeholder2) => {
          const match = placeholder2.match(PP_TEMPLATE_ID_REGEXP);
          const templateId2 = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;
          const isCloseTemplateTag2 = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder2);
          placeholders.push([templateId2, isCloseTemplateTag2, placeholder2]);
        });
        matches[content] = placeholders;
      }
      if (!placeholders.length) {
        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);
      }
      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];
      let idx = 0;
      for (let i = 0; i < placeholders.length; i++) {
        if (placeholders[i][0] === currentTemplateId) {
          idx = i;
          break;
        }
      }
      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];
      if (isCloseTemplateTag) {
        templateIdsStack.pop();
      } else if (currentTemplateId !== templateId) {
        templateIdsStack.push(templateId);
      }
      placeholders.splice(idx, 1);
      return placeholder;
    });
  }
  if (!Object.keys(replacements).length) {
    return result;
  }
  result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end) => {
    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;
  });
  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key) => {
    return replacements.hasOwnProperty(key) ? replacements[key] : match;
  });
  result = result.replace(PP_ICUS_REGEXP, (match, key) => {
    if (replacements.hasOwnProperty(key)) {
      const list = replacements[key];
      if (!list.length) {
        throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);
      }
      return list.shift();
    }
    return match;
  });
  return result;
}
function \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex = -1) {
  const tView = getTView();
  const lView = getLView();
  const adjustedIndex = HEADER_OFFSET + index;
  define_ngDevMode_default && assertDefined(tView, `tView should be defined`);
  const message = getConstant(tView.consts, messageIndex);
  const parentTNode = getCurrentParentTNode();
  if (tView.firstCreatePass) {
    i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);
  }
  const tI18n = tView.data[adjustedIndex];
  const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;
  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);
  const insertInFrontOf = parentTNode && parentTNode.type & 8 ? lView[parentTNode.index] : null;
  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);
  setInI18nBlock(true);
}
function \u0275\u0275i18nEnd() {
  setInI18nBlock(false);
}
function \u0275\u0275i18n(index, messageIndex, subTemplateIndex) {
  \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex);
  \u0275\u0275i18nEnd();
}
function \u0275\u0275i18nAttributes(index, attrsIndex) {
  const tView = getTView();
  define_ngDevMode_default && assertDefined(tView, `tView should be defined`);
  const attrs = getConstant(tView.consts, attrsIndex);
  i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);
}
function \u0275\u0275i18nExp(value) {
  const lView = getLView();
  setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));
  return \u0275\u0275i18nExp;
}
function \u0275\u0275i18nApply(index) {
  applyI18n(getTView(), getLView(), index + HEADER_OFFSET);
}
function \u0275\u0275i18nPostprocess(message, replacements = {}) {
  return i18nPostprocess(message, replacements);
}
function providersResolver(def, providers, viewProviders) {
  const tView = getTView();
  if (tView.firstCreatePass) {
    const isComponent = isComponentDef(def);
    resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent, true);
    resolveProvider(providers, tView.data, tView.blueprint, isComponent, false);
  }
}
function resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent, isViewProvider) {
  provider = resolveForwardRef(provider);
  if (Array.isArray(provider)) {
    for (let i = 0; i < provider.length; i++) {
      resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider);
    }
  } else {
    const tView = getTView();
    const lView = getLView();
    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);
    let providerFactory = providerToFactory(provider);
    const tNode = getCurrentTNode();
    const beginIndex = tNode.providerIndexes & 1048575;
    const endIndex = tNode.directiveStart;
    const cptViewProvidersCount = tNode.providerIndexes >> 20;
    if (isTypeProvider(provider) || !provider.multi) {
      const factory = new NodeInjectorFactory(providerFactory, isViewProvider, \u0275\u0275directiveInject);
      const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);
      if (existingFactoryIndex === -1) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        lInjectablesBlueprint[existingFactoryIndex] = factory;
        lView[existingFactoryIndex] = factory;
      }
    } else {
      const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);
      const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);
      const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];
      const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];
      if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory);
        if (!isViewProvider && doesViewProvidersFactoryExist) {
          lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;
        }
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent);
        registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex : existingViewProvidersFactoryIndex, indexInFactory);
      }
      if (!isViewProvider && isComponent && doesViewProvidersFactoryExist) {
        lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
      }
    }
  }
}
function registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {
  const providerIsTypeProvider = isTypeProvider(provider);
  const providerIsClassProvider = isClassProvider(provider);
  if (providerIsTypeProvider || providerIsClassProvider) {
    const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;
    const prototype = classToken.prototype;
    const ngOnDestroy = prototype.ngOnDestroy;
    if (ngOnDestroy) {
      const hooks = tView.destroyHooks || (tView.destroyHooks = []);
      if (!providerIsTypeProvider && provider.multi) {
        define_ngDevMode_default && assertDefined(indexInFactory, "indexInFactory when registering multi factory destroy hook");
        const existingCallbacksIndex = hooks.indexOf(contextIndex);
        if (existingCallbacksIndex === -1) {
          hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);
        } else {
          hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);
        }
      } else {
        hooks.push(contextIndex, ngOnDestroy);
      }
    }
  }
}
function multiFactoryAdd(multiFactory2, factory, isComponentProvider) {
  if (isComponentProvider) {
    multiFactory2.componentProviders++;
  }
  return multiFactory2.multi.push(factory) - 1;
}
function indexOf(item, arr, begin, end) {
  for (let i = begin; i < end; i++) {
    if (arr[i] === item)
      return i;
  }
  return -1;
}
function multiProvidersFactoryResolver(_, tData, lData, tNode) {
  return multiResolve(this.multi, []);
}
function multiViewProvidersFactoryResolver(_, tData, lView, tNode) {
  const factories = this.multi;
  let result;
  if (this.providerFactory) {
    const componentCount = this.providerFactory.componentProviders;
    const multiProviders = getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode);
    result = multiProviders.slice(0, componentCount);
    multiResolve(factories, result);
    for (let i = componentCount; i < multiProviders.length; i++) {
      result.push(multiProviders[i]);
    }
  } else {
    result = [];
    multiResolve(factories, result);
  }
  return result;
}
function multiResolve(factories, result) {
  for (let i = 0; i < factories.length; i++) {
    const factory = factories[i];
    result.push(factory());
  }
  return result;
}
function multiFactory(factoryFn, index, isViewProvider, isComponent, f) {
  const factory = new NodeInjectorFactory(factoryFn, isViewProvider, \u0275\u0275directiveInject);
  factory.multi = [];
  factory.index = index;
  factory.componentProviders = 0;
  multiFactoryAdd(factory, f, isComponent && !isViewProvider);
  return factory;
}
function \u0275\u0275ProvidersFeature(providers, viewProviders = []) {
  return (definition) => {
    definition.providersResolver = (def, processProvidersFn) => {
      return providersResolver(
        def,
        processProvidersFn ? processProvidersFn(providers) : providers,
        viewProviders
      );
    };
  };
}
function createNgModule(ngModule, parentInjector) {
  return new NgModuleRef(ngModule, parentInjector !== null && parentInjector !== void 0 ? parentInjector : null);
}
function createEnvironmentInjector(providers, parent, debugName = null) {
  const adapter = new EnvironmentNgModuleRefAdapter(providers, parent, debugName);
  return adapter.injector;
}
function \u0275\u0275StandaloneFeature(definition) {
  definition.getStandaloneInjector = (parentInjector) => {
    return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(definition);
  };
}
function getComponent(element) {
  define_ngDevMode_default && assertDomElement(element);
  const context2 = getLContext(element);
  if (context2 === null)
    return null;
  if (context2.component === void 0) {
    const lView = context2.lView;
    if (lView === null) {
      return null;
    }
    context2.component = getComponentAtNodeIndex(context2.nodeIndex, lView);
  }
  return context2.component;
}
function getContext(element) {
  assertDomElement(element);
  const context2 = getLContext(element);
  const lView = context2 ? context2.lView : null;
  return lView === null ? null : lView[CONTEXT];
}
function getOwningComponent(elementOrDir) {
  const context2 = getLContext(elementOrDir);
  let lView = context2 ? context2.lView : null;
  if (lView === null)
    return null;
  let parent;
  while (lView[TVIEW].type === 2 && (parent = getLViewParent(lView))) {
    lView = parent;
  }
  return lView[FLAGS] & 256 ? null : lView[CONTEXT];
}
function getRootComponents(elementOrDir) {
  const lView = readPatchedLView(elementOrDir);
  return lView !== null ? [...getRootContext(lView).components] : [];
}
function getInjector(elementOrDir) {
  const context2 = getLContext(elementOrDir);
  const lView = context2 ? context2.lView : null;
  if (lView === null)
    return Injector.NULL;
  const tNode = lView[TVIEW].data[context2.nodeIndex];
  return new NodeInjector(tNode, lView);
}
function getInjectionTokens(element) {
  const context2 = getLContext(element);
  const lView = context2 ? context2.lView : null;
  if (lView === null)
    return [];
  const tView = lView[TVIEW];
  const tNode = tView.data[context2.nodeIndex];
  const providerTokens = [];
  const startIndex = tNode.providerIndexes & 1048575;
  const endIndex = tNode.directiveEnd;
  for (let i = startIndex; i < endIndex; i++) {
    let value = tView.data[i];
    if (isDirectiveDefHack(value)) {
      value = value.type;
    }
    providerTokens.push(value);
  }
  return providerTokens;
}
function getDirectives(node) {
  if (node instanceof Text) {
    return [];
  }
  const context2 = getLContext(node);
  const lView = context2 ? context2.lView : null;
  if (lView === null) {
    return [];
  }
  const tView = lView[TVIEW];
  const nodeIndex = context2.nodeIndex;
  if (!(tView === null || tView === void 0 ? void 0 : tView.data[nodeIndex])) {
    return [];
  }
  if (context2.directives === void 0) {
    context2.directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);
  }
  return context2.directives === null ? [] : [...context2.directives];
}
function getDirectiveMetadata$1(directiveOrComponentInstance) {
  const {
    constructor
  } = directiveOrComponentInstance;
  if (!constructor) {
    throw new Error("Unable to find the instance constructor");
  }
  const componentDef = getComponentDef(constructor);
  if (componentDef) {
    return {
      inputs: componentDef.inputs,
      outputs: componentDef.outputs,
      encapsulation: componentDef.encapsulation,
      changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush : ChangeDetectionStrategy.Default
    };
  }
  const directiveDef = getDirectiveDef(constructor);
  if (directiveDef) {
    return {
      inputs: directiveDef.inputs,
      outputs: directiveDef.outputs
    };
  }
  return null;
}
function getLocalRefs(target) {
  const context2 = getLContext(target);
  if (context2 === null)
    return {};
  if (context2.localRefs === void 0) {
    const lView = context2.lView;
    if (lView === null) {
      return {};
    }
    context2.localRefs = discoverLocalRefs(lView, context2.nodeIndex);
  }
  return context2.localRefs || {};
}
function getHostElement(componentOrDirective) {
  return getLContext(componentOrDirective).native;
}
function getListeners(element) {
  define_ngDevMode_default && assertDomElement(element);
  const lContext = getLContext(element);
  const lView = lContext === null ? null : lContext.lView;
  if (lView === null)
    return [];
  const tView = lView[TVIEW];
  const lCleanup = lView[CLEANUP];
  const tCleanup = tView.cleanup;
  const listeners = [];
  if (tCleanup && lCleanup) {
    for (let i = 0; i < tCleanup.length; ) {
      const firstParam = tCleanup[i++];
      const secondParam = tCleanup[i++];
      if (typeof firstParam === "string") {
        const name = firstParam;
        const listenerElement = unwrapRNode(lView[secondParam]);
        const callback = lCleanup[tCleanup[i++]];
        const useCaptureOrIndx = tCleanup[i++];
        const type = typeof useCaptureOrIndx === "boolean" || useCaptureOrIndx >= 0 ? "dom" : "output";
        const useCapture = typeof useCaptureOrIndx === "boolean" ? useCaptureOrIndx : false;
        if (element == listenerElement) {
          listeners.push({
            element,
            name,
            callback,
            useCapture,
            type
          });
        }
      }
    }
  }
  listeners.sort(sortListeners);
  return listeners;
}
function sortListeners(a, b) {
  if (a.name == b.name)
    return 0;
  return a.name < b.name ? -1 : 1;
}
function isDirectiveDefHack(obj) {
  return obj.type !== void 0 && obj.template !== void 0 && obj.declaredInputs !== void 0;
}
function assertDomElement(value) {
  if (typeof Element !== "undefined" && !(value instanceof Element)) {
    throw new Error("Expecting instance of DOM Element");
  }
}
function setClassMetadata(type, decorators, ctorParameters, propDecorators) {
  return noSideEffects(() => {
    const clazz = type;
    if (decorators !== null) {
      if (clazz.hasOwnProperty("decorators") && clazz.decorators !== void 0) {
        clazz.decorators.push(...decorators);
      } else {
        clazz.decorators = decorators;
      }
    }
    if (ctorParameters !== null) {
      clazz.ctorParameters = ctorParameters;
    }
    if (propDecorators !== null) {
      if (clazz.hasOwnProperty("propDecorators") && clazz.propDecorators !== void 0) {
        clazz.propDecorators = Object.assign(Object.assign({}, clazz.propDecorators), propDecorators);
      } else {
        clazz.propDecorators = propDecorators;
      }
    }
  });
}
function \u0275\u0275pureFunction0(slotOffset, pureFn, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  return lView[bindingIndex] === NO_CHANGE ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) : getBinding(lView, bindingIndex);
}
function \u0275\u0275pureFunction1(slotOffset, pureFn, exp, thisArg) {
  return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);
}
function \u0275\u0275pureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
  return pureFunction2Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);
}
function \u0275\u0275pureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  return pureFunction3Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);
}
function \u0275\u0275pureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  return pureFunction4Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);
}
function \u0275\u0275pureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) : pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);
}
function \u0275\u0275pureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);
}
function \u0275\u0275pureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);
}
function \u0275\u0275pureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);
}
function \u0275\u0275pureFunctionV(slotOffset, pureFn, exps, thisArg) {
  return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);
}
function getPureFunctionReturnValue(lView, returnValueIndex) {
  define_ngDevMode_default && assertIndexInRange(lView, returnValueIndex);
  const lastReturnValue = lView[returnValueIndex];
  return lastReturnValue === NO_CHANGE ? void 0 : lastReturnValue;
}
function pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getPureFunctionReturnValue(lView, bindingIndex + 1);
}
function pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getPureFunctionReturnValue(lView, bindingIndex + 2);
}
function pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getPureFunctionReturnValue(lView, bindingIndex + 3);
}
function pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getPureFunctionReturnValue(lView, bindingIndex + 4);
}
function pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {
  let bindingIndex = bindingRoot + slotOffset;
  let different = false;
  for (let i = 0; i < exps.length; i++) {
    bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);
  }
  return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getPureFunctionReturnValue(lView, bindingIndex);
}
function \u0275\u0275pipe(index, pipeName) {
  const tView = getTView();
  let pipeDef;
  const adjustedIndex = index + HEADER_OFFSET;
  if (tView.firstCreatePass) {
    pipeDef = getPipeDef(pipeName, tView.pipeRegistry);
    tView.data[adjustedIndex] = pipeDef;
    if (pipeDef.onDestroy) {
      (tView.destroyHooks || (tView.destroyHooks = [])).push(adjustedIndex, pipeDef.onDestroy);
    }
  } else {
    pipeDef = tView.data[adjustedIndex];
  }
  const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));
  const previousInjectImplementation = setInjectImplementation(\u0275\u0275directiveInject);
  try {
    const previousIncludeViewProviders = setIncludeViewProviders(false);
    const pipeInstance = pipeFactory();
    setIncludeViewProviders(previousIncludeViewProviders);
    store(tView, getLView(), adjustedIndex, pipeInstance);
    return pipeInstance;
  } finally {
    setInjectImplementation(previousInjectImplementation);
  }
}
function getPipeDef(name, registry) {
  if (registry) {
    for (let i = registry.length - 1; i >= 0; i--) {
      const pipeDef = registry[i];
      if (name === pipeDef.name) {
        return pipeDef;
      }
    }
  }
  if (define_ngDevMode_default) {
    throw new RuntimeError(
      -302,
      getPipeNotFoundErrorMessage(name)
    );
  }
}
function getPipeNotFoundErrorMessage(name) {
  const lView = getLView();
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context2 = declarationLView[CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context2 ? ` in the '${context2.constructor.name}' component` : "";
  const verifyMessage = `Verify that it is ${hostIsStandalone ? "included in the '@Component.imports' of this component" : "declared or imported in this module"}`;
  const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function \u0275\u0275pipeBind1(index, slotOffset, v1) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction1Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1);
}
function \u0275\u0275pipeBind2(index, slotOffset, v1, v2) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction2Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) : pipeInstance.transform(v1, v2);
}
function \u0275\u0275pipeBind3(index, slotOffset, v1, v2, v3) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction3Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) : pipeInstance.transform(v1, v2, v3);
}
function \u0275\u0275pipeBind4(index, slotOffset, v1, v2, v3, v4) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) : pipeInstance.transform(v1, v2, v3, v4);
}
function \u0275\u0275pipeBindV(index, slotOffset, values) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunctionVInternal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values);
}
function isPure(lView, index) {
  return lView[TVIEW].data[index].pure;
}
function _wrapInTimeout(fn2) {
  return (value) => {
    setTimeout(fn2, void 0, value);
  };
}
function symbolIterator() {
  return this._results[getSymbolIterator2()]();
}
function injectTemplateRef() {
  return createTemplateRef(getCurrentTNode(), getLView());
}
function createTemplateRef(hostTNode, hostLView) {
  if (hostTNode.type & 4) {
    define_ngDevMode_default && assertDefined(hostTNode.tViews, "TView must be allocated");
    return new R3TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));
  }
  return null;
}
function injectViewContainerRef() {
  const previousTNode = getCurrentTNode();
  return createContainerRef(previousTNode, getLView());
}
function getViewRefs(lContainer) {
  return lContainer[VIEW_REFS];
}
function getOrCreateViewRefs(lContainer) {
  return lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []);
}
function createContainerRef(hostTNode, hostLView) {
  define_ngDevMode_default && assertTNodeType(
    hostTNode,
    12 | 3
  );
  let lContainer;
  const slotValue = hostLView[hostTNode.index];
  if (isLContainer(slotValue)) {
    lContainer = slotValue;
  } else {
    let commentNode;
    if (hostTNode.type & 8) {
      commentNode = unwrapRNode(slotValue);
    } else {
      const renderer = hostLView[RENDERER];
      define_ngDevMode_default && define_ngDevMode_default.rendererCreateComment++;
      commentNode = renderer.createComment(define_ngDevMode_default ? "container" : "");
      const hostNative = getNativeByTNode(hostTNode, hostLView);
      const parentOfHostNative = nativeParentNode(renderer, hostNative);
      nativeInsertBefore(renderer, parentOfHostNative, commentNode, nativeNextSibling(renderer, hostNative), false);
    }
    hostLView[hostTNode.index] = lContainer = createLContainer(slotValue, hostLView, commentNode, hostTNode);
    addToViewTree(hostLView, lContainer);
  }
  return new R3ViewContainerRef(lContainer, hostTNode, hostLView);
}
function getIdxOfMatchingSelector(tNode, selector) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    for (let i = 0; i < localNames.length; i += 2) {
      if (localNames[i] === selector) {
        return localNames[i + 1];
      }
    }
  }
  return null;
}
function createResultByTNodeType(tNode, currentView) {
  if (tNode.type & (3 | 8)) {
    return createElementRef(tNode, currentView);
  } else if (tNode.type & 4) {
    return createTemplateRef(tNode, currentView);
  }
  return null;
}
function createResultForNode(lView, tNode, matchingIdx, read) {
  if (matchingIdx === -1) {
    return createResultByTNodeType(tNode, lView);
  } else if (matchingIdx === -2) {
    return createSpecialToken(lView, tNode, read);
  } else {
    return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);
  }
}
function createSpecialToken(lView, tNode, read) {
  if (read === ElementRef) {
    return createElementRef(tNode, lView);
  } else if (read === TemplateRef) {
    return createTemplateRef(tNode, lView);
  } else if (read === ViewContainerRef) {
    define_ngDevMode_default && assertTNodeType(
      tNode,
      3 | 12
    );
    return createContainerRef(tNode, lView);
  } else {
    define_ngDevMode_default && throwError2(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`);
  }
}
function materializeViewResults(tView, lView, tQuery, queryIndex) {
  const lQuery = lView[QUERIES].queries[queryIndex];
  if (lQuery.matches === null) {
    const tViewData = tView.data;
    const tQueryMatches = tQuery.matches;
    const result = [];
    for (let i = 0; i < tQueryMatches.length; i += 2) {
      const matchedNodeIdx = tQueryMatches[i];
      if (matchedNodeIdx < 0) {
        result.push(null);
      } else {
        define_ngDevMode_default && assertIndexInRange(tViewData, matchedNodeIdx);
        const tNode = tViewData[matchedNodeIdx];
        result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));
      }
    }
    lQuery.matches = result;
  }
  return lQuery.matches;
}
function collectQueryResults(tView, lView, queryIndex, result) {
  const tQuery = tView.queries.getByIndex(queryIndex);
  const tQueryMatches = tQuery.matches;
  if (tQueryMatches !== null) {
    const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);
    for (let i = 0; i < tQueryMatches.length; i += 2) {
      const tNodeIdx = tQueryMatches[i];
      if (tNodeIdx > 0) {
        result.push(lViewResults[i / 2]);
      } else {
        const childQueryIndex = tQueryMatches[i + 1];
        const declarationLContainer = lView[-tNodeIdx];
        define_ngDevMode_default && assertLContainer(declarationLContainer);
        for (let i2 = CONTAINER_HEADER_OFFSET; i2 < declarationLContainer.length; i2++) {
          const embeddedLView = declarationLContainer[i2];
          if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {
            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
        if (declarationLContainer[MOVED_VIEWS] !== null) {
          const embeddedLViews = declarationLContainer[MOVED_VIEWS];
          for (let i2 = 0; i2 < embeddedLViews.length; i2++) {
            const embeddedLView = embeddedLViews[i2];
            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
      }
    }
  }
  return result;
}
function \u0275\u0275queryRefresh(queryList) {
  const lView = getLView();
  const tView = getTView();
  const queryIndex = getCurrentQueryIndex();
  setCurrentQueryIndex(queryIndex + 1);
  const tQuery = getTQuery(tView, queryIndex);
  if (queryList.dirty && isCreationMode(lView) === ((tQuery.metadata.flags & 2) === 2)) {
    if (tQuery.matches === null) {
      queryList.reset([]);
    } else {
      const result = tQuery.crossesNgTemplate ? collectQueryResults(tView, lView, queryIndex, []) : materializeViewResults(tView, lView, tQuery, queryIndex);
      queryList.reset(result, unwrapElementRef);
      queryList.notifyOnChanges();
    }
    return true;
  }
  return false;
}
function \u0275\u0275viewQuery(predicate, flags, read) {
  define_ngDevMode_default && assertNumber(flags, "Expecting flags");
  const tView = getTView();
  if (tView.firstCreatePass) {
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);
    if ((flags & 2) === 2) {
      tView.staticViewQueries = true;
    }
  }
  createLQuery(tView, getLView(), flags);
}
function \u0275\u0275contentQuery(directiveIndex, predicate, flags, read) {
  define_ngDevMode_default && assertNumber(flags, "Expecting flags");
  const tView = getTView();
  if (tView.firstCreatePass) {
    const tNode = getCurrentTNode();
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);
    saveContentQueryAndDirectiveIndex(tView, directiveIndex);
    if ((flags & 2) === 2) {
      tView.staticContentQueries = true;
    }
  }
  createLQuery(tView, getLView(), flags);
}
function \u0275\u0275loadQuery() {
  return loadQueryInternal(getLView(), getCurrentQueryIndex());
}
function loadQueryInternal(lView, queryIndex) {
  define_ngDevMode_default && assertDefined(lView[QUERIES], "LQueries should be defined when trying to load a query");
  define_ngDevMode_default && assertIndexInRange(lView[QUERIES].queries, queryIndex);
  return lView[QUERIES].queries[queryIndex].queryList;
}
function createLQuery(tView, lView, flags) {
  const queryList = new QueryList(
    (flags & 4) === 4
  );
  storeCleanupWithContext(tView, lView, queryList, queryList.destroy);
  if (lView[QUERIES] === null)
    lView[QUERIES] = new LQueries_();
  lView[QUERIES].queries.push(new LQuery_(queryList));
}
function createTQuery(tView, metadata, nodeIndex) {
  if (tView.queries === null)
    tView.queries = new TQueries_();
  tView.queries.track(new TQuery_(metadata, nodeIndex));
}
function saveContentQueryAndDirectiveIndex(tView, directiveIndex) {
  const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
  const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;
  if (directiveIndex !== lastSavedDirectiveIndex) {
    tViewContentQueries.push(tView.queries.length - 1, directiveIndex);
  }
}
function getTQuery(tView, index) {
  define_ngDevMode_default && assertDefined(tView.queries, "TQueries must be defined to retrieve a TQuery");
  return tView.queries.getByIndex(index);
}
function \u0275\u0275templateRefExtractor(tNode, lView) {
  return createTemplateRef(tNode, lView);
}
function setJitOptions(options) {
  if (jitOptions !== null) {
    if (options.defaultEncapsulation !== jitOptions.defaultEncapsulation) {
      define_ngDevMode_default && console.error("Provided value for `defaultEncapsulation` can not be changed once it has been set.");
      return;
    }
    if (options.preserveWhitespaces !== jitOptions.preserveWhitespaces) {
      define_ngDevMode_default && console.error("Provided value for `preserveWhitespaces` can not be changed once it has been set.");
      return;
    }
  }
  jitOptions = options;
}
function getJitOptions() {
  return jitOptions;
}
function resetJitOptions() {
  jitOptions = null;
}
function patchModuleCompilation() {
}
function isModuleWithProviders(value) {
  return value.ngModule !== void 0;
}
function isNgModule(value) {
  return !!getNgModuleDef(value);
}
function enqueueModuleForDelayedScoping(moduleType, ngModule) {
  moduleQueue.push({
    moduleType,
    ngModule
  });
}
function flushModuleScopingQueueAsMuchAsPossible() {
  if (!flushingModuleQueue) {
    flushingModuleQueue = true;
    try {
      for (let i = moduleQueue.length - 1; i >= 0; i--) {
        const {
          moduleType,
          ngModule
        } = moduleQueue[i];
        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {
          moduleQueue.splice(i, 1);
          setScopeOnDeclaredComponents(moduleType, ngModule);
        }
      }
    } finally {
      flushingModuleQueue = false;
    }
  }
}
function isResolvedDeclaration(declaration) {
  if (Array.isArray(declaration)) {
    return declaration.every(isResolvedDeclaration);
  }
  return !!resolveForwardRef(declaration);
}
function compileNgModule(moduleType, ngModule = {}) {
  patchModuleCompilation();
  compileNgModuleDefs(moduleType, ngModule);
  if (ngModule.id !== void 0) {
    registerNgModuleType(moduleType, ngModule.id);
  }
  enqueueModuleForDelayedScoping(moduleType, ngModule);
}
function compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {
  define_ngDevMode_default && assertDefined(moduleType, "Required value moduleType");
  define_ngDevMode_default && assertDefined(ngModule, "Required value ngModule");
  const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
  let ngModuleDef = null;
  Object.defineProperty(moduleType, NG_MOD_DEF, {
    configurable: true,
    get: () => {
      if (ngModuleDef === null) {
        if (define_ngDevMode_default && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {
          throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);
        }
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/\u0275mod.js`, {
          type: moduleType,
          bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),
          declarations: declarations.map(resolveForwardRef),
          imports: flatten(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
          exports: flatten(ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
          schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,
          id: ngModule.id || null
        });
        if (!ngModuleDef.schemas) {
          ngModuleDef.schemas = [];
        }
      }
      return ngModuleDef;
    }
  });
  let ngFactoryDef = null;
  Object.defineProperty(moduleType, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/\u0275fac.js`, {
          name: moduleType.name,
          type: moduleType,
          deps: reflectDependencies(moduleType),
          target: compiler.FactoryTarget.NgModule,
          typeArgumentCount: 0
        });
      }
      return ngFactoryDef;
    },
    configurable: !!define_ngDevMode_default
  });
  let ngInjectorDef = null;
  Object.defineProperty(moduleType, NG_INJ_DEF, {
    get: () => {
      if (ngInjectorDef === null) {
        define_ngDevMode_default && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);
        const meta = {
          name: moduleType.name,
          type: moduleType,
          providers: ngModule.providers || EMPTY_ARRAY,
          imports: [(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef), (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef)]
        };
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngInjectorDef = compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/\u0275inj.js`, meta);
      }
      return ngInjectorDef;
    },
    configurable: !!define_ngDevMode_default
  });
}
function isStandalone(type) {
  const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
  return def !== null ? def.standalone : false;
}
function generateStandaloneInDeclarationsError(type, location2) {
  const prefix = `Unexpected "${stringifyForError(type)}" found in the "declarations" array of the`;
  const suffix = `"${stringifyForError(type)}" is marked as standalone and can't be declared in any NgModule - did you intend to import it instead (by adding it to the "imports" array)?`;
  return `${prefix} ${location2}, ${suffix}`;
}
function verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {
  if (verifiedNgModule.get(moduleType))
    return;
  if (isStandalone(moduleType))
    return;
  verifiedNgModule.set(moduleType, true);
  moduleType = resolveForwardRef(moduleType);
  let ngModuleDef;
  if (importingModule) {
    ngModuleDef = getNgModuleDef(moduleType);
    if (!ngModuleDef) {
      throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
    }
  } else {
    ngModuleDef = getNgModuleDef(moduleType, true);
  }
  const errors = [];
  const declarations = maybeUnwrapFn(ngModuleDef.declarations);
  const imports = maybeUnwrapFn(ngModuleDef.imports);
  flatten(imports).map(unwrapModuleWithProvidersImports).forEach((modOrStandaloneCmpt) => {
    verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);
    verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);
  });
  const exports = maybeUnwrapFn(ngModuleDef.exports);
  declarations.forEach(verifyDeclarationsHaveDefinitions);
  declarations.forEach(verifyDirectivesHaveSelector);
  declarations.forEach((declarationType) => verifyNotStandalone(declarationType, moduleType));
  const combinedDeclarations = [...declarations.map(resolveForwardRef), ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef)];
  exports.forEach(verifyExportsAreDeclaredOrReExported);
  declarations.forEach((decl) => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));
  declarations.forEach(verifyComponentEntryComponentsIsPartOfNgModule);
  const ngModule = getAnnotation(moduleType, "NgModule");
  if (ngModule) {
    ngModule.imports && flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach((mod) => {
      verifySemanticsOfNgModuleImport(mod, moduleType);
      verifySemanticsOfNgModuleDef(mod, false, moduleType);
    });
    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);
    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);
    ngModule.entryComponents && deepForEach(ngModule.entryComponents, verifyComponentIsPartOfNgModule);
  }
  if (errors.length) {
    throw new Error(errors.join("\n"));
  }
  function verifyDeclarationsHaveDefinitions(type) {
    type = resolveForwardRef(type);
    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
    if (!def) {
      errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);
    }
  }
  function verifyDirectivesHaveSelector(type) {
    type = resolveForwardRef(type);
    const def = getDirectiveDef(type);
    if (!getComponentDef(type) && def && def.selectors.length == 0) {
      errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);
    }
  }
  function verifyNotStandalone(type, moduleType2) {
    type = resolveForwardRef(type);
    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
    if (def === null || def === void 0 ? void 0 : def.standalone) {
      const location2 = `"${stringifyForError(moduleType2)}" NgModule`;
      errors.push(generateStandaloneInDeclarationsError(type, location2));
    }
  }
  function verifyExportsAreDeclaredOrReExported(type) {
    type = resolveForwardRef(type);
    const kind = getComponentDef(type) && "component" || getDirectiveDef(type) && "directive" || getPipeDef$1(type) && "pipe";
    if (kind) {
      if (combinedDeclarations.lastIndexOf(type) === -1) {
        errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`);
      }
    }
  }
  function verifyDeclarationIsUnique(type, suppressErrors) {
    type = resolveForwardRef(type);
    const existingModule = ownerNgModule.get(type);
    if (existingModule && existingModule !== moduleType) {
      if (!suppressErrors) {
        const modules2 = [existingModule, moduleType].map(stringifyForError).sort();
        errors.push(`Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${modules2[0]} and ${modules2[1]}! Please consider moving ${stringifyForError(type)} to a higher module that imports ${modules2[0]} and ${modules2[1]}. You can also create a new NgModule that exports and includes ${stringifyForError(type)} then import that NgModule in ${modules2[0]} and ${modules2[1]}.`);
      }
    } else {
      ownerNgModule.set(type, moduleType);
    }
  }
  function verifyComponentIsPartOfNgModule(type) {
    type = resolveForwardRef(type);
    const existingModule = ownerNgModule.get(type);
    if (!existingModule && !isStandalone(type)) {
      errors.push(`Component ${stringifyForError(type)} is not part of any NgModule or the module has not been imported into your module.`);
    }
  }
  function verifyCorrectBootstrapType(type) {
    type = resolveForwardRef(type);
    if (!getComponentDef(type)) {
      errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);
    }
    if (isStandalone(type)) {
      errors.push(`The \`${stringifyForError(type)}\` class is a standalone component, which can not be used in the \`@NgModule.bootstrap\` array. Use the \`bootstrapApplication\` function for bootstrap instead.`);
    }
  }
  function verifyComponentEntryComponentsIsPartOfNgModule(type) {
    type = resolveForwardRef(type);
    if (getComponentDef(type)) {
      const component = getAnnotation(type, "Component");
      if (component && component.entryComponents) {
        deepForEach(component.entryComponents, verifyComponentIsPartOfNgModule);
      }
    }
  }
  function verifySemanticsOfNgModuleImport(type, importingModule2) {
    type = resolveForwardRef(type);
    const directiveDef = getComponentDef(type) || getDirectiveDef(type);
    if (directiveDef !== null && !directiveDef.standalone) {
      throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
    }
    const pipeDef = getPipeDef$1(type);
    if (pipeDef !== null && !pipeDef.standalone) {
      throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
    }
  }
}
function unwrapModuleWithProvidersImports(typeOrWithProviders) {
  typeOrWithProviders = resolveForwardRef(typeOrWithProviders);
  return typeOrWithProviders.ngModule || typeOrWithProviders;
}
function getAnnotation(type, name) {
  let annotation = null;
  collect(type.__annotations__);
  collect(type.decorators);
  return annotation;
  function collect(annotations) {
    if (annotations) {
      annotations.forEach(readAnnotation);
    }
  }
  function readAnnotation(decorator) {
    if (!annotation) {
      const proto = Object.getPrototypeOf(decorator);
      if (proto.ngMetadataName == name) {
        annotation = decorator;
      } else if (decorator.type) {
        const proto2 = Object.getPrototypeOf(decorator.type);
        if (proto2.ngMetadataName == name) {
          annotation = decorator.args[0];
        }
      }
    }
  }
}
function resetCompiledComponents() {
  ownerNgModule = /* @__PURE__ */ new WeakMap();
  verifiedNgModule = /* @__PURE__ */ new WeakMap();
  moduleQueue.length = 0;
}
function computeCombinedExports(type) {
  type = resolveForwardRef(type);
  const ngModuleDef = getNgModuleDef(type);
  if (ngModuleDef === null) {
    return [type];
  }
  return [...flatten(maybeUnwrapFn(ngModuleDef.exports).map((type2) => {
    const ngModuleDef2 = getNgModuleDef(type2);
    if (ngModuleDef2) {
      verifySemanticsOfNgModuleDef(type2, false);
      return computeCombinedExports(type2);
    } else {
      return type2;
    }
  }))];
}
function setScopeOnDeclaredComponents(moduleType, ngModule) {
  const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
  const transitiveScopes = transitiveScopesFor(moduleType);
  declarations.forEach((declaration) => {
    declaration = resolveForwardRef(declaration);
    if (declaration.hasOwnProperty(NG_COMP_DEF)) {
      const component = declaration;
      const componentDef = getComponentDef(component);
      patchComponentDefWithScope(componentDef, transitiveScopes);
    } else if (!declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {
      declaration.ngSelectorScope = moduleType;
    }
  });
}
function patchComponentDefWithScope(componentDef, transitiveScopes) {
  componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives).map((dir) => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir) : getDirectiveDef(dir)).filter((def) => !!def);
  componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map((pipe2) => getPipeDef$1(pipe2));
  componentDef.schemas = transitiveScopes.schemas;
  componentDef.tView = null;
}
function transitiveScopesFor(type) {
  if (isNgModule(type)) {
    return transitiveScopesForNgModule(type);
  } else if (isStandalone(type)) {
    const directiveDef = getComponentDef(type) || getDirectiveDef(type);
    if (directiveDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set()
        },
        exported: {
          directives: /* @__PURE__ */ new Set([type]),
          pipes: /* @__PURE__ */ new Set()
        }
      };
    }
    const pipeDef = getPipeDef$1(type);
    if (pipeDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set()
        },
        exported: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set([type])
        }
      };
    }
  }
  throw new Error(`${type.name} does not have a module def (\u0275mod property)`);
}
function transitiveScopesForNgModule(moduleType) {
  const def = getNgModuleDef(moduleType, true);
  if (def.transitiveCompileScopes !== null) {
    return def.transitiveCompileScopes;
  }
  const scopes = {
    schemas: def.schemas || null,
    compilation: {
      directives: /* @__PURE__ */ new Set(),
      pipes: /* @__PURE__ */ new Set()
    },
    exported: {
      directives: /* @__PURE__ */ new Set(),
      pipes: /* @__PURE__ */ new Set()
    }
  };
  maybeUnwrapFn(def.imports).forEach((imported) => {
    const importedScope = transitiveScopesFor(imported);
    importedScope.exported.directives.forEach((entry) => scopes.compilation.directives.add(entry));
    importedScope.exported.pipes.forEach((entry) => scopes.compilation.pipes.add(entry));
  });
  maybeUnwrapFn(def.declarations).forEach((declared) => {
    const declaredWithDefs = declared;
    if (getPipeDef$1(declaredWithDefs)) {
      scopes.compilation.pipes.add(declared);
    } else {
      scopes.compilation.directives.add(declared);
    }
  });
  maybeUnwrapFn(def.exports).forEach((exported) => {
    const exportedType = exported;
    if (isNgModule(exportedType)) {
      const exportedScope = transitiveScopesFor(exportedType);
      exportedScope.exported.directives.forEach((entry) => {
        scopes.compilation.directives.add(entry);
        scopes.exported.directives.add(entry);
      });
      exportedScope.exported.pipes.forEach((entry) => {
        scopes.compilation.pipes.add(entry);
        scopes.exported.pipes.add(entry);
      });
    } else if (getPipeDef$1(exportedType)) {
      scopes.exported.pipes.add(exportedType);
    } else {
      scopes.exported.directives.add(exportedType);
    }
  });
  def.transitiveCompileScopes = scopes;
  return scopes;
}
function expandModuleWithProviders(value) {
  if (isModuleWithProviders(value)) {
    return value.ngModule;
  }
  return value;
}
function compileComponent(type, metadata) {
  (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && initNgDevMode();
  let ngComponentDef = null;
  maybeQueueResolutionOfComponentResources(type, metadata);
  addDirectiveFactoryDef(type, metadata);
  Object.defineProperty(type, NG_COMP_DEF, {
    get: () => {
      if (ngComponentDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "component",
          type
        });
        if (componentNeedsResolution(metadata)) {
          const error2 = [`Component '${type.name}' is not resolved:`];
          if (metadata.templateUrl) {
            error2.push(` - templateUrl: ${metadata.templateUrl}`);
          }
          if (metadata.styleUrls && metadata.styleUrls.length) {
            error2.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);
          }
          error2.push(`Did you run and wait for 'resolveComponentResources()'?`);
          throw new Error(error2.join("\n"));
        }
        const options = getJitOptions();
        let preserveWhitespaces = metadata.preserveWhitespaces;
        if (preserveWhitespaces === void 0) {
          if (options !== null && options.preserveWhitespaces !== void 0) {
            preserveWhitespaces = options.preserveWhitespaces;
          } else {
            preserveWhitespaces = false;
          }
        }
        let encapsulation = metadata.encapsulation;
        if (encapsulation === void 0) {
          if (options !== null && options.defaultEncapsulation !== void 0) {
            encapsulation = options.defaultEncapsulation;
          } else {
            encapsulation = ViewEncapsulation$1.Emulated;
          }
        }
        const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;
        const meta = Object.assign(Object.assign({}, directiveMetadata(type, metadata)), {
          typeSourceSpan: compiler.createParseSourceSpan("Component", type.name, templateUrl),
          template: metadata.template || "",
          preserveWhitespaces,
          styles: metadata.styles || EMPTY_ARRAY,
          animations: metadata.animations,
          declarations: [],
          changeDetection: metadata.changeDetection,
          encapsulation,
          interpolation: metadata.interpolation,
          viewProviders: metadata.viewProviders || null,
          isStandalone: !!metadata.standalone
        });
        compilationDepth++;
        try {
          if (meta.usesInheritance) {
            addDirectiveDefToUndecoratedParents(type);
          }
          ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);
          if (metadata.standalone) {
            const imports = flatten(metadata.imports || EMPTY_ARRAY);
            const {
              directiveDefs,
              pipeDefs
            } = getStandaloneDefFunctions(type, imports);
            ngComponentDef.directiveDefs = directiveDefs;
            ngComponentDef.pipeDefs = pipeDefs;
            ngComponentDef.dependencies = () => imports.map(resolveForwardRef);
          }
        } finally {
          compilationDepth--;
        }
        if (compilationDepth === 0) {
          flushModuleScopingQueueAsMuchAsPossible();
        }
        if (hasSelectorScope(type)) {
          const scopes = transitiveScopesFor(type.ngSelectorScope);
          patchComponentDefWithScope(ngComponentDef, scopes);
        }
        if (metadata.schemas) {
          if (metadata.standalone) {
            ngComponentDef.schemas = metadata.schemas;
          } else {
            throw new Error(`The 'schemas' was specified for the ${stringifyForError(type)} but is only valid on a component that is standalone.`);
          }
        } else if (metadata.standalone) {
          ngComponentDef.schemas = [];
        }
      }
      return ngComponentDef;
    },
    configurable: !!define_ngDevMode_default
  });
}
function getDependencyTypeForError(type) {
  if (getComponentDef(type))
    return "component";
  if (getDirectiveDef(type))
    return "directive";
  if (getPipeDef$1(type))
    return "pipe";
  return "type";
}
function verifyStandaloneImport(depType, importingType) {
  if (isForwardRef(depType)) {
    depType = resolveForwardRef(depType);
    if (!depType) {
      throw new Error(`Expected forwardRef function, imported from "${stringifyForError(importingType)}", to return a standalone entity or NgModule but got "${stringifyForError(depType) || depType}".`);
    }
  }
  if (getNgModuleDef(depType) == null) {
    const def = getComponentDef(depType) || getDirectiveDef(depType) || getPipeDef$1(depType);
    if (def != null) {
      if (!def.standalone) {
        throw new Error(`The "${stringifyForError(depType)}" ${getDependencyTypeForError(depType)}, imported from "${stringifyForError(importingType)}", is not standalone. Did you forget to add the standalone: true flag?`);
      }
    } else {
      if (isModuleWithProviders(depType)) {
        throw new Error(`A module with providers was imported from "${stringifyForError(importingType)}". Modules with providers are not supported in standalone components imports.`);
      } else {
        throw new Error(`The "${stringifyForError(depType)}" type, imported from "${stringifyForError(importingType)}", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);
      }
    }
  }
}
function getStandaloneDefFunctions(type, imports) {
  let cachedDirectiveDefs = null;
  let cachedPipeDefs = null;
  const directiveDefs = () => {
    if (cachedDirectiveDefs === null) {
      cachedDirectiveDefs = [getComponentDef(type)];
      const seen = /* @__PURE__ */ new Set();
      for (const rawDep of imports) {
        define_ngDevMode_default && verifyStandaloneImport(rawDep, type);
        const dep = resolveForwardRef(rawDep);
        if (seen.has(dep)) {
          continue;
        }
        seen.add(dep);
        if (!!getNgModuleDef(dep)) {
          const scope = transitiveScopesFor(dep);
          for (const dir of scope.exported.directives) {
            const def = getComponentDef(dir) || getDirectiveDef(dir);
            if (def && !seen.has(dir)) {
              seen.add(dir);
              cachedDirectiveDefs.push(def);
            }
          }
        } else {
          const def = getComponentDef(dep) || getDirectiveDef(dep);
          if (def) {
            cachedDirectiveDefs.push(def);
          }
        }
      }
    }
    return cachedDirectiveDefs;
  };
  const pipeDefs = () => {
    if (cachedPipeDefs === null) {
      cachedPipeDefs = [];
      const seen = /* @__PURE__ */ new Set();
      for (const rawDep of imports) {
        const dep = resolveForwardRef(rawDep);
        if (seen.has(dep)) {
          continue;
        }
        seen.add(dep);
        if (!!getNgModuleDef(dep)) {
          const scope = transitiveScopesFor(dep);
          for (const pipe2 of scope.exported.pipes) {
            const def = getPipeDef$1(pipe2);
            if (def && !seen.has(pipe2)) {
              seen.add(pipe2);
              cachedPipeDefs.push(def);
            }
          }
        } else {
          const def = getPipeDef$1(dep);
          if (def) {
            cachedPipeDefs.push(def);
          }
        }
      }
    }
    return cachedPipeDefs;
  };
  return {
    directiveDefs,
    pipeDefs
  };
}
function hasSelectorScope(component) {
  return component.ngSelectorScope !== void 0;
}
function compileDirective(type, directive) {
  let ngDirectiveDef = null;
  addDirectiveFactoryDef(type, directive || {});
  Object.defineProperty(type, NG_DIR_DEF, {
    get: () => {
      if (ngDirectiveDef === null) {
        const meta = getDirectiveMetadata(type, directive || {});
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "directive",
          type
        });
        ngDirectiveDef = compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);
      }
      return ngDirectiveDef;
    },
    configurable: !!define_ngDevMode_default
  });
}
function getDirectiveMetadata(type, metadata) {
  const name = type && type.name;
  const sourceMapUrl = `ng:///${name}/\u0275dir.js`;
  const compiler = getCompilerFacade({
    usage: 0,
    kind: "directive",
    type
  });
  const facade = directiveMetadata(type, metadata);
  facade.typeSourceSpan = compiler.createParseSourceSpan("Directive", name, sourceMapUrl);
  if (facade.usesInheritance) {
    addDirectiveDefToUndecoratedParents(type);
  }
  return {
    metadata: facade,
    sourceMapUrl
  };
}
function addDirectiveFactoryDef(type, metadata) {
  let ngFactoryDef = null;
  Object.defineProperty(type, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const meta = getDirectiveMetadata(type, metadata);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "directive",
          type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type.name}/\u0275fac.js`, {
          name: meta.metadata.name,
          type: meta.metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type),
          target: compiler.FactoryTarget.Directive
        });
      }
      return ngFactoryDef;
    },
    configurable: !!define_ngDevMode_default
  });
}
function extendsDirectlyFromObject(type) {
  return Object.getPrototypeOf(type.prototype) === Object.prototype;
}
function directiveMetadata(type, metadata) {
  const reflect = getReflect();
  const propMetadata = reflect.ownPropMetadata(type);
  return {
    name: type.name,
    type,
    selector: metadata.selector !== void 0 ? metadata.selector : null,
    host: metadata.host || EMPTY_OBJ,
    propMetadata,
    inputs: metadata.inputs || EMPTY_ARRAY,
    outputs: metadata.outputs || EMPTY_ARRAY,
    queries: extractQueriesMetadata(type, propMetadata, isContentQuery),
    lifecycle: {
      usesOnChanges: reflect.hasLifecycleHook(type, "ngOnChanges")
    },
    typeSourceSpan: null,
    usesInheritance: !extendsDirectlyFromObject(type),
    exportAs: extractExportAs(metadata.exportAs),
    providers: metadata.providers || null,
    viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery),
    isStandalone: !!metadata.standalone
  };
}
function addDirectiveDefToUndecoratedParents(type) {
  const objPrototype = Object.prototype;
  let parent = Object.getPrototypeOf(type.prototype).constructor;
  while (parent && parent !== objPrototype) {
    if (!getDirectiveDef(parent) && !getComponentDef(parent) && shouldAddAbstractDirective(parent)) {
      compileDirective(parent, null);
    }
    parent = Object.getPrototypeOf(parent);
  }
}
function convertToR3QueryPredicate(selector) {
  return typeof selector === "string" ? splitByComma(selector) : resolveForwardRef(selector);
}
function convertToR3QueryMetadata(propertyName, ann) {
  return {
    propertyName,
    predicate: convertToR3QueryPredicate(ann.selector),
    descendants: ann.descendants,
    first: ann.first,
    read: ann.read ? ann.read : null,
    static: !!ann.static,
    emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly
  };
}
function extractQueriesMetadata(type, propMetadata, isQueryAnn) {
  const queriesMeta = [];
  for (const field in propMetadata) {
    if (propMetadata.hasOwnProperty(field)) {
      const annotations = propMetadata[field];
      annotations.forEach((ann) => {
        if (isQueryAnn(ann)) {
          if (!ann.selector) {
            throw new Error(`Can't construct a query for the property "${field}" of "${stringifyForError(type)}" since the query selector wasn't defined.`);
          }
          if (annotations.some(isInputAnnotation)) {
            throw new Error(`Cannot combine @Input decorators with query decorators`);
          }
          queriesMeta.push(convertToR3QueryMetadata(field, ann));
        }
      });
    }
  }
  return queriesMeta;
}
function extractExportAs(exportAs) {
  return exportAs === void 0 ? null : splitByComma(exportAs);
}
function isContentQuery(value) {
  const name = value.ngMetadataName;
  return name === "ContentChild" || name === "ContentChildren";
}
function isViewQuery(value) {
  const name = value.ngMetadataName;
  return name === "ViewChild" || name === "ViewChildren";
}
function isInputAnnotation(value) {
  return value.ngMetadataName === "Input";
}
function splitByComma(value) {
  return value.split(",").map((piece) => piece.trim());
}
function shouldAddAbstractDirective(type) {
  const reflect = getReflect();
  if (LIFECYCLE_HOOKS.some((hookName) => reflect.hasLifecycleHook(type, hookName))) {
    return true;
  }
  const propMetadata = reflect.propMetadata(type);
  for (const field in propMetadata) {
    const annotations = propMetadata[field];
    for (let i = 0; i < annotations.length; i++) {
      const current = annotations[i];
      const metadataName = current.ngMetadataName;
      if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) || metadataName === "Output" || metadataName === "HostBinding" || metadataName === "HostListener") {
        return true;
      }
    }
  }
  return false;
}
function compilePipe(type, meta) {
  let ngPipeDef = null;
  let ngFactoryDef = null;
  Object.defineProperty(type, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const metadata = getPipeMetadata(type, meta);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "pipe",
          type: metadata.type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/\u0275fac.js`, {
          name: metadata.name,
          type: metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type),
          target: compiler.FactoryTarget.Pipe
        });
      }
      return ngFactoryDef;
    },
    configurable: !!define_ngDevMode_default
  });
  Object.defineProperty(type, NG_PIPE_DEF, {
    get: () => {
      if (ngPipeDef === null) {
        const metadata = getPipeMetadata(type, meta);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "pipe",
          type: metadata.type
        });
        ngPipeDef = compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/\u0275pipe.js`, metadata);
      }
      return ngPipeDef;
    },
    configurable: !!define_ngDevMode_default
  });
}
function getPipeMetadata(type, meta) {
  return {
    type,
    name: type.name,
    pipeName: meta.name,
    pure: meta.pure !== void 0 ? meta.pure : true,
    isStandalone: !!meta.standalone
  };
}
function noop2(...args) {
}
function _appIdRandomProviderFactory() {
  return `${_randomChar()}${_randomChar()}${_randomChar()}`;
}
function _randomChar() {
  return String.fromCharCode(97 + Math.floor(Math.random() * 25));
}
function getGlobalLocale() {
  if (false) {
    return goog.LOCALE;
  } else {
    return typeof $localize !== "undefined" && $localize.locale || DEFAULT_LOCALE_ID;
  }
}
function applyChanges(component) {
  markDirty(component);
  getRootComponents(component).forEach((rootComponent) => detectChanges(rootComponent));
}
function publishDefaultGlobalUtils$1() {
  if (!_published) {
    _published = true;
    publishGlobalUtil("\u0275setProfiler", setProfiler);
    publishGlobalUtil("getDirectiveMetadata", getDirectiveMetadata$1);
    publishGlobalUtil("getComponent", getComponent);
    publishGlobalUtil("getContext", getContext);
    publishGlobalUtil("getListeners", getListeners);
    publishGlobalUtil("getOwningComponent", getOwningComponent);
    publishGlobalUtil("getHostElement", getHostElement);
    publishGlobalUtil("getInjector", getInjector);
    publishGlobalUtil("getRootComponents", getRootComponents);
    publishGlobalUtil("getDirectives", getDirectives);
    publishGlobalUtil("applyChanges", applyChanges);
  }
}
function publishGlobalUtil(name, fn2) {
  if (typeof COMPILED === "undefined" || !COMPILED) {
    const w = _global;
    define_ngDevMode_default && assertDefined(fn2, "function not defined");
    if (w) {
      let container = w[GLOBAL_PUBLISH_EXPANDO_KEY];
      if (!container) {
        container = w[GLOBAL_PUBLISH_EXPANDO_KEY] = {};
      }
      container[name] = fn2;
    }
  }
}
function scheduleMicroTask(fn2) {
  if (typeof Zone === "undefined") {
    promise.then(() => {
      fn2 && fn2.apply(null, null);
    });
  } else {
    Zone.current.scheduleMicroTask("scheduleMicrotask", fn2);
  }
}
function getNativeRequestAnimationFrame() {
  let nativeRequestAnimationFrame = _global["requestAnimationFrame"];
  let nativeCancelAnimationFrame = _global["cancelAnimationFrame"];
  if (typeof Zone !== "undefined" && nativeRequestAnimationFrame && nativeCancelAnimationFrame) {
    const unpatchedRequestAnimationFrame = nativeRequestAnimationFrame[Zone.__symbol__("OriginalDelegate")];
    if (unpatchedRequestAnimationFrame) {
      nativeRequestAnimationFrame = unpatchedRequestAnimationFrame;
    }
    const unpatchedCancelAnimationFrame = nativeCancelAnimationFrame[Zone.__symbol__("OriginalDelegate")];
    if (unpatchedCancelAnimationFrame) {
      nativeCancelAnimationFrame = unpatchedCancelAnimationFrame;
    }
  }
  return {
    nativeRequestAnimationFrame,
    nativeCancelAnimationFrame
  };
}
function checkStable(zone) {
  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
    try {
      zone._nesting++;
      zone.onMicrotaskEmpty.emit(null);
    } finally {
      zone._nesting--;
      if (!zone.hasPendingMicrotasks) {
        try {
          zone.runOutsideAngular(() => zone.onStable.emit(null));
        } finally {
          zone.isStable = true;
        }
      }
    }
  }
}
function delayChangeDetectionForEvents(zone) {
  if (zone.isCheckStableRunning || zone.lastRequestAnimationFrameId !== -1) {
    return;
  }
  zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(_global, () => {
    if (!zone.fakeTopEventTask) {
      zone.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => {
        zone.lastRequestAnimationFrameId = -1;
        updateMicroTaskStatus(zone);
        zone.isCheckStableRunning = true;
        checkStable(zone);
        zone.isCheckStableRunning = false;
      }, void 0, () => {
      }, () => {
      });
    }
    zone.fakeTopEventTask.invoke();
  });
  updateMicroTaskStatus(zone);
}
function forkInnerZoneWithAngularBehavior(zone) {
  const delayChangeDetectionForEventsDelegate = () => {
    delayChangeDetectionForEvents(zone);
  };
  zone._inner = zone._inner.fork({
    name: "angular",
    properties: {
      "isAngularZone": true
    },
    onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
      try {
        onEnter(zone);
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      } finally {
        if (zone.shouldCoalesceEventChangeDetection && task.type === "eventTask" || zone.shouldCoalesceRunChangeDetection) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
      try {
        onEnter(zone);
        return delegate.invoke(target, callback, applyThis, applyArgs, source);
      } finally {
        if (zone.shouldCoalesceRunChangeDetection) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onHasTask: (delegate, current, target, hasTaskState) => {
      delegate.hasTask(target, hasTaskState);
      if (current === target) {
        if (hasTaskState.change == "microTask") {
          zone._hasPendingMicrotasks = hasTaskState.microTask;
          updateMicroTaskStatus(zone);
          checkStable(zone);
        } else if (hasTaskState.change == "macroTask") {
          zone.hasPendingMacrotasks = hasTaskState.macroTask;
        }
      }
    },
    onHandleError: (delegate, current, target, error2) => {
      delegate.handleError(target, error2);
      zone.runOutsideAngular(() => zone.onError.emit(error2));
      return false;
    }
  });
}
function updateMicroTaskStatus(zone) {
  if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.lastRequestAnimationFrameId !== -1) {
    zone.hasPendingMicrotasks = true;
  } else {
    zone.hasPendingMicrotasks = false;
  }
}
function onEnter(zone) {
  zone._nesting++;
  if (zone.isStable) {
    zone.isStable = false;
    zone.onUnstable.emit(null);
  }
}
function onLeave(zone) {
  zone._nesting--;
  checkStable(zone);
}
function setTestabilityGetter(getter) {
  _testabilityGetter = getter;
}
function compileNgModuleFactory(injector, options, moduleType) {
  define_ngDevMode_default && assertNgModuleType(moduleType);
  const moduleFactory = new NgModuleFactory(moduleType);
  if (true) {
    return Promise.resolve(moduleFactory);
  }
  const compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options);
  setJitOptions({
    defaultEncapsulation: _lastDefined(compilerOptions.map((opts) => opts.defaultEncapsulation)),
    preserveWhitespaces: _lastDefined(compilerOptions.map((opts) => opts.preserveWhitespaces))
  });
  if (isComponentResourceResolutionQueueEmpty()) {
    return Promise.resolve(moduleFactory);
  }
  const compilerProviders = _mergeArrays(compilerOptions.map((o) => o.providers));
  if (compilerProviders.length === 0) {
    return Promise.resolve(moduleFactory);
  }
  const compiler = getCompilerFacade({
    usage: 0,
    kind: "NgModule",
    type: moduleType
  });
  const compilerInjector = Injector.create({
    providers: compilerProviders
  });
  const resourceLoader = compilerInjector.get(compiler.ResourceLoader);
  return resolveComponentResources((url) => Promise.resolve(resourceLoader.get(url))).then(() => moduleFactory);
}
function publishDefaultGlobalUtils() {
  define_ngDevMode_default && publishDefaultGlobalUtils$1();
}
function isBoundToModule(cf) {
  return cf.isBoundToModule;
}
function createPlatform(injector) {
  if (_platformInjector && !_platformInjector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
    throw new RuntimeError(
      400,
      define_ngDevMode_default && "There can be only one platform. Destroy the previous one to create a new one."
    );
  }
  publishDefaultGlobalUtils();
  _platformInjector = injector;
  const platform = injector.get(PlatformRef);
  runPlatformInitializers(injector);
  return platform;
}
function createOrReusePlatformInjector(providers = []) {
  if (_platformInjector)
    return _platformInjector;
  const injector = createPlatformInjector(providers);
  _platformInjector = injector;
  publishDefaultGlobalUtils();
  runPlatformInitializers(injector);
  return injector;
}
function runPlatformInitializers(injector) {
  const inits = injector.get(PLATFORM_INITIALIZER, null);
  if (inits) {
    inits.forEach((init) => init());
  }
}
function internalBootstrapApplication(config2) {
  const {
    rootComponent,
    appProviders,
    platformProviders
  } = config2;
  NG_DEV_MODE && assertStandaloneComponentType(rootComponent);
  const platformInjector = createOrReusePlatformInjector(platformProviders);
  const ngZone = new NgZone(getNgZoneOptions());
  return ngZone.run(() => {
    const allAppProviders = [
      {
        provide: NgZone,
        useValue: ngZone
      },
      ...appProviders || []
    ];
    const appInjector = createEnvironmentInjector(allAppProviders, platformInjector, "Environment Injector");
    const exceptionHandler = appInjector.get(ErrorHandler, null);
    if (NG_DEV_MODE && !exceptionHandler) {
      throw new RuntimeError(
        402,
        "No `ErrorHandler` found in the Dependency Injection tree."
      );
    }
    let onErrorSubscription;
    ngZone.runOutsideAngular(() => {
      onErrorSubscription = ngZone.onError.subscribe({
        next: (error2) => {
          exceptionHandler.handleError(error2);
        }
      });
    });
    return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
      const initStatus = appInjector.get(ApplicationInitStatus);
      initStatus.runInitializers();
      return initStatus.donePromise.then(() => {
        const localeId = appInjector.get(LOCALE_ID, DEFAULT_LOCALE_ID);
        setLocaleId(localeId || DEFAULT_LOCALE_ID);
        const appRef = appInjector.get(ApplicationRef);
        const destroyListener = () => appRef.destroy();
        const onPlatformDestroyListeners = platformInjector.get(PLATFORM_DESTROY_LISTENERS, null);
        onPlatformDestroyListeners === null || onPlatformDestroyListeners === void 0 ? void 0 : onPlatformDestroyListeners.add(destroyListener);
        appRef.onDestroy(() => {
          onPlatformDestroyListeners === null || onPlatformDestroyListeners === void 0 ? void 0 : onPlatformDestroyListeners.delete(destroyListener);
          onErrorSubscription.unsubscribe();
        });
        appRef.bootstrap(rootComponent);
        return appRef;
      });
    });
  });
}
function createPlatformFactory(parentPlatformFactory, name, providers = []) {
  const desc = `Platform: ${name}`;
  const marker = new InjectionToken(desc);
  return (extraProviders = []) => {
    let platform = getPlatform();
    if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
      const platformProviders = [...providers, ...extraProviders, {
        provide: marker,
        useValue: true
      }];
      if (parentPlatformFactory) {
        parentPlatformFactory(platformProviders);
      } else {
        createPlatform(createPlatformInjector(platformProviders, desc));
      }
    }
    return assertPlatform(marker);
  };
}
function assertPlatform(requiredToken) {
  const platform = getPlatform();
  if (!platform) {
    throw new RuntimeError(
      401,
      define_ngDevMode_default && "No platform exists!"
    );
  }
  if ((typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && !platform.injector.get(requiredToken, null)) {
    throw new RuntimeError(
      400,
      "A platform with a different configuration has been created. Please destroy it first."
    );
  }
  return platform;
}
function createPlatformInjector(providers = [], name) {
  return Injector.create({
    name,
    providers: [{
      provide: INJECTOR_SCOPE,
      useValue: "platform"
    }, {
      provide: PLATFORM_DESTROY_LISTENERS,
      useValue: /* @__PURE__ */ new Set([() => _platformInjector = null])
    }, ...providers]
  });
}
function destroyPlatform() {
  var _a;
  (_a = getPlatform()) === null || _a === void 0 ? void 0 : _a.destroy();
}
function getPlatform() {
  var _a;
  return (_a = _platformInjector === null || _platformInjector === void 0 ? void 0 : _platformInjector.get(PlatformRef)) !== null && _a !== void 0 ? _a : null;
}
function getNgZoneOptions(options) {
  return {
    enableLongStackTrace: typeof define_ngDevMode_default === "undefined" ? false : !!define_ngDevMode_default,
    shouldCoalesceEventChangeDetection: !!(options && options.ngZoneEventCoalescing) || false,
    shouldCoalesceRunChangeDetection: !!(options && options.ngZoneRunCoalescing) || false
  };
}
function getNgZone(ngZoneToUse, options) {
  let ngZone;
  if (ngZoneToUse === "noop") {
    ngZone = new NoopNgZone();
  } else {
    ngZone = (ngZoneToUse === "zone.js" ? void 0 : ngZoneToUse) || new NgZone(options);
  }
  return ngZone;
}
function _callAndReportToErrorHandler(errorHandler2, ngZone, callback) {
  try {
    const result = callback();
    if (isPromise2(result)) {
      return result.catch((e) => {
        ngZone.runOutsideAngular(() => errorHandler2.handleError(e));
        throw e;
      });
    }
    return result;
  } catch (e) {
    ngZone.runOutsideAngular(() => errorHandler2.handleError(e));
    throw e;
  }
}
function optionsReducer(dst, objs) {
  if (Array.isArray(objs)) {
    dst = objs.reduce(optionsReducer, dst);
  } else {
    dst = Object.assign(Object.assign({}, dst), objs);
  }
  return dst;
}
function remove(list, el) {
  const index = list.indexOf(el);
  if (index > -1) {
    list.splice(index, 1);
  }
}
function _lastDefined(args) {
  for (let i = args.length - 1; i >= 0; i--) {
    if (args[i] !== void 0) {
      return args[i];
    }
  }
  return void 0;
}
function _mergeArrays(parts) {
  const result = [];
  parts.forEach((part) => part && result.push(...part));
  return result;
}
function isDevMode() {
  _runModeLocked = true;
  return _devMode;
}
function enableProdMode() {
  if (_runModeLocked) {
    throw new Error("Cannot enable prod mode after platform setup.");
  }
  if (typeof define_ngDevMode_default === void 0 || !!define_ngDevMode_default) {
    _global["ngDevMode"] = false;
  }
  _devMode = false;
}
function getModuleFactory(id) {
  const type = getRegisteredNgModuleType(id);
  if (!type)
    throw noModuleError(id);
  return new NgModuleFactory(type);
}
function getNgModuleById(id) {
  const type = getRegisteredNgModuleType(id);
  if (!type)
    throw noModuleError(id);
  return type;
}
function noModuleError(id) {
  return new Error(`No module with ID ${id} loaded`);
}
function injectChangeDetectorRef(flags) {
  return createViewRef(
    getCurrentTNode(),
    getLView(),
    (flags & 16) === 16
  );
}
function createViewRef(tNode, lView, isPipe) {
  if (isComponentHost(tNode) && !isPipe) {
    const componentView = getComponentLViewByIndex(tNode.index, lView);
    return new ViewRef$1(componentView, componentView);
  } else if (tNode.type & (3 | 12 | 32)) {
    const hostComponentView = lView[DECLARATION_COMPONENT_VIEW];
    return new ViewRef$1(hostComponentView, lView);
  }
  return null;
}
function asNativeElements(debugEls) {
  return debugEls.map((el) => el.nativeElement);
}
function copyDomProperties(element, properties) {
  if (element) {
    let obj = Object.getPrototypeOf(element);
    const NodePrototype = Node.prototype;
    while (obj !== null && obj !== NodePrototype) {
      const descriptors = Object.getOwnPropertyDescriptors(obj);
      for (let key in descriptors) {
        if (!key.startsWith("__") && !key.startsWith("on")) {
          const value = element[key];
          if (isPrimitiveValue(value)) {
            properties[key] = value;
          }
        }
      }
      obj = Object.getPrototypeOf(obj);
    }
  }
}
function isPrimitiveValue(value) {
  return typeof value === "string" || typeof value === "boolean" || typeof value === "number" || value === null;
}
function _queryAll(parentElement, predicate, matches, elementsOnly) {
  const context2 = getLContext(parentElement.nativeNode);
  const lView = context2 ? context2.lView : null;
  if (lView !== null) {
    const parentTNode = lView[TVIEW].data[context2.nodeIndex];
    _queryNodeChildren(parentTNode, lView, predicate, matches, elementsOnly, parentElement.nativeNode);
  } else {
    _queryNativeNodeDescendants(parentElement.nativeNode, predicate, matches, elementsOnly);
  }
}
function _queryNodeChildren(tNode, lView, predicate, matches, elementsOnly, rootNativeNode) {
  define_ngDevMode_default && assertTNodeForLView(tNode, lView);
  const nativeNode = getNativeByTNodeOrNull(tNode, lView);
  if (tNode.type & (3 | 8)) {
    _addQueryMatch(nativeNode, predicate, matches, elementsOnly, rootNativeNode);
    if (isComponentHost(tNode)) {
      const componentView = getComponentLViewByIndex(tNode.index, lView);
      if (componentView && componentView[TVIEW].firstChild) {
        _queryNodeChildren(componentView[TVIEW].firstChild, componentView, predicate, matches, elementsOnly, rootNativeNode);
      }
    } else {
      if (tNode.child) {
        _queryNodeChildren(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
      }
      nativeNode && _queryNativeNodeDescendants(nativeNode, predicate, matches, elementsOnly);
    }
    const nodeOrContainer = lView[tNode.index];
    if (isLContainer(nodeOrContainer)) {
      _queryNodeChildrenInContainer(nodeOrContainer, predicate, matches, elementsOnly, rootNativeNode);
    }
  } else if (tNode.type & 4) {
    const lContainer = lView[tNode.index];
    _addQueryMatch(lContainer[NATIVE], predicate, matches, elementsOnly, rootNativeNode);
    _queryNodeChildrenInContainer(lContainer, predicate, matches, elementsOnly, rootNativeNode);
  } else if (tNode.type & 16) {
    const componentView = lView[DECLARATION_COMPONENT_VIEW];
    const componentHost = componentView[T_HOST];
    const head = componentHost.projection[tNode.projection];
    if (Array.isArray(head)) {
      for (let nativeNode2 of head) {
        _addQueryMatch(nativeNode2, predicate, matches, elementsOnly, rootNativeNode);
      }
    } else if (head) {
      const nextLView = componentView[PARENT];
      const nextTNode = nextLView[TVIEW].data[head.index];
      _queryNodeChildren(nextTNode, nextLView, predicate, matches, elementsOnly, rootNativeNode);
    }
  } else if (tNode.child) {
    _queryNodeChildren(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
  }
  if (rootNativeNode !== nativeNode) {
    const nextTNode = tNode.flags & 4 ? tNode.projectionNext : tNode.next;
    if (nextTNode) {
      _queryNodeChildren(nextTNode, lView, predicate, matches, elementsOnly, rootNativeNode);
    }
  }
}
function _queryNodeChildrenInContainer(lContainer, predicate, matches, elementsOnly, rootNativeNode) {
  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const childView = lContainer[i];
    const firstChild = childView[TVIEW].firstChild;
    if (firstChild) {
      _queryNodeChildren(firstChild, childView, predicate, matches, elementsOnly, rootNativeNode);
    }
  }
}
function _addQueryMatch(nativeNode, predicate, matches, elementsOnly, rootNativeNode) {
  if (rootNativeNode !== nativeNode) {
    const debugNode = getDebugNode(nativeNode);
    if (!debugNode) {
      return;
    }
    if (elementsOnly && debugNode instanceof DebugElement && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
      matches.push(debugNode);
    } else if (!elementsOnly && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
      matches.push(debugNode);
    }
  }
}
function _queryNativeNodeDescendants(parentNode, predicate, matches, elementsOnly) {
  const nodes = parentNode.childNodes;
  const length = nodes.length;
  for (let i = 0; i < length; i++) {
    const node = nodes[i];
    const debugNode = getDebugNode(node);
    if (debugNode) {
      if (elementsOnly && debugNode instanceof DebugElement && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
        matches.push(debugNode);
      } else if (!elementsOnly && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
        matches.push(debugNode);
      }
      _queryNativeNodeDescendants(node, predicate, matches, elementsOnly);
    }
  }
}
function collectPropertyBindings(properties, tNode, lView, tData) {
  let bindingIndexes = tNode.propertyBindings;
  if (bindingIndexes !== null) {
    for (let i = 0; i < bindingIndexes.length; i++) {
      const bindingIndex = bindingIndexes[i];
      const propMetadata = tData[bindingIndex];
      const metadataParts = propMetadata.split(INTERPOLATION_DELIMITER);
      const propertyName = metadataParts[0];
      if (metadataParts.length > 1) {
        let value = metadataParts[1];
        for (let j = 1; j < metadataParts.length - 1; j++) {
          value += renderStringify(lView[bindingIndex + j - 1]) + metadataParts[j + 1];
        }
        properties[propertyName] = value;
      } else {
        properties[propertyName] = lView[bindingIndex];
      }
    }
  }
}
function getDebugNode(nativeNode) {
  if (nativeNode instanceof Node) {
    if (!nativeNode.hasOwnProperty(NG_DEBUG_PROPERTY)) {
      nativeNode[NG_DEBUG_PROPERTY] = nativeNode.nodeType == Node.ELEMENT_NODE ? new DebugElement(nativeNode) : new DebugNode(nativeNode);
    }
    return nativeNode[NG_DEBUG_PROPERTY];
  }
  return null;
}
function getDebugNodeR2(_nativeNode) {
  return null;
}
function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
  const previousIndex = item.previousIndex;
  if (previousIndex === null)
    return previousIndex;
  let moveOffset = 0;
  if (moveOffsets && previousIndex < moveOffsets.length) {
    moveOffset = moveOffsets[previousIndex];
  }
  return previousIndex + addRemoveOffset + moveOffset;
}
function defaultIterableDiffersFactory() {
  return new IterableDiffers([new DefaultIterableDifferFactory()]);
}
function getTypeNameForDebugging(type) {
  return type["name"] || typeof type;
}
function defaultKeyValueDiffersFactory() {
  return new KeyValueDiffers([new DefaultKeyValueDifferFactory()]);
}
function coerceToBoolean(value) {
  return typeof value === "boolean" ? value : value != null && value !== "false";
}
function \u0275\u0275ngDeclareDirective(decl) {
  const compiler = getCompilerFacade({
    usage: 1,
    kind: "directive",
    type: decl.type
  });
  return compiler.compileDirectiveDeclaration(angularCoreEnv, `ng:///${decl.type.name}/\u0275fac.js`, decl);
}
function \u0275\u0275ngDeclareClassMetadata(decl) {
  var _a, _b;
  setClassMetadata(decl.type, decl.decorators, (_a = decl.ctorParameters) !== null && _a !== void 0 ? _a : null, (_b = decl.propDecorators) !== null && _b !== void 0 ? _b : null);
}
function \u0275\u0275ngDeclareComponent(decl) {
  const compiler = getCompilerFacade({
    usage: 1,
    kind: "component",
    type: decl.type
  });
  return compiler.compileComponentDeclaration(angularCoreEnv, `ng:///${decl.type.name}/\u0275cmp.js`, decl);
}
function \u0275\u0275ngDeclareFactory(decl) {
  const compiler = getCompilerFacade({
    usage: 1,
    kind: getFactoryKind(decl.target),
    type: decl.type
  });
  return compiler.compileFactoryDeclaration(angularCoreEnv, `ng:///${decl.type.name}/\u0275fac.js`, decl);
}
function getFactoryKind(target) {
  switch (target) {
    case FactoryTarget.Directive:
      return "directive";
    case FactoryTarget.Component:
      return "component";
    case FactoryTarget.Injectable:
      return "injectable";
    case FactoryTarget.Pipe:
      return "pipe";
    case FactoryTarget.NgModule:
      return "NgModule";
  }
}
function \u0275\u0275ngDeclareInjectable(decl) {
  const compiler = getCompilerFacade({
    usage: 1,
    kind: "injectable",
    type: decl.type
  });
  return compiler.compileInjectableDeclaration(angularCoreEnv, `ng:///${decl.type.name}/\u0275prov.js`, decl);
}
function \u0275\u0275ngDeclareInjector(decl) {
  const compiler = getCompilerFacade({
    usage: 1,
    kind: "NgModule",
    type: decl.type
  });
  return compiler.compileInjectorDeclaration(angularCoreEnv, `ng:///${decl.type.name}/\u0275inj.js`, decl);
}
function \u0275\u0275ngDeclareNgModule(decl) {
  const compiler = getCompilerFacade({
    usage: 1,
    kind: "NgModule",
    type: decl.type
  });
  return compiler.compileNgModuleDeclaration(angularCoreEnv, `ng:///${decl.type.name}/\u0275mod.js`, decl);
}
function \u0275\u0275ngDeclarePipe(decl) {
  const compiler = getCompilerFacade({
    usage: 1,
    kind: "pipe",
    type: decl.type
  });
  return compiler.compilePipeDeclaration(angularCoreEnv, `ng:///${decl.type.name}/\u0275pipe.js`, decl);
}
function createComponent(component, options) {
  define_ngDevMode_default && assertComponentDef(component);
  const componentDef = getComponentDef(component);
  const elementInjector = options.elementInjector || getNullInjector();
  const factory = new ComponentFactory(componentDef);
  return factory.create(elementInjector, options.projectableNodes, options.hostElement, options.environmentInjector);
}
function reflectComponentType(component) {
  const componentDef = getComponentDef(component);
  if (!componentDef)
    return null;
  const factory = new ComponentFactory(componentDef);
  return {
    get selector() {
      return factory.selector;
    },
    get type() {
      return factory.componentType;
    },
    get inputs() {
      return factory.inputs;
    },
    get outputs() {
      return factory.outputs;
    },
    get ngContentSelectors() {
      return factory.ngContentSelectors;
    },
    get isStandalone() {
      return componentDef.standalone;
    }
  };
}
var __forward_ref__, ERROR_DETAILS_PAGE_BASE_URL, RuntimeError, defineInjectable, NG_PROV_DEF, NG_INJ_DEF, NG_INJECTABLE_DEF, NG_INJECTOR_DEF, InjectFlags, _injectImplementation, ChangeDetectionStrategy, ChangeDetectorStatus, ViewEncapsulation$1, _global, EMPTY_OBJ, EMPTY_ARRAY, NG_COMP_DEF, NG_DIR_DEF, NG_PIPE_DEF, NG_MOD_DEF, NG_FACTORY_DEF, NG_ELEMENT_ID, componentDefCount, autoRegisterModuleById, \u0275\u0275defineDirective, TYPE, HAS_TRANSPLANTED_VIEWS, NATIVE, VIEW_REFS, MOVED_VIEWS, CONTAINER_HEADER_OFFSET, unusedValueExportToPlacateAjd$8, HOST, TVIEW, FLAGS, PARENT, NEXT, TRANSPLANTED_VIEWS_TO_REFRESH, T_HOST, CLEANUP, CONTEXT, INJECTOR$1, RENDERER_FACTORY, RENDERER, SANITIZER, CHILD_HEAD, CHILD_TAIL, DECLARATION_VIEW, DECLARATION_COMPONENT_VIEW, DECLARATION_LCONTAINER, PREORDER_HOOK_FLAGS, QUERIES, ID, EMBEDDED_VIEW_INJECTOR, HEADER_OFFSET, TViewTypeAsString, unusedValueExportToPlacateAjd$7, SimpleChange, SIMPLE_CHANGES_STORE, profilerCallback, setProfiler, profiler, SVG_NAMESPACE, MATH_ML_NAMESPACE, instructionState, _isInCheckNoChangesMode, leaveDI, NO_PARENT_INJECTOR, NodeInjectorFactory, unusedValueExportToPlacateAjd$6, unusedValueExportToPlacateAjd$5, includeViewProviders, BLOOM_SIZE, BLOOM_MASK, BLOOM_BUCKET_BITS, nextNgElementId, NOT_FOUND, NodeInjector, ANNOTATIONS, PARAMETERS, PROP_METADATA, Attribute, InjectionToken, ANALYZE_FOR_ENTRY_COMPONENTS, emitDistinctChangesOnlyDefaultValue, Query, ContentChildren, ContentChild, ViewChildren, ViewChild, FactoryTarget, R3TemplateDependencyKind, ViewEncapsulation, Type, ES5_DELEGATE_CTOR, ES2015_INHERITED_CLASS, ES2015_INHERITED_CLASS_WITH_CTOR, ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR, ReflectionCapabilities, _THROW_IF_NOT_FOUND, THROW_IF_NOT_FOUND, DI_DECORATOR_FLAG, NG_TEMP_TOKEN_PATH, NG_TOKEN_PATH, NEW_LINE, NO_NEW_LINE, SOURCE, _currentInjector, Inject, Optional, Self, SkipSelf, Host, _reflect, componentResourceResolutionQueue, componentDefPendingResolution, modules, checkForDuplicateNgModules, DOCUMENT, policy$1, policy, SafeValueImpl, SafeHtmlImpl, SafeStyleImpl, SafeScriptImpl, SafeUrlImpl, SafeResourceUrlImpl, DOMParserHelper, InertDocumentHelper, SAFE_URL_PATTERN, DATA_URL_PATTERN, VOID_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS, OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, VALID_ELEMENTS, URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS, ARIA_ATTRS, VALID_ATTRS, SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS, SanitizingHtmlSerializer, SURROGATE_PAIR_REGEXP, NON_ALPHANUMERIC_REGEXP, inertBodyHelper, SecurityContext, ENVIRONMENT_INITIALIZER, INJECTOR, INJECTOR_DEF_TYPES, NullInjector, USE_VALUE$1, INJECTOR_SCOPE, NOT_YET, CIRCULAR, NULL_INJECTOR$1, EnvironmentInjector, R3Injector, ComponentRef$1, ComponentFactory$1, ERROR_COMPONENT, _NullComponentFactoryResolver, ComponentFactoryResolver$1, ElementRef, Renderer2Interceptor, RendererFactory2, Renderer2, Sanitizer, Version, VERSION, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, shouldThrowErrorOnUnknownElement, shouldThrowErrorOnUnknownProperty, KNOWN_CONTROL_FLOW_DIRECTIVES, ERROR_ORIGINAL_ERROR, ErrorHandler, COMMENT_DISALLOWED, COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED, CAMEL_CASE_REGEXP, TRACKED_LVIEWS, uniqueIdCounter, LContext, MONKEY_PATCH_KEY_NAME, defaultScheduler, INTERPOLATION_DELIMITER, RendererStyleFlags2, _icuContainerIterate, unusedValueExportToPlacateAjd$4, unusedValueExportToPlacateAjd$3, unusedValueToPlacateAjd$2, _getInsertInFrontOfRNodeWithI18n, _processI18nInsertBefore, unusedValueToPlacateAjd$1, NG_TEMPLATE_SELECTOR, NO_CHANGE, angularCoreDiEnv, USE_VALUE, Injectable, Injector, ReflectiveKey, KeyRegistry, _globalKeyRegistry, ReflectiveDependency, _EMPTY_LIST, ResolvedReflectiveProvider_, ResolvedReflectiveFactory, UNDEFINED, ReflectiveInjector, ReflectiveInjector_, LVIEW_COMPONENT_CACHE, LVIEW_EMBEDDED_CACHE, LVIEW_ROOT, LVIEW_COMPONENT, LVIEW_EMBEDDED, LRootView, LComponentView, LEmbeddedView, TViewConstructor, TNode, TNodeDebug, TViewData, TVIEWDATA_EMPTY, LViewBlueprint, MatchesArray, TViewComponents, TNodeLocalNames, TNodeInitialInputs, LCleanup, TCleanup, LViewDebug, LContainerDebug, _CLEAN_PROMISE, LContainerArray, CLEAN_PROMISE, ViewRef$1, RootViewRef, ComponentFactoryResolver, ChainedInjector, ComponentFactory, componentFactoryResolver, ComponentRef, COPY_DIRECTIVE_FIELDS, COPY_COMPONENT_FIELDS, _symbolIterator, isObservable2, parserState, u, localeEn, LOCALE_DATA, LocaleDataIndex, pluralMapping, DEFAULT_LOCALE_ID, USD_CURRENCY_CODE, ELEMENT_MARKER, ICU_MARKER, I18nCreateOpCode, LOCALE_ID$1, changeMask, changeMaskCounter, OpCodeParser, BINDING_REGEXP, ICU_REGEXP, NESTED_ICU, ICU_BLOCK_REGEXP, MARKER, SUBTEMPLATE_REGEXP, PH_REGEXP, NGSP_UNICODE_REGEXP, ROOT_TEMPLATE_ID, PP_MULTI_VALUE_PLACEHOLDERS_REGEXP, PP_PLACEHOLDERS_REGEXP, PP_ICU_VARS_REGEXP, PP_ICU_PLACEHOLDERS_REGEXP, PP_ICUS_REGEXP, PP_CLOSE_TEMPLATE_REGEXP, PP_TEMPLATE_ID_REGEXP, NgModuleRef$1, NgModuleFactory$1, createNgModuleRef, NgModuleRef, NgModuleFactory, EnvironmentNgModuleRefAdapter, StandaloneService, EventEmitter_, EventEmitter, QueryList, TemplateRef, ViewEngineTemplateRef, R3TemplateRef, ViewContainerRef, VE_ViewContainerRef, R3ViewContainerRef, unusedValueExportToPlacateAjd$1, unusedValueExportToPlacateAjd, unusedValueToPlacateAjd, LQuery_, LQueries_, TQueryMetadata_, TQueries_, TQuery_, angularCoreEnv, jitOptions, moduleQueue, flushingModuleQueue, ownerNgModule, verifiedNgModule, compilationDepth, LIFECYCLE_HOOKS, Directive, Component, Pipe, Input, Output, HostBinding, HostListener, NgModule, APP_INITIALIZER, ApplicationInitStatus, APP_ID, APP_ID_RANDOM_PROVIDER, PLATFORM_INITIALIZER, PLATFORM_ID, APP_BOOTSTRAP_LISTENER, PACKAGE_ROOT_URL, ANIMATION_MODULE_TYPE, Console, LOCALE_ID, DEFAULT_CURRENCY_CODE, TRANSLATIONS, TRANSLATIONS_FORMAT, MissingTranslationStrategy, ModuleWithComponentFactories, Compiler, COMPILER_OPTIONS, CompilerFactory, GLOBAL_PUBLISH_EXPANDO_KEY, _published, promise, NgZone, EMPTY_PAYLOAD, NoopNgZone, TESTABILITY, TESTABILITY_GETTER, Testability, TestabilityRegistry, _testabilityGetter, _platformInjector, ALLOW_MULTIPLE_PLATFORMS, PLATFORM_DESTROY_LISTENERS, NG_DEV_MODE, NgProbeToken, PlatformRef, ApplicationRef, _devMode, _runModeLocked, ChangeDetectorRef, ViewRef, EmbeddedViewRef, DebugEventListener, DebugNode, DebugElement, NG_DEBUG_PROPERTY, DefaultIterableDifferFactory, trackByIdentity, DefaultIterableDiffer, IterableChangeRecord_, _DuplicateItemRecordList, _DuplicateMap, DefaultKeyValueDifferFactory, DefaultKeyValueDiffer, KeyValueChangeRecord_, IterableDiffers, KeyValueDiffers, keyValDiff, iterableDiff, defaultIterableDiffers, defaultKeyValueDiffers, platformCore, ApplicationModule, \u0275ivyEnabled;
var init_core = __esm({
  "node_modules/@angular/core/fesm2015/core.mjs"() {
    init_define_ngDevMode();
    init_esm5();
    init_operators();
    __forward_ref__ = getClosureSafeProperty({
      __forward_ref__: getClosureSafeProperty
    });
    ERROR_DETAILS_PAGE_BASE_URL = "https://angular.io/errors";
    RuntimeError = class extends Error {
      constructor(code, message) {
        super(formatRuntimeError(code, message));
        this.code = code;
      }
    };
    defineInjectable = \u0275\u0275defineInjectable;
    NG_PROV_DEF = getClosureSafeProperty({
      \u0275prov: getClosureSafeProperty
    });
    NG_INJ_DEF = getClosureSafeProperty({
      \u0275inj: getClosureSafeProperty
    });
    NG_INJECTABLE_DEF = getClosureSafeProperty({
      ngInjectableDef: getClosureSafeProperty
    });
    NG_INJECTOR_DEF = getClosureSafeProperty({
      ngInjectorDef: getClosureSafeProperty
    });
    (function(InjectFlags2) {
      InjectFlags2[InjectFlags2["Default"] = 0] = "Default";
      InjectFlags2[InjectFlags2["Host"] = 1] = "Host";
      InjectFlags2[InjectFlags2["Self"] = 2] = "Self";
      InjectFlags2[InjectFlags2["SkipSelf"] = 4] = "SkipSelf";
      InjectFlags2[InjectFlags2["Optional"] = 8] = "Optional";
    })(InjectFlags || (InjectFlags = {}));
    (function(ChangeDetectionStrategy3) {
      ChangeDetectionStrategy3[ChangeDetectionStrategy3["OnPush"] = 0] = "OnPush";
      ChangeDetectionStrategy3[ChangeDetectionStrategy3["Default"] = 1] = "Default";
    })(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));
    (function(ChangeDetectorStatus2) {
      ChangeDetectorStatus2[ChangeDetectorStatus2["CheckOnce"] = 0] = "CheckOnce";
      ChangeDetectorStatus2[ChangeDetectorStatus2["Checked"] = 1] = "Checked";
      ChangeDetectorStatus2[ChangeDetectorStatus2["CheckAlways"] = 2] = "CheckAlways";
      ChangeDetectorStatus2[ChangeDetectorStatus2["Detached"] = 3] = "Detached";
      ChangeDetectorStatus2[ChangeDetectorStatus2["Errored"] = 4] = "Errored";
      ChangeDetectorStatus2[ChangeDetectorStatus2["Destroyed"] = 5] = "Destroyed";
    })(ChangeDetectorStatus || (ChangeDetectorStatus = {}));
    (function(ViewEncapsulation3) {
      ViewEncapsulation3[ViewEncapsulation3["Emulated"] = 0] = "Emulated";
      ViewEncapsulation3[ViewEncapsulation3["None"] = 2] = "None";
      ViewEncapsulation3[ViewEncapsulation3["ShadowDom"] = 3] = "ShadowDom";
    })(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));
    _global = (() => typeof globalThis !== "undefined" && globalThis || typeof global !== "undefined" && global || typeof window !== "undefined" && window || typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && self)();
    EMPTY_OBJ = {};
    EMPTY_ARRAY = [];
    if ((typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && initNgDevMode()) {
      Object.freeze(EMPTY_OBJ);
      Object.freeze(EMPTY_ARRAY);
    }
    NG_COMP_DEF = getClosureSafeProperty({
      \u0275cmp: getClosureSafeProperty
    });
    NG_DIR_DEF = getClosureSafeProperty({
      \u0275dir: getClosureSafeProperty
    });
    NG_PIPE_DEF = getClosureSafeProperty({
      \u0275pipe: getClosureSafeProperty
    });
    NG_MOD_DEF = getClosureSafeProperty({
      \u0275mod: getClosureSafeProperty
    });
    NG_FACTORY_DEF = getClosureSafeProperty({
      \u0275fac: getClosureSafeProperty
    });
    NG_ELEMENT_ID = getClosureSafeProperty({
      __NG_ELEMENT_ID__: getClosureSafeProperty
    });
    componentDefCount = 0;
    autoRegisterModuleById = {};
    \u0275\u0275defineDirective = \u0275\u0275defineComponent;
    TYPE = 1;
    HAS_TRANSPLANTED_VIEWS = 2;
    NATIVE = 7;
    VIEW_REFS = 8;
    MOVED_VIEWS = 9;
    CONTAINER_HEADER_OFFSET = 10;
    unusedValueExportToPlacateAjd$8 = 1;
    HOST = 0;
    TVIEW = 1;
    FLAGS = 2;
    PARENT = 3;
    NEXT = 4;
    TRANSPLANTED_VIEWS_TO_REFRESH = 5;
    T_HOST = 6;
    CLEANUP = 7;
    CONTEXT = 8;
    INJECTOR$1 = 9;
    RENDERER_FACTORY = 10;
    RENDERER = 11;
    SANITIZER = 12;
    CHILD_HEAD = 13;
    CHILD_TAIL = 14;
    DECLARATION_VIEW = 15;
    DECLARATION_COMPONENT_VIEW = 16;
    DECLARATION_LCONTAINER = 17;
    PREORDER_HOOK_FLAGS = 18;
    QUERIES = 19;
    ID = 20;
    EMBEDDED_VIEW_INJECTOR = 21;
    HEADER_OFFSET = 22;
    TViewTypeAsString = [
      "Root",
      "Component",
      "Embedded"
    ];
    unusedValueExportToPlacateAjd$7 = 1;
    SimpleChange = class {
      constructor(previousValue, currentValue, firstChange) {
        this.previousValue = previousValue;
        this.currentValue = currentValue;
        this.firstChange = firstChange;
      }
      isFirstChange() {
        return this.firstChange;
      }
    };
    \u0275\u0275NgOnChangesFeature.ngInherit = true;
    SIMPLE_CHANGES_STORE = "__ngSimpleChanges__";
    profilerCallback = null;
    setProfiler = (profiler2) => {
      profilerCallback = profiler2;
    };
    profiler = function(event, instance, hookOrListener) {
      if (profilerCallback != null) {
        profilerCallback(event, instance, hookOrListener);
      }
    };
    SVG_NAMESPACE = "svg";
    MATH_ML_NAMESPACE = "math";
    instructionState = {
      lFrame: createLFrame(null),
      bindingsEnabled: true
    };
    _isInCheckNoChangesMode = false;
    leaveDI = leaveViewLight;
    NO_PARENT_INJECTOR = -1;
    NodeInjectorFactory = class {
      constructor(factory, isViewProvider, injectImplementation) {
        this.factory = factory;
        this.resolving = false;
        define_ngDevMode_default && assertDefined(factory, "Factory not specified");
        define_ngDevMode_default && assertEqual(typeof factory, "function", "Expected factory function.");
        this.canSeeViewProviders = isViewProvider;
        this.injectImpl = injectImplementation;
      }
    };
    unusedValueExportToPlacateAjd$6 = 1;
    unusedValueExportToPlacateAjd$5 = 1;
    includeViewProviders = true;
    BLOOM_SIZE = 256;
    BLOOM_MASK = BLOOM_SIZE - 1;
    BLOOM_BUCKET_BITS = 5;
    nextNgElementId = 0;
    NOT_FOUND = {};
    NodeInjector = class {
      constructor(_tNode, _lView) {
        this._tNode = _tNode;
        this._lView = _lView;
      }
      get(token, notFoundValue, flags) {
        return getOrCreateInjectable(this._tNode, this._lView, token, flags, notFoundValue);
      }
    };
    ANNOTATIONS = "__annotations__";
    PARAMETERS = "__parameters__";
    PROP_METADATA = "__prop__metadata__";
    Attribute = makeParamDecorator("Attribute", (attributeName) => ({
      attributeName,
      __NG_ELEMENT_ID__: () => \u0275\u0275injectAttribute(attributeName)
    }));
    InjectionToken = class {
      constructor(_desc, options) {
        this._desc = _desc;
        this.ngMetadataName = "InjectionToken";
        this.\u0275prov = void 0;
        if (typeof options == "number") {
          (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && assertLessThan(options, 0, "Only negative numbers are supported here");
          this.__NG_ELEMENT_ID__ = options;
        } else if (options !== void 0) {
          this.\u0275prov = \u0275\u0275defineInjectable({
            token: this,
            providedIn: options.providedIn || "root",
            factory: options.factory
          });
        }
      }
      get multi() {
        return this;
      }
      toString() {
        return `InjectionToken ${this._desc}`;
      }
    };
    ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken("AnalyzeForEntryComponents");
    emitDistinctChangesOnlyDefaultValue = true;
    Query = class {
    };
    ContentChildren = makePropDecorator("ContentChildren", (selector, data = {}) => Object.assign({
      selector,
      first: false,
      isViewQuery: false,
      descendants: false,
      emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue
    }, data), Query);
    ContentChild = makePropDecorator("ContentChild", (selector, data = {}) => Object.assign({
      selector,
      first: true,
      isViewQuery: false,
      descendants: true
    }, data), Query);
    ViewChildren = makePropDecorator("ViewChildren", (selector, data = {}) => Object.assign({
      selector,
      first: false,
      isViewQuery: true,
      descendants: true,
      emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue
    }, data), Query);
    ViewChild = makePropDecorator("ViewChild", (selector, data) => Object.assign({
      selector,
      first: true,
      isViewQuery: true,
      descendants: true
    }, data), Query);
    (function(FactoryTarget3) {
      FactoryTarget3[FactoryTarget3["Directive"] = 0] = "Directive";
      FactoryTarget3[FactoryTarget3["Component"] = 1] = "Component";
      FactoryTarget3[FactoryTarget3["Injectable"] = 2] = "Injectable";
      FactoryTarget3[FactoryTarget3["Pipe"] = 3] = "Pipe";
      FactoryTarget3[FactoryTarget3["NgModule"] = 4] = "NgModule";
    })(FactoryTarget || (FactoryTarget = {}));
    (function(R3TemplateDependencyKind3) {
      R3TemplateDependencyKind3[R3TemplateDependencyKind3["Directive"] = 0] = "Directive";
      R3TemplateDependencyKind3[R3TemplateDependencyKind3["Pipe"] = 1] = "Pipe";
      R3TemplateDependencyKind3[R3TemplateDependencyKind3["NgModule"] = 2] = "NgModule";
    })(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));
    (function(ViewEncapsulation3) {
      ViewEncapsulation3[ViewEncapsulation3["Emulated"] = 0] = "Emulated";
      ViewEncapsulation3[ViewEncapsulation3["None"] = 2] = "None";
      ViewEncapsulation3[ViewEncapsulation3["ShadowDom"] = 3] = "ShadowDom";
    })(ViewEncapsulation || (ViewEncapsulation = {}));
    Type = Function;
    ES5_DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/;
    ES2015_INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
    ES2015_INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
    ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;
    ReflectionCapabilities = class {
      constructor(reflect) {
        this._reflect = reflect || _global["Reflect"];
      }
      factory(t) {
        return (...args) => new t(...args);
      }
      _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
        let result;
        if (typeof paramTypes === "undefined") {
          result = newArray(paramAnnotations.length);
        } else {
          result = newArray(paramTypes.length);
        }
        for (let i = 0; i < result.length; i++) {
          if (typeof paramTypes === "undefined") {
            result[i] = [];
          } else if (paramTypes[i] && paramTypes[i] != Object) {
            result[i] = [paramTypes[i]];
          } else {
            result[i] = [];
          }
          if (paramAnnotations && paramAnnotations[i] != null) {
            result[i] = result[i].concat(paramAnnotations[i]);
          }
        }
        return result;
      }
      _ownParameters(type, parentCtor) {
        const typeStr = type.toString();
        if (isDelegateCtor(typeStr)) {
          return null;
        }
        if (type.parameters && type.parameters !== parentCtor.parameters) {
          return type.parameters;
        }
        const tsickleCtorParams = type.ctorParameters;
        if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
          const ctorParameters = typeof tsickleCtorParams === "function" ? tsickleCtorParams() : tsickleCtorParams;
          const paramTypes2 = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);
          const paramAnnotations2 = ctorParameters.map((ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
          return this._zipTypesAndAnnotations(paramTypes2, paramAnnotations2);
        }
        const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];
        const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata("design:paramtypes", type);
        if (paramTypes || paramAnnotations) {
          return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
        }
        return newArray(type.length);
      }
      parameters(type) {
        if (!isType(type)) {
          return [];
        }
        const parentCtor = getParentCtor(type);
        let parameters = this._ownParameters(type, parentCtor);
        if (!parameters && parentCtor !== Object) {
          parameters = this.parameters(parentCtor);
        }
        return parameters || [];
      }
      _ownAnnotations(typeOrFunc, parentCtor) {
        if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
          let annotations = typeOrFunc.annotations;
          if (typeof annotations === "function" && annotations.annotations) {
            annotations = annotations.annotations;
          }
          return annotations;
        }
        if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {
          return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
        }
        if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {
          return typeOrFunc[ANNOTATIONS];
        }
        return null;
      }
      annotations(typeOrFunc) {
        if (!isType(typeOrFunc)) {
          return [];
        }
        const parentCtor = getParentCtor(typeOrFunc);
        const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
        const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
        return parentAnnotations.concat(ownAnnotations);
      }
      _ownPropMetadata(typeOrFunc, parentCtor) {
        if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {
          let propMetadata = typeOrFunc.propMetadata;
          if (typeof propMetadata === "function" && propMetadata.propMetadata) {
            propMetadata = propMetadata.propMetadata;
          }
          return propMetadata;
        }
        if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {
          const propDecorators = typeOrFunc.propDecorators;
          const propMetadata = {};
          Object.keys(propDecorators).forEach((prop) => {
            propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
          });
          return propMetadata;
        }
        if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {
          return typeOrFunc[PROP_METADATA];
        }
        return null;
      }
      propMetadata(typeOrFunc) {
        if (!isType(typeOrFunc)) {
          return {};
        }
        const parentCtor = getParentCtor(typeOrFunc);
        const propMetadata = {};
        if (parentCtor !== Object) {
          const parentPropMetadata = this.propMetadata(parentCtor);
          Object.keys(parentPropMetadata).forEach((propName) => {
            propMetadata[propName] = parentPropMetadata[propName];
          });
        }
        const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
        if (ownPropMetadata) {
          Object.keys(ownPropMetadata).forEach((propName) => {
            const decorators = [];
            if (propMetadata.hasOwnProperty(propName)) {
              decorators.push(...propMetadata[propName]);
            }
            decorators.push(...ownPropMetadata[propName]);
            propMetadata[propName] = decorators;
          });
        }
        return propMetadata;
      }
      ownPropMetadata(typeOrFunc) {
        if (!isType(typeOrFunc)) {
          return {};
        }
        return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};
      }
      hasLifecycleHook(type, lcProperty) {
        return type instanceof Type && lcProperty in type.prototype;
      }
    };
    _THROW_IF_NOT_FOUND = {};
    THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
    DI_DECORATOR_FLAG = "__NG_DI_FLAG__";
    NG_TEMP_TOKEN_PATH = "ngTempTokenPath";
    NG_TOKEN_PATH = "ngTokenPath";
    NEW_LINE = /\n/gm;
    NO_NEW_LINE = "\u0275";
    SOURCE = "__source";
    _currentInjector = void 0;
    Inject = attachInjectFlag(
      makeParamDecorator("Inject", (token) => ({
        token
      })),
      -1
    );
    Optional = attachInjectFlag(
      makeParamDecorator("Optional"),
      8
    );
    Self = attachInjectFlag(
      makeParamDecorator("Self"),
      2
    );
    SkipSelf = attachInjectFlag(
      makeParamDecorator("SkipSelf"),
      4
    );
    Host = attachInjectFlag(
      makeParamDecorator("Host"),
      1
    );
    _reflect = null;
    componentResourceResolutionQueue = /* @__PURE__ */ new Map();
    componentDefPendingResolution = /* @__PURE__ */ new Set();
    modules = /* @__PURE__ */ new Map();
    checkForDuplicateNgModules = true;
    DOCUMENT = void 0;
    SafeValueImpl = class {
      constructor(changingThisBreaksApplicationSecurity) {
        this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
      }
      toString() {
        return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`;
      }
    };
    SafeHtmlImpl = class extends SafeValueImpl {
      getTypeName() {
        return "HTML";
      }
    };
    SafeStyleImpl = class extends SafeValueImpl {
      getTypeName() {
        return "Style";
      }
    };
    SafeScriptImpl = class extends SafeValueImpl {
      getTypeName() {
        return "Script";
      }
    };
    SafeUrlImpl = class extends SafeValueImpl {
      getTypeName() {
        return "URL";
      }
    };
    SafeResourceUrlImpl = class extends SafeValueImpl {
      getTypeName() {
        return "ResourceURL";
      }
    };
    DOMParserHelper = class {
      constructor(inertDocumentHelper) {
        this.inertDocumentHelper = inertDocumentHelper;
      }
      getInertBodyElement(html) {
        html = "<body><remove></remove>" + html;
        try {
          const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html), "text/html").body;
          if (body === null) {
            return this.inertDocumentHelper.getInertBodyElement(html);
          }
          body.removeChild(body.firstChild);
          return body;
        } catch (_a) {
          return null;
        }
      }
    };
    InertDocumentHelper = class {
      constructor(defaultDoc) {
        this.defaultDoc = defaultDoc;
        this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert");
        if (this.inertDocument.body == null) {
          const inertHtml = this.inertDocument.createElement("html");
          this.inertDocument.appendChild(inertHtml);
          const inertBodyElement = this.inertDocument.createElement("body");
          inertHtml.appendChild(inertBodyElement);
        }
      }
      getInertBodyElement(html) {
        const templateEl = this.inertDocument.createElement("template");
        if ("content" in templateEl) {
          templateEl.innerHTML = trustedHTMLFromString(html);
          return templateEl;
        }
        const inertBody = this.inertDocument.createElement("body");
        inertBody.innerHTML = trustedHTMLFromString(html);
        if (this.defaultDoc.documentMode) {
          this.stripCustomNsAttrs(inertBody);
        }
        return inertBody;
      }
      stripCustomNsAttrs(el) {
        const elAttrs = el.attributes;
        for (let i = elAttrs.length - 1; 0 < i; i--) {
          const attrib = elAttrs.item(i);
          const attrName = attrib.name;
          if (attrName === "xmlns:ns1" || attrName.indexOf("ns1:") === 0) {
            el.removeAttribute(attrName);
          }
        }
        let childNode = el.firstChild;
        while (childNode) {
          if (childNode.nodeType === Node.ELEMENT_NODE)
            this.stripCustomNsAttrs(childNode);
          childNode = childNode.nextSibling;
        }
      }
    };
    SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi;
    DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
    VOID_ELEMENTS = tagSet("area,br,col,hr,img,wbr");
    OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr");
    OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet("rp,rt");
    OPTIONAL_END_TAG_ELEMENTS = merge3(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
    BLOCK_ELEMENTS = merge3(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul"));
    INLINE_ELEMENTS = merge3(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video"));
    VALID_ELEMENTS = merge3(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
    URI_ATTRS = tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href");
    SRCSET_ATTRS = tagSet("srcset");
    HTML_ATTRS = tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width");
    ARIA_ATTRS = tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext");
    VALID_ATTRS = merge3(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS, ARIA_ATTRS);
    SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet("script,style,template");
    SanitizingHtmlSerializer = class {
      constructor() {
        this.sanitizedSomething = false;
        this.buf = [];
      }
      sanitizeChildren(el) {
        let current = el.firstChild;
        let traverseContent = true;
        while (current) {
          if (current.nodeType === Node.ELEMENT_NODE) {
            traverseContent = this.startElement(current);
          } else if (current.nodeType === Node.TEXT_NODE) {
            this.chars(current.nodeValue);
          } else {
            this.sanitizedSomething = true;
          }
          if (traverseContent && current.firstChild) {
            current = current.firstChild;
            continue;
          }
          while (current) {
            if (current.nodeType === Node.ELEMENT_NODE) {
              this.endElement(current);
            }
            let next = this.checkClobberedElement(current, current.nextSibling);
            if (next) {
              current = next;
              break;
            }
            current = this.checkClobberedElement(current, current.parentNode);
          }
        }
        return this.buf.join("");
      }
      startElement(element) {
        const tagName = element.nodeName.toLowerCase();
        if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
          this.sanitizedSomething = true;
          return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
        }
        this.buf.push("<");
        this.buf.push(tagName);
        const elAttrs = element.attributes;
        for (let i = 0; i < elAttrs.length; i++) {
          const elAttr = elAttrs.item(i);
          const attrName = elAttr.name;
          const lower = attrName.toLowerCase();
          if (!VALID_ATTRS.hasOwnProperty(lower)) {
            this.sanitizedSomething = true;
            continue;
          }
          let value = elAttr.value;
          if (URI_ATTRS[lower])
            value = _sanitizeUrl(value);
          if (SRCSET_ATTRS[lower])
            value = sanitizeSrcset(value);
          this.buf.push(" ", attrName, '="', encodeEntities(value), '"');
        }
        this.buf.push(">");
        return true;
      }
      endElement(current) {
        const tagName = current.nodeName.toLowerCase();
        if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
          this.buf.push("</");
          this.buf.push(tagName);
          this.buf.push(">");
        }
      }
      chars(chars) {
        this.buf.push(encodeEntities(chars));
      }
      checkClobberedElement(node, nextNode) {
        if (nextNode && (node.compareDocumentPosition(nextNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) {
          throw new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
        }
        return nextNode;
      }
    };
    SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
    (function(SecurityContext3) {
      SecurityContext3[SecurityContext3["NONE"] = 0] = "NONE";
      SecurityContext3[SecurityContext3["HTML"] = 1] = "HTML";
      SecurityContext3[SecurityContext3["STYLE"] = 2] = "STYLE";
      SecurityContext3[SecurityContext3["SCRIPT"] = 3] = "SCRIPT";
      SecurityContext3[SecurityContext3["URL"] = 4] = "URL";
      SecurityContext3[SecurityContext3["RESOURCE_URL"] = 5] = "RESOURCE_URL";
    })(SecurityContext || (SecurityContext = {}));
    ENVIRONMENT_INITIALIZER = new InjectionToken("ENVIRONMENT_INITIALIZER");
    INJECTOR = new InjectionToken(
      "INJECTOR",
      -1
    );
    INJECTOR_DEF_TYPES = new InjectionToken("INJECTOR_DEF_TYPES");
    NullInjector = class {
      get(token, notFoundValue = THROW_IF_NOT_FOUND) {
        if (notFoundValue === THROW_IF_NOT_FOUND) {
          const error2 = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
          error2.name = "NullInjectorError";
          throw error2;
        }
        return notFoundValue;
      }
    };
    USE_VALUE$1 = getClosureSafeProperty({
      provide: String,
      useValue: getClosureSafeProperty
    });
    INJECTOR_SCOPE = new InjectionToken("Set Injector scope.");
    NOT_YET = {};
    CIRCULAR = {};
    NULL_INJECTOR$1 = void 0;
    EnvironmentInjector = class {
    };
    R3Injector = class extends EnvironmentInjector {
      constructor(providers, parent, source, scopes) {
        super();
        this.parent = parent;
        this.source = source;
        this.scopes = scopes;
        this.records = /* @__PURE__ */ new Map();
        this._ngOnDestroyHooks = /* @__PURE__ */ new Set();
        this._onDestroyHooks = [];
        this._destroyed = false;
        forEachSingleProvider(providers, (provider) => this.processProvider(provider));
        this.records.set(INJECTOR, makeRecord(void 0, this));
        if (scopes.has("environment")) {
          this.records.set(EnvironmentInjector, makeRecord(void 0, this));
        }
        const record = this.records.get(INJECTOR_SCOPE);
        if (record != null && typeof record.value === "string") {
          this.scopes.add(record.value);
        }
        this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES.multi, EMPTY_ARRAY, InjectFlags.Self));
      }
      get destroyed() {
        return this._destroyed;
      }
      destroy() {
        this.assertNotDestroyed();
        this._destroyed = true;
        try {
          for (const service of this._ngOnDestroyHooks) {
            service.ngOnDestroy();
          }
          for (const hook of this._onDestroyHooks) {
            hook();
          }
        } finally {
          this.records.clear();
          this._ngOnDestroyHooks.clear();
          this.injectorDefTypes.clear();
          this._onDestroyHooks.length = 0;
        }
      }
      onDestroy(callback) {
        this._onDestroyHooks.push(callback);
      }
      runInContext(fn2) {
        this.assertNotDestroyed();
        const previousInjector = setCurrentInjector(this);
        const previousInjectImplementation = setInjectImplementation(void 0);
        try {
          return fn2();
        } finally {
          setCurrentInjector(previousInjector);
          setInjectImplementation(previousInjectImplementation);
        }
      }
      get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {
        this.assertNotDestroyed();
        const previousInjector = setCurrentInjector(this);
        const previousInjectImplementation = setInjectImplementation(void 0);
        try {
          if (!(flags & InjectFlags.SkipSelf)) {
            let record = this.records.get(token);
            if (record === void 0) {
              const def = couldBeInjectableType(token) && getInjectableDef(token);
              if (def && this.injectableDefInScope(def)) {
                record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);
              } else {
                record = null;
              }
              this.records.set(token, record);
            }
            if (record != null) {
              return this.hydrate(token, record);
            }
          }
          const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();
          notFoundValue = flags & InjectFlags.Optional && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;
          return nextInjector.get(token, notFoundValue);
        } catch (e) {
          if (e.name === "NullInjectorError") {
            const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
            path.unshift(stringify(token));
            if (previousInjector) {
              throw e;
            } else {
              return catchInjectorError(e, token, "R3InjectorError", this.source);
            }
          } else {
            throw e;
          }
        } finally {
          setInjectImplementation(previousInjectImplementation);
          setCurrentInjector(previousInjector);
        }
      }
      resolveInjectorInitializers() {
        const previousInjector = setCurrentInjector(this);
        const previousInjectImplementation = setInjectImplementation(void 0);
        try {
          const initializers = this.get(ENVIRONMENT_INITIALIZER.multi, EMPTY_ARRAY, InjectFlags.Self);
          if (define_ngDevMode_default && !Array.isArray(initializers)) {
            throw new RuntimeError(
              209,
              `Unexpected type of the \`ENVIRONMENT_INITIALIZER\` token value (expected an array, but got ${typeof initializers}). Please check that the \`ENVIRONMENT_INITIALIZER\` token is configured as a \`multi: true\` provider.`
            );
          }
          for (const initializer of initializers) {
            initializer();
          }
        } finally {
          setCurrentInjector(previousInjector);
          setInjectImplementation(previousInjectImplementation);
        }
      }
      toString() {
        const tokens = [];
        const records = this.records;
        for (const token of records.keys()) {
          tokens.push(stringify(token));
        }
        return `R3Injector[${tokens.join(", ")}]`;
      }
      assertNotDestroyed() {
        if (this._destroyed) {
          throw new RuntimeError(
            205,
            define_ngDevMode_default && "Injector has already been destroyed."
          );
        }
      }
      processProvider(provider) {
        provider = resolveForwardRef(provider);
        let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);
        const record = providerToRecord(provider);
        if (!isTypeProvider(provider) && provider.multi === true) {
          let multiRecord = this.records.get(token);
          if (multiRecord) {
            if (define_ngDevMode_default && multiRecord.multi === void 0) {
              throwMixedMultiProviderError();
            }
          } else {
            multiRecord = makeRecord(void 0, NOT_YET, true);
            multiRecord.factory = () => injectArgs(multiRecord.multi);
            this.records.set(token, multiRecord);
          }
          token = provider;
          multiRecord.multi.push(provider);
        } else {
          const existing = this.records.get(token);
          if (define_ngDevMode_default && existing && existing.multi !== void 0) {
            throwMixedMultiProviderError();
          }
        }
        this.records.set(token, record);
      }
      hydrate(token, record) {
        if (define_ngDevMode_default && record.value === CIRCULAR) {
          throwCyclicDependencyError(stringify(token));
        } else if (record.value === NOT_YET) {
          record.value = CIRCULAR;
          record.value = record.factory();
        }
        if (typeof record.value === "object" && record.value && hasOnDestroy(record.value)) {
          this._ngOnDestroyHooks.add(record.value);
        }
        return record.value;
      }
      injectableDefInScope(def) {
        if (!def.providedIn) {
          return false;
        }
        const providedIn = resolveForwardRef(def.providedIn);
        if (typeof providedIn === "string") {
          return providedIn === "any" || this.scopes.has(providedIn);
        } else {
          return this.injectorDefTypes.has(providedIn);
        }
      }
    };
    ComponentRef$1 = class {
    };
    ComponentFactory$1 = class {
    };
    ERROR_COMPONENT = "ngComponent";
    _NullComponentFactoryResolver = class {
      resolveComponentFactory(component) {
        throw noComponentFactoryError(component);
      }
    };
    ComponentFactoryResolver$1 = class {
    };
    ComponentFactoryResolver$1.NULL = new _NullComponentFactoryResolver();
    ElementRef = class {
      constructor(nativeElement) {
        this.nativeElement = nativeElement;
      }
    };
    ElementRef.__NG_ELEMENT_ID__ = injectElementRef;
    Renderer2Interceptor = new InjectionToken("Renderer2Interceptor");
    RendererFactory2 = class {
    };
    Renderer2 = class {
    };
    Renderer2.__NG_ELEMENT_ID__ = () => injectRenderer2();
    Sanitizer = class {
    };
    Sanitizer.\u0275prov = \u0275\u0275defineInjectable({
      token: Sanitizer,
      providedIn: "root",
      factory: () => null
    });
    Version = class {
      constructor(full) {
        this.full = full;
        this.major = full.split(".")[0];
        this.minor = full.split(".")[1];
        this.patch = full.split(".").slice(2).join(".");
      }
    };
    VERSION = new Version("14.1.1");
    NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
    CUSTOM_ELEMENTS_SCHEMA = {
      name: "custom-elements"
    };
    NO_ERRORS_SCHEMA = {
      name: "no-errors-schema"
    };
    shouldThrowErrorOnUnknownElement = false;
    shouldThrowErrorOnUnknownProperty = false;
    KNOWN_CONTROL_FLOW_DIRECTIVES = /* @__PURE__ */ new Map([["ngIf", "NgIf"], ["ngFor", "NgForOf"], ["ngSwitchCase", "NgSwitchCase"], ["ngSwitchDefault", "NgSwitchDefault"]]);
    ERROR_ORIGINAL_ERROR = "ngOriginalError";
    ErrorHandler = class {
      constructor() {
        this._console = console;
      }
      handleError(error2) {
        const originalError = this._findOriginalError(error2);
        this._console.error("ERROR", error2);
        if (originalError) {
          this._console.error("ORIGINAL ERROR", originalError);
        }
      }
      _findOriginalError(error2) {
        let e = error2 && getOriginalError(error2);
        while (e && getOriginalError(e)) {
          e = getOriginalError(e);
        }
        return e || null;
      }
    };
    COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;
    COMMENT_DELIMITER = /(<|>)/;
    COMMENT_DELIMITER_ESCAPED = "\u200B$1\u200B";
    CAMEL_CASE_REGEXP = /([A-Z])/g;
    TRACKED_LVIEWS = /* @__PURE__ */ new Map();
    uniqueIdCounter = 0;
    LContext = class {
      constructor(lViewId, nodeIndex, native) {
        this.lViewId = lViewId;
        this.nodeIndex = nodeIndex;
        this.native = native;
      }
      get lView() {
        return getLViewById(this.lViewId);
      }
    };
    MONKEY_PATCH_KEY_NAME = "__ngContext__";
    defaultScheduler = (() => (typeof requestAnimationFrame !== "undefined" && requestAnimationFrame || setTimeout).bind(_global))();
    INTERPOLATION_DELIMITER = `\uFFFD`;
    (function(RendererStyleFlags22) {
      RendererStyleFlags22[RendererStyleFlags22["Important"] = 1] = "Important";
      RendererStyleFlags22[RendererStyleFlags22["DashCase"] = 2] = "DashCase";
    })(RendererStyleFlags2 || (RendererStyleFlags2 = {}));
    unusedValueExportToPlacateAjd$4 = 1;
    unusedValueExportToPlacateAjd$3 = 1;
    unusedValueToPlacateAjd$2 = unusedValueExportToPlacateAjd$8 + unusedValueExportToPlacateAjd$5 + unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd$3 + unusedValueExportToPlacateAjd$7;
    _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;
    unusedValueToPlacateAjd$1 = unusedValueExportToPlacateAjd$5 + unusedValueExportToPlacateAjd$4;
    NG_TEMPLATE_SELECTOR = "ng-template";
    NO_CHANGE = typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default ? {
      __brand__: "NO_CHANGE"
    } : {};
    angularCoreDiEnv = {
      "\u0275\u0275defineInjectable": \u0275\u0275defineInjectable,
      "\u0275\u0275defineInjector": \u0275\u0275defineInjector,
      "\u0275\u0275inject": \u0275\u0275inject,
      "\u0275\u0275invalidFactoryDep": \u0275\u0275invalidFactoryDep,
      "resolveForwardRef": resolveForwardRef
    };
    USE_VALUE = getClosureSafeProperty({
      provide: String,
      useValue: getClosureSafeProperty
    });
    Injectable = makeDecorator("Injectable", void 0, void 0, void 0, (type, meta) => compileInjectable(type, meta));
    Injector = class {
      static create(options, parent) {
        var _a;
        if (Array.isArray(options)) {
          return createInjector({
            name: ""
          }, parent, options, "");
        } else {
          const name = (_a = options.name) !== null && _a !== void 0 ? _a : "";
          return createInjector({
            name
          }, options.parent, options.providers, name);
        }
      }
    };
    Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
    Injector.NULL = new NullInjector();
    Injector.\u0275prov = \u0275\u0275defineInjectable({
      token: Injector,
      providedIn: "any",
      factory: () => \u0275\u0275inject(INJECTOR)
    });
    Injector.__NG_ELEMENT_ID__ = -1;
    ReflectiveKey = class {
      constructor(token, id) {
        this.token = token;
        this.id = id;
        if (!token) {
          throw new RuntimeError(
            208,
            define_ngDevMode_default && "Token must be defined!"
          );
        }
        this.displayName = stringify(this.token);
      }
      static get(token) {
        return _globalKeyRegistry.get(resolveForwardRef(token));
      }
      static get numberOfKeys() {
        return _globalKeyRegistry.numberOfKeys;
      }
    };
    KeyRegistry = class {
      constructor() {
        this._allKeys = /* @__PURE__ */ new Map();
      }
      get(token) {
        if (token instanceof ReflectiveKey)
          return token;
        if (this._allKeys.has(token)) {
          return this._allKeys.get(token);
        }
        const newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
        this._allKeys.set(token, newKey);
        return newKey;
      }
      get numberOfKeys() {
        return this._allKeys.size;
      }
    };
    _globalKeyRegistry = new KeyRegistry();
    ReflectiveDependency = class {
      constructor(key, optional, visibility) {
        this.key = key;
        this.optional = optional;
        this.visibility = visibility;
      }
      static fromKey(key) {
        return new ReflectiveDependency(key, false, null);
      }
    };
    _EMPTY_LIST = [];
    ResolvedReflectiveProvider_ = class {
      constructor(key, resolvedFactories, multiProvider) {
        this.key = key;
        this.resolvedFactories = resolvedFactories;
        this.multiProvider = multiProvider;
        this.resolvedFactory = this.resolvedFactories[0];
      }
    };
    ResolvedReflectiveFactory = class {
      constructor(factory, dependencies) {
        this.factory = factory;
        this.dependencies = dependencies;
      }
    };
    UNDEFINED = {};
    ReflectiveInjector = class {
      static resolve(providers) {
        return resolveReflectiveProviders(providers);
      }
      static resolveAndCreate(providers, parent) {
        const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
        return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
      }
      static fromResolvedProviders(providers, parent) {
        return new ReflectiveInjector_(providers, parent);
      }
    };
    ReflectiveInjector_ = class {
      constructor(_providers, _parent) {
        this._constructionCounter = 0;
        this._providers = _providers;
        this.parent = _parent || null;
        const len = _providers.length;
        this.keyIds = [];
        this.objs = [];
        for (let i = 0; i < len; i++) {
          this.keyIds[i] = _providers[i].key.id;
          this.objs[i] = UNDEFINED;
        }
      }
      get(token, notFoundValue = THROW_IF_NOT_FOUND) {
        return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);
      }
      resolveAndCreateChild(providers) {
        const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
        return this.createChildFromResolved(ResolvedReflectiveProviders);
      }
      createChildFromResolved(providers) {
        const inj = new ReflectiveInjector_(providers);
        inj.parent = this;
        return inj;
      }
      resolveAndInstantiate(provider) {
        return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
      }
      instantiateResolved(provider) {
        return this._instantiateProvider(provider);
      }
      getProviderAtIndex(index) {
        if (index < 0 || index >= this._providers.length) {
          throw outOfBoundsError(index);
        }
        return this._providers[index];
      }
      _new(provider) {
        if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {
          throw cyclicDependencyError(this, provider.key);
        }
        return this._instantiateProvider(provider);
      }
      _getMaxNumberOfObjects() {
        return this.objs.length;
      }
      _instantiateProvider(provider) {
        if (provider.multiProvider) {
          const res = [];
          for (let i = 0; i < provider.resolvedFactories.length; ++i) {
            res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
          }
          return res;
        } else {
          return this._instantiate(provider, provider.resolvedFactories[0]);
        }
      }
      _instantiate(provider, ResolvedReflectiveFactory2) {
        const factory = ResolvedReflectiveFactory2.factory;
        let deps;
        try {
          deps = ResolvedReflectiveFactory2.dependencies.map((dep) => this._getByReflectiveDependency(dep));
        } catch (e) {
          if (e.addKey) {
            e.addKey(this, provider.key);
          }
          throw e;
        }
        let obj;
        try {
          obj = factory(...deps);
        } catch (e) {
          throw instantiationError(this, e, e.stack, provider.key);
        }
        return obj;
      }
      _getByReflectiveDependency(dep) {
        return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);
      }
      _getByKey(key, visibility, notFoundValue) {
        if (key === ReflectiveInjector_.INJECTOR_KEY) {
          return this;
        }
        if (visibility instanceof Self) {
          return this._getByKeySelf(key, notFoundValue);
        } else {
          return this._getByKeyDefault(key, notFoundValue, visibility);
        }
      }
      _getObjByKeyId(keyId) {
        for (let i = 0; i < this.keyIds.length; i++) {
          if (this.keyIds[i] === keyId) {
            if (this.objs[i] === UNDEFINED) {
              this.objs[i] = this._new(this._providers[i]);
            }
            return this.objs[i];
          }
        }
        return UNDEFINED;
      }
      _throwOrNull(key, notFoundValue) {
        if (notFoundValue !== THROW_IF_NOT_FOUND) {
          return notFoundValue;
        } else {
          throw noProviderError(this, key);
        }
      }
      _getByKeySelf(key, notFoundValue) {
        const obj = this._getObjByKeyId(key.id);
        return obj !== UNDEFINED ? obj : this._throwOrNull(key, notFoundValue);
      }
      _getByKeyDefault(key, notFoundValue, visibility) {
        let inj;
        if (visibility instanceof SkipSelf) {
          inj = this.parent;
        } else {
          inj = this;
        }
        while (inj instanceof ReflectiveInjector_) {
          const inj_ = inj;
          const obj = inj_._getObjByKeyId(key.id);
          if (obj !== UNDEFINED)
            return obj;
          inj = inj_.parent;
        }
        if (inj !== null) {
          return inj.get(key.token, notFoundValue);
        } else {
          return this._throwOrNull(key, notFoundValue);
        }
      }
      get displayName() {
        const providers = _mapProviders(this, (b) => ' "' + b.key.displayName + '" ').join(", ");
        return `ReflectiveInjector(providers: [${providers}])`;
      }
      toString() {
        return this.displayName;
      }
    };
    ReflectiveInjector_.INJECTOR_KEY = ReflectiveKey.get(Injector);
    LRootView = class extends Array {
    };
    LComponentView = class extends Array {
    };
    LEmbeddedView = class extends Array {
    };
    TViewConstructor = class TView {
      constructor(type, blueprint, template, queries, viewQuery, declTNode, data, bindingStartIndex, expandoStartIndex, hostBindingOpCodes, firstCreatePass, firstUpdatePass, staticViewQueries, staticContentQueries, preOrderHooks, preOrderCheckHooks, contentHooks, contentCheckHooks, viewHooks, viewCheckHooks, destroyHooks, cleanup, contentQueries, components, directiveRegistry, pipeRegistry, firstChild, schemas, consts, incompleteFirstPass, _decls, _vars) {
        this.type = type;
        this.blueprint = blueprint;
        this.template = template;
        this.queries = queries;
        this.viewQuery = viewQuery;
        this.declTNode = declTNode;
        this.data = data;
        this.bindingStartIndex = bindingStartIndex;
        this.expandoStartIndex = expandoStartIndex;
        this.hostBindingOpCodes = hostBindingOpCodes;
        this.firstCreatePass = firstCreatePass;
        this.firstUpdatePass = firstUpdatePass;
        this.staticViewQueries = staticViewQueries;
        this.staticContentQueries = staticContentQueries;
        this.preOrderHooks = preOrderHooks;
        this.preOrderCheckHooks = preOrderCheckHooks;
        this.contentHooks = contentHooks;
        this.contentCheckHooks = contentCheckHooks;
        this.viewHooks = viewHooks;
        this.viewCheckHooks = viewCheckHooks;
        this.destroyHooks = destroyHooks;
        this.cleanup = cleanup;
        this.contentQueries = contentQueries;
        this.components = components;
        this.directiveRegistry = directiveRegistry;
        this.pipeRegistry = pipeRegistry;
        this.firstChild = firstChild;
        this.schemas = schemas;
        this.consts = consts;
        this.incompleteFirstPass = incompleteFirstPass;
        this._decls = _decls;
        this._vars = _vars;
      }
      get template_() {
        const buf = [];
        processTNodeChildren(this.firstChild, buf);
        return buf.join("");
      }
      get type_() {
        return TViewTypeAsString[this.type] || `TViewType.?${this.type}?`;
      }
    };
    TNode = class {
      constructor(tView_, type, index, insertBeforeIndex, injectorIndex, directiveStart, directiveEnd, directiveStylingLast, propertyBindings, flags, providerIndexes, value, attrs, mergedAttrs, localNames, initialInputs, inputs, outputs, tViews, next, projectionNext, child, parent, projection, styles, stylesWithoutHost, residualStyles, classes, classesWithoutHost, residualClasses, classBindings, styleBindings) {
        this.tView_ = tView_;
        this.type = type;
        this.index = index;
        this.insertBeforeIndex = insertBeforeIndex;
        this.injectorIndex = injectorIndex;
        this.directiveStart = directiveStart;
        this.directiveEnd = directiveEnd;
        this.directiveStylingLast = directiveStylingLast;
        this.propertyBindings = propertyBindings;
        this.flags = flags;
        this.providerIndexes = providerIndexes;
        this.value = value;
        this.attrs = attrs;
        this.mergedAttrs = mergedAttrs;
        this.localNames = localNames;
        this.initialInputs = initialInputs;
        this.inputs = inputs;
        this.outputs = outputs;
        this.tViews = tViews;
        this.next = next;
        this.projectionNext = projectionNext;
        this.child = child;
        this.parent = parent;
        this.projection = projection;
        this.styles = styles;
        this.stylesWithoutHost = stylesWithoutHost;
        this.residualStyles = residualStyles;
        this.classes = classes;
        this.classesWithoutHost = classesWithoutHost;
        this.residualClasses = residualClasses;
        this.classBindings = classBindings;
        this.styleBindings = styleBindings;
      }
      debugNodeInjectorPath(lView) {
        const path = [];
        let injectorIndex = getInjectorIndex(this, lView);
        if (injectorIndex === -1) {
          const parentLocation = getParentInjectorLocation(this, lView);
          if (parentLocation !== NO_PARENT_INJECTOR) {
            injectorIndex = getParentInjectorIndex(parentLocation);
            lView = getParentInjectorView(parentLocation, lView);
          } else {
          }
        }
        while (injectorIndex !== -1) {
          define_ngDevMode_default && assertNodeInjector(lView, injectorIndex);
          const tNode = lView[TVIEW].data[injectorIndex + 8];
          path.push(buildDebugNode(tNode, lView));
          const parentLocation = lView[injectorIndex + 8];
          if (parentLocation === NO_PARENT_INJECTOR) {
            injectorIndex = -1;
          } else {
            injectorIndex = getParentInjectorIndex(parentLocation);
            lView = getParentInjectorView(parentLocation, lView);
          }
        }
        return path;
      }
      get type_() {
        return toTNodeTypeAsString(this.type) || `TNodeType.?${this.type}?`;
      }
      get flags_() {
        const flags = [];
        if (this.flags & 16)
          flags.push("TNodeFlags.hasClassInput");
        if (this.flags & 8)
          flags.push("TNodeFlags.hasContentQuery");
        if (this.flags & 32)
          flags.push("TNodeFlags.hasStyleInput");
        if (this.flags & 128)
          flags.push("TNodeFlags.hasHostBindings");
        if (this.flags & 2)
          flags.push("TNodeFlags.isComponentHost");
        if (this.flags & 1)
          flags.push("TNodeFlags.isDirectiveHost");
        if (this.flags & 64)
          flags.push("TNodeFlags.isDetached");
        if (this.flags & 4)
          flags.push("TNodeFlags.isProjected");
        return flags.join("|");
      }
      get template_() {
        if (this.type & 1)
          return this.value;
        const buf = [];
        const tagName = typeof this.value === "string" && this.value || this.type_;
        buf.push("<", tagName);
        if (this.flags) {
          buf.push(" ", this.flags_);
        }
        if (this.attrs) {
          for (let i = 0; i < this.attrs.length; ) {
            const attrName = this.attrs[i++];
            if (typeof attrName == "number") {
              break;
            }
            const attrValue = this.attrs[i++];
            buf.push(" ", attrName, '="', attrValue, '"');
          }
        }
        buf.push(">");
        processTNodeChildren(this.child, buf);
        buf.push("</", tagName, ">");
        return buf.join("");
      }
      get styleBindings_() {
        return toDebugStyleBinding(this, false);
      }
      get classBindings_() {
        return toDebugStyleBinding(this, true);
      }
      get providerIndexStart_() {
        return this.providerIndexes & 1048575;
      }
      get providerIndexEnd_() {
        return this.providerIndexStart_ + (this.providerIndexes >>> 20);
      }
    };
    TNodeDebug = TNode;
    TViewData = class extends Array {
    };
    LViewBlueprint = class extends Array {
    };
    MatchesArray = class extends Array {
    };
    TViewComponents = class extends Array {
    };
    TNodeLocalNames = class extends Array {
    };
    TNodeInitialInputs = class extends Array {
    };
    LCleanup = class extends Array {
    };
    TCleanup = class extends Array {
    };
    LViewDebug = class {
      constructor(_raw_lView) {
        this._raw_lView = _raw_lView;
      }
      get flags() {
        const flags = this._raw_lView[FLAGS];
        return {
          __raw__flags__: flags,
          initPhaseState: flags & 3,
          creationMode: !!(flags & 4),
          firstViewPass: !!(flags & 8),
          checkAlways: !!(flags & 16),
          dirty: !!(flags & 32),
          attached: !!(flags & 64),
          destroyed: !!(flags & 128),
          isRoot: !!(flags & 256),
          indexWithinInitPhase: flags >> 11
        };
      }
      get parent() {
        return toDebug(this._raw_lView[PARENT]);
      }
      get hostHTML() {
        return toHtml(this._raw_lView[HOST], true);
      }
      get html() {
        return (this.nodes || []).map(mapToHTML).join("");
      }
      get context() {
        return this._raw_lView[CONTEXT];
      }
      get nodes() {
        const lView = this._raw_lView;
        const tNode = lView[TVIEW].firstChild;
        return toDebugNodes(tNode, lView);
      }
      get template() {
        return this.tView.template_;
      }
      get tView() {
        return this._raw_lView[TVIEW];
      }
      get cleanup() {
        return this._raw_lView[CLEANUP];
      }
      get injector() {
        return this._raw_lView[INJECTOR$1];
      }
      get rendererFactory() {
        return this._raw_lView[RENDERER_FACTORY];
      }
      get renderer() {
        return this._raw_lView[RENDERER];
      }
      get sanitizer() {
        return this._raw_lView[SANITIZER];
      }
      get childHead() {
        return toDebug(this._raw_lView[CHILD_HEAD]);
      }
      get next() {
        return toDebug(this._raw_lView[NEXT]);
      }
      get childTail() {
        return toDebug(this._raw_lView[CHILD_TAIL]);
      }
      get declarationView() {
        return toDebug(this._raw_lView[DECLARATION_VIEW]);
      }
      get queries() {
        return this._raw_lView[QUERIES];
      }
      get tHost() {
        return this._raw_lView[T_HOST];
      }
      get id() {
        return this._raw_lView[ID];
      }
      get decls() {
        return toLViewRange(this.tView, this._raw_lView, HEADER_OFFSET, this.tView.bindingStartIndex);
      }
      get vars() {
        return toLViewRange(this.tView, this._raw_lView, this.tView.bindingStartIndex, this.tView.expandoStartIndex);
      }
      get expando() {
        return toLViewRange(this.tView, this._raw_lView, this.tView.expandoStartIndex, this._raw_lView.length);
      }
      get childViews() {
        const childViews = [];
        let child = this.childHead;
        while (child) {
          childViews.push(child);
          child = child.next;
        }
        return childViews;
      }
    };
    LContainerDebug = class {
      constructor(_raw_lContainer) {
        this._raw_lContainer = _raw_lContainer;
      }
      get hasTransplantedViews() {
        return this._raw_lContainer[HAS_TRANSPLANTED_VIEWS];
      }
      get views() {
        return this._raw_lContainer.slice(CONTAINER_HEADER_OFFSET).map(toDebug);
      }
      get parent() {
        return toDebug(this._raw_lContainer[PARENT]);
      }
      get movedViews() {
        return this._raw_lContainer[MOVED_VIEWS];
      }
      get host() {
        return this._raw_lContainer[HOST];
      }
      get native() {
        return this._raw_lContainer[NATIVE];
      }
      get next() {
        return toDebug(this._raw_lContainer[NEXT]);
      }
    };
    _CLEAN_PROMISE = (() => Promise.resolve(null))();
    LContainerArray = class LContainer extends Array {
    };
    CLEAN_PROMISE = _CLEAN_PROMISE;
    ViewRef$1 = class {
      constructor(_lView, _cdRefInjectingView) {
        this._lView = _lView;
        this._cdRefInjectingView = _cdRefInjectingView;
        this._appRef = null;
        this._attachedToViewContainer = false;
      }
      get rootNodes() {
        const lView = this._lView;
        const tView = lView[TVIEW];
        return collectNativeNodes(tView, lView, tView.firstChild, []);
      }
      get context() {
        return this._lView[CONTEXT];
      }
      set context(value) {
        this._lView[CONTEXT] = value;
      }
      get destroyed() {
        return (this._lView[FLAGS] & 128) === 128;
      }
      destroy() {
        if (this._appRef) {
          this._appRef.detachView(this);
        } else if (this._attachedToViewContainer) {
          const parent = this._lView[PARENT];
          if (isLContainer(parent)) {
            const viewRefs = parent[VIEW_REFS];
            const index = viewRefs ? viewRefs.indexOf(this) : -1;
            if (index > -1) {
              define_ngDevMode_default && assertEqual(index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, "An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.");
              detachView(parent, index);
              removeFromArray(viewRefs, index);
            }
          }
          this._attachedToViewContainer = false;
        }
        destroyLView(this._lView[TVIEW], this._lView);
      }
      onDestroy(callback) {
        storeCleanupWithContext(this._lView[TVIEW], this._lView, null, callback);
      }
      markForCheck() {
        markViewDirty(this._cdRefInjectingView || this._lView);
      }
      detach() {
        this._lView[FLAGS] &= ~64;
      }
      reattach() {
        this._lView[FLAGS] |= 64;
      }
      detectChanges() {
        detectChangesInternal(this._lView[TVIEW], this._lView, this.context);
      }
      checkNoChanges() {
        if (define_ngDevMode_default) {
          checkNoChangesInternal(this._lView[TVIEW], this._lView, this.context);
        }
      }
      attachToViewContainerRef() {
        if (this._appRef) {
          throw new RuntimeError(
            902,
            define_ngDevMode_default && "This view is already attached directly to the ApplicationRef!"
          );
        }
        this._attachedToViewContainer = true;
      }
      detachFromAppRef() {
        this._appRef = null;
        renderDetachView(this._lView[TVIEW], this._lView);
      }
      attachToAppRef(appRef) {
        if (this._attachedToViewContainer) {
          throw new RuntimeError(
            902,
            define_ngDevMode_default && "This view is already attached to a ViewContainer!"
          );
        }
        this._appRef = appRef;
      }
    };
    RootViewRef = class extends ViewRef$1 {
      constructor(_view) {
        super(_view);
        this._view = _view;
      }
      detectChanges() {
        detectChangesInRootView(this._view);
      }
      checkNoChanges() {
        if (define_ngDevMode_default) {
          checkNoChangesInRootView(this._view);
        }
      }
      get context() {
        return null;
      }
    };
    ComponentFactoryResolver = class extends ComponentFactoryResolver$1 {
      constructor(ngModule) {
        super();
        this.ngModule = ngModule;
      }
      resolveComponentFactory(component) {
        define_ngDevMode_default && assertComponentType(component);
        const componentDef = getComponentDef(component);
        return new ComponentFactory(componentDef, this.ngModule);
      }
    };
    ChainedInjector = class {
      constructor(injector, parentInjector) {
        this.injector = injector;
        this.parentInjector = parentInjector;
      }
      get(token, notFoundValue, flags) {
        const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);
        if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
          return value;
        }
        return this.parentInjector.get(token, notFoundValue, flags);
      }
    };
    ComponentFactory = class extends ComponentFactory$1 {
      constructor(componentDef, ngModule) {
        super();
        this.componentDef = componentDef;
        this.ngModule = ngModule;
        this.componentType = componentDef.type;
        this.selector = stringifyCSSSelectorList(componentDef.selectors);
        this.ngContentSelectors = componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];
        this.isBoundToModule = !!ngModule;
      }
      get inputs() {
        return toRefArray(this.componentDef.inputs);
      }
      get outputs() {
        return toRefArray(this.componentDef.outputs);
      }
      create(injector, projectableNodes, rootSelectorOrNode, environmentInjector) {
        environmentInjector = environmentInjector || this.ngModule;
        let realEnvironmentInjector = environmentInjector instanceof EnvironmentInjector ? environmentInjector : environmentInjector === null || environmentInjector === void 0 ? void 0 : environmentInjector.injector;
        if (realEnvironmentInjector && this.componentDef.getStandaloneInjector !== null) {
          realEnvironmentInjector = this.componentDef.getStandaloneInjector(realEnvironmentInjector) || realEnvironmentInjector;
        }
        const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;
        const rendererFactory = rootViewInjector.get(RendererFactory2, null);
        if (rendererFactory === null) {
          throw new RuntimeError(
            407,
            define_ngDevMode_default && "Angular was not able to inject a renderer (RendererFactory2). Likely this is due to a broken DI hierarchy. Make sure that any injector used to create this component has a correct parent."
          );
        }
        const sanitizer = rootViewInjector.get(Sanitizer, null);
        const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);
        const elementName = this.componentDef.selectors[0][0] || "div";
        const hostRNode = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation) : createElementNode(rendererFactory.createRenderer(null, this.componentDef), elementName, getNamespace(elementName));
        const rootFlags = this.componentDef.onPush ? 32 | 256 : 16 | 256;
        const rootContext = createRootContext();
        const rootTView = createTView(
          0,
          null,
          null,
          1,
          0,
          null,
          null,
          null,
          null,
          null
        );
        const rootLView = createLView(null, rootTView, rootContext, rootFlags, null, null, rendererFactory, hostRenderer, sanitizer, rootViewInjector, null);
        enterView(rootLView);
        let component;
        let tElementNode;
        try {
          const componentView = createRootComponentView(hostRNode, this.componentDef, rootLView, rendererFactory, hostRenderer);
          if (hostRNode) {
            if (rootSelectorOrNode) {
              setUpAttributes(hostRenderer, hostRNode, ["ng-version", VERSION.full]);
            } else {
              const {
                attrs,
                classes
              } = extractAttrsAndClassesFromSelector(this.componentDef.selectors[0]);
              if (attrs) {
                setUpAttributes(hostRenderer, hostRNode, attrs);
              }
              if (classes && classes.length > 0) {
                writeDirectClass(hostRenderer, hostRNode, classes.join(" "));
              }
            }
          }
          tElementNode = getTNode(rootTView, HEADER_OFFSET);
          if (projectableNodes !== void 0) {
            const projection = tElementNode.projection = [];
            for (let i = 0; i < this.ngContentSelectors.length; i++) {
              const nodesforSlot = projectableNodes[i];
              projection.push(nodesforSlot != null ? Array.from(nodesforSlot) : null);
            }
          }
          component = createRootComponent(componentView, this.componentDef, rootLView, rootContext, [LifecycleHooksFeature]);
          renderView(rootTView, rootLView, null);
        } finally {
          leaveView();
        }
        return new ComponentRef(this.componentType, component, createElementRef(tElementNode, rootLView), rootLView, tElementNode);
      }
    };
    componentFactoryResolver = new ComponentFactoryResolver();
    ComponentRef = class extends ComponentRef$1 {
      constructor(componentType, instance, location2, _rootLView, _tNode) {
        super();
        this.location = location2;
        this._rootLView = _rootLView;
        this._tNode = _tNode;
        this.instance = instance;
        this.hostView = this.changeDetectorRef = new RootViewRef(_rootLView);
        this.componentType = componentType;
      }
      setInput(name, value) {
        const inputData = this._tNode.inputs;
        let dataValue;
        if (inputData !== null && (dataValue = inputData[name])) {
          const lView = this._rootLView;
          setInputsForProperty(lView[TVIEW], lView, dataValue, name, value);
          markDirtyIfOnPush(lView, this._tNode.index);
        } else {
          if (define_ngDevMode_default) {
            const cmpNameForError = stringifyForError(this.componentType);
            let message = `Can't set value of the '${name}' input on the '${cmpNameForError}' component. `;
            message += `Make sure that the '${name}' property is annotated with @Input() or a mapped @Input('${name}') exists.`;
            reportUnknownPropertyError(message);
          }
        }
      }
      get injector() {
        return new NodeInjector(this._tNode, this._rootLView);
      }
      destroy() {
        this.hostView.destroy();
      }
      onDestroy(callback) {
        this.hostView.onDestroy(callback);
      }
    };
    COPY_DIRECTIVE_FIELDS = [
      "providersResolver"
    ];
    COPY_COMPONENT_FIELDS = [
      "template",
      "decls",
      "consts",
      "vars",
      "onPush",
      "ngContentSelectors",
      "styles",
      "encapsulation",
      "schemas"
    ];
    _symbolIterator = null;
    isObservable2 = isSubscribable;
    parserState = {
      textEnd: 0,
      key: 0,
      keyEnd: 0,
      value: 0,
      valueEnd: 0
    };
    if (false) {
      (function() {
        _global["ngI18nClosureMode"] = typeof goog !== "undefined" && typeof goog.getMsg === "function";
      })();
    }
    u = void 0;
    localeEn = ["en", [["a", "p"], ["AM", "PM"], u], [["AM", "PM"], u, u], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], u, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], u, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", u, "{1} 'at' {0}", u], [".", ",", ";", "%", "+", "-", "E", "\xD7", "\u2030", "\u221E", "NaN", ":"], ["#,##0.###", "#,##0%", "\xA4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", plural];
    LOCALE_DATA = {};
    (function(LocaleDataIndex2) {
      LocaleDataIndex2[LocaleDataIndex2["LocaleId"] = 0] = "LocaleId";
      LocaleDataIndex2[LocaleDataIndex2["DayPeriodsFormat"] = 1] = "DayPeriodsFormat";
      LocaleDataIndex2[LocaleDataIndex2["DayPeriodsStandalone"] = 2] = "DayPeriodsStandalone";
      LocaleDataIndex2[LocaleDataIndex2["DaysFormat"] = 3] = "DaysFormat";
      LocaleDataIndex2[LocaleDataIndex2["DaysStandalone"] = 4] = "DaysStandalone";
      LocaleDataIndex2[LocaleDataIndex2["MonthsFormat"] = 5] = "MonthsFormat";
      LocaleDataIndex2[LocaleDataIndex2["MonthsStandalone"] = 6] = "MonthsStandalone";
      LocaleDataIndex2[LocaleDataIndex2["Eras"] = 7] = "Eras";
      LocaleDataIndex2[LocaleDataIndex2["FirstDayOfWeek"] = 8] = "FirstDayOfWeek";
      LocaleDataIndex2[LocaleDataIndex2["WeekendRange"] = 9] = "WeekendRange";
      LocaleDataIndex2[LocaleDataIndex2["DateFormat"] = 10] = "DateFormat";
      LocaleDataIndex2[LocaleDataIndex2["TimeFormat"] = 11] = "TimeFormat";
      LocaleDataIndex2[LocaleDataIndex2["DateTimeFormat"] = 12] = "DateTimeFormat";
      LocaleDataIndex2[LocaleDataIndex2["NumberSymbols"] = 13] = "NumberSymbols";
      LocaleDataIndex2[LocaleDataIndex2["NumberFormats"] = 14] = "NumberFormats";
      LocaleDataIndex2[LocaleDataIndex2["CurrencyCode"] = 15] = "CurrencyCode";
      LocaleDataIndex2[LocaleDataIndex2["CurrencySymbol"] = 16] = "CurrencySymbol";
      LocaleDataIndex2[LocaleDataIndex2["CurrencyName"] = 17] = "CurrencyName";
      LocaleDataIndex2[LocaleDataIndex2["Currencies"] = 18] = "Currencies";
      LocaleDataIndex2[LocaleDataIndex2["Directionality"] = 19] = "Directionality";
      LocaleDataIndex2[LocaleDataIndex2["PluralCase"] = 20] = "PluralCase";
      LocaleDataIndex2[LocaleDataIndex2["ExtraData"] = 21] = "ExtraData";
    })(LocaleDataIndex || (LocaleDataIndex = {}));
    pluralMapping = ["zero", "one", "two", "few", "many"];
    DEFAULT_LOCALE_ID = "en-US";
    USD_CURRENCY_CODE = "USD";
    ELEMENT_MARKER = {
      marker: "element"
    };
    ICU_MARKER = {
      marker: "ICU"
    };
    (function(I18nCreateOpCode2) {
      I18nCreateOpCode2[I18nCreateOpCode2["SHIFT"] = 2] = "SHIFT";
      I18nCreateOpCode2[I18nCreateOpCode2["APPEND_EAGERLY"] = 1] = "APPEND_EAGERLY";
      I18nCreateOpCode2[I18nCreateOpCode2["COMMENT"] = 2] = "COMMENT";
    })(I18nCreateOpCode || (I18nCreateOpCode = {}));
    LOCALE_ID$1 = DEFAULT_LOCALE_ID;
    changeMask = 0;
    changeMaskCounter = 0;
    OpCodeParser = class {
      constructor(codes) {
        this.i = 0;
        this.codes = codes;
      }
      hasMore() {
        return this.i < this.codes.length;
      }
      consumeNumber() {
        let value = this.codes[this.i++];
        assertNumber(value, "expecting number in OpCode");
        return value;
      }
      consumeString() {
        let value = this.codes[this.i++];
        assertString(value, "expecting string in OpCode");
        return value;
      }
      consumeFunction() {
        let value = this.codes[this.i++];
        if (value === null || typeof value === "function") {
          return value;
        }
        throw new Error("expecting function in OpCode");
      }
      consumeNumberOrString() {
        let value = this.codes[this.i++];
        if (typeof value === "string") {
          return value;
        }
        assertNumber(value, "expecting number or string in OpCode");
        return value;
      }
      consumeNumberStringOrMarker() {
        let value = this.codes[this.i++];
        if (typeof value === "string" || typeof value === "number" || value == ICU_MARKER || value == ELEMENT_MARKER) {
          return value;
        }
        assertNumber(value, "expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode");
        return value;
      }
    };
    BINDING_REGEXP = /�(\d+):?\d*�/gi;
    ICU_REGEXP = /({\s*�\d+:?\d*�\s*,\s*\S{6}\s*,[\s\S]*})/gi;
    NESTED_ICU = /�(\d+)�/;
    ICU_BLOCK_REGEXP = /^\s*(�\d+:?\d*�)\s*,\s*(select|plural)\s*,/;
    MARKER = `\uFFFD`;
    SUBTEMPLATE_REGEXP = /�\/?\*(\d+:\d+)�/gi;
    PH_REGEXP = /�(\/?[#*]\d+):?\d*�/gi;
    NGSP_UNICODE_REGEXP = /\uE500/g;
    ROOT_TEMPLATE_ID = 0;
    PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]/;
    PP_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]|(�\/?\*\d+:\d+�)/g;
    PP_ICU_VARS_REGEXP = /({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g;
    PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;
    PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\d+)?)�/g;
    PP_CLOSE_TEMPLATE_REGEXP = /\/\*/;
    PP_TEMPLATE_ID_REGEXP = /\d+\:(\d+)/;
    NgModuleRef$1 = class {
    };
    NgModuleFactory$1 = class {
    };
    createNgModuleRef = createNgModule;
    NgModuleRef = class extends NgModuleRef$1 {
      constructor(ngModuleType, _parent) {
        super();
        this._parent = _parent;
        this._bootstrapComponents = [];
        this.destroyCbs = [];
        this.componentFactoryResolver = new ComponentFactoryResolver(this);
        const ngModuleDef = getNgModuleDef(ngModuleType);
        define_ngDevMode_default && assertDefined(ngModuleDef, `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);
        this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap);
        this._r3Injector = createInjectorWithoutInjectorInstances(ngModuleType, _parent, [{
          provide: NgModuleRef$1,
          useValue: this
        }, {
          provide: ComponentFactoryResolver$1,
          useValue: this.componentFactoryResolver
        }], stringify(ngModuleType), /* @__PURE__ */ new Set(["environment"]));
        this._r3Injector.resolveInjectorInitializers();
        this.instance = this._r3Injector.get(ngModuleType);
      }
      get injector() {
        return this._r3Injector;
      }
      destroy() {
        define_ngDevMode_default && assertDefined(this.destroyCbs, "NgModule already destroyed");
        const injector = this._r3Injector;
        !injector.destroyed && injector.destroy();
        this.destroyCbs.forEach((fn2) => fn2());
        this.destroyCbs = null;
      }
      onDestroy(callback) {
        define_ngDevMode_default && assertDefined(this.destroyCbs, "NgModule already destroyed");
        this.destroyCbs.push(callback);
      }
    };
    NgModuleFactory = class extends NgModuleFactory$1 {
      constructor(moduleType) {
        super();
        this.moduleType = moduleType;
      }
      create(parentInjector) {
        return new NgModuleRef(this.moduleType, parentInjector);
      }
    };
    EnvironmentNgModuleRefAdapter = class extends NgModuleRef$1 {
      constructor(providers, parent, source) {
        super();
        this.componentFactoryResolver = new ComponentFactoryResolver(this);
        this.instance = null;
        const injector = new R3Injector([...providers, {
          provide: NgModuleRef$1,
          useValue: this
        }, {
          provide: ComponentFactoryResolver$1,
          useValue: this.componentFactoryResolver
        }], parent || getNullInjector(), source, /* @__PURE__ */ new Set(["environment"]));
        this.injector = injector;
        injector.resolveInjectorInitializers();
      }
      destroy() {
        this.injector.destroy();
      }
      onDestroy(callback) {
        this.injector.onDestroy(callback);
      }
    };
    StandaloneService = class {
      constructor(_injector) {
        this._injector = _injector;
        this.cachedInjectors = /* @__PURE__ */ new Map();
      }
      getOrCreateStandaloneInjector(componentDef) {
        if (!componentDef.standalone) {
          return null;
        }
        if (!this.cachedInjectors.has(componentDef.id)) {
          const providers = internalImportProvidersFrom(false, componentDef.type);
          const standaloneInjector = providers.length > 0 ? createEnvironmentInjector([providers], this._injector, `Standalone[${componentDef.type.name}]`) : null;
          this.cachedInjectors.set(componentDef.id, standaloneInjector);
        }
        return this.cachedInjectors.get(componentDef.id);
      }
      ngOnDestroy() {
        try {
          for (const injector of this.cachedInjectors.values()) {
            if (injector !== null) {
              injector.destroy();
            }
          }
        } finally {
          this.cachedInjectors.clear();
        }
      }
    };
    StandaloneService.\u0275prov = \u0275\u0275defineInjectable({
      token: StandaloneService,
      providedIn: "environment",
      factory: () => new StandaloneService(\u0275\u0275inject(EnvironmentInjector))
    });
    EventEmitter_ = class extends Subject {
      constructor(isAsync = false) {
        super();
        this.__isAsync = isAsync;
      }
      emit(value) {
        super.next(value);
      }
      subscribe(observerOrNext, error2, complete) {
        var _a, _b, _c;
        let nextFn = observerOrNext;
        let errorFn = error2 || (() => null);
        let completeFn = complete;
        if (observerOrNext && typeof observerOrNext === "object") {
          const observer = observerOrNext;
          nextFn = (_a = observer.next) === null || _a === void 0 ? void 0 : _a.bind(observer);
          errorFn = (_b = observer.error) === null || _b === void 0 ? void 0 : _b.bind(observer);
          completeFn = (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.bind(observer);
        }
        if (this.__isAsync) {
          errorFn = _wrapInTimeout(errorFn);
          if (nextFn) {
            nextFn = _wrapInTimeout(nextFn);
          }
          if (completeFn) {
            completeFn = _wrapInTimeout(completeFn);
          }
        }
        const sink = super.subscribe({
          next: nextFn,
          error: errorFn,
          complete: completeFn
        });
        if (observerOrNext instanceof Subscription) {
          observerOrNext.add(sink);
        }
        return sink;
      }
    };
    EventEmitter = EventEmitter_;
    QueryList = class {
      constructor(_emitDistinctChangesOnly = false) {
        this._emitDistinctChangesOnly = _emitDistinctChangesOnly;
        this.dirty = true;
        this._results = [];
        this._changesDetected = false;
        this._changes = null;
        this.length = 0;
        this.first = void 0;
        this.last = void 0;
        const symbol = getSymbolIterator2();
        const proto = QueryList.prototype;
        if (!proto[symbol])
          proto[symbol] = symbolIterator;
      }
      get changes() {
        return this._changes || (this._changes = new EventEmitter());
      }
      get(index) {
        return this._results[index];
      }
      map(fn2) {
        return this._results.map(fn2);
      }
      filter(fn2) {
        return this._results.filter(fn2);
      }
      find(fn2) {
        return this._results.find(fn2);
      }
      reduce(fn2, init) {
        return this._results.reduce(fn2, init);
      }
      forEach(fn2) {
        this._results.forEach(fn2);
      }
      some(fn2) {
        return this._results.some(fn2);
      }
      toArray() {
        return this._results.slice();
      }
      toString() {
        return this._results.toString();
      }
      reset(resultsTree, identityAccessor) {
        const self2 = this;
        self2.dirty = false;
        const newResultFlat = flatten(resultsTree);
        if (this._changesDetected = !arrayEquals(self2._results, newResultFlat, identityAccessor)) {
          self2._results = newResultFlat;
          self2.length = newResultFlat.length;
          self2.last = newResultFlat[this.length - 1];
          self2.first = newResultFlat[0];
        }
      }
      notifyOnChanges() {
        if (this._changes && (this._changesDetected || !this._emitDistinctChangesOnly))
          this._changes.emit(this);
      }
      setDirty() {
        this.dirty = true;
      }
      destroy() {
        this.changes.complete();
        this.changes.unsubscribe();
      }
    };
    TemplateRef = class {
    };
    TemplateRef.__NG_ELEMENT_ID__ = injectTemplateRef;
    ViewEngineTemplateRef = TemplateRef;
    R3TemplateRef = class TemplateRef2 extends ViewEngineTemplateRef {
      constructor(_declarationLView, _declarationTContainer, elementRef) {
        super();
        this._declarationLView = _declarationLView;
        this._declarationTContainer = _declarationTContainer;
        this.elementRef = elementRef;
      }
      createEmbeddedView(context2, injector) {
        const embeddedTView = this._declarationTContainer.tViews;
        const embeddedLView = createLView(
          this._declarationLView,
          embeddedTView,
          context2,
          16,
          null,
          embeddedTView.declTNode,
          null,
          null,
          null,
          null,
          injector || null
        );
        const declarationLContainer = this._declarationLView[this._declarationTContainer.index];
        define_ngDevMode_default && assertLContainer(declarationLContainer);
        embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;
        const declarationViewLQueries = this._declarationLView[QUERIES];
        if (declarationViewLQueries !== null) {
          embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);
        }
        renderView(embeddedTView, embeddedLView, context2);
        return new ViewRef$1(embeddedLView);
      }
    };
    ViewContainerRef = class {
    };
    ViewContainerRef.__NG_ELEMENT_ID__ = injectViewContainerRef;
    VE_ViewContainerRef = ViewContainerRef;
    R3ViewContainerRef = class ViewContainerRef2 extends VE_ViewContainerRef {
      constructor(_lContainer, _hostTNode, _hostLView) {
        super();
        this._lContainer = _lContainer;
        this._hostTNode = _hostTNode;
        this._hostLView = _hostLView;
      }
      get element() {
        return createElementRef(this._hostTNode, this._hostLView);
      }
      get injector() {
        return new NodeInjector(this._hostTNode, this._hostLView);
      }
      get parentInjector() {
        const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);
        if (hasParentInjector(parentLocation)) {
          const parentView = getParentInjectorView(parentLocation, this._hostLView);
          const injectorIndex = getParentInjectorIndex(parentLocation);
          define_ngDevMode_default && assertNodeInjector(parentView, injectorIndex);
          const parentTNode = parentView[TVIEW].data[injectorIndex + 8];
          return new NodeInjector(parentTNode, parentView);
        } else {
          return new NodeInjector(null, this._hostLView);
        }
      }
      clear() {
        while (this.length > 0) {
          this.remove(this.length - 1);
        }
      }
      get(index) {
        const viewRefs = getViewRefs(this._lContainer);
        return viewRefs !== null && viewRefs[index] || null;
      }
      get length() {
        return this._lContainer.length - CONTAINER_HEADER_OFFSET;
      }
      createEmbeddedView(templateRef, context2, indexOrOptions) {
        let index;
        let injector;
        if (typeof indexOrOptions === "number") {
          index = indexOrOptions;
        } else if (indexOrOptions != null) {
          index = indexOrOptions.index;
          injector = indexOrOptions.injector;
        }
        const viewRef = templateRef.createEmbeddedView(context2 || {}, injector);
        this.insert(viewRef, index);
        return viewRef;
      }
      createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector) {
        const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);
        let index;
        if (isComponentFactory) {
          if (define_ngDevMode_default) {
            assertEqual(typeof indexOrOptions !== "object", true, "It looks like Component factory was provided as the first argument and an options object as the second argument. This combination of arguments is incompatible. You can either change the first argument to provide Component type or change the second argument to be a number (representing an index at which to insert the new component's host view into this container)");
          }
          index = indexOrOptions;
        } else {
          if (define_ngDevMode_default) {
            assertDefined(getComponentDef(componentFactoryOrType), `Provided Component class doesn't contain Component definition. Please check whether provided class has @Component decorator.`);
            assertEqual(typeof indexOrOptions !== "number", true, "It looks like Component type was provided as the first argument and a number (representing an index at which to insert the new component's host view into this container as the second argument. This combination of arguments is incompatible. Please use an object as the second argument instead.");
          }
          const options = indexOrOptions || {};
          if (define_ngDevMode_default && options.environmentInjector && options.ngModuleRef) {
            throwError2(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);
          }
          index = options.index;
          injector = options.injector;
          projectableNodes = options.projectableNodes;
          environmentInjector = options.environmentInjector || options.ngModuleRef;
        }
        const componentFactory = isComponentFactory ? componentFactoryOrType : new ComponentFactory(getComponentDef(componentFactoryOrType));
        const contextInjector = injector || this.parentInjector;
        if (!environmentInjector && componentFactory.ngModule == null) {
          const _injector = isComponentFactory ? contextInjector : this.parentInjector;
          const result = _injector.get(EnvironmentInjector, null);
          if (result) {
            environmentInjector = result;
          }
        }
        const componentRef = componentFactory.create(contextInjector, projectableNodes, void 0, environmentInjector);
        this.insert(componentRef.hostView, index);
        return componentRef;
      }
      insert(viewRef, index) {
        const lView = viewRef._lView;
        const tView = lView[TVIEW];
        if (define_ngDevMode_default && viewRef.destroyed) {
          throw new Error("Cannot insert a destroyed View in a ViewContainer!");
        }
        if (viewAttachedToContainer(lView)) {
          const prevIdx = this.indexOf(viewRef);
          if (prevIdx !== -1) {
            this.detach(prevIdx);
          } else {
            const prevLContainer = lView[PARENT];
            define_ngDevMode_default && assertEqual(isLContainer(prevLContainer), true, "An attached view should have its PARENT point to a container.");
            const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);
            prevVCRef.detach(prevVCRef.indexOf(viewRef));
          }
        }
        const adjustedIdx = this._adjustIndex(index);
        const lContainer = this._lContainer;
        insertView(tView, lView, lContainer, adjustedIdx);
        const beforeNode = getBeforeNodeForView(adjustedIdx, lContainer);
        const renderer = lView[RENDERER];
        const parentRNode = nativeParentNode(renderer, lContainer[NATIVE]);
        if (parentRNode !== null) {
          addViewToContainer(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);
        }
        viewRef.attachToViewContainerRef();
        addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);
        return viewRef;
      }
      move(viewRef, newIndex) {
        if (define_ngDevMode_default && viewRef.destroyed) {
          throw new Error("Cannot move a destroyed View in a ViewContainer!");
        }
        return this.insert(viewRef, newIndex);
      }
      indexOf(viewRef) {
        const viewRefsArr = getViewRefs(this._lContainer);
        return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;
      }
      remove(index) {
        const adjustedIdx = this._adjustIndex(index, -1);
        const detachedView = detachView(this._lContainer, adjustedIdx);
        if (detachedView) {
          removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);
          destroyLView(detachedView[TVIEW], detachedView);
        }
      }
      detach(index) {
        const adjustedIdx = this._adjustIndex(index, -1);
        const view = detachView(this._lContainer, adjustedIdx);
        const wasDetached = view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;
        return wasDetached ? new ViewRef$1(view) : null;
      }
      _adjustIndex(index, shift = 0) {
        if (index == null) {
          return this.length + shift;
        }
        if (define_ngDevMode_default) {
          assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);
          assertLessThan(index, this.length + 1 + shift, "index");
        }
        return index;
      }
    };
    unusedValueExportToPlacateAjd$1 = 1;
    unusedValueExportToPlacateAjd = 1;
    unusedValueToPlacateAjd = unusedValueExportToPlacateAjd$1 + unusedValueExportToPlacateAjd$6 + unusedValueExportToPlacateAjd$5 + unusedValueExportToPlacateAjd;
    LQuery_ = class {
      constructor(queryList) {
        this.queryList = queryList;
        this.matches = null;
      }
      clone() {
        return new LQuery_(this.queryList);
      }
      setDirty() {
        this.queryList.setDirty();
      }
    };
    LQueries_ = class {
      constructor(queries = []) {
        this.queries = queries;
      }
      createEmbeddedView(tView) {
        const tQueries = tView.queries;
        if (tQueries !== null) {
          const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;
          const viewLQueries = [];
          for (let i = 0; i < noOfInheritedQueries; i++) {
            const tQuery = tQueries.getByIndex(i);
            const parentLQuery = this.queries[tQuery.indexInDeclarationView];
            viewLQueries.push(parentLQuery.clone());
          }
          return new LQueries_(viewLQueries);
        }
        return null;
      }
      insertView(tView) {
        this.dirtyQueriesWithMatches(tView);
      }
      detachView(tView) {
        this.dirtyQueriesWithMatches(tView);
      }
      dirtyQueriesWithMatches(tView) {
        for (let i = 0; i < this.queries.length; i++) {
          if (getTQuery(tView, i).matches !== null) {
            this.queries[i].setDirty();
          }
        }
      }
    };
    TQueryMetadata_ = class {
      constructor(predicate, flags, read = null) {
        this.predicate = predicate;
        this.flags = flags;
        this.read = read;
      }
    };
    TQueries_ = class {
      constructor(queries = []) {
        this.queries = queries;
      }
      elementStart(tView, tNode) {
        define_ngDevMode_default && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
        for (let i = 0; i < this.queries.length; i++) {
          this.queries[i].elementStart(tView, tNode);
        }
      }
      elementEnd(tNode) {
        for (let i = 0; i < this.queries.length; i++) {
          this.queries[i].elementEnd(tNode);
        }
      }
      embeddedTView(tNode) {
        let queriesForTemplateRef = null;
        for (let i = 0; i < this.length; i++) {
          const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;
          const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);
          if (tqueryClone) {
            tqueryClone.indexInDeclarationView = i;
            if (queriesForTemplateRef !== null) {
              queriesForTemplateRef.push(tqueryClone);
            } else {
              queriesForTemplateRef = [tqueryClone];
            }
          }
        }
        return queriesForTemplateRef !== null ? new TQueries_(queriesForTemplateRef) : null;
      }
      template(tView, tNode) {
        define_ngDevMode_default && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
        for (let i = 0; i < this.queries.length; i++) {
          this.queries[i].template(tView, tNode);
        }
      }
      getByIndex(index) {
        define_ngDevMode_default && assertIndexInRange(this.queries, index);
        return this.queries[index];
      }
      get length() {
        return this.queries.length;
      }
      track(tquery) {
        this.queries.push(tquery);
      }
    };
    TQuery_ = class {
      constructor(metadata, nodeIndex = -1) {
        this.metadata = metadata;
        this.matches = null;
        this.indexInDeclarationView = -1;
        this.crossesNgTemplate = false;
        this._appliesToNextNode = true;
        this._declarationNodeIndex = nodeIndex;
      }
      elementStart(tView, tNode) {
        if (this.isApplyingToNode(tNode)) {
          this.matchTNode(tView, tNode);
        }
      }
      elementEnd(tNode) {
        if (this._declarationNodeIndex === tNode.index) {
          this._appliesToNextNode = false;
        }
      }
      template(tView, tNode) {
        this.elementStart(tView, tNode);
      }
      embeddedTView(tNode, childQueryIndex) {
        if (this.isApplyingToNode(tNode)) {
          this.crossesNgTemplate = true;
          this.addMatch(-tNode.index, childQueryIndex);
          return new TQuery_(this.metadata);
        }
        return null;
      }
      isApplyingToNode(tNode) {
        if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {
          const declarationNodeIdx = this._declarationNodeIndex;
          let parent = tNode.parent;
          while (parent !== null && parent.type & 8 && parent.index !== declarationNodeIdx) {
            parent = parent.parent;
          }
          return declarationNodeIdx === (parent !== null ? parent.index : -1);
        }
        return this._appliesToNextNode;
      }
      matchTNode(tView, tNode) {
        const predicate = this.metadata.predicate;
        if (Array.isArray(predicate)) {
          for (let i = 0; i < predicate.length; i++) {
            const name = predicate[i];
            this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));
            this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));
          }
        } else {
          if (predicate === TemplateRef) {
            if (tNode.type & 4) {
              this.matchTNodeWithReadOption(tView, tNode, -1);
            }
          } else {
            this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));
          }
        }
      }
      matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
        if (nodeMatchIdx !== null) {
          const read = this.metadata.read;
          if (read !== null) {
            if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type & 4) {
              this.addMatch(tNode.index, -2);
            } else {
              const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);
              if (directiveOrProviderIdx !== null) {
                this.addMatch(tNode.index, directiveOrProviderIdx);
              }
            }
          } else {
            this.addMatch(tNode.index, nodeMatchIdx);
          }
        }
      }
      addMatch(tNodeIdx, matchIdx) {
        if (this.matches === null) {
          this.matches = [tNodeIdx, matchIdx];
        } else {
          this.matches.push(tNodeIdx, matchIdx);
        }
      }
    };
    angularCoreEnv = (() => ({
      "\u0275\u0275attribute": \u0275\u0275attribute,
      "\u0275\u0275attributeInterpolate1": \u0275\u0275attributeInterpolate1,
      "\u0275\u0275attributeInterpolate2": \u0275\u0275attributeInterpolate2,
      "\u0275\u0275attributeInterpolate3": \u0275\u0275attributeInterpolate3,
      "\u0275\u0275attributeInterpolate4": \u0275\u0275attributeInterpolate4,
      "\u0275\u0275attributeInterpolate5": \u0275\u0275attributeInterpolate5,
      "\u0275\u0275attributeInterpolate6": \u0275\u0275attributeInterpolate6,
      "\u0275\u0275attributeInterpolate7": \u0275\u0275attributeInterpolate7,
      "\u0275\u0275attributeInterpolate8": \u0275\u0275attributeInterpolate8,
      "\u0275\u0275attributeInterpolateV": \u0275\u0275attributeInterpolateV,
      "\u0275\u0275defineComponent": \u0275\u0275defineComponent,
      "\u0275\u0275defineDirective": \u0275\u0275defineDirective,
      "\u0275\u0275defineInjectable": \u0275\u0275defineInjectable,
      "\u0275\u0275defineInjector": \u0275\u0275defineInjector,
      "\u0275\u0275defineNgModule": \u0275\u0275defineNgModule,
      "\u0275\u0275definePipe": \u0275\u0275definePipe,
      "\u0275\u0275directiveInject": \u0275\u0275directiveInject,
      "\u0275\u0275getInheritedFactory": \u0275\u0275getInheritedFactory,
      "\u0275\u0275inject": \u0275\u0275inject,
      "\u0275\u0275injectAttribute": \u0275\u0275injectAttribute,
      "\u0275\u0275invalidFactory": \u0275\u0275invalidFactory,
      "\u0275\u0275invalidFactoryDep": \u0275\u0275invalidFactoryDep,
      "\u0275\u0275templateRefExtractor": \u0275\u0275templateRefExtractor,
      "\u0275\u0275resetView": \u0275\u0275resetView,
      "\u0275\u0275NgOnChangesFeature": \u0275\u0275NgOnChangesFeature,
      "\u0275\u0275ProvidersFeature": \u0275\u0275ProvidersFeature,
      "\u0275\u0275CopyDefinitionFeature": \u0275\u0275CopyDefinitionFeature,
      "\u0275\u0275InheritDefinitionFeature": \u0275\u0275InheritDefinitionFeature,
      "\u0275\u0275StandaloneFeature": \u0275\u0275StandaloneFeature,
      "\u0275\u0275nextContext": \u0275\u0275nextContext,
      "\u0275\u0275namespaceHTML": \u0275\u0275namespaceHTML,
      "\u0275\u0275namespaceMathML": \u0275\u0275namespaceMathML,
      "\u0275\u0275namespaceSVG": \u0275\u0275namespaceSVG,
      "\u0275\u0275enableBindings": \u0275\u0275enableBindings,
      "\u0275\u0275disableBindings": \u0275\u0275disableBindings,
      "\u0275\u0275elementStart": \u0275\u0275elementStart,
      "\u0275\u0275elementEnd": \u0275\u0275elementEnd,
      "\u0275\u0275element": \u0275\u0275element,
      "\u0275\u0275elementContainerStart": \u0275\u0275elementContainerStart,
      "\u0275\u0275elementContainerEnd": \u0275\u0275elementContainerEnd,
      "\u0275\u0275elementContainer": \u0275\u0275elementContainer,
      "\u0275\u0275pureFunction0": \u0275\u0275pureFunction0,
      "\u0275\u0275pureFunction1": \u0275\u0275pureFunction1,
      "\u0275\u0275pureFunction2": \u0275\u0275pureFunction2,
      "\u0275\u0275pureFunction3": \u0275\u0275pureFunction3,
      "\u0275\u0275pureFunction4": \u0275\u0275pureFunction4,
      "\u0275\u0275pureFunction5": \u0275\u0275pureFunction5,
      "\u0275\u0275pureFunction6": \u0275\u0275pureFunction6,
      "\u0275\u0275pureFunction7": \u0275\u0275pureFunction7,
      "\u0275\u0275pureFunction8": \u0275\u0275pureFunction8,
      "\u0275\u0275pureFunctionV": \u0275\u0275pureFunctionV,
      "\u0275\u0275getCurrentView": \u0275\u0275getCurrentView,
      "\u0275\u0275restoreView": \u0275\u0275restoreView,
      "\u0275\u0275listener": \u0275\u0275listener,
      "\u0275\u0275projection": \u0275\u0275projection,
      "\u0275\u0275syntheticHostProperty": \u0275\u0275syntheticHostProperty,
      "\u0275\u0275syntheticHostListener": \u0275\u0275syntheticHostListener,
      "\u0275\u0275pipeBind1": \u0275\u0275pipeBind1,
      "\u0275\u0275pipeBind2": \u0275\u0275pipeBind2,
      "\u0275\u0275pipeBind3": \u0275\u0275pipeBind3,
      "\u0275\u0275pipeBind4": \u0275\u0275pipeBind4,
      "\u0275\u0275pipeBindV": \u0275\u0275pipeBindV,
      "\u0275\u0275projectionDef": \u0275\u0275projectionDef,
      "\u0275\u0275hostProperty": \u0275\u0275hostProperty,
      "\u0275\u0275property": \u0275\u0275property,
      "\u0275\u0275propertyInterpolate": \u0275\u0275propertyInterpolate,
      "\u0275\u0275propertyInterpolate1": \u0275\u0275propertyInterpolate1,
      "\u0275\u0275propertyInterpolate2": \u0275\u0275propertyInterpolate2,
      "\u0275\u0275propertyInterpolate3": \u0275\u0275propertyInterpolate3,
      "\u0275\u0275propertyInterpolate4": \u0275\u0275propertyInterpolate4,
      "\u0275\u0275propertyInterpolate5": \u0275\u0275propertyInterpolate5,
      "\u0275\u0275propertyInterpolate6": \u0275\u0275propertyInterpolate6,
      "\u0275\u0275propertyInterpolate7": \u0275\u0275propertyInterpolate7,
      "\u0275\u0275propertyInterpolate8": \u0275\u0275propertyInterpolate8,
      "\u0275\u0275propertyInterpolateV": \u0275\u0275propertyInterpolateV,
      "\u0275\u0275pipe": \u0275\u0275pipe,
      "\u0275\u0275queryRefresh": \u0275\u0275queryRefresh,
      "\u0275\u0275viewQuery": \u0275\u0275viewQuery,
      "\u0275\u0275loadQuery": \u0275\u0275loadQuery,
      "\u0275\u0275contentQuery": \u0275\u0275contentQuery,
      "\u0275\u0275reference": \u0275\u0275reference,
      "\u0275\u0275classMap": \u0275\u0275classMap,
      "\u0275\u0275classMapInterpolate1": \u0275\u0275classMapInterpolate1,
      "\u0275\u0275classMapInterpolate2": \u0275\u0275classMapInterpolate2,
      "\u0275\u0275classMapInterpolate3": \u0275\u0275classMapInterpolate3,
      "\u0275\u0275classMapInterpolate4": \u0275\u0275classMapInterpolate4,
      "\u0275\u0275classMapInterpolate5": \u0275\u0275classMapInterpolate5,
      "\u0275\u0275classMapInterpolate6": \u0275\u0275classMapInterpolate6,
      "\u0275\u0275classMapInterpolate7": \u0275\u0275classMapInterpolate7,
      "\u0275\u0275classMapInterpolate8": \u0275\u0275classMapInterpolate8,
      "\u0275\u0275classMapInterpolateV": \u0275\u0275classMapInterpolateV,
      "\u0275\u0275styleMap": \u0275\u0275styleMap,
      "\u0275\u0275styleMapInterpolate1": \u0275\u0275styleMapInterpolate1,
      "\u0275\u0275styleMapInterpolate2": \u0275\u0275styleMapInterpolate2,
      "\u0275\u0275styleMapInterpolate3": \u0275\u0275styleMapInterpolate3,
      "\u0275\u0275styleMapInterpolate4": \u0275\u0275styleMapInterpolate4,
      "\u0275\u0275styleMapInterpolate5": \u0275\u0275styleMapInterpolate5,
      "\u0275\u0275styleMapInterpolate6": \u0275\u0275styleMapInterpolate6,
      "\u0275\u0275styleMapInterpolate7": \u0275\u0275styleMapInterpolate7,
      "\u0275\u0275styleMapInterpolate8": \u0275\u0275styleMapInterpolate8,
      "\u0275\u0275styleMapInterpolateV": \u0275\u0275styleMapInterpolateV,
      "\u0275\u0275styleProp": \u0275\u0275styleProp,
      "\u0275\u0275stylePropInterpolate1": \u0275\u0275stylePropInterpolate1,
      "\u0275\u0275stylePropInterpolate2": \u0275\u0275stylePropInterpolate2,
      "\u0275\u0275stylePropInterpolate3": \u0275\u0275stylePropInterpolate3,
      "\u0275\u0275stylePropInterpolate4": \u0275\u0275stylePropInterpolate4,
      "\u0275\u0275stylePropInterpolate5": \u0275\u0275stylePropInterpolate5,
      "\u0275\u0275stylePropInterpolate6": \u0275\u0275stylePropInterpolate6,
      "\u0275\u0275stylePropInterpolate7": \u0275\u0275stylePropInterpolate7,
      "\u0275\u0275stylePropInterpolate8": \u0275\u0275stylePropInterpolate8,
      "\u0275\u0275stylePropInterpolateV": \u0275\u0275stylePropInterpolateV,
      "\u0275\u0275classProp": \u0275\u0275classProp,
      "\u0275\u0275advance": \u0275\u0275advance,
      "\u0275\u0275template": \u0275\u0275template,
      "\u0275\u0275text": \u0275\u0275text,
      "\u0275\u0275textInterpolate": \u0275\u0275textInterpolate,
      "\u0275\u0275textInterpolate1": \u0275\u0275textInterpolate1,
      "\u0275\u0275textInterpolate2": \u0275\u0275textInterpolate2,
      "\u0275\u0275textInterpolate3": \u0275\u0275textInterpolate3,
      "\u0275\u0275textInterpolate4": \u0275\u0275textInterpolate4,
      "\u0275\u0275textInterpolate5": \u0275\u0275textInterpolate5,
      "\u0275\u0275textInterpolate6": \u0275\u0275textInterpolate6,
      "\u0275\u0275textInterpolate7": \u0275\u0275textInterpolate7,
      "\u0275\u0275textInterpolate8": \u0275\u0275textInterpolate8,
      "\u0275\u0275textInterpolateV": \u0275\u0275textInterpolateV,
      "\u0275\u0275i18n": \u0275\u0275i18n,
      "\u0275\u0275i18nAttributes": \u0275\u0275i18nAttributes,
      "\u0275\u0275i18nExp": \u0275\u0275i18nExp,
      "\u0275\u0275i18nStart": \u0275\u0275i18nStart,
      "\u0275\u0275i18nEnd": \u0275\u0275i18nEnd,
      "\u0275\u0275i18nApply": \u0275\u0275i18nApply,
      "\u0275\u0275i18nPostprocess": \u0275\u0275i18nPostprocess,
      "\u0275\u0275resolveWindow": \u0275\u0275resolveWindow,
      "\u0275\u0275resolveDocument": \u0275\u0275resolveDocument,
      "\u0275\u0275resolveBody": \u0275\u0275resolveBody,
      "\u0275\u0275setComponentScope": \u0275\u0275setComponentScope,
      "\u0275\u0275setNgModuleScope": \u0275\u0275setNgModuleScope,
      "\u0275\u0275registerNgModuleType": registerNgModuleType,
      "\u0275\u0275sanitizeHtml": \u0275\u0275sanitizeHtml,
      "\u0275\u0275sanitizeStyle": \u0275\u0275sanitizeStyle,
      "\u0275\u0275sanitizeResourceUrl": \u0275\u0275sanitizeResourceUrl,
      "\u0275\u0275sanitizeScript": \u0275\u0275sanitizeScript,
      "\u0275\u0275sanitizeUrl": \u0275\u0275sanitizeUrl,
      "\u0275\u0275sanitizeUrlOrResourceUrl": \u0275\u0275sanitizeUrlOrResourceUrl,
      "\u0275\u0275trustConstantHtml": \u0275\u0275trustConstantHtml,
      "\u0275\u0275trustConstantResourceUrl": \u0275\u0275trustConstantResourceUrl,
      "forwardRef": forwardRef,
      "resolveForwardRef": resolveForwardRef
    }))();
    jitOptions = null;
    moduleQueue = [];
    flushingModuleQueue = false;
    ownerNgModule = /* @__PURE__ */ new WeakMap();
    verifiedNgModule = /* @__PURE__ */ new WeakMap();
    compilationDepth = 0;
    LIFECYCLE_HOOKS = ["ngOnChanges", "ngOnInit", "ngOnDestroy", "ngDoCheck", "ngAfterViewInit", "ngAfterViewChecked", "ngAfterContentInit", "ngAfterContentChecked"];
    Directive = makeDecorator("Directive", (dir = {}) => dir, void 0, void 0, (type, meta) => compileDirective(type, meta));
    Component = makeDecorator("Component", (c = {}) => Object.assign({
      changeDetection: ChangeDetectionStrategy.Default
    }, c), Directive, void 0, (type, meta) => compileComponent(type, meta));
    Pipe = makeDecorator("Pipe", (p) => Object.assign({
      pure: true
    }, p), void 0, void 0, (type, meta) => compilePipe(type, meta));
    Input = makePropDecorator("Input", (bindingPropertyName) => ({
      bindingPropertyName
    }));
    Output = makePropDecorator("Output", (bindingPropertyName) => ({
      bindingPropertyName
    }));
    HostBinding = makePropDecorator("HostBinding", (hostPropertyName) => ({
      hostPropertyName
    }));
    HostListener = makePropDecorator("HostListener", (eventName, args) => ({
      eventName,
      args
    }));
    NgModule = makeDecorator(
      "NgModule",
      (ngModule) => ngModule,
      void 0,
      void 0,
      (type, meta) => compileNgModule(type, meta)
    );
    APP_INITIALIZER = new InjectionToken("Application Initializer");
    ApplicationInitStatus = class {
      constructor(appInits) {
        this.appInits = appInits;
        this.resolve = noop2;
        this.reject = noop2;
        this.initialized = false;
        this.done = false;
        this.donePromise = new Promise((res, rej) => {
          this.resolve = res;
          this.reject = rej;
        });
      }
      runInitializers() {
        if (this.initialized) {
          return;
        }
        const asyncInitPromises = [];
        const complete = () => {
          this.done = true;
          this.resolve();
        };
        if (this.appInits) {
          for (let i = 0; i < this.appInits.length; i++) {
            const initResult = this.appInits[i]();
            if (isPromise2(initResult)) {
              asyncInitPromises.push(initResult);
            } else if (isObservable2(initResult)) {
              const observableAsPromise = new Promise((resolve, reject) => {
                initResult.subscribe({
                  complete: resolve,
                  error: reject
                });
              });
              asyncInitPromises.push(observableAsPromise);
            }
          }
        }
        Promise.all(asyncInitPromises).then(() => {
          complete();
        }).catch((e) => {
          this.reject(e);
        });
        if (asyncInitPromises.length === 0) {
          complete();
        }
        this.initialized = true;
      }
    };
    ApplicationInitStatus.\u0275fac = function ApplicationInitStatus_Factory(t) {
      return new (t || ApplicationInitStatus)(\u0275\u0275inject(APP_INITIALIZER, 8));
    };
    ApplicationInitStatus.\u0275prov = \u0275\u0275defineInjectable({
      token: ApplicationInitStatus,
      factory: ApplicationInitStatus.\u0275fac,
      providedIn: "root"
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(ApplicationInitStatus, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Inject,
            args: [APP_INITIALIZER]
          }, {
            type: Optional
          }]
        }];
      }, null);
    })();
    APP_ID = new InjectionToken("AppId", {
      providedIn: "root",
      factory: _appIdRandomProviderFactory
    });
    APP_ID_RANDOM_PROVIDER = {
      provide: APP_ID,
      useFactory: _appIdRandomProviderFactory,
      deps: []
    };
    PLATFORM_INITIALIZER = new InjectionToken("Platform Initializer");
    PLATFORM_ID = new InjectionToken("Platform ID", {
      providedIn: "platform",
      factory: () => "unknown"
    });
    APP_BOOTSTRAP_LISTENER = new InjectionToken("appBootstrapListener");
    PACKAGE_ROOT_URL = new InjectionToken("Application Packages Root URL");
    ANIMATION_MODULE_TYPE = new InjectionToken("AnimationModuleType");
    Console = class {
      log(message) {
        console.log(message);
      }
      warn(message) {
        console.warn(message);
      }
    };
    Console.\u0275fac = function Console_Factory(t) {
      return new (t || Console)();
    };
    Console.\u0275prov = \u0275\u0275defineInjectable({
      token: Console,
      factory: Console.\u0275fac,
      providedIn: "platform"
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(Console, [{
        type: Injectable,
        args: [{
          providedIn: "platform"
        }]
      }], null, null);
    })();
    LOCALE_ID = new InjectionToken("LocaleId", {
      providedIn: "root",
      factory: () => inject(LOCALE_ID, InjectFlags.Optional | InjectFlags.SkipSelf) || getGlobalLocale()
    });
    DEFAULT_CURRENCY_CODE = new InjectionToken("DefaultCurrencyCode", {
      providedIn: "root",
      factory: () => USD_CURRENCY_CODE
    });
    TRANSLATIONS = new InjectionToken("Translations");
    TRANSLATIONS_FORMAT = new InjectionToken("TranslationsFormat");
    (function(MissingTranslationStrategy3) {
      MissingTranslationStrategy3[MissingTranslationStrategy3["Error"] = 0] = "Error";
      MissingTranslationStrategy3[MissingTranslationStrategy3["Warning"] = 1] = "Warning";
      MissingTranslationStrategy3[MissingTranslationStrategy3["Ignore"] = 2] = "Ignore";
    })(MissingTranslationStrategy || (MissingTranslationStrategy = {}));
    ModuleWithComponentFactories = class {
      constructor(ngModuleFactory, componentFactories) {
        this.ngModuleFactory = ngModuleFactory;
        this.componentFactories = componentFactories;
      }
    };
    Compiler = class {
      compileModuleSync(moduleType) {
        return new NgModuleFactory(moduleType);
      }
      compileModuleAsync(moduleType) {
        return Promise.resolve(this.compileModuleSync(moduleType));
      }
      compileModuleAndAllComponentsSync(moduleType) {
        const ngModuleFactory = this.compileModuleSync(moduleType);
        const moduleDef = getNgModuleDef(moduleType);
        const componentFactories = maybeUnwrapFn(moduleDef.declarations).reduce((factories, declaration) => {
          const componentDef = getComponentDef(declaration);
          componentDef && factories.push(new ComponentFactory(componentDef));
          return factories;
        }, []);
        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
      }
      compileModuleAndAllComponentsAsync(moduleType) {
        return Promise.resolve(this.compileModuleAndAllComponentsSync(moduleType));
      }
      clearCache() {
      }
      clearCacheFor(type) {
      }
      getModuleId(moduleType) {
        return void 0;
      }
    };
    Compiler.\u0275fac = function Compiler_Factory(t) {
      return new (t || Compiler)();
    };
    Compiler.\u0275prov = \u0275\u0275defineInjectable({
      token: Compiler,
      factory: Compiler.\u0275fac,
      providedIn: "root"
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(Compiler, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], null, null);
    })();
    COMPILER_OPTIONS = new InjectionToken("compilerOptions");
    CompilerFactory = class {
    };
    GLOBAL_PUBLISH_EXPANDO_KEY = "ng";
    _published = false;
    promise = (() => Promise.resolve(0))();
    NgZone = class {
      constructor({
        enableLongStackTrace = false,
        shouldCoalesceEventChangeDetection = false,
        shouldCoalesceRunChangeDetection = false
      }) {
        this.hasPendingMacrotasks = false;
        this.hasPendingMicrotasks = false;
        this.isStable = true;
        this.onUnstable = new EventEmitter(false);
        this.onMicrotaskEmpty = new EventEmitter(false);
        this.onStable = new EventEmitter(false);
        this.onError = new EventEmitter(false);
        if (typeof Zone == "undefined") {
          throw new RuntimeError(
            908,
            define_ngDevMode_default && `In this configuration Angular requires Zone.js`
          );
        }
        Zone.assertZonePatched();
        const self2 = this;
        self2._nesting = 0;
        self2._outer = self2._inner = Zone.current;
        if (Zone["AsyncStackTaggingZoneSpec"]) {
          const AsyncStackTaggingZoneSpec = Zone["AsyncStackTaggingZoneSpec"];
          self2._inner = self2._inner.fork(new AsyncStackTaggingZoneSpec("Angular"));
        }
        if (Zone["TaskTrackingZoneSpec"]) {
          self2._inner = self2._inner.fork(new Zone["TaskTrackingZoneSpec"]());
        }
        if (enableLongStackTrace && Zone["longStackTraceZoneSpec"]) {
          self2._inner = self2._inner.fork(Zone["longStackTraceZoneSpec"]);
        }
        self2.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
        self2.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
        self2.lastRequestAnimationFrameId = -1;
        self2.nativeRequestAnimationFrame = getNativeRequestAnimationFrame().nativeRequestAnimationFrame;
        forkInnerZoneWithAngularBehavior(self2);
      }
      static isInAngularZone() {
        return typeof Zone !== "undefined" && Zone.current.get("isAngularZone") === true;
      }
      static assertInAngularZone() {
        if (!NgZone.isInAngularZone()) {
          throw new RuntimeError(
            909,
            define_ngDevMode_default && "Expected to be in Angular Zone, but it is not!"
          );
        }
      }
      static assertNotInAngularZone() {
        if (NgZone.isInAngularZone()) {
          throw new RuntimeError(
            909,
            define_ngDevMode_default && "Expected to not be in Angular Zone, but it is!"
          );
        }
      }
      run(fn2, applyThis, applyArgs) {
        return this._inner.run(fn2, applyThis, applyArgs);
      }
      runTask(fn2, applyThis, applyArgs, name) {
        const zone = this._inner;
        const task = zone.scheduleEventTask("NgZoneEvent: " + name, fn2, EMPTY_PAYLOAD, noop2, noop2);
        try {
          return zone.runTask(task, applyThis, applyArgs);
        } finally {
          zone.cancelTask(task);
        }
      }
      runGuarded(fn2, applyThis, applyArgs) {
        return this._inner.runGuarded(fn2, applyThis, applyArgs);
      }
      runOutsideAngular(fn2) {
        return this._outer.run(fn2);
      }
    };
    EMPTY_PAYLOAD = {};
    NoopNgZone = class {
      constructor() {
        this.hasPendingMicrotasks = false;
        this.hasPendingMacrotasks = false;
        this.isStable = true;
        this.onUnstable = new EventEmitter();
        this.onMicrotaskEmpty = new EventEmitter();
        this.onStable = new EventEmitter();
        this.onError = new EventEmitter();
      }
      run(fn2, applyThis, applyArgs) {
        return fn2.apply(applyThis, applyArgs);
      }
      runGuarded(fn2, applyThis, applyArgs) {
        return fn2.apply(applyThis, applyArgs);
      }
      runOutsideAngular(fn2) {
        return fn2();
      }
      runTask(fn2, applyThis, applyArgs, name) {
        return fn2.apply(applyThis, applyArgs);
      }
    };
    TESTABILITY = new InjectionToken("");
    TESTABILITY_GETTER = new InjectionToken("");
    Testability = class {
      constructor(_ngZone, registry, testabilityGetter) {
        this._ngZone = _ngZone;
        this.registry = registry;
        this._pendingCount = 0;
        this._isZoneStable = true;
        this._didWork = false;
        this._callbacks = [];
        this.taskTrackingZone = null;
        if (!_testabilityGetter) {
          setTestabilityGetter(testabilityGetter);
          testabilityGetter.addToWindow(registry);
        }
        this._watchAngularEvents();
        _ngZone.run(() => {
          this.taskTrackingZone = typeof Zone == "undefined" ? null : Zone.current.get("TaskTrackingZone");
        });
      }
      _watchAngularEvents() {
        this._ngZone.onUnstable.subscribe({
          next: () => {
            this._didWork = true;
            this._isZoneStable = false;
          }
        });
        this._ngZone.runOutsideAngular(() => {
          this._ngZone.onStable.subscribe({
            next: () => {
              NgZone.assertNotInAngularZone();
              scheduleMicroTask(() => {
                this._isZoneStable = true;
                this._runCallbacksIfReady();
              });
            }
          });
        });
      }
      increasePendingRequestCount() {
        this._pendingCount += 1;
        this._didWork = true;
        return this._pendingCount;
      }
      decreasePendingRequestCount() {
        this._pendingCount -= 1;
        if (this._pendingCount < 0) {
          throw new Error("pending async requests below zero");
        }
        this._runCallbacksIfReady();
        return this._pendingCount;
      }
      isStable() {
        return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks;
      }
      _runCallbacksIfReady() {
        if (this.isStable()) {
          scheduleMicroTask(() => {
            while (this._callbacks.length !== 0) {
              let cb = this._callbacks.pop();
              clearTimeout(cb.timeoutId);
              cb.doneCb(this._didWork);
            }
            this._didWork = false;
          });
        } else {
          let pending = this.getPendingTasks();
          this._callbacks = this._callbacks.filter((cb) => {
            if (cb.updateCb && cb.updateCb(pending)) {
              clearTimeout(cb.timeoutId);
              return false;
            }
            return true;
          });
          this._didWork = true;
        }
      }
      getPendingTasks() {
        if (!this.taskTrackingZone) {
          return [];
        }
        return this.taskTrackingZone.macroTasks.map((t) => {
          return {
            source: t.source,
            creationLocation: t.creationLocation,
            data: t.data
          };
        });
      }
      addCallback(cb, timeout2, updateCb) {
        let timeoutId = -1;
        if (timeout2 && timeout2 > 0) {
          timeoutId = setTimeout(() => {
            this._callbacks = this._callbacks.filter((cb2) => cb2.timeoutId !== timeoutId);
            cb(this._didWork, this.getPendingTasks());
          }, timeout2);
        }
        this._callbacks.push({
          doneCb: cb,
          timeoutId,
          updateCb
        });
      }
      whenStable(doneCb, timeout2, updateCb) {
        if (updateCb && !this.taskTrackingZone) {
          throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
        }
        this.addCallback(doneCb, timeout2, updateCb);
        this._runCallbacksIfReady();
      }
      getPendingRequestCount() {
        return this._pendingCount;
      }
      registerApplication(token) {
        this.registry.registerApplication(token, this);
      }
      unregisterApplication(token) {
        this.registry.unregisterApplication(token);
      }
      findProviders(using2, provider, exactMatch) {
        return [];
      }
    };
    Testability.\u0275fac = function Testability_Factory(t) {
      return new (t || Testability)(\u0275\u0275inject(NgZone), \u0275\u0275inject(TestabilityRegistry), \u0275\u0275inject(TESTABILITY_GETTER));
    };
    Testability.\u0275prov = \u0275\u0275defineInjectable({
      token: Testability,
      factory: Testability.\u0275fac
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(Testability, [{
        type: Injectable
      }], function() {
        return [{
          type: NgZone
        }, {
          type: TestabilityRegistry
        }, {
          type: void 0,
          decorators: [{
            type: Inject,
            args: [TESTABILITY_GETTER]
          }]
        }];
      }, null);
    })();
    TestabilityRegistry = class {
      constructor() {
        this._applications = /* @__PURE__ */ new Map();
      }
      registerApplication(token, testability) {
        this._applications.set(token, testability);
      }
      unregisterApplication(token) {
        this._applications.delete(token);
      }
      unregisterAllApplications() {
        this._applications.clear();
      }
      getTestability(elem) {
        return this._applications.get(elem) || null;
      }
      getAllTestabilities() {
        return Array.from(this._applications.values());
      }
      getAllRootElements() {
        return Array.from(this._applications.keys());
      }
      findTestabilityInTree(elem, findInAncestors = true) {
        var _a;
        return (_a = _testabilityGetter === null || _testabilityGetter === void 0 ? void 0 : _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors)) !== null && _a !== void 0 ? _a : null;
      }
    };
    TestabilityRegistry.\u0275fac = function TestabilityRegistry_Factory(t) {
      return new (t || TestabilityRegistry)();
    };
    TestabilityRegistry.\u0275prov = \u0275\u0275defineInjectable({
      token: TestabilityRegistry,
      factory: TestabilityRegistry.\u0275fac,
      providedIn: "platform"
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(TestabilityRegistry, [{
        type: Injectable,
        args: [{
          providedIn: "platform"
        }]
      }], null, null);
    })();
    _platformInjector = null;
    ALLOW_MULTIPLE_PLATFORMS = new InjectionToken("AllowMultipleToken");
    PLATFORM_DESTROY_LISTENERS = new InjectionToken("PlatformDestroyListeners");
    NG_DEV_MODE = typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default;
    NgProbeToken = class {
      constructor(name, token) {
        this.name = name;
        this.token = token;
      }
    };
    PlatformRef = class {
      constructor(_injector) {
        this._injector = _injector;
        this._modules = [];
        this._destroyListeners = [];
        this._destroyed = false;
      }
      bootstrapModuleFactory(moduleFactory, options) {
        const ngZone = getNgZone(options === null || options === void 0 ? void 0 : options.ngZone, getNgZoneOptions(options));
        const providers = [{
          provide: NgZone,
          useValue: ngZone
        }];
        return ngZone.run(() => {
          const ngZoneInjector = Injector.create({
            providers,
            parent: this.injector,
            name: moduleFactory.moduleType.name
          });
          const moduleRef = moduleFactory.create(ngZoneInjector);
          const exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
          if (!exceptionHandler) {
            throw new RuntimeError(
              402,
              define_ngDevMode_default && "No ErrorHandler. Is platform module (BrowserModule) included?"
            );
          }
          ngZone.runOutsideAngular(() => {
            const subscription = ngZone.onError.subscribe({
              next: (error2) => {
                exceptionHandler.handleError(error2);
              }
            });
            moduleRef.onDestroy(() => {
              remove(this._modules, moduleRef);
              subscription.unsubscribe();
            });
          });
          return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
            const initStatus = moduleRef.injector.get(ApplicationInitStatus);
            initStatus.runInitializers();
            return initStatus.donePromise.then(() => {
              const localeId = moduleRef.injector.get(LOCALE_ID, DEFAULT_LOCALE_ID);
              setLocaleId(localeId || DEFAULT_LOCALE_ID);
              this._moduleDoBootstrap(moduleRef);
              return moduleRef;
            });
          });
        });
      }
      bootstrapModule(moduleType, compilerOptions = []) {
        const options = optionsReducer({}, compilerOptions);
        return compileNgModuleFactory(this.injector, options, moduleType).then((moduleFactory) => this.bootstrapModuleFactory(moduleFactory, options));
      }
      _moduleDoBootstrap(moduleRef) {
        const appRef = moduleRef.injector.get(ApplicationRef);
        if (moduleRef._bootstrapComponents.length > 0) {
          moduleRef._bootstrapComponents.forEach((f) => appRef.bootstrap(f));
        } else if (moduleRef.instance.ngDoBootstrap) {
          moduleRef.instance.ngDoBootstrap(appRef);
        } else {
          throw new RuntimeError(
            403,
            define_ngDevMode_default && `The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`
          );
        }
        this._modules.push(moduleRef);
      }
      onDestroy(callback) {
        this._destroyListeners.push(callback);
      }
      get injector() {
        return this._injector;
      }
      destroy() {
        if (this._destroyed) {
          throw new RuntimeError(
            404,
            define_ngDevMode_default && "The platform has already been destroyed!"
          );
        }
        this._modules.slice().forEach((module) => module.destroy());
        this._destroyListeners.forEach((listener) => listener());
        const destroyListeners = this._injector.get(PLATFORM_DESTROY_LISTENERS, null);
        if (destroyListeners) {
          destroyListeners.forEach((listener) => listener());
          destroyListeners.clear();
        }
        this._destroyed = true;
      }
      get destroyed() {
        return this._destroyed;
      }
    };
    PlatformRef.\u0275fac = function PlatformRef_Factory(t) {
      return new (t || PlatformRef)(\u0275\u0275inject(Injector));
    };
    PlatformRef.\u0275prov = \u0275\u0275defineInjectable({
      token: PlatformRef,
      factory: PlatformRef.\u0275fac,
      providedIn: "platform"
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(PlatformRef, [{
        type: Injectable,
        args: [{
          providedIn: "platform"
        }]
      }], function() {
        return [{
          type: Injector
        }];
      }, null);
    })();
    ApplicationRef = class {
      constructor(_zone, _injector, _exceptionHandler) {
        this._zone = _zone;
        this._injector = _injector;
        this._exceptionHandler = _exceptionHandler;
        this._bootstrapListeners = [];
        this._views = [];
        this._runningTick = false;
        this._stable = true;
        this._destroyed = false;
        this._destroyListeners = [];
        this.componentTypes = [];
        this.components = [];
        this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({
          next: () => {
            this._zone.run(() => {
              this.tick();
            });
          }
        });
        const isCurrentlyStable = new Observable((observer) => {
          this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks;
          this._zone.runOutsideAngular(() => {
            observer.next(this._stable);
            observer.complete();
          });
        });
        const isStable = new Observable((observer) => {
          let stableSub;
          this._zone.runOutsideAngular(() => {
            stableSub = this._zone.onStable.subscribe(() => {
              NgZone.assertNotInAngularZone();
              scheduleMicroTask(() => {
                if (!this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks) {
                  this._stable = true;
                  observer.next(true);
                }
              });
            });
          });
          const unstableSub = this._zone.onUnstable.subscribe(() => {
            NgZone.assertInAngularZone();
            if (this._stable) {
              this._stable = false;
              this._zone.runOutsideAngular(() => {
                observer.next(false);
              });
            }
          });
          return () => {
            stableSub.unsubscribe();
            unstableSub.unsubscribe();
          };
        });
        this.isStable = merge(isCurrentlyStable, isStable.pipe(share()));
      }
      get destroyed() {
        return this._destroyed;
      }
      get injector() {
        return this._injector;
      }
      bootstrap(componentOrFactory, rootSelectorOrNode) {
        NG_DEV_MODE && this.warnIfDestroyed();
        const isComponentFactory = componentOrFactory instanceof ComponentFactory$1;
        const initStatus = this._injector.get(ApplicationInitStatus);
        if (!initStatus.done) {
          const standalone = !isComponentFactory && isStandalone(componentOrFactory);
          const errorMessage = "Cannot bootstrap as there are still asynchronous initializers running." + (standalone ? "" : " Bootstrap components in the `ngDoBootstrap` method of the root module.");
          throw new RuntimeError(
            405,
            NG_DEV_MODE && errorMessage
          );
        }
        let componentFactory;
        if (isComponentFactory) {
          componentFactory = componentOrFactory;
        } else {
          const resolver = this._injector.get(ComponentFactoryResolver$1);
          componentFactory = resolver.resolveComponentFactory(componentOrFactory);
        }
        this.componentTypes.push(componentFactory.componentType);
        const ngModule = isBoundToModule(componentFactory) ? void 0 : this._injector.get(NgModuleRef$1);
        const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
        const compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);
        const nativeElement = compRef.location.nativeElement;
        const testability = compRef.injector.get(TESTABILITY, null);
        testability === null || testability === void 0 ? void 0 : testability.registerApplication(nativeElement);
        compRef.onDestroy(() => {
          this.detachView(compRef.hostView);
          remove(this.components, compRef);
          testability === null || testability === void 0 ? void 0 : testability.unregisterApplication(nativeElement);
        });
        this._loadComponent(compRef);
        if (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) {
          const _console = this._injector.get(Console);
          _console.log(`Angular is running in development mode. Call enableProdMode() to enable production mode.`);
        }
        return compRef;
      }
      tick() {
        NG_DEV_MODE && this.warnIfDestroyed();
        if (this._runningTick) {
          throw new RuntimeError(
            101,
            define_ngDevMode_default && "ApplicationRef.tick is called recursively"
          );
        }
        try {
          this._runningTick = true;
          for (let view of this._views) {
            view.detectChanges();
          }
          if (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) {
            for (let view of this._views) {
              view.checkNoChanges();
            }
          }
        } catch (e) {
          this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e));
        } finally {
          this._runningTick = false;
        }
      }
      attachView(viewRef) {
        NG_DEV_MODE && this.warnIfDestroyed();
        const view = viewRef;
        this._views.push(view);
        view.attachToAppRef(this);
      }
      detachView(viewRef) {
        NG_DEV_MODE && this.warnIfDestroyed();
        const view = viewRef;
        remove(this._views, view);
        view.detachFromAppRef();
      }
      _loadComponent(componentRef) {
        this.attachView(componentRef.hostView);
        this.tick();
        this.components.push(componentRef);
        const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners);
        listeners.forEach((listener) => listener(componentRef));
      }
      ngOnDestroy() {
        if (this._destroyed)
          return;
        try {
          this._destroyListeners.forEach((listener) => listener());
          this._views.slice().forEach((view) => view.destroy());
          this._onMicrotaskEmptySubscription.unsubscribe();
        } finally {
          this._destroyed = true;
          this._views = [];
          this._bootstrapListeners = [];
          this._destroyListeners = [];
        }
      }
      onDestroy(callback) {
        NG_DEV_MODE && this.warnIfDestroyed();
        this._destroyListeners.push(callback);
        return () => remove(this._destroyListeners, callback);
      }
      destroy() {
        if (this._destroyed) {
          throw new RuntimeError(
            406,
            define_ngDevMode_default && "This instance of the `ApplicationRef` has already been destroyed."
          );
        }
        const injector = this._injector;
        if (injector.destroy && !injector.destroyed) {
          injector.destroy();
        }
      }
      get viewCount() {
        return this._views.length;
      }
      warnIfDestroyed() {
        if (NG_DEV_MODE && this._destroyed) {
          console.warn(formatRuntimeError(
            406,
            "This instance of the `ApplicationRef` has already been destroyed."
          ));
        }
      }
    };
    ApplicationRef.\u0275fac = function ApplicationRef_Factory(t) {
      return new (t || ApplicationRef)(\u0275\u0275inject(NgZone), \u0275\u0275inject(EnvironmentInjector), \u0275\u0275inject(ErrorHandler));
    };
    ApplicationRef.\u0275prov = \u0275\u0275defineInjectable({
      token: ApplicationRef,
      factory: ApplicationRef.\u0275fac,
      providedIn: "root"
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(ApplicationRef, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], function() {
        return [{
          type: NgZone
        }, {
          type: EnvironmentInjector
        }, {
          type: ErrorHandler
        }];
      }, null);
    })();
    _devMode = true;
    _runModeLocked = false;
    ChangeDetectorRef = class {
    };
    ChangeDetectorRef.__NG_ELEMENT_ID__ = injectChangeDetectorRef;
    ViewRef = class extends ChangeDetectorRef {
    };
    EmbeddedViewRef = class extends ViewRef {
    };
    DebugEventListener = class {
      constructor(name, callback) {
        this.name = name;
        this.callback = callback;
      }
    };
    DebugNode = class {
      constructor(nativeNode) {
        this.nativeNode = nativeNode;
      }
      get parent() {
        const parent = this.nativeNode.parentNode;
        return parent ? new DebugElement(parent) : null;
      }
      get injector() {
        return getInjector(this.nativeNode);
      }
      get componentInstance() {
        const nativeElement = this.nativeNode;
        return nativeElement && (getComponent(nativeElement) || getOwningComponent(nativeElement));
      }
      get context() {
        return getComponent(this.nativeNode) || getContext(this.nativeNode);
      }
      get listeners() {
        return getListeners(this.nativeNode).filter((listener) => listener.type === "dom");
      }
      get references() {
        return getLocalRefs(this.nativeNode);
      }
      get providerTokens() {
        return getInjectionTokens(this.nativeNode);
      }
    };
    DebugElement = class extends DebugNode {
      constructor(nativeNode) {
        define_ngDevMode_default && assertDomNode(nativeNode);
        super(nativeNode);
      }
      get nativeElement() {
        return this.nativeNode.nodeType == Node.ELEMENT_NODE ? this.nativeNode : null;
      }
      get name() {
        const context2 = getLContext(this.nativeNode);
        const lView = context2 ? context2.lView : null;
        if (lView !== null) {
          const tData = lView[TVIEW].data;
          const tNode = tData[context2.nodeIndex];
          return tNode.value;
        } else {
          return this.nativeNode.nodeName;
        }
      }
      get properties() {
        const context2 = getLContext(this.nativeNode);
        const lView = context2 ? context2.lView : null;
        if (lView === null) {
          return {};
        }
        const tData = lView[TVIEW].data;
        const tNode = tData[context2.nodeIndex];
        const properties = {};
        copyDomProperties(this.nativeElement, properties);
        collectPropertyBindings(properties, tNode, lView, tData);
        return properties;
      }
      get attributes() {
        const attributes = {};
        const element = this.nativeElement;
        if (!element) {
          return attributes;
        }
        const context2 = getLContext(element);
        const lView = context2 ? context2.lView : null;
        if (lView === null) {
          return {};
        }
        const tNodeAttrs = lView[TVIEW].data[context2.nodeIndex].attrs;
        const lowercaseTNodeAttrs = [];
        if (tNodeAttrs) {
          let i = 0;
          while (i < tNodeAttrs.length) {
            const attrName = tNodeAttrs[i];
            if (typeof attrName !== "string")
              break;
            const attrValue = tNodeAttrs[i + 1];
            attributes[attrName] = attrValue;
            lowercaseTNodeAttrs.push(attrName.toLowerCase());
            i += 2;
          }
        }
        const eAttrs = element.attributes;
        for (let i = 0; i < eAttrs.length; i++) {
          const attr = eAttrs[i];
          const lowercaseName = attr.name.toLowerCase();
          if (lowercaseTNodeAttrs.indexOf(lowercaseName) === -1) {
            attributes[lowercaseName] = attr.value;
          }
        }
        return attributes;
      }
      get styles() {
        if (this.nativeElement && this.nativeElement.style) {
          return this.nativeElement.style;
        }
        return {};
      }
      get classes() {
        const result = {};
        const element = this.nativeElement;
        const className = element.className;
        const classes = typeof className !== "string" ? className.baseVal.split(" ") : className.split(" ");
        classes.forEach((value) => result[value] = true);
        return result;
      }
      get childNodes() {
        const childNodes = this.nativeNode.childNodes;
        const children = [];
        for (let i = 0; i < childNodes.length; i++) {
          const element = childNodes[i];
          children.push(getDebugNode(element));
        }
        return children;
      }
      get children() {
        const nativeElement = this.nativeElement;
        if (!nativeElement)
          return [];
        const childNodes = nativeElement.children;
        const children = [];
        for (let i = 0; i < childNodes.length; i++) {
          const element = childNodes[i];
          children.push(getDebugNode(element));
        }
        return children;
      }
      query(predicate) {
        const results = this.queryAll(predicate);
        return results[0] || null;
      }
      queryAll(predicate) {
        const matches = [];
        _queryAll(this, predicate, matches, true);
        return matches;
      }
      queryAllNodes(predicate) {
        const matches = [];
        _queryAll(this, predicate, matches, false);
        return matches;
      }
      triggerEventHandler(eventName, eventObj) {
        const node = this.nativeNode;
        const invokedListeners = [];
        this.listeners.forEach((listener) => {
          if (listener.name === eventName) {
            const callback = listener.callback;
            callback.call(node, eventObj);
            invokedListeners.push(callback);
          }
        });
        if (typeof node.eventListeners === "function") {
          node.eventListeners(eventName).forEach((listener) => {
            if (listener.toString().indexOf("__ngUnwrap__") !== -1) {
              const unwrappedListener = listener("__ngUnwrap__");
              return invokedListeners.indexOf(unwrappedListener) === -1 && unwrappedListener.call(node, eventObj);
            }
          });
        }
      }
    };
    NG_DEBUG_PROPERTY = "__ng_debug__";
    DefaultIterableDifferFactory = class {
      constructor() {
      }
      supports(obj) {
        return isListLikeIterable(obj);
      }
      create(trackByFn) {
        return new DefaultIterableDiffer(trackByFn);
      }
    };
    trackByIdentity = (index, item) => item;
    DefaultIterableDiffer = class {
      constructor(trackByFn) {
        this.length = 0;
        this._linkedRecords = null;
        this._unlinkedRecords = null;
        this._previousItHead = null;
        this._itHead = null;
        this._itTail = null;
        this._additionsHead = null;
        this._additionsTail = null;
        this._movesHead = null;
        this._movesTail = null;
        this._removalsHead = null;
        this._removalsTail = null;
        this._identityChangesHead = null;
        this._identityChangesTail = null;
        this._trackByFn = trackByFn || trackByIdentity;
      }
      forEachItem(fn2) {
        let record;
        for (record = this._itHead; record !== null; record = record._next) {
          fn2(record);
        }
      }
      forEachOperation(fn2) {
        let nextIt = this._itHead;
        let nextRemove = this._removalsHead;
        let addRemoveOffset = 0;
        let moveOffsets = null;
        while (nextIt || nextRemove) {
          const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove;
          const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
          const currentIndex = record.currentIndex;
          if (record === nextRemove) {
            addRemoveOffset--;
            nextRemove = nextRemove._nextRemoved;
          } else {
            nextIt = nextIt._next;
            if (record.previousIndex == null) {
              addRemoveOffset++;
            } else {
              if (!moveOffsets)
                moveOffsets = [];
              const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
              const localCurrentIndex = currentIndex - addRemoveOffset;
              if (localMovePreviousIndex != localCurrentIndex) {
                for (let i = 0; i < localMovePreviousIndex; i++) {
                  const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0;
                  const index = offset + i;
                  if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                    moveOffsets[i] = offset + 1;
                  }
                }
                const previousIndex = record.previousIndex;
                moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
              }
            }
          }
          if (adjPreviousIndex !== currentIndex) {
            fn2(record, adjPreviousIndex, currentIndex);
          }
        }
      }
      forEachPreviousItem(fn2) {
        let record;
        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
          fn2(record);
        }
      }
      forEachAddedItem(fn2) {
        let record;
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
          fn2(record);
        }
      }
      forEachMovedItem(fn2) {
        let record;
        for (record = this._movesHead; record !== null; record = record._nextMoved) {
          fn2(record);
        }
      }
      forEachRemovedItem(fn2) {
        let record;
        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
          fn2(record);
        }
      }
      forEachIdentityChange(fn2) {
        let record;
        for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
          fn2(record);
        }
      }
      diff(collection) {
        if (collection == null)
          collection = [];
        if (!isListLikeIterable(collection)) {
          throw new RuntimeError(
            900,
            define_ngDevMode_default && `Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`
          );
        }
        if (this.check(collection)) {
          return this;
        } else {
          return null;
        }
      }
      onDestroy() {
      }
      check(collection) {
        this._reset();
        let record = this._itHead;
        let mayBeDirty = false;
        let index;
        let item;
        let itemTrackBy;
        if (Array.isArray(collection)) {
          this.length = collection.length;
          for (let index2 = 0; index2 < this.length; index2++) {
            item = collection[index2];
            itemTrackBy = this._trackByFn(index2, item);
            if (record === null || !Object.is(record.trackById, itemTrackBy)) {
              record = this._mismatch(record, item, itemTrackBy, index2);
              mayBeDirty = true;
            } else {
              if (mayBeDirty) {
                record = this._verifyReinsertion(record, item, itemTrackBy, index2);
              }
              if (!Object.is(record.item, item))
                this._addIdentityChange(record, item);
            }
            record = record._next;
          }
        } else {
          index = 0;
          iterateListLike(collection, (item2) => {
            itemTrackBy = this._trackByFn(index, item2);
            if (record === null || !Object.is(record.trackById, itemTrackBy)) {
              record = this._mismatch(record, item2, itemTrackBy, index);
              mayBeDirty = true;
            } else {
              if (mayBeDirty) {
                record = this._verifyReinsertion(record, item2, itemTrackBy, index);
              }
              if (!Object.is(record.item, item2))
                this._addIdentityChange(record, item2);
            }
            record = record._next;
            index++;
          });
          this.length = index;
        }
        this._truncate(record);
        this.collection = collection;
        return this.isDirty;
      }
      get isDirty() {
        return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
      }
      _reset() {
        if (this.isDirty) {
          let record;
          for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
            record._nextPrevious = record._next;
          }
          for (record = this._additionsHead; record !== null; record = record._nextAdded) {
            record.previousIndex = record.currentIndex;
          }
          this._additionsHead = this._additionsTail = null;
          for (record = this._movesHead; record !== null; record = record._nextMoved) {
            record.previousIndex = record.currentIndex;
          }
          this._movesHead = this._movesTail = null;
          this._removalsHead = this._removalsTail = null;
          this._identityChangesHead = this._identityChangesTail = null;
        }
      }
      _mismatch(record, item, itemTrackBy, index) {
        let previousRecord;
        if (record === null) {
          previousRecord = this._itTail;
        } else {
          previousRecord = record._prev;
          this._remove(record);
        }
        record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
        if (record !== null) {
          if (!Object.is(record.item, item))
            this._addIdentityChange(record, item);
          this._reinsertAfter(record, previousRecord, index);
        } else {
          record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
          if (record !== null) {
            if (!Object.is(record.item, item))
              this._addIdentityChange(record, item);
            this._moveAfter(record, previousRecord, index);
          } else {
            record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
          }
        }
        return record;
      }
      _verifyReinsertion(record, item, itemTrackBy, index) {
        let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
        if (reinsertRecord !== null) {
          record = this._reinsertAfter(reinsertRecord, record._prev, index);
        } else if (record.currentIndex != index) {
          record.currentIndex = index;
          this._addToMoves(record, index);
        }
        return record;
      }
      _truncate(record) {
        while (record !== null) {
          const nextRecord = record._next;
          this._addToRemovals(this._unlink(record));
          record = nextRecord;
        }
        if (this._unlinkedRecords !== null) {
          this._unlinkedRecords.clear();
        }
        if (this._additionsTail !== null) {
          this._additionsTail._nextAdded = null;
        }
        if (this._movesTail !== null) {
          this._movesTail._nextMoved = null;
        }
        if (this._itTail !== null) {
          this._itTail._next = null;
        }
        if (this._removalsTail !== null) {
          this._removalsTail._nextRemoved = null;
        }
        if (this._identityChangesTail !== null) {
          this._identityChangesTail._nextIdentityChange = null;
        }
      }
      _reinsertAfter(record, prevRecord, index) {
        if (this._unlinkedRecords !== null) {
          this._unlinkedRecords.remove(record);
        }
        const prev = record._prevRemoved;
        const next = record._nextRemoved;
        if (prev === null) {
          this._removalsHead = next;
        } else {
          prev._nextRemoved = next;
        }
        if (next === null) {
          this._removalsTail = prev;
        } else {
          next._prevRemoved = prev;
        }
        this._insertAfter(record, prevRecord, index);
        this._addToMoves(record, index);
        return record;
      }
      _moveAfter(record, prevRecord, index) {
        this._unlink(record);
        this._insertAfter(record, prevRecord, index);
        this._addToMoves(record, index);
        return record;
      }
      _addAfter(record, prevRecord, index) {
        this._insertAfter(record, prevRecord, index);
        if (this._additionsTail === null) {
          this._additionsTail = this._additionsHead = record;
        } else {
          this._additionsTail = this._additionsTail._nextAdded = record;
        }
        return record;
      }
      _insertAfter(record, prevRecord, index) {
        const next = prevRecord === null ? this._itHead : prevRecord._next;
        record._next = next;
        record._prev = prevRecord;
        if (next === null) {
          this._itTail = record;
        } else {
          next._prev = record;
        }
        if (prevRecord === null) {
          this._itHead = record;
        } else {
          prevRecord._next = record;
        }
        if (this._linkedRecords === null) {
          this._linkedRecords = new _DuplicateMap();
        }
        this._linkedRecords.put(record);
        record.currentIndex = index;
        return record;
      }
      _remove(record) {
        return this._addToRemovals(this._unlink(record));
      }
      _unlink(record) {
        if (this._linkedRecords !== null) {
          this._linkedRecords.remove(record);
        }
        const prev = record._prev;
        const next = record._next;
        if (prev === null) {
          this._itHead = next;
        } else {
          prev._next = next;
        }
        if (next === null) {
          this._itTail = prev;
        } else {
          next._prev = prev;
        }
        return record;
      }
      _addToMoves(record, toIndex) {
        if (record.previousIndex === toIndex) {
          return record;
        }
        if (this._movesTail === null) {
          this._movesTail = this._movesHead = record;
        } else {
          this._movesTail = this._movesTail._nextMoved = record;
        }
        return record;
      }
      _addToRemovals(record) {
        if (this._unlinkedRecords === null) {
          this._unlinkedRecords = new _DuplicateMap();
        }
        this._unlinkedRecords.put(record);
        record.currentIndex = null;
        record._nextRemoved = null;
        if (this._removalsTail === null) {
          this._removalsTail = this._removalsHead = record;
          record._prevRemoved = null;
        } else {
          record._prevRemoved = this._removalsTail;
          this._removalsTail = this._removalsTail._nextRemoved = record;
        }
        return record;
      }
      _addIdentityChange(record, item) {
        record.item = item;
        if (this._identityChangesTail === null) {
          this._identityChangesTail = this._identityChangesHead = record;
        } else {
          this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
        }
        return record;
      }
    };
    IterableChangeRecord_ = class {
      constructor(item, trackById) {
        this.item = item;
        this.trackById = trackById;
        this.currentIndex = null;
        this.previousIndex = null;
        this._nextPrevious = null;
        this._prev = null;
        this._next = null;
        this._prevDup = null;
        this._nextDup = null;
        this._prevRemoved = null;
        this._nextRemoved = null;
        this._nextAdded = null;
        this._nextMoved = null;
        this._nextIdentityChange = null;
      }
    };
    _DuplicateItemRecordList = class {
      constructor() {
        this._head = null;
        this._tail = null;
      }
      add(record) {
        if (this._head === null) {
          this._head = this._tail = record;
          record._nextDup = null;
          record._prevDup = null;
        } else {
          this._tail._nextDup = record;
          record._prevDup = this._tail;
          record._nextDup = null;
          this._tail = record;
        }
      }
      get(trackById, atOrAfterIndex) {
        let record;
        for (record = this._head; record !== null; record = record._nextDup) {
          if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) && Object.is(record.trackById, trackById)) {
            return record;
          }
        }
        return null;
      }
      remove(record) {
        const prev = record._prevDup;
        const next = record._nextDup;
        if (prev === null) {
          this._head = next;
        } else {
          prev._nextDup = next;
        }
        if (next === null) {
          this._tail = prev;
        } else {
          next._prevDup = prev;
        }
        return this._head === null;
      }
    };
    _DuplicateMap = class {
      constructor() {
        this.map = /* @__PURE__ */ new Map();
      }
      put(record) {
        const key = record.trackById;
        let duplicates = this.map.get(key);
        if (!duplicates) {
          duplicates = new _DuplicateItemRecordList();
          this.map.set(key, duplicates);
        }
        duplicates.add(record);
      }
      get(trackById, atOrAfterIndex) {
        const key = trackById;
        const recordList = this.map.get(key);
        return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
      }
      remove(record) {
        const key = record.trackById;
        const recordList = this.map.get(key);
        if (recordList.remove(record)) {
          this.map.delete(key);
        }
        return record;
      }
      get isEmpty() {
        return this.map.size === 0;
      }
      clear() {
        this.map.clear();
      }
    };
    DefaultKeyValueDifferFactory = class {
      constructor() {
      }
      supports(obj) {
        return obj instanceof Map || isJsObject(obj);
      }
      create() {
        return new DefaultKeyValueDiffer();
      }
    };
    DefaultKeyValueDiffer = class {
      constructor() {
        this._records = /* @__PURE__ */ new Map();
        this._mapHead = null;
        this._appendAfter = null;
        this._previousMapHead = null;
        this._changesHead = null;
        this._changesTail = null;
        this._additionsHead = null;
        this._additionsTail = null;
        this._removalsHead = null;
        this._removalsTail = null;
      }
      get isDirty() {
        return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
      }
      forEachItem(fn2) {
        let record;
        for (record = this._mapHead; record !== null; record = record._next) {
          fn2(record);
        }
      }
      forEachPreviousItem(fn2) {
        let record;
        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
          fn2(record);
        }
      }
      forEachChangedItem(fn2) {
        let record;
        for (record = this._changesHead; record !== null; record = record._nextChanged) {
          fn2(record);
        }
      }
      forEachAddedItem(fn2) {
        let record;
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
          fn2(record);
        }
      }
      forEachRemovedItem(fn2) {
        let record;
        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
          fn2(record);
        }
      }
      diff(map2) {
        if (!map2) {
          map2 = /* @__PURE__ */ new Map();
        } else if (!(map2 instanceof Map || isJsObject(map2))) {
          throw new RuntimeError(
            900,
            define_ngDevMode_default && `Error trying to diff '${stringify(map2)}'. Only maps and objects are allowed`
          );
        }
        return this.check(map2) ? this : null;
      }
      onDestroy() {
      }
      check(map2) {
        this._reset();
        let insertBefore = this._mapHead;
        this._appendAfter = null;
        this._forEach(map2, (value, key) => {
          if (insertBefore && insertBefore.key === key) {
            this._maybeAddToChanges(insertBefore, value);
            this._appendAfter = insertBefore;
            insertBefore = insertBefore._next;
          } else {
            const record = this._getOrCreateRecordForKey(key, value);
            insertBefore = this._insertBeforeOrAppend(insertBefore, record);
          }
        });
        if (insertBefore) {
          if (insertBefore._prev) {
            insertBefore._prev._next = null;
          }
          this._removalsHead = insertBefore;
          for (let record = insertBefore; record !== null; record = record._nextRemoved) {
            if (record === this._mapHead) {
              this._mapHead = null;
            }
            this._records.delete(record.key);
            record._nextRemoved = record._next;
            record.previousValue = record.currentValue;
            record.currentValue = null;
            record._prev = null;
            record._next = null;
          }
        }
        if (this._changesTail)
          this._changesTail._nextChanged = null;
        if (this._additionsTail)
          this._additionsTail._nextAdded = null;
        return this.isDirty;
      }
      _insertBeforeOrAppend(before, record) {
        if (before) {
          const prev = before._prev;
          record._next = before;
          record._prev = prev;
          before._prev = record;
          if (prev) {
            prev._next = record;
          }
          if (before === this._mapHead) {
            this._mapHead = record;
          }
          this._appendAfter = before;
          return before;
        }
        if (this._appendAfter) {
          this._appendAfter._next = record;
          record._prev = this._appendAfter;
        } else {
          this._mapHead = record;
        }
        this._appendAfter = record;
        return null;
      }
      _getOrCreateRecordForKey(key, value) {
        if (this._records.has(key)) {
          const record2 = this._records.get(key);
          this._maybeAddToChanges(record2, value);
          const prev = record2._prev;
          const next = record2._next;
          if (prev) {
            prev._next = next;
          }
          if (next) {
            next._prev = prev;
          }
          record2._next = null;
          record2._prev = null;
          return record2;
        }
        const record = new KeyValueChangeRecord_(key);
        this._records.set(key, record);
        record.currentValue = value;
        this._addToAdditions(record);
        return record;
      }
      _reset() {
        if (this.isDirty) {
          let record;
          this._previousMapHead = this._mapHead;
          for (record = this._previousMapHead; record !== null; record = record._next) {
            record._nextPrevious = record._next;
          }
          for (record = this._changesHead; record !== null; record = record._nextChanged) {
            record.previousValue = record.currentValue;
          }
          for (record = this._additionsHead; record != null; record = record._nextAdded) {
            record.previousValue = record.currentValue;
          }
          this._changesHead = this._changesTail = null;
          this._additionsHead = this._additionsTail = null;
          this._removalsHead = null;
        }
      }
      _maybeAddToChanges(record, newValue) {
        if (!Object.is(newValue, record.currentValue)) {
          record.previousValue = record.currentValue;
          record.currentValue = newValue;
          this._addToChanges(record);
        }
      }
      _addToAdditions(record) {
        if (this._additionsHead === null) {
          this._additionsHead = this._additionsTail = record;
        } else {
          this._additionsTail._nextAdded = record;
          this._additionsTail = record;
        }
      }
      _addToChanges(record) {
        if (this._changesHead === null) {
          this._changesHead = this._changesTail = record;
        } else {
          this._changesTail._nextChanged = record;
          this._changesTail = record;
        }
      }
      _forEach(obj, fn2) {
        if (obj instanceof Map) {
          obj.forEach(fn2);
        } else {
          Object.keys(obj).forEach((k) => fn2(obj[k], k));
        }
      }
    };
    KeyValueChangeRecord_ = class {
      constructor(key) {
        this.key = key;
        this.previousValue = null;
        this.currentValue = null;
        this._nextPrevious = null;
        this._next = null;
        this._prev = null;
        this._nextAdded = null;
        this._nextRemoved = null;
        this._nextChanged = null;
      }
    };
    IterableDiffers = class {
      constructor(factories) {
        this.factories = factories;
      }
      static create(factories, parent) {
        if (parent != null) {
          const copied = parent.factories.slice();
          factories = factories.concat(copied);
        }
        return new IterableDiffers(factories);
      }
      static extend(factories) {
        return {
          provide: IterableDiffers,
          useFactory: (parent) => {
            return IterableDiffers.create(factories, parent || defaultIterableDiffersFactory());
          },
          deps: [[IterableDiffers, new SkipSelf(), new Optional()]]
        };
      }
      find(iterable) {
        const factory = this.factories.find((f) => f.supports(iterable));
        if (factory != null) {
          return factory;
        } else {
          throw new RuntimeError(
            901,
            define_ngDevMode_default && `Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`
          );
        }
      }
    };
    IterableDiffers.\u0275prov = \u0275\u0275defineInjectable({
      token: IterableDiffers,
      providedIn: "root",
      factory: defaultIterableDiffersFactory
    });
    KeyValueDiffers = class {
      constructor(factories) {
        this.factories = factories;
      }
      static create(factories, parent) {
        if (parent) {
          const copied = parent.factories.slice();
          factories = factories.concat(copied);
        }
        return new KeyValueDiffers(factories);
      }
      static extend(factories) {
        return {
          provide: KeyValueDiffers,
          useFactory: (parent) => {
            return KeyValueDiffers.create(factories, parent || defaultKeyValueDiffersFactory());
          },
          deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]
        };
      }
      find(kv) {
        const factory = this.factories.find((f) => f.supports(kv));
        if (factory) {
          return factory;
        }
        throw new RuntimeError(
          901,
          define_ngDevMode_default && `Cannot find a differ supporting object '${kv}'`
        );
      }
    };
    KeyValueDiffers.\u0275prov = \u0275\u0275defineInjectable({
      token: KeyValueDiffers,
      providedIn: "root",
      factory: defaultKeyValueDiffersFactory
    });
    keyValDiff = [new DefaultKeyValueDifferFactory()];
    iterableDiff = [new DefaultIterableDifferFactory()];
    defaultIterableDiffers = new IterableDiffers(iterableDiff);
    defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
    platformCore = createPlatformFactory(null, "core", []);
    ApplicationModule = class {
      constructor(appRef) {
      }
    };
    ApplicationModule.\u0275fac = function ApplicationModule_Factory(t) {
      return new (t || ApplicationModule)(\u0275\u0275inject(ApplicationRef));
    };
    ApplicationModule.\u0275mod = \u0275\u0275defineNgModule({
      type: ApplicationModule
    });
    ApplicationModule.\u0275inj = \u0275\u0275defineInjector({});
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(ApplicationModule, [{
        type: NgModule
      }], function() {
        return [{
          type: ApplicationRef
        }];
      }, null);
    })();
    \u0275ivyEnabled = true;
    if (typeof define_ngDevMode_default !== "undefined" && define_ngDevMode_default) {
      _global.$localize = _global.$localize || function() {
        throw new Error("It looks like your application or one of its dependencies is using i18n.\nAngular 9 introduced a global `$localize()` function that needs to be loaded.\nPlease run `ng add @angular/localize` from the Angular CLI.\n(For non-CLI projects, add `import '@angular/localize/init';` to your `polyfills.ts` file.\nFor server-side rendering applications add the import to your `main.server.ts` file.)");
      };
    }
  }
});

// node_modules/@angular/common/fesm2015/common.mjs
function getDOM() {
  return _DOM;
}
function setRootDomAdapter(adapter) {
  if (!_DOM) {
    _DOM = adapter;
  }
}
function useBrowserPlatformLocation() {
  return \u0275\u0275inject(BrowserPlatformLocation);
}
function supportsState() {
  return !!window.history.pushState;
}
function createBrowserPlatformLocation() {
  return new BrowserPlatformLocation(\u0275\u0275inject(DOCUMENT2));
}
function joinWithSlash(start, end) {
  if (start.length == 0) {
    return end;
  }
  if (end.length == 0) {
    return start;
  }
  let slashes = 0;
  if (start.endsWith("/")) {
    slashes++;
  }
  if (end.startsWith("/")) {
    slashes++;
  }
  if (slashes == 2) {
    return start + end.substring(1);
  }
  if (slashes == 1) {
    return start + end;
  }
  return start + "/" + end;
}
function stripTrailingSlash(url) {
  const match = url.match(/#|\?|$/);
  const pathEndIdx = match && match.index || url.length;
  const droppedSlashIdx = pathEndIdx - (url[pathEndIdx - 1] === "/" ? 1 : 0);
  return url.slice(0, droppedSlashIdx) + url.slice(pathEndIdx);
}
function normalizeQueryParams(params) {
  return params && params[0] !== "?" ? "?" + params : params;
}
function createLocation() {
  return new Location(\u0275\u0275inject(LocationStrategy));
}
function _stripBaseHref(baseHref, url) {
  return baseHref && url.startsWith(baseHref) ? url.substring(baseHref.length) : url;
}
function _stripIndexHtml(url) {
  return url.replace(/\/index.html$/, "");
}
function getLocaleId2(locale) {
  return findLocaleData(locale)[LocaleDataIndex.LocaleId];
}
function getLocaleDayPeriods(locale, formStyle, width) {
  const data = findLocaleData(locale);
  const amPmData = [data[LocaleDataIndex.DayPeriodsFormat], data[LocaleDataIndex.DayPeriodsStandalone]];
  const amPm = getLastDefinedValue(amPmData, formStyle);
  return getLastDefinedValue(amPm, width);
}
function getLocaleDayNames(locale, formStyle, width) {
  const data = findLocaleData(locale);
  const daysData = [data[LocaleDataIndex.DaysFormat], data[LocaleDataIndex.DaysStandalone]];
  const days = getLastDefinedValue(daysData, formStyle);
  return getLastDefinedValue(days, width);
}
function getLocaleMonthNames(locale, formStyle, width) {
  const data = findLocaleData(locale);
  const monthsData = [data[LocaleDataIndex.MonthsFormat], data[LocaleDataIndex.MonthsStandalone]];
  const months = getLastDefinedValue(monthsData, formStyle);
  return getLastDefinedValue(months, width);
}
function getLocaleEraNames(locale, width) {
  const data = findLocaleData(locale);
  const erasData = data[LocaleDataIndex.Eras];
  return getLastDefinedValue(erasData, width);
}
function getLocaleDateFormat(locale, width) {
  const data = findLocaleData(locale);
  return getLastDefinedValue(data[LocaleDataIndex.DateFormat], width);
}
function getLocaleTimeFormat(locale, width) {
  const data = findLocaleData(locale);
  return getLastDefinedValue(data[LocaleDataIndex.TimeFormat], width);
}
function getLocaleDateTimeFormat(locale, width) {
  const data = findLocaleData(locale);
  const dateTimeFormatData = data[LocaleDataIndex.DateTimeFormat];
  return getLastDefinedValue(dateTimeFormatData, width);
}
function getLocaleNumberSymbol(locale, symbol) {
  const data = findLocaleData(locale);
  const res = data[LocaleDataIndex.NumberSymbols][symbol];
  if (typeof res === "undefined") {
    if (symbol === NumberSymbol.CurrencyDecimal) {
      return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Decimal];
    } else if (symbol === NumberSymbol.CurrencyGroup) {
      return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Group];
    }
  }
  return res;
}
function getLocaleNumberFormat(locale, type) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.NumberFormats][type];
}
function getLocaleCurrencies(locale) {
  const data = findLocaleData(locale);
  return data[LocaleDataIndex.Currencies];
}
function checkFullData(data) {
  if (!data[LocaleDataIndex.ExtraData]) {
    throw new Error(`Missing extra locale data for the locale "${data[LocaleDataIndex.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`);
  }
}
function getLocaleExtraDayPeriodRules(locale) {
  const data = findLocaleData(locale);
  checkFullData(data);
  const rules = data[LocaleDataIndex.ExtraData][2] || [];
  return rules.map((rule) => {
    if (typeof rule === "string") {
      return extractTime(rule);
    }
    return [extractTime(rule[0]), extractTime(rule[1])];
  });
}
function getLocaleExtraDayPeriods(locale, formStyle, width) {
  const data = findLocaleData(locale);
  checkFullData(data);
  const dayPeriodsData = [data[LocaleDataIndex.ExtraData][0], data[LocaleDataIndex.ExtraData][1]];
  const dayPeriods = getLastDefinedValue(dayPeriodsData, formStyle) || [];
  return getLastDefinedValue(dayPeriods, width) || [];
}
function getLastDefinedValue(data, index) {
  for (let i = index; i > -1; i--) {
    if (typeof data[i] !== "undefined") {
      return data[i];
    }
  }
  throw new Error("Locale data API: locale data undefined");
}
function extractTime(time) {
  const [h, m] = time.split(":");
  return {
    hours: +h,
    minutes: +m
  };
}
function getCurrencySymbol(code, format, locale = "en") {
  const currency = getLocaleCurrencies(locale)[code] || CURRENCIES_EN[code] || [];
  const symbolNarrow = currency[1];
  if (format === "narrow" && typeof symbolNarrow === "string") {
    return symbolNarrow;
  }
  return currency[0] || code;
}
function getNumberOfCurrencyDigits(code) {
  let digits;
  const currency = CURRENCIES_EN[code];
  if (currency) {
    digits = currency[2];
  }
  return typeof digits === "number" ? digits : DEFAULT_NB_OF_CURRENCY_DIGITS;
}
function formatDate(value, format, locale, timezone) {
  let date = toDate(value);
  const namedFormat = getNamedFormat(locale, format);
  format = namedFormat || format;
  let parts = [];
  let match;
  while (format) {
    match = DATE_FORMATS_SPLIT.exec(format);
    if (match) {
      parts = parts.concat(match.slice(1));
      const part = parts.pop();
      if (!part) {
        break;
      }
      format = part;
    } else {
      parts.push(format);
      break;
    }
  }
  let dateTimezoneOffset = date.getTimezoneOffset();
  if (timezone) {
    dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
    date = convertTimezoneToLocal(date, timezone, true);
  }
  let text = "";
  parts.forEach((value2) => {
    const dateFormatter = getDateFormatter(value2);
    text += dateFormatter ? dateFormatter(date, locale, dateTimezoneOffset) : value2 === "''" ? "'" : value2.replace(/(^'|'$)/g, "").replace(/''/g, "'");
  });
  return text;
}
function createDate(year, month, date) {
  const newDate = new Date(0);
  newDate.setFullYear(year, month, date);
  newDate.setHours(0, 0, 0);
  return newDate;
}
function getNamedFormat(locale, format) {
  const localeId = getLocaleId2(locale);
  NAMED_FORMATS[localeId] = NAMED_FORMATS[localeId] || {};
  if (NAMED_FORMATS[localeId][format]) {
    return NAMED_FORMATS[localeId][format];
  }
  let formatValue = "";
  switch (format) {
    case "shortDate":
      formatValue = getLocaleDateFormat(locale, FormatWidth.Short);
      break;
    case "mediumDate":
      formatValue = getLocaleDateFormat(locale, FormatWidth.Medium);
      break;
    case "longDate":
      formatValue = getLocaleDateFormat(locale, FormatWidth.Long);
      break;
    case "fullDate":
      formatValue = getLocaleDateFormat(locale, FormatWidth.Full);
      break;
    case "shortTime":
      formatValue = getLocaleTimeFormat(locale, FormatWidth.Short);
      break;
    case "mediumTime":
      formatValue = getLocaleTimeFormat(locale, FormatWidth.Medium);
      break;
    case "longTime":
      formatValue = getLocaleTimeFormat(locale, FormatWidth.Long);
      break;
    case "fullTime":
      formatValue = getLocaleTimeFormat(locale, FormatWidth.Full);
      break;
    case "short":
      const shortTime = getNamedFormat(locale, "shortTime");
      const shortDate = getNamedFormat(locale, "shortDate");
      formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Short), [shortTime, shortDate]);
      break;
    case "medium":
      const mediumTime = getNamedFormat(locale, "mediumTime");
      const mediumDate = getNamedFormat(locale, "mediumDate");
      formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Medium), [mediumTime, mediumDate]);
      break;
    case "long":
      const longTime = getNamedFormat(locale, "longTime");
      const longDate = getNamedFormat(locale, "longDate");
      formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Long), [longTime, longDate]);
      break;
    case "full":
      const fullTime = getNamedFormat(locale, "fullTime");
      const fullDate = getNamedFormat(locale, "fullDate");
      formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Full), [fullTime, fullDate]);
      break;
  }
  if (formatValue) {
    NAMED_FORMATS[localeId][format] = formatValue;
  }
  return formatValue;
}
function formatDateTime(str, opt_values) {
  if (opt_values) {
    str = str.replace(/\{([^}]+)}/g, function(match, key) {
      return opt_values != null && key in opt_values ? opt_values[key] : match;
    });
  }
  return str;
}
function padNumber(num, digits, minusSign = "-", trim, negWrap) {
  let neg = "";
  if (num < 0 || negWrap && num <= 0) {
    if (negWrap) {
      num = -num + 1;
    } else {
      num = -num;
      neg = minusSign;
    }
  }
  let strNum = String(num);
  while (strNum.length < digits) {
    strNum = "0" + strNum;
  }
  if (trim) {
    strNum = strNum.slice(strNum.length - digits);
  }
  return neg + strNum;
}
function formatFractionalSeconds(milliseconds, digits) {
  const strMs = padNumber(milliseconds, 3);
  return strMs.substring(0, digits);
}
function dateGetter(name, size, offset = 0, trim = false, negWrap = false) {
  return function(date, locale) {
    let part = getDatePart(name, date);
    if (offset > 0 || part > -offset) {
      part += offset;
    }
    if (name === DateType.Hours) {
      if (part === 0 && offset === -12) {
        part = 12;
      }
    } else if (name === DateType.FractionalSeconds) {
      return formatFractionalSeconds(part, size);
    }
    const localeMinus = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
    return padNumber(part, size, localeMinus, trim, negWrap);
  };
}
function getDatePart(part, date) {
  switch (part) {
    case DateType.FullYear:
      return date.getFullYear();
    case DateType.Month:
      return date.getMonth();
    case DateType.Date:
      return date.getDate();
    case DateType.Hours:
      return date.getHours();
    case DateType.Minutes:
      return date.getMinutes();
    case DateType.Seconds:
      return date.getSeconds();
    case DateType.FractionalSeconds:
      return date.getMilliseconds();
    case DateType.Day:
      return date.getDay();
    default:
      throw new Error(`Unknown DateType value "${part}".`);
  }
}
function dateStrGetter(name, width, form = FormStyle.Format, extended = false) {
  return function(date, locale) {
    return getDateTranslation(date, locale, name, width, form, extended);
  };
}
function getDateTranslation(date, locale, name, width, form, extended) {
  switch (name) {
    case TranslationType.Months:
      return getLocaleMonthNames(locale, form, width)[date.getMonth()];
    case TranslationType.Days:
      return getLocaleDayNames(locale, form, width)[date.getDay()];
    case TranslationType.DayPeriods:
      const currentHours = date.getHours();
      const currentMinutes = date.getMinutes();
      if (extended) {
        const rules = getLocaleExtraDayPeriodRules(locale);
        const dayPeriods = getLocaleExtraDayPeriods(locale, form, width);
        const index = rules.findIndex((rule) => {
          if (Array.isArray(rule)) {
            const [from2, to] = rule;
            const afterFrom = currentHours >= from2.hours && currentMinutes >= from2.minutes;
            const beforeTo = currentHours < to.hours || currentHours === to.hours && currentMinutes < to.minutes;
            if (from2.hours < to.hours) {
              if (afterFrom && beforeTo) {
                return true;
              }
            } else if (afterFrom || beforeTo) {
              return true;
            }
          } else {
            if (rule.hours === currentHours && rule.minutes === currentMinutes) {
              return true;
            }
          }
          return false;
        });
        if (index !== -1) {
          return dayPeriods[index];
        }
      }
      return getLocaleDayPeriods(locale, form, width)[currentHours < 12 ? 0 : 1];
    case TranslationType.Eras:
      return getLocaleEraNames(locale, width)[date.getFullYear() <= 0 ? 0 : 1];
    default:
      const unexpected = name;
      throw new Error(`unexpected translation type ${unexpected}`);
  }
}
function timeZoneGetter(width) {
  return function(date, locale, offset) {
    const zone = -1 * offset;
    const minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
    const hours = zone > 0 ? Math.floor(zone / 60) : Math.ceil(zone / 60);
    switch (width) {
      case ZoneWidth.Short:
        return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + padNumber(Math.abs(zone % 60), 2, minusSign);
      case ZoneWidth.ShortGMT:
        return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 1, minusSign);
      case ZoneWidth.Long:
        return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
      case ZoneWidth.Extended:
        if (offset === 0) {
          return "Z";
        } else {
          return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
        }
      default:
        throw new Error(`Unknown zone width "${width}"`);
    }
  };
}
function getFirstThursdayOfYear(year) {
  const firstDayOfYear = createDate(year, JANUARY, 1).getDay();
  return createDate(year, 0, 1 + (firstDayOfYear <= THURSDAY ? THURSDAY : THURSDAY + 7) - firstDayOfYear);
}
function getThursdayThisWeek(datetime) {
  return createDate(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (THURSDAY - datetime.getDay()));
}
function weekGetter(size, monthBased = false) {
  return function(date, locale) {
    let result;
    if (monthBased) {
      const nbDaysBefore1stDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1).getDay() - 1;
      const today = date.getDate();
      result = 1 + Math.floor((today + nbDaysBefore1stDayOfMonth) / 7);
    } else {
      const thisThurs = getThursdayThisWeek(date);
      const firstThurs = getFirstThursdayOfYear(thisThurs.getFullYear());
      const diff = thisThurs.getTime() - firstThurs.getTime();
      result = 1 + Math.round(diff / 6048e5);
    }
    return padNumber(result, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  };
}
function weekNumberingYearGetter(size, trim = false) {
  return function(date, locale) {
    const thisThurs = getThursdayThisWeek(date);
    const weekNumberingYear = thisThurs.getFullYear();
    return padNumber(weekNumberingYear, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign), trim);
  };
}
function getDateFormatter(format) {
  if (DATE_FORMATS[format]) {
    return DATE_FORMATS[format];
  }
  let formatter;
  switch (format) {
    case "G":
    case "GG":
    case "GGG":
      formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Abbreviated);
      break;
    case "GGGG":
      formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Wide);
      break;
    case "GGGGG":
      formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Narrow);
      break;
    case "y":
      formatter = dateGetter(DateType.FullYear, 1, 0, false, true);
      break;
    case "yy":
      formatter = dateGetter(DateType.FullYear, 2, 0, true, true);
      break;
    case "yyy":
      formatter = dateGetter(DateType.FullYear, 3, 0, false, true);
      break;
    case "yyyy":
      formatter = dateGetter(DateType.FullYear, 4, 0, false, true);
      break;
    case "Y":
      formatter = weekNumberingYearGetter(1);
      break;
    case "YY":
      formatter = weekNumberingYearGetter(2, true);
      break;
    case "YYY":
      formatter = weekNumberingYearGetter(3);
      break;
    case "YYYY":
      formatter = weekNumberingYearGetter(4);
      break;
    case "M":
    case "L":
      formatter = dateGetter(DateType.Month, 1, 1);
      break;
    case "MM":
    case "LL":
      formatter = dateGetter(DateType.Month, 2, 1);
      break;
    case "MMM":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated);
      break;
    case "MMMM":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide);
      break;
    case "MMMMM":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow);
      break;
    case "LLL":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated, FormStyle.Standalone);
      break;
    case "LLLL":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide, FormStyle.Standalone);
      break;
    case "LLLLL":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow, FormStyle.Standalone);
      break;
    case "w":
      formatter = weekGetter(1);
      break;
    case "ww":
      formatter = weekGetter(2);
      break;
    case "W":
      formatter = weekGetter(1, true);
      break;
    case "d":
      formatter = dateGetter(DateType.Date, 1);
      break;
    case "dd":
      formatter = dateGetter(DateType.Date, 2);
      break;
    case "c":
    case "cc":
      formatter = dateGetter(DateType.Day, 1);
      break;
    case "ccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated, FormStyle.Standalone);
      break;
    case "cccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide, FormStyle.Standalone);
      break;
    case "ccccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow, FormStyle.Standalone);
      break;
    case "cccccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short, FormStyle.Standalone);
      break;
    case "E":
    case "EE":
    case "EEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated);
      break;
    case "EEEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide);
      break;
    case "EEEEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow);
      break;
    case "EEEEEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short);
      break;
    case "a":
    case "aa":
    case "aaa":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated);
      break;
    case "aaaa":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide);
      break;
    case "aaaaa":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow);
      break;
    case "b":
    case "bb":
    case "bbb":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Standalone, true);
      break;
    case "bbbb":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Standalone, true);
      break;
    case "bbbbb":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Standalone, true);
      break;
    case "B":
    case "BB":
    case "BBB":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Format, true);
      break;
    case "BBBB":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Format, true);
      break;
    case "BBBBB":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Format, true);
      break;
    case "h":
      formatter = dateGetter(DateType.Hours, 1, -12);
      break;
    case "hh":
      formatter = dateGetter(DateType.Hours, 2, -12);
      break;
    case "H":
      formatter = dateGetter(DateType.Hours, 1);
      break;
    case "HH":
      formatter = dateGetter(DateType.Hours, 2);
      break;
    case "m":
      formatter = dateGetter(DateType.Minutes, 1);
      break;
    case "mm":
      formatter = dateGetter(DateType.Minutes, 2);
      break;
    case "s":
      formatter = dateGetter(DateType.Seconds, 1);
      break;
    case "ss":
      formatter = dateGetter(DateType.Seconds, 2);
      break;
    case "S":
      formatter = dateGetter(DateType.FractionalSeconds, 1);
      break;
    case "SS":
      formatter = dateGetter(DateType.FractionalSeconds, 2);
      break;
    case "SSS":
      formatter = dateGetter(DateType.FractionalSeconds, 3);
      break;
    case "Z":
    case "ZZ":
    case "ZZZ":
      formatter = timeZoneGetter(ZoneWidth.Short);
      break;
    case "ZZZZZ":
      formatter = timeZoneGetter(ZoneWidth.Extended);
      break;
    case "O":
    case "OO":
    case "OOO":
    case "z":
    case "zz":
    case "zzz":
      formatter = timeZoneGetter(ZoneWidth.ShortGMT);
      break;
    case "OOOO":
    case "ZZZZ":
    case "zzzz":
      formatter = timeZoneGetter(ZoneWidth.Long);
      break;
    default:
      return null;
  }
  DATE_FORMATS[format] = formatter;
  return formatter;
}
function timezoneToOffset(timezone, fallback) {
  timezone = timezone.replace(/:/g, "");
  const requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
  return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
}
function addDateMinutes(date, minutes) {
  date = new Date(date.getTime());
  date.setMinutes(date.getMinutes() + minutes);
  return date;
}
function convertTimezoneToLocal(date, timezone, reverse) {
  const reverseValue = reverse ? -1 : 1;
  const dateTimezoneOffset = date.getTimezoneOffset();
  const timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
  return addDateMinutes(date, reverseValue * (timezoneOffset - dateTimezoneOffset));
}
function toDate(value) {
  if (isDate(value)) {
    return value;
  }
  if (typeof value === "number" && !isNaN(value)) {
    return new Date(value);
  }
  if (typeof value === "string") {
    value = value.trim();
    if (/^(\d{4}(-\d{1,2}(-\d{1,2})?)?)$/.test(value)) {
      const [y, m = 1, d = 1] = value.split("-").map((val) => +val);
      return createDate(y, m - 1, d);
    }
    const parsedNb = parseFloat(value);
    if (!isNaN(value - parsedNb)) {
      return new Date(parsedNb);
    }
    let match;
    if (match = value.match(ISO8601_DATE_REGEX)) {
      return isoStringToDate(match);
    }
  }
  const date = new Date(value);
  if (!isDate(date)) {
    throw new Error(`Unable to convert "${value}" into a date`);
  }
  return date;
}
function isoStringToDate(match) {
  const date = new Date(0);
  let tzHour = 0;
  let tzMin = 0;
  const dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear;
  const timeSetter = match[8] ? date.setUTCHours : date.setHours;
  if (match[9]) {
    tzHour = Number(match[9] + match[10]);
    tzMin = Number(match[9] + match[11]);
  }
  dateSetter.call(date, Number(match[1]), Number(match[2]) - 1, Number(match[3]));
  const h = Number(match[4] || 0) - tzHour;
  const m = Number(match[5] || 0) - tzMin;
  const s = Number(match[6] || 0);
  const ms = Math.floor(parseFloat("0." + (match[7] || 0)) * 1e3);
  timeSetter.call(date, h, m, s, ms);
  return date;
}
function isDate(value) {
  return value instanceof Date && !isNaN(value.valueOf());
}
function formatNumberToLocaleString(value, pattern, locale, groupSymbol, decimalSymbol, digitsInfo, isPercent = false) {
  let formattedText = "";
  let isZero = false;
  if (!isFinite(value)) {
    formattedText = getLocaleNumberSymbol(locale, NumberSymbol.Infinity);
  } else {
    let parsedNumber = parseNumber(value);
    if (isPercent) {
      parsedNumber = toPercent(parsedNumber);
    }
    let minInt = pattern.minInt;
    let minFraction = pattern.minFrac;
    let maxFraction = pattern.maxFrac;
    if (digitsInfo) {
      const parts = digitsInfo.match(NUMBER_FORMAT_REGEXP);
      if (parts === null) {
        throw new Error(`${digitsInfo} is not a valid digit info`);
      }
      const minIntPart = parts[1];
      const minFractionPart = parts[3];
      const maxFractionPart = parts[5];
      if (minIntPart != null) {
        minInt = parseIntAutoRadix(minIntPart);
      }
      if (minFractionPart != null) {
        minFraction = parseIntAutoRadix(minFractionPart);
      }
      if (maxFractionPart != null) {
        maxFraction = parseIntAutoRadix(maxFractionPart);
      } else if (minFractionPart != null && minFraction > maxFraction) {
        maxFraction = minFraction;
      }
    }
    roundNumber(parsedNumber, minFraction, maxFraction);
    let digits = parsedNumber.digits;
    let integerLen = parsedNumber.integerLen;
    const exponent = parsedNumber.exponent;
    let decimals = [];
    isZero = digits.every((d) => !d);
    for (; integerLen < minInt; integerLen++) {
      digits.unshift(0);
    }
    for (; integerLen < 0; integerLen++) {
      digits.unshift(0);
    }
    if (integerLen > 0) {
      decimals = digits.splice(integerLen, digits.length);
    } else {
      decimals = digits;
      digits = [0];
    }
    const groups = [];
    if (digits.length >= pattern.lgSize) {
      groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(""));
    }
    while (digits.length > pattern.gSize) {
      groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
    }
    if (digits.length) {
      groups.unshift(digits.join(""));
    }
    formattedText = groups.join(getLocaleNumberSymbol(locale, groupSymbol));
    if (decimals.length) {
      formattedText += getLocaleNumberSymbol(locale, decimalSymbol) + decimals.join("");
    }
    if (exponent) {
      formattedText += getLocaleNumberSymbol(locale, NumberSymbol.Exponential) + "+" + exponent;
    }
  }
  if (value < 0 && !isZero) {
    formattedText = pattern.negPre + formattedText + pattern.negSuf;
  } else {
    formattedText = pattern.posPre + formattedText + pattern.posSuf;
  }
  return formattedText;
}
function formatCurrency(value, locale, currency, currencyCode, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Currency);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  pattern.minFrac = getNumberOfCurrencyDigits(currencyCode);
  pattern.maxFrac = pattern.minFrac;
  const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.CurrencyGroup, NumberSymbol.CurrencyDecimal, digitsInfo);
  return res.replace(CURRENCY_CHAR, currency).replace(CURRENCY_CHAR, "").trim();
}
function formatPercent(value, locale, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Percent);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo, true);
  return res.replace(new RegExp(PERCENT_CHAR, "g"), getLocaleNumberSymbol(locale, NumberSymbol.PercentSign));
}
function formatNumber(value, locale, digitsInfo) {
  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Decimal);
  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
  return formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo);
}
function parseNumberFormat(format, minusSign = "-") {
  const p = {
    minInt: 1,
    minFrac: 0,
    maxFrac: 0,
    posPre: "",
    posSuf: "",
    negPre: "",
    negSuf: "",
    gSize: 0,
    lgSize: 0
  };
  const patternParts = format.split(PATTERN_SEP);
  const positive = patternParts[0];
  const negative = patternParts[1];
  const positiveParts = positive.indexOf(DECIMAL_SEP) !== -1 ? positive.split(DECIMAL_SEP) : [positive.substring(0, positive.lastIndexOf(ZERO_CHAR) + 1), positive.substring(positive.lastIndexOf(ZERO_CHAR) + 1)], integer = positiveParts[0], fraction = positiveParts[1] || "";
  p.posPre = integer.substring(0, integer.indexOf(DIGIT_CHAR));
  for (let i = 0; i < fraction.length; i++) {
    const ch = fraction.charAt(i);
    if (ch === ZERO_CHAR) {
      p.minFrac = p.maxFrac = i + 1;
    } else if (ch === DIGIT_CHAR) {
      p.maxFrac = i + 1;
    } else {
      p.posSuf += ch;
    }
  }
  const groups = integer.split(GROUP_SEP);
  p.gSize = groups[1] ? groups[1].length : 0;
  p.lgSize = groups[2] || groups[1] ? (groups[2] || groups[1]).length : 0;
  if (negative) {
    const trunkLen = positive.length - p.posPre.length - p.posSuf.length, pos = negative.indexOf(DIGIT_CHAR);
    p.negPre = negative.substring(0, pos).replace(/'/g, "");
    p.negSuf = negative.slice(pos + trunkLen).replace(/'/g, "");
  } else {
    p.negPre = minusSign + p.posPre;
    p.negSuf = p.posSuf;
  }
  return p;
}
function toPercent(parsedNumber) {
  if (parsedNumber.digits[0] === 0) {
    return parsedNumber;
  }
  const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;
  if (parsedNumber.exponent) {
    parsedNumber.exponent += 2;
  } else {
    if (fractionLen === 0) {
      parsedNumber.digits.push(0, 0);
    } else if (fractionLen === 1) {
      parsedNumber.digits.push(0);
    }
    parsedNumber.integerLen += 2;
  }
  return parsedNumber;
}
function parseNumber(num) {
  let numStr = Math.abs(num) + "";
  let exponent = 0, digits, integerLen;
  let i, j, zeros;
  if ((integerLen = numStr.indexOf(DECIMAL_SEP)) > -1) {
    numStr = numStr.replace(DECIMAL_SEP, "");
  }
  if ((i = numStr.search(/e/i)) > 0) {
    if (integerLen < 0)
      integerLen = i;
    integerLen += +numStr.slice(i + 1);
    numStr = numStr.substring(0, i);
  } else if (integerLen < 0) {
    integerLen = numStr.length;
  }
  for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {
  }
  if (i === (zeros = numStr.length)) {
    digits = [0];
    integerLen = 1;
  } else {
    zeros--;
    while (numStr.charAt(zeros) === ZERO_CHAR)
      zeros--;
    integerLen -= i;
    digits = [];
    for (j = 0; i <= zeros; i++, j++) {
      digits[j] = Number(numStr.charAt(i));
    }
  }
  if (integerLen > MAX_DIGITS) {
    digits = digits.splice(0, MAX_DIGITS - 1);
    exponent = integerLen - 1;
    integerLen = 1;
  }
  return {
    digits,
    exponent,
    integerLen
  };
}
function roundNumber(parsedNumber, minFrac, maxFrac) {
  if (minFrac > maxFrac) {
    throw new Error(`The minimum number of digits after fraction (${minFrac}) is higher than the maximum (${maxFrac}).`);
  }
  let digits = parsedNumber.digits;
  let fractionLen = digits.length - parsedNumber.integerLen;
  const fractionSize = Math.min(Math.max(minFrac, fractionLen), maxFrac);
  let roundAt = fractionSize + parsedNumber.integerLen;
  let digit = digits[roundAt];
  if (roundAt > 0) {
    digits.splice(Math.max(parsedNumber.integerLen, roundAt));
    for (let j = roundAt; j < digits.length; j++) {
      digits[j] = 0;
    }
  } else {
    fractionLen = Math.max(0, fractionLen);
    parsedNumber.integerLen = 1;
    digits.length = Math.max(1, roundAt = fractionSize + 1);
    digits[0] = 0;
    for (let i = 1; i < roundAt; i++)
      digits[i] = 0;
  }
  if (digit >= 5) {
    if (roundAt - 1 < 0) {
      for (let k = 0; k > roundAt; k--) {
        digits.unshift(0);
        parsedNumber.integerLen++;
      }
      digits.unshift(1);
      parsedNumber.integerLen++;
    } else {
      digits[roundAt - 1]++;
    }
  }
  for (; fractionLen < Math.max(0, fractionSize); fractionLen++)
    digits.push(0);
  let dropTrailingZeros = fractionSize !== 0;
  const minLen = minFrac + parsedNumber.integerLen;
  const carry = digits.reduceRight(function(carry2, d, i, digits2) {
    d = d + carry2;
    digits2[i] = d < 10 ? d : d - 10;
    if (dropTrailingZeros) {
      if (digits2[i] === 0 && i >= minLen) {
        digits2.pop();
      } else {
        dropTrailingZeros = false;
      }
    }
    return d >= 10 ? 1 : 0;
  }, 0);
  if (carry) {
    digits.unshift(carry);
    parsedNumber.integerLen++;
  }
}
function parseIntAutoRadix(text) {
  const result = parseInt(text);
  if (isNaN(result)) {
    throw new Error("Invalid integer literal when parsing " + text);
  }
  return result;
}
function getPluralCategory(value, cases, ngLocalization, locale) {
  let key = `=${value}`;
  if (cases.indexOf(key) > -1) {
    return key;
  }
  key = ngLocalization.getPluralCategory(value, locale);
  if (cases.indexOf(key) > -1) {
    return key;
  }
  if (cases.indexOf("other") > -1) {
    return "other";
  }
  throw new Error(`No plural message found for value "${value}"`);
}
function parseCookieValue(cookieStr, name) {
  name = encodeURIComponent(name);
  for (const cookie of cookieStr.split(";")) {
    const eqIndex = cookie.indexOf("=");
    const [cookieName, cookieValue] = eqIndex == -1 ? [cookie, ""] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)];
    if (cookieName.trim() === name) {
      return decodeURIComponent(cookieValue);
    }
  }
  return null;
}
function getParentInjector(injector) {
  const parentNgModule = injector.get(NgModuleRef$1);
  return parentNgModule.injector;
}
function applyViewChange(view, record) {
  view.context.$implicit = record.item;
}
function getTypeName2(type) {
  return type["name"] || typeof type;
}
function assertTemplate(property, templateRef) {
  const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);
  if (!isTemplateRefOrNull) {
    throw new Error(`${property} must be a TemplateRef, but received '${stringify(templateRef)}'.`);
  }
}
function throwNgSwitchProviderNotFoundError(attrName, directiveName) {
  throw new RuntimeError(
    2e3,
    `An element with the "${attrName}" attribute (matching the "${directiveName}" directive) must be located inside an element with the "ngSwitch" attribute (matching "NgSwitch" directive)`
  );
}
function invalidPipeArgumentError(type, value) {
  return new RuntimeError(
    2100,
    define_ngDevMode_default && `InvalidPipeArgument: '${value}' for pipe '${stringify(type)}'`
  );
}
function makeKeyValuePair(key, value) {
  return {
    key,
    value
  };
}
function defaultComparator(keyValueA, keyValueB) {
  const a = keyValueA.key;
  const b = keyValueB.key;
  if (a === b)
    return 0;
  if (a === void 0)
    return 1;
  if (b === void 0)
    return -1;
  if (a === null)
    return 1;
  if (b === null)
    return -1;
  if (typeof a == "string" && typeof b == "string") {
    return a < b ? -1 : 1;
  }
  if (typeof a == "number" && typeof b == "number") {
    return a - b;
  }
  if (typeof a == "boolean" && typeof b == "boolean") {
    return a < b ? -1 : 1;
  }
  const aString = String(a);
  const bString = String(b);
  return aString == bString ? 0 : aString < bString ? -1 : 1;
}
function isValue(value) {
  return !(value == null || value === "" || value !== value);
}
function strToNumber(value) {
  if (typeof value === "string" && !isNaN(Number(value) - parseFloat(value))) {
    return Number(value);
  }
  if (typeof value !== "number") {
    throw new Error(`${value} is not a number`);
  }
  return value;
}
function getScrollRestorationProperty(obj) {
  return Object.getOwnPropertyDescriptor(obj, "scrollRestoration");
}
function findAnchorFromDocument(document2, target) {
  const documentResult = document2.getElementById(target) || document2.getElementsByName(target)[0];
  if (documentResult) {
    return documentResult;
  }
  if (typeof document2.createTreeWalker === "function" && document2.body && (document2.body.createShadowRoot || document2.body.attachShadow)) {
    const treeWalker = document2.createTreeWalker(document2.body, NodeFilter.SHOW_ELEMENT);
    let currentNode = treeWalker.currentNode;
    while (currentNode) {
      const shadowRoot = currentNode.shadowRoot;
      if (shadowRoot) {
        const result = shadowRoot.getElementById(target) || shadowRoot.querySelector(`[name="${target}"]`);
        if (result) {
          return result;
        }
      }
      currentNode = treeWalker.nextNode();
    }
  }
  return null;
}
var _DOM, DomAdapter, DOCUMENT2, PlatformLocation, LOCATION_INITIALIZED, BrowserPlatformLocation, LocationStrategy, APP_BASE_HREF, PathLocationStrategy, HashLocationStrategy, Location, CURRENCIES_EN, NumberFormatStyle, Plural, FormStyle, TranslationWidth, FormatWidth, NumberSymbol, WeekDay, getLocalePluralCase2, DEFAULT_NB_OF_CURRENCY_DIGITS, ISO8601_DATE_REGEX, NAMED_FORMATS, DATE_FORMATS_SPLIT, ZoneWidth, DateType, TranslationType, JANUARY, THURSDAY, DATE_FORMATS, NUMBER_FORMAT_REGEXP, MAX_DIGITS, DECIMAL_SEP, ZERO_CHAR, PATTERN_SEP, GROUP_SEP, DIGIT_CHAR, CURRENCY_CHAR, PERCENT_CHAR, NgLocalization, NgLocaleLocalization, NgClass, NgComponentOutlet, NG_DEV_MODE2, NgForOfContext, NgForOf, NgIf, NgIfContext, SwitchView, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase, NgStyle, NgTemplateOutlet, COMMON_DIRECTIVES, SubscribableStrategy, PromiseStrategy, _promiseStrategy, _subscribableStrategy, AsyncPipe, LowerCasePipe, unicodeWordMatch, TitleCasePipe, UpperCasePipe, DATE_PIPE_DEFAULT_TIMEZONE, DatePipe, _INTERPOLATION_REGEXP, I18nPluralPipe, I18nSelectPipe, JsonPipe, KeyValuePipe, DecimalPipe, PercentPipe, CurrencyPipe, SlicePipe, COMMON_PIPES, CommonModule, PLATFORM_BROWSER_ID, VERSION2, ViewportScroller, BrowserViewportScroller, XhrFactory;
var init_common = __esm({
  "node_modules/@angular/common/fesm2015/common.mjs"() {
    init_define_ngDevMode();
    init_core();
    init_core();
    _DOM = null;
    DomAdapter = class {
    };
    DOCUMENT2 = new InjectionToken("DocumentToken");
    PlatformLocation = class {
      historyGo(relativePosition) {
        throw new Error("Not implemented");
      }
    };
    PlatformLocation.\u0275fac = function PlatformLocation_Factory(t) {
      return new (t || PlatformLocation)();
    };
    PlatformLocation.\u0275prov = \u0275\u0275defineInjectable({
      token: PlatformLocation,
      factory: function() {
        return useBrowserPlatformLocation();
      },
      providedIn: "platform"
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(PlatformLocation, [{
        type: Injectable,
        args: [{
          providedIn: "platform",
          useFactory: useBrowserPlatformLocation
        }]
      }], null, null);
    })();
    LOCATION_INITIALIZED = new InjectionToken("Location Initialized");
    BrowserPlatformLocation = class extends PlatformLocation {
      constructor(_doc) {
        super();
        this._doc = _doc;
        this._init();
      }
      _init() {
        this.location = window.location;
        this._history = window.history;
      }
      getBaseHrefFromDOM() {
        return getDOM().getBaseHref(this._doc);
      }
      onPopState(fn2) {
        const window3 = getDOM().getGlobalEventTarget(this._doc, "window");
        window3.addEventListener("popstate", fn2, false);
        return () => window3.removeEventListener("popstate", fn2);
      }
      onHashChange(fn2) {
        const window3 = getDOM().getGlobalEventTarget(this._doc, "window");
        window3.addEventListener("hashchange", fn2, false);
        return () => window3.removeEventListener("hashchange", fn2);
      }
      get href() {
        return this.location.href;
      }
      get protocol() {
        return this.location.protocol;
      }
      get hostname() {
        return this.location.hostname;
      }
      get port() {
        return this.location.port;
      }
      get pathname() {
        return this.location.pathname;
      }
      get search() {
        return this.location.search;
      }
      get hash() {
        return this.location.hash;
      }
      set pathname(newPath) {
        this.location.pathname = newPath;
      }
      pushState(state, title, url) {
        if (supportsState()) {
          this._history.pushState(state, title, url);
        } else {
          this.location.hash = url;
        }
      }
      replaceState(state, title, url) {
        if (supportsState()) {
          this._history.replaceState(state, title, url);
        } else {
          this.location.hash = url;
        }
      }
      forward() {
        this._history.forward();
      }
      back() {
        this._history.back();
      }
      historyGo(relativePosition = 0) {
        this._history.go(relativePosition);
      }
      getState() {
        return this._history.state;
      }
    };
    BrowserPlatformLocation.\u0275fac = function BrowserPlatformLocation_Factory(t) {
      return new (t || BrowserPlatformLocation)(\u0275\u0275inject(DOCUMENT2));
    };
    BrowserPlatformLocation.\u0275prov = \u0275\u0275defineInjectable({
      token: BrowserPlatformLocation,
      factory: function() {
        return createBrowserPlatformLocation();
      },
      providedIn: "platform"
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(BrowserPlatformLocation, [{
        type: Injectable,
        args: [{
          providedIn: "platform",
          useFactory: createBrowserPlatformLocation
        }]
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Inject,
            args: [DOCUMENT2]
          }]
        }];
      }, null);
    })();
    LocationStrategy = class {
      historyGo(relativePosition) {
        throw new Error("Not implemented");
      }
    };
    LocationStrategy.\u0275fac = function LocationStrategy_Factory(t) {
      return new (t || LocationStrategy)();
    };
    LocationStrategy.\u0275prov = \u0275\u0275defineInjectable({
      token: LocationStrategy,
      factory: function() {
        return (() => inject(PathLocationStrategy))();
      },
      providedIn: "root"
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(LocationStrategy, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: () => inject(PathLocationStrategy)
        }]
      }], null, null);
    })();
    APP_BASE_HREF = new InjectionToken("appBaseHref");
    PathLocationStrategy = class extends LocationStrategy {
      constructor(_platformLocation, href) {
        var _a, _b, _c;
        super();
        this._platformLocation = _platformLocation;
        this._removeListenerFns = [];
        this._baseHref = (_c = (_a = href !== null && href !== void 0 ? href : this._platformLocation.getBaseHrefFromDOM()) !== null && _a !== void 0 ? _a : (_b = inject(DOCUMENT2).location) === null || _b === void 0 ? void 0 : _b.origin) !== null && _c !== void 0 ? _c : "";
      }
      ngOnDestroy() {
        while (this._removeListenerFns.length) {
          this._removeListenerFns.pop()();
        }
      }
      onPopState(fn2) {
        this._removeListenerFns.push(this._platformLocation.onPopState(fn2), this._platformLocation.onHashChange(fn2));
      }
      getBaseHref() {
        return this._baseHref;
      }
      prepareExternalUrl(internal) {
        return joinWithSlash(this._baseHref, internal);
      }
      path(includeHash = false) {
        const pathname = this._platformLocation.pathname + normalizeQueryParams(this._platformLocation.search);
        const hash = this._platformLocation.hash;
        return hash && includeHash ? `${pathname}${hash}` : pathname;
      }
      pushState(state, title, url, queryParams) {
        const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
        this._platformLocation.pushState(state, title, externalUrl);
      }
      replaceState(state, title, url, queryParams) {
        const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
        this._platformLocation.replaceState(state, title, externalUrl);
      }
      forward() {
        this._platformLocation.forward();
      }
      back() {
        this._platformLocation.back();
      }
      getState() {
        return this._platformLocation.getState();
      }
      historyGo(relativePosition = 0) {
        var _a, _b;
        (_b = (_a = this._platformLocation).historyGo) === null || _b === void 0 ? void 0 : _b.call(_a, relativePosition);
      }
    };
    PathLocationStrategy.\u0275fac = function PathLocationStrategy_Factory(t) {
      return new (t || PathLocationStrategy)(\u0275\u0275inject(PlatformLocation), \u0275\u0275inject(APP_BASE_HREF, 8));
    };
    PathLocationStrategy.\u0275prov = \u0275\u0275defineInjectable({
      token: PathLocationStrategy,
      factory: PathLocationStrategy.\u0275fac,
      providedIn: "root"
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(PathLocationStrategy, [{
        type: Injectable,
        args: [{
          providedIn: "root"
        }]
      }], function() {
        return [{
          type: PlatformLocation
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Inject,
            args: [APP_BASE_HREF]
          }]
        }];
      }, null);
    })();
    HashLocationStrategy = class extends LocationStrategy {
      constructor(_platformLocation, _baseHref) {
        super();
        this._platformLocation = _platformLocation;
        this._baseHref = "";
        this._removeListenerFns = [];
        if (_baseHref != null) {
          this._baseHref = _baseHref;
        }
      }
      ngOnDestroy() {
        while (this._removeListenerFns.length) {
          this._removeListenerFns.pop()();
        }
      }
      onPopState(fn2) {
        this._removeListenerFns.push(this._platformLocation.onPopState(fn2), this._platformLocation.onHashChange(fn2));
      }
      getBaseHref() {
        return this._baseHref;
      }
      path(includeHash = false) {
        let path = this._platformLocation.hash;
        if (path == null)
          path = "#";
        return path.length > 0 ? path.substring(1) : path;
      }
      prepareExternalUrl(internal) {
        const url = joinWithSlash(this._baseHref, internal);
        return url.length > 0 ? "#" + url : url;
      }
      pushState(state, title, path, queryParams) {
        let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
        if (url.length == 0) {
          url = this._platformLocation.pathname;
        }
        this._platformLocation.pushState(state, title, url);
      }
      replaceState(state, title, path, queryParams) {
        let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
        if (url.length == 0) {
          url = this._platformLocation.pathname;
        }
        this._platformLocation.replaceState(state, title, url);
      }
      forward() {
        this._platformLocation.forward();
      }
      back() {
        this._platformLocation.back();
      }
      getState() {
        return this._platformLocation.getState();
      }
      historyGo(relativePosition = 0) {
        var _a, _b;
        (_b = (_a = this._platformLocation).historyGo) === null || _b === void 0 ? void 0 : _b.call(_a, relativePosition);
      }
    };
    HashLocationStrategy.\u0275fac = function HashLocationStrategy_Factory(t) {
      return new (t || HashLocationStrategy)(\u0275\u0275inject(PlatformLocation), \u0275\u0275inject(APP_BASE_HREF, 8));
    };
    HashLocationStrategy.\u0275prov = \u0275\u0275defineInjectable({
      token: HashLocationStrategy,
      factory: HashLocationStrategy.\u0275fac
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(HashLocationStrategy, [{
        type: Injectable
      }], function() {
        return [{
          type: PlatformLocation
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Inject,
            args: [APP_BASE_HREF]
          }]
        }];
      }, null);
    })();
    Location = class {
      constructor(locationStrategy) {
        this._subject = new EventEmitter();
        this._urlChangeListeners = [];
        this._urlChangeSubscription = null;
        this._locationStrategy = locationStrategy;
        const browserBaseHref = this._locationStrategy.getBaseHref();
        this._baseHref = stripTrailingSlash(_stripIndexHtml(browserBaseHref));
        this._locationStrategy.onPopState((ev) => {
          this._subject.emit({
            "url": this.path(true),
            "pop": true,
            "state": ev.state,
            "type": ev.type
          });
        });
      }
      ngOnDestroy() {
        var _a;
        (_a = this._urlChangeSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        this._urlChangeListeners = [];
      }
      path(includeHash = false) {
        return this.normalize(this._locationStrategy.path(includeHash));
      }
      getState() {
        return this._locationStrategy.getState();
      }
      isCurrentPathEqualTo(path, query = "") {
        return this.path() == this.normalize(path + normalizeQueryParams(query));
      }
      normalize(url) {
        return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));
      }
      prepareExternalUrl(url) {
        if (url && url[0] !== "/") {
          url = "/" + url;
        }
        return this._locationStrategy.prepareExternalUrl(url);
      }
      go(path, query = "", state = null) {
        this._locationStrategy.pushState(state, "", path, query);
        this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
      }
      replaceState(path, query = "", state = null) {
        this._locationStrategy.replaceState(state, "", path, query);
        this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
      }
      forward() {
        this._locationStrategy.forward();
      }
      back() {
        this._locationStrategy.back();
      }
      historyGo(relativePosition = 0) {
        var _a, _b;
        (_b = (_a = this._locationStrategy).historyGo) === null || _b === void 0 ? void 0 : _b.call(_a, relativePosition);
      }
      onUrlChange(fn2) {
        this._urlChangeListeners.push(fn2);
        if (!this._urlChangeSubscription) {
          this._urlChangeSubscription = this.subscribe((v) => {
            this._notifyUrlChangeListeners(v.url, v.state);
          });
        }
        return () => {
          var _a;
          const fnIndex = this._urlChangeListeners.indexOf(fn2);
          this._urlChangeListeners.splice(fnIndex, 1);
          if (this._urlChangeListeners.length === 0) {
            (_a = this._urlChangeSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
            this._urlChangeSubscription = null;
          }
        };
      }
      _notifyUrlChangeListeners(url = "", state) {
        this._urlChangeListeners.forEach((fn2) => fn2(url, state));
      }
      subscribe(onNext, onThrow, onReturn) {
        return this._subject.subscribe({
          next: onNext,
          error: onThrow,
          complete: onReturn
        });
      }
    };
    Location.normalizeQueryParams = normalizeQueryParams;
    Location.joinWithSlash = joinWithSlash;
    Location.stripTrailingSlash = stripTrailingSlash;
    Location.\u0275fac = function Location_Factory(t) {
      return new (t || Location)(\u0275\u0275inject(LocationStrategy));
    };
    Location.\u0275prov = \u0275\u0275defineInjectable({
      token: Location,
      factory: function() {
        return createLocation();
      },
      providedIn: "root"
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(Location, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: createLocation
        }]
      }], function() {
        return [{
          type: LocationStrategy
        }];
      }, null);
    })();
    CURRENCIES_EN = {
      "ADP": [void 0, void 0, 0],
      "AFN": [void 0, "\u060B", 0],
      "ALL": [void 0, void 0, 0],
      "AMD": [void 0, "\u058F", 2],
      "AOA": [void 0, "Kz"],
      "ARS": [void 0, "$"],
      "AUD": ["A$", "$"],
      "AZN": [void 0, "\u20BC"],
      "BAM": [void 0, "KM"],
      "BBD": [void 0, "$"],
      "BDT": [void 0, "\u09F3"],
      "BHD": [void 0, void 0, 3],
      "BIF": [void 0, void 0, 0],
      "BMD": [void 0, "$"],
      "BND": [void 0, "$"],
      "BOB": [void 0, "Bs"],
      "BRL": ["R$"],
      "BSD": [void 0, "$"],
      "BWP": [void 0, "P"],
      "BYN": [void 0, void 0, 2],
      "BYR": [void 0, void 0, 0],
      "BZD": [void 0, "$"],
      "CAD": ["CA$", "$", 2],
      "CHF": [void 0, void 0, 2],
      "CLF": [void 0, void 0, 4],
      "CLP": [void 0, "$", 0],
      "CNY": ["CN\xA5", "\xA5"],
      "COP": [void 0, "$", 2],
      "CRC": [void 0, "\u20A1", 2],
      "CUC": [void 0, "$"],
      "CUP": [void 0, "$"],
      "CZK": [void 0, "K\u010D", 2],
      "DJF": [void 0, void 0, 0],
      "DKK": [void 0, "kr", 2],
      "DOP": [void 0, "$"],
      "EGP": [void 0, "E\xA3"],
      "ESP": [void 0, "\u20A7", 0],
      "EUR": ["\u20AC"],
      "FJD": [void 0, "$"],
      "FKP": [void 0, "\xA3"],
      "GBP": ["\xA3"],
      "GEL": [void 0, "\u20BE"],
      "GHS": [void 0, "GH\u20B5"],
      "GIP": [void 0, "\xA3"],
      "GNF": [void 0, "FG", 0],
      "GTQ": [void 0, "Q"],
      "GYD": [void 0, "$", 2],
      "HKD": ["HK$", "$"],
      "HNL": [void 0, "L"],
      "HRK": [void 0, "kn"],
      "HUF": [void 0, "Ft", 2],
      "IDR": [void 0, "Rp", 2],
      "ILS": ["\u20AA"],
      "INR": ["\u20B9"],
      "IQD": [void 0, void 0, 0],
      "IRR": [void 0, void 0, 0],
      "ISK": [void 0, "kr", 0],
      "ITL": [void 0, void 0, 0],
      "JMD": [void 0, "$"],
      "JOD": [void 0, void 0, 3],
      "JPY": ["\xA5", void 0, 0],
      "KHR": [void 0, "\u17DB"],
      "KMF": [void 0, "CF", 0],
      "KPW": [void 0, "\u20A9", 0],
      "KRW": ["\u20A9", void 0, 0],
      "KWD": [void 0, void 0, 3],
      "KYD": [void 0, "$"],
      "KZT": [void 0, "\u20B8"],
      "LAK": [void 0, "\u20AD", 0],
      "LBP": [void 0, "L\xA3", 0],
      "LKR": [void 0, "Rs"],
      "LRD": [void 0, "$"],
      "LTL": [void 0, "Lt"],
      "LUF": [void 0, void 0, 0],
      "LVL": [void 0, "Ls"],
      "LYD": [void 0, void 0, 3],
      "MGA": [void 0, "Ar", 0],
      "MGF": [void 0, void 0, 0],
      "MMK": [void 0, "K", 0],
      "MNT": [void 0, "\u20AE", 2],
      "MRO": [void 0, void 0, 0],
      "MUR": [void 0, "Rs", 2],
      "MXN": ["MX$", "$"],
      "MYR": [void 0, "RM"],
      "NAD": [void 0, "$"],
      "NGN": [void 0, "\u20A6"],
      "NIO": [void 0, "C$"],
      "NOK": [void 0, "kr", 2],
      "NPR": [void 0, "Rs"],
      "NZD": ["NZ$", "$"],
      "OMR": [void 0, void 0, 3],
      "PHP": ["\u20B1"],
      "PKR": [void 0, "Rs", 2],
      "PLN": [void 0, "z\u0142"],
      "PYG": [void 0, "\u20B2", 0],
      "RON": [void 0, "lei"],
      "RSD": [void 0, void 0, 0],
      "RUB": [void 0, "\u20BD"],
      "RWF": [void 0, "RF", 0],
      "SBD": [void 0, "$"],
      "SEK": [void 0, "kr", 2],
      "SGD": [void 0, "$"],
      "SHP": [void 0, "\xA3"],
      "SLE": [void 0, void 0, 2],
      "SLL": [void 0, void 0, 0],
      "SOS": [void 0, void 0, 0],
      "SRD": [void 0, "$"],
      "SSP": [void 0, "\xA3"],
      "STD": [void 0, void 0, 0],
      "STN": [void 0, "Db"],
      "SYP": [void 0, "\xA3", 0],
      "THB": [void 0, "\u0E3F"],
      "TMM": [void 0, void 0, 0],
      "TND": [void 0, void 0, 3],
      "TOP": [void 0, "T$"],
      "TRL": [void 0, void 0, 0],
      "TRY": [void 0, "\u20BA"],
      "TTD": [void 0, "$"],
      "TWD": ["NT$", "$", 2],
      "TZS": [void 0, void 0, 2],
      "UAH": [void 0, "\u20B4"],
      "UGX": [void 0, void 0, 0],
      "USD": ["$"],
      "UYI": [void 0, void 0, 0],
      "UYU": [void 0, "$"],
      "UYW": [void 0, void 0, 4],
      "UZS": [void 0, void 0, 2],
      "VEF": [void 0, "Bs", 2],
      "VND": ["\u20AB", void 0, 0],
      "VUV": [void 0, void 0, 0],
      "XAF": ["FCFA", void 0, 0],
      "XCD": ["EC$", "$"],
      "XOF": ["F\u202FCFA", void 0, 0],
      "XPF": ["CFPF", void 0, 0],
      "XXX": ["\xA4"],
      "YER": [void 0, void 0, 0],
      "ZAR": [void 0, "R"],
      "ZMK": [void 0, void 0, 0],
      "ZMW": [void 0, "ZK"],
      "ZWD": [void 0, void 0, 0]
    };
    (function(NumberFormatStyle2) {
      NumberFormatStyle2[NumberFormatStyle2["Decimal"] = 0] = "Decimal";
      NumberFormatStyle2[NumberFormatStyle2["Percent"] = 1] = "Percent";
      NumberFormatStyle2[NumberFormatStyle2["Currency"] = 2] = "Currency";
      NumberFormatStyle2[NumberFormatStyle2["Scientific"] = 3] = "Scientific";
    })(NumberFormatStyle || (NumberFormatStyle = {}));
    (function(Plural2) {
      Plural2[Plural2["Zero"] = 0] = "Zero";
      Plural2[Plural2["One"] = 1] = "One";
      Plural2[Plural2["Two"] = 2] = "Two";
      Plural2[Plural2["Few"] = 3] = "Few";
      Plural2[Plural2["Many"] = 4] = "Many";
      Plural2[Plural2["Other"] = 5] = "Other";
    })(Plural || (Plural = {}));
    (function(FormStyle2) {
      FormStyle2[FormStyle2["Format"] = 0] = "Format";
      FormStyle2[FormStyle2["Standalone"] = 1] = "Standalone";
    })(FormStyle || (FormStyle = {}));
    (function(TranslationWidth2) {
      TranslationWidth2[TranslationWidth2["Narrow"] = 0] = "Narrow";
      TranslationWidth2[TranslationWidth2["Abbreviated"] = 1] = "Abbreviated";
      TranslationWidth2[TranslationWidth2["Wide"] = 2] = "Wide";
      TranslationWidth2[TranslationWidth2["Short"] = 3] = "Short";
    })(TranslationWidth || (TranslationWidth = {}));
    (function(FormatWidth2) {
      FormatWidth2[FormatWidth2["Short"] = 0] = "Short";
      FormatWidth2[FormatWidth2["Medium"] = 1] = "Medium";
      FormatWidth2[FormatWidth2["Long"] = 2] = "Long";
      FormatWidth2[FormatWidth2["Full"] = 3] = "Full";
    })(FormatWidth || (FormatWidth = {}));
    (function(NumberSymbol2) {
      NumberSymbol2[NumberSymbol2["Decimal"] = 0] = "Decimal";
      NumberSymbol2[NumberSymbol2["Group"] = 1] = "Group";
      NumberSymbol2[NumberSymbol2["List"] = 2] = "List";
      NumberSymbol2[NumberSymbol2["PercentSign"] = 3] = "PercentSign";
      NumberSymbol2[NumberSymbol2["PlusSign"] = 4] = "PlusSign";
      NumberSymbol2[NumberSymbol2["MinusSign"] = 5] = "MinusSign";
      NumberSymbol2[NumberSymbol2["Exponential"] = 6] = "Exponential";
      NumberSymbol2[NumberSymbol2["SuperscriptingExponent"] = 7] = "SuperscriptingExponent";
      NumberSymbol2[NumberSymbol2["PerMille"] = 8] = "PerMille";
      NumberSymbol2[NumberSymbol2["Infinity"] = 9] = "Infinity";
      NumberSymbol2[NumberSymbol2["NaN"] = 10] = "NaN";
      NumberSymbol2[NumberSymbol2["TimeSeparator"] = 11] = "TimeSeparator";
      NumberSymbol2[NumberSymbol2["CurrencyDecimal"] = 12] = "CurrencyDecimal";
      NumberSymbol2[NumberSymbol2["CurrencyGroup"] = 13] = "CurrencyGroup";
    })(NumberSymbol || (NumberSymbol = {}));
    (function(WeekDay2) {
      WeekDay2[WeekDay2["Sunday"] = 0] = "Sunday";
      WeekDay2[WeekDay2["Monday"] = 1] = "Monday";
      WeekDay2[WeekDay2["Tuesday"] = 2] = "Tuesday";
      WeekDay2[WeekDay2["Wednesday"] = 3] = "Wednesday";
      WeekDay2[WeekDay2["Thursday"] = 4] = "Thursday";
      WeekDay2[WeekDay2["Friday"] = 5] = "Friday";
      WeekDay2[WeekDay2["Saturday"] = 6] = "Saturday";
    })(WeekDay || (WeekDay = {}));
    getLocalePluralCase2 = getLocalePluralCase;
    DEFAULT_NB_OF_CURRENCY_DIGITS = 2;
    ISO8601_DATE_REGEX = /^(\d{4,})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
    NAMED_FORMATS = {};
    DATE_FORMATS_SPLIT = /((?:[^BEGHLMOSWYZabcdhmswyz']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|c{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/;
    (function(ZoneWidth2) {
      ZoneWidth2[ZoneWidth2["Short"] = 0] = "Short";
      ZoneWidth2[ZoneWidth2["ShortGMT"] = 1] = "ShortGMT";
      ZoneWidth2[ZoneWidth2["Long"] = 2] = "Long";
      ZoneWidth2[ZoneWidth2["Extended"] = 3] = "Extended";
    })(ZoneWidth || (ZoneWidth = {}));
    (function(DateType2) {
      DateType2[DateType2["FullYear"] = 0] = "FullYear";
      DateType2[DateType2["Month"] = 1] = "Month";
      DateType2[DateType2["Date"] = 2] = "Date";
      DateType2[DateType2["Hours"] = 3] = "Hours";
      DateType2[DateType2["Minutes"] = 4] = "Minutes";
      DateType2[DateType2["Seconds"] = 5] = "Seconds";
      DateType2[DateType2["FractionalSeconds"] = 6] = "FractionalSeconds";
      DateType2[DateType2["Day"] = 7] = "Day";
    })(DateType || (DateType = {}));
    (function(TranslationType2) {
      TranslationType2[TranslationType2["DayPeriods"] = 0] = "DayPeriods";
      TranslationType2[TranslationType2["Days"] = 1] = "Days";
      TranslationType2[TranslationType2["Months"] = 2] = "Months";
      TranslationType2[TranslationType2["Eras"] = 3] = "Eras";
    })(TranslationType || (TranslationType = {}));
    JANUARY = 0;
    THURSDAY = 4;
    DATE_FORMATS = {};
    NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
    MAX_DIGITS = 22;
    DECIMAL_SEP = ".";
    ZERO_CHAR = "0";
    PATTERN_SEP = ";";
    GROUP_SEP = ",";
    DIGIT_CHAR = "#";
    CURRENCY_CHAR = "\xA4";
    PERCENT_CHAR = "%";
    NgLocalization = class {
    };
    NgLocalization.\u0275fac = function NgLocalization_Factory(t) {
      return new (t || NgLocalization)();
    };
    NgLocalization.\u0275prov = \u0275\u0275defineInjectable({
      token: NgLocalization,
      factory: function NgLocalization_Factory2(t) {
        let r = null;
        if (t) {
          r = new t();
        } else {
          r = ((locale) => new NgLocaleLocalization(locale))(\u0275\u0275inject(LOCALE_ID));
        }
        return r;
      },
      providedIn: "root"
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgLocalization, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: (locale) => new NgLocaleLocalization(locale),
          deps: [LOCALE_ID]
        }]
      }], null, null);
    })();
    NgLocaleLocalization = class extends NgLocalization {
      constructor(locale) {
        super();
        this.locale = locale;
      }
      getPluralCategory(value, locale) {
        const plural2 = getLocalePluralCase2(locale || this.locale)(value);
        switch (plural2) {
          case Plural.Zero:
            return "zero";
          case Plural.One:
            return "one";
          case Plural.Two:
            return "two";
          case Plural.Few:
            return "few";
          case Plural.Many:
            return "many";
          default:
            return "other";
        }
      }
    };
    NgLocaleLocalization.\u0275fac = function NgLocaleLocalization_Factory(t) {
      return new (t || NgLocaleLocalization)(\u0275\u0275inject(LOCALE_ID));
    };
    NgLocaleLocalization.\u0275prov = \u0275\u0275defineInjectable({
      token: NgLocaleLocalization,
      factory: NgLocaleLocalization.\u0275fac
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgLocaleLocalization, [{
        type: Injectable
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Inject,
            args: [LOCALE_ID]
          }]
        }];
      }, null);
    })();
    NgClass = class {
      constructor(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
        this._iterableDiffers = _iterableDiffers;
        this._keyValueDiffers = _keyValueDiffers;
        this._ngEl = _ngEl;
        this._renderer = _renderer;
        this._iterableDiffer = null;
        this._keyValueDiffer = null;
        this._initialClasses = [];
        this._rawClass = null;
      }
      set klass(value) {
        this._removeClasses(this._initialClasses);
        this._initialClasses = typeof value === "string" ? value.split(/\s+/) : [];
        this._applyClasses(this._initialClasses);
        this._applyClasses(this._rawClass);
      }
      set ngClass(value) {
        this._removeClasses(this._rawClass);
        this._applyClasses(this._initialClasses);
        this._iterableDiffer = null;
        this._keyValueDiffer = null;
        this._rawClass = typeof value === "string" ? value.split(/\s+/) : value;
        if (this._rawClass) {
          if (isListLikeIterable(this._rawClass)) {
            this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create();
          } else {
            this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create();
          }
        }
      }
      ngDoCheck() {
        if (this._iterableDiffer) {
          const iterableChanges = this._iterableDiffer.diff(this._rawClass);
          if (iterableChanges) {
            this._applyIterableChanges(iterableChanges);
          }
        } else if (this._keyValueDiffer) {
          const keyValueChanges = this._keyValueDiffer.diff(this._rawClass);
          if (keyValueChanges) {
            this._applyKeyValueChanges(keyValueChanges);
          }
        }
      }
      _applyKeyValueChanges(changes) {
        changes.forEachAddedItem((record) => this._toggleClass(record.key, record.currentValue));
        changes.forEachChangedItem((record) => this._toggleClass(record.key, record.currentValue));
        changes.forEachRemovedItem((record) => {
          if (record.previousValue) {
            this._toggleClass(record.key, false);
          }
        });
      }
      _applyIterableChanges(changes) {
        changes.forEachAddedItem((record) => {
          if (typeof record.item === "string") {
            this._toggleClass(record.item, true);
          } else {
            throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${stringify(record.item)}`);
          }
        });
        changes.forEachRemovedItem((record) => this._toggleClass(record.item, false));
      }
      _applyClasses(rawClassVal) {
        if (rawClassVal) {
          if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
            rawClassVal.forEach((klass) => this._toggleClass(klass, true));
          } else {
            Object.keys(rawClassVal).forEach((klass) => this._toggleClass(klass, !!rawClassVal[klass]));
          }
        }
      }
      _removeClasses(rawClassVal) {
        if (rawClassVal) {
          if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
            rawClassVal.forEach((klass) => this._toggleClass(klass, false));
          } else {
            Object.keys(rawClassVal).forEach((klass) => this._toggleClass(klass, false));
          }
        }
      }
      _toggleClass(klass, enabled) {
        klass = klass.trim();
        if (klass) {
          klass.split(/\s+/g).forEach((klass2) => {
            if (enabled) {
              this._renderer.addClass(this._ngEl.nativeElement, klass2);
            } else {
              this._renderer.removeClass(this._ngEl.nativeElement, klass2);
            }
          });
        }
      }
    };
    NgClass.\u0275fac = function NgClass_Factory(t) {
      return new (t || NgClass)(\u0275\u0275directiveInject(IterableDiffers), \u0275\u0275directiveInject(KeyValueDiffers), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2));
    };
    NgClass.\u0275dir = \u0275\u0275defineDirective({
      type: NgClass,
      selectors: [["", "ngClass", ""]],
      inputs: {
        klass: ["class", "klass"],
        ngClass: "ngClass"
      },
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgClass, [{
        type: Directive,
        args: [{
          selector: "[ngClass]",
          standalone: true
        }]
      }], function() {
        return [{
          type: IterableDiffers
        }, {
          type: KeyValueDiffers
        }, {
          type: ElementRef
        }, {
          type: Renderer2
        }];
      }, {
        klass: [{
          type: Input,
          args: ["class"]
        }],
        ngClass: [{
          type: Input,
          args: ["ngClass"]
        }]
      });
    })();
    NgComponentOutlet = class {
      constructor(_viewContainerRef) {
        this._viewContainerRef = _viewContainerRef;
        this.ngComponentOutlet = null;
      }
      ngOnChanges(changes) {
        const {
          _viewContainerRef: viewContainerRef,
          ngComponentOutletNgModule: ngModule,
          ngComponentOutletNgModuleFactory: ngModuleFactory
        } = this;
        viewContainerRef.clear();
        this._componentRef = void 0;
        if (this.ngComponentOutlet) {
          const injector = this.ngComponentOutletInjector || viewContainerRef.parentInjector;
          if (changes["ngComponentOutletNgModule"] || changes["ngComponentOutletNgModuleFactory"]) {
            if (this._moduleRef)
              this._moduleRef.destroy();
            if (ngModule) {
              this._moduleRef = createNgModule(ngModule, getParentInjector(injector));
            } else if (ngModuleFactory) {
              this._moduleRef = ngModuleFactory.create(getParentInjector(injector));
            } else {
              this._moduleRef = void 0;
            }
          }
          this._componentRef = viewContainerRef.createComponent(this.ngComponentOutlet, {
            index: viewContainerRef.length,
            injector,
            ngModuleRef: this._moduleRef,
            projectableNodes: this.ngComponentOutletContent
          });
        }
      }
      ngOnDestroy() {
        if (this._moduleRef)
          this._moduleRef.destroy();
      }
    };
    NgComponentOutlet.\u0275fac = function NgComponentOutlet_Factory(t) {
      return new (t || NgComponentOutlet)(\u0275\u0275directiveInject(ViewContainerRef));
    };
    NgComponentOutlet.\u0275dir = \u0275\u0275defineDirective({
      type: NgComponentOutlet,
      selectors: [["", "ngComponentOutlet", ""]],
      inputs: {
        ngComponentOutlet: "ngComponentOutlet",
        ngComponentOutletInjector: "ngComponentOutletInjector",
        ngComponentOutletContent: "ngComponentOutletContent",
        ngComponentOutletNgModule: "ngComponentOutletNgModule",
        ngComponentOutletNgModuleFactory: "ngComponentOutletNgModuleFactory"
      },
      standalone: true,
      features: [\u0275\u0275NgOnChangesFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgComponentOutlet, [{
        type: Directive,
        args: [{
          selector: "[ngComponentOutlet]",
          standalone: true
        }]
      }], function() {
        return [{
          type: ViewContainerRef
        }];
      }, {
        ngComponentOutlet: [{
          type: Input
        }],
        ngComponentOutletInjector: [{
          type: Input
        }],
        ngComponentOutletContent: [{
          type: Input
        }],
        ngComponentOutletNgModule: [{
          type: Input
        }],
        ngComponentOutletNgModuleFactory: [{
          type: Input
        }]
      });
    })();
    NG_DEV_MODE2 = typeof define_ngDevMode_default === "undefined" || !!define_ngDevMode_default;
    NgForOfContext = class {
      constructor($implicit, ngForOf, index, count2) {
        this.$implicit = $implicit;
        this.ngForOf = ngForOf;
        this.index = index;
        this.count = count2;
      }
      get first() {
        return this.index === 0;
      }
      get last() {
        return this.index === this.count - 1;
      }
      get even() {
        return this.index % 2 === 0;
      }
      get odd() {
        return !this.even;
      }
    };
    NgForOf = class {
      constructor(_viewContainer, _template, _differs) {
        this._viewContainer = _viewContainer;
        this._template = _template;
        this._differs = _differs;
        this._ngForOf = null;
        this._ngForOfDirty = true;
        this._differ = null;
      }
      set ngForOf(ngForOf) {
        this._ngForOf = ngForOf;
        this._ngForOfDirty = true;
      }
      set ngForTrackBy(fn2) {
        if (NG_DEV_MODE2 && fn2 != null && typeof fn2 !== "function") {
          if (console && console.warn) {
            console.warn(`trackBy must be a function, but received ${JSON.stringify(fn2)}. See https://angular.io/api/common/NgForOf#change-propagation for more information.`);
          }
        }
        this._trackByFn = fn2;
      }
      get ngForTrackBy() {
        return this._trackByFn;
      }
      set ngForTemplate(value) {
        if (value) {
          this._template = value;
        }
      }
      ngDoCheck() {
        if (this._ngForOfDirty) {
          this._ngForOfDirty = false;
          const value = this._ngForOf;
          if (!this._differ && value) {
            if (NG_DEV_MODE2) {
              try {
                this._differ = this._differs.find(value).create(this.ngForTrackBy);
              } catch (_a) {
                let errorMessage = `Cannot find a differ supporting object '${value}' of type '${getTypeName2(value)}'. NgFor only supports binding to Iterables, such as Arrays.`;
                if (typeof value === "object") {
                  errorMessage += " Did you mean to use the keyvalue pipe?";
                }
                throw new RuntimeError(
                  -2200,
                  errorMessage
                );
              }
            } else {
              this._differ = this._differs.find(value).create(this.ngForTrackBy);
            }
          }
        }
        if (this._differ) {
          const changes = this._differ.diff(this._ngForOf);
          if (changes)
            this._applyChanges(changes);
        }
      }
      _applyChanges(changes) {
        const viewContainer = this._viewContainer;
        changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
          if (item.previousIndex == null) {
            viewContainer.createEmbeddedView(this._template, new NgForOfContext(item.item, this._ngForOf, -1, -1), currentIndex === null ? void 0 : currentIndex);
          } else if (currentIndex == null) {
            viewContainer.remove(adjustedPreviousIndex === null ? void 0 : adjustedPreviousIndex);
          } else if (adjustedPreviousIndex !== null) {
            const view = viewContainer.get(adjustedPreviousIndex);
            viewContainer.move(view, currentIndex);
            applyViewChange(view, item);
          }
        });
        for (let i = 0, ilen = viewContainer.length; i < ilen; i++) {
          const viewRef = viewContainer.get(i);
          const context2 = viewRef.context;
          context2.index = i;
          context2.count = ilen;
          context2.ngForOf = this._ngForOf;
        }
        changes.forEachIdentityChange((record) => {
          const viewRef = viewContainer.get(record.currentIndex);
          applyViewChange(viewRef, record);
        });
      }
      static ngTemplateContextGuard(dir, ctx) {
        return true;
      }
    };
    NgForOf.\u0275fac = function NgForOf_Factory(t) {
      return new (t || NgForOf)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(IterableDiffers));
    };
    NgForOf.\u0275dir = \u0275\u0275defineDirective({
      type: NgForOf,
      selectors: [["", "ngFor", "", "ngForOf", ""]],
      inputs: {
        ngForOf: "ngForOf",
        ngForTrackBy: "ngForTrackBy",
        ngForTemplate: "ngForTemplate"
      },
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgForOf, [{
        type: Directive,
        args: [{
          selector: "[ngFor][ngForOf]",
          standalone: true
        }]
      }], function() {
        return [{
          type: ViewContainerRef
        }, {
          type: TemplateRef
        }, {
          type: IterableDiffers
        }];
      }, {
        ngForOf: [{
          type: Input
        }],
        ngForTrackBy: [{
          type: Input
        }],
        ngForTemplate: [{
          type: Input
        }]
      });
    })();
    NgIf = class {
      constructor(_viewContainer, templateRef) {
        this._viewContainer = _viewContainer;
        this._context = new NgIfContext();
        this._thenTemplateRef = null;
        this._elseTemplateRef = null;
        this._thenViewRef = null;
        this._elseViewRef = null;
        this._thenTemplateRef = templateRef;
      }
      set ngIf(condition) {
        this._context.$implicit = this._context.ngIf = condition;
        this._updateView();
      }
      set ngIfThen(templateRef) {
        assertTemplate("ngIfThen", templateRef);
        this._thenTemplateRef = templateRef;
        this._thenViewRef = null;
        this._updateView();
      }
      set ngIfElse(templateRef) {
        assertTemplate("ngIfElse", templateRef);
        this._elseTemplateRef = templateRef;
        this._elseViewRef = null;
        this._updateView();
      }
      _updateView() {
        if (this._context.$implicit) {
          if (!this._thenViewRef) {
            this._viewContainer.clear();
            this._elseViewRef = null;
            if (this._thenTemplateRef) {
              this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);
            }
          }
        } else {
          if (!this._elseViewRef) {
            this._viewContainer.clear();
            this._thenViewRef = null;
            if (this._elseTemplateRef) {
              this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context);
            }
          }
        }
      }
      static ngTemplateContextGuard(dir, ctx) {
        return true;
      }
    };
    NgIf.\u0275fac = function NgIf_Factory(t) {
      return new (t || NgIf)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef));
    };
    NgIf.\u0275dir = \u0275\u0275defineDirective({
      type: NgIf,
      selectors: [["", "ngIf", ""]],
      inputs: {
        ngIf: "ngIf",
        ngIfThen: "ngIfThen",
        ngIfElse: "ngIfElse"
      },
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgIf, [{
        type: Directive,
        args: [{
          selector: "[ngIf]",
          standalone: true
        }]
      }], function() {
        return [{
          type: ViewContainerRef
        }, {
          type: TemplateRef
        }];
      }, {
        ngIf: [{
          type: Input
        }],
        ngIfThen: [{
          type: Input
        }],
        ngIfElse: [{
          type: Input
        }]
      });
    })();
    NgIfContext = class {
      constructor() {
        this.$implicit = null;
        this.ngIf = null;
      }
    };
    SwitchView = class {
      constructor(_viewContainerRef, _templateRef) {
        this._viewContainerRef = _viewContainerRef;
        this._templateRef = _templateRef;
        this._created = false;
      }
      create() {
        this._created = true;
        this._viewContainerRef.createEmbeddedView(this._templateRef);
      }
      destroy() {
        this._created = false;
        this._viewContainerRef.clear();
      }
      enforceState(created) {
        if (created && !this._created) {
          this.create();
        } else if (!created && this._created) {
          this.destroy();
        }
      }
    };
    NgSwitch = class {
      constructor() {
        this._defaultUsed = false;
        this._caseCount = 0;
        this._lastCaseCheckIndex = 0;
        this._lastCasesMatched = false;
      }
      set ngSwitch(newValue) {
        this._ngSwitch = newValue;
        if (this._caseCount === 0) {
          this._updateDefaultCases(true);
        }
      }
      _addCase() {
        return this._caseCount++;
      }
      _addDefault(view) {
        if (!this._defaultViews) {
          this._defaultViews = [];
        }
        this._defaultViews.push(view);
      }
      _matchCase(value) {
        const matched = value == this._ngSwitch;
        this._lastCasesMatched = this._lastCasesMatched || matched;
        this._lastCaseCheckIndex++;
        if (this._lastCaseCheckIndex === this._caseCount) {
          this._updateDefaultCases(!this._lastCasesMatched);
          this._lastCaseCheckIndex = 0;
          this._lastCasesMatched = false;
        }
        return matched;
      }
      _updateDefaultCases(useDefault) {
        if (this._defaultViews && useDefault !== this._defaultUsed) {
          this._defaultUsed = useDefault;
          for (let i = 0; i < this._defaultViews.length; i++) {
            const defaultView = this._defaultViews[i];
            defaultView.enforceState(useDefault);
          }
        }
      }
    };
    NgSwitch.\u0275fac = function NgSwitch_Factory(t) {
      return new (t || NgSwitch)();
    };
    NgSwitch.\u0275dir = \u0275\u0275defineDirective({
      type: NgSwitch,
      selectors: [["", "ngSwitch", ""]],
      inputs: {
        ngSwitch: "ngSwitch"
      },
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgSwitch, [{
        type: Directive,
        args: [{
          selector: "[ngSwitch]",
          standalone: true
        }]
      }], null, {
        ngSwitch: [{
          type: Input
        }]
      });
    })();
    NgSwitchCase = class {
      constructor(viewContainer, templateRef, ngSwitch) {
        this.ngSwitch = ngSwitch;
        if ((typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && !ngSwitch) {
          throwNgSwitchProviderNotFoundError("ngSwitchCase", "NgSwitchCase");
        }
        ngSwitch._addCase();
        this._view = new SwitchView(viewContainer, templateRef);
      }
      ngDoCheck() {
        this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase));
      }
    };
    NgSwitchCase.\u0275fac = function NgSwitchCase_Factory(t) {
      return new (t || NgSwitchCase)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(NgSwitch, 9));
    };
    NgSwitchCase.\u0275dir = \u0275\u0275defineDirective({
      type: NgSwitchCase,
      selectors: [["", "ngSwitchCase", ""]],
      inputs: {
        ngSwitchCase: "ngSwitchCase"
      },
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgSwitchCase, [{
        type: Directive,
        args: [{
          selector: "[ngSwitchCase]",
          standalone: true
        }]
      }], function() {
        return [{
          type: ViewContainerRef
        }, {
          type: TemplateRef
        }, {
          type: NgSwitch,
          decorators: [{
            type: Optional
          }, {
            type: Host
          }]
        }];
      }, {
        ngSwitchCase: [{
          type: Input
        }]
      });
    })();
    NgSwitchDefault = class {
      constructor(viewContainer, templateRef, ngSwitch) {
        if ((typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && !ngSwitch) {
          throwNgSwitchProviderNotFoundError("ngSwitchDefault", "NgSwitchDefault");
        }
        ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
      }
    };
    NgSwitchDefault.\u0275fac = function NgSwitchDefault_Factory(t) {
      return new (t || NgSwitchDefault)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(NgSwitch, 9));
    };
    NgSwitchDefault.\u0275dir = \u0275\u0275defineDirective({
      type: NgSwitchDefault,
      selectors: [["", "ngSwitchDefault", ""]],
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgSwitchDefault, [{
        type: Directive,
        args: [{
          selector: "[ngSwitchDefault]",
          standalone: true
        }]
      }], function() {
        return [{
          type: ViewContainerRef
        }, {
          type: TemplateRef
        }, {
          type: NgSwitch,
          decorators: [{
            type: Optional
          }, {
            type: Host
          }]
        }];
      }, null);
    })();
    NgPlural = class {
      constructor(_localization) {
        this._localization = _localization;
        this._caseViews = {};
      }
      set ngPlural(value) {
        this._switchValue = value;
        this._updateView();
      }
      addCase(value, switchView) {
        this._caseViews[value] = switchView;
      }
      _updateView() {
        this._clearViews();
        const cases = Object.keys(this._caseViews);
        const key = getPluralCategory(this._switchValue, cases, this._localization);
        this._activateView(this._caseViews[key]);
      }
      _clearViews() {
        if (this._activeView)
          this._activeView.destroy();
      }
      _activateView(view) {
        if (view) {
          this._activeView = view;
          this._activeView.create();
        }
      }
    };
    NgPlural.\u0275fac = function NgPlural_Factory(t) {
      return new (t || NgPlural)(\u0275\u0275directiveInject(NgLocalization));
    };
    NgPlural.\u0275dir = \u0275\u0275defineDirective({
      type: NgPlural,
      selectors: [["", "ngPlural", ""]],
      inputs: {
        ngPlural: "ngPlural"
      },
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgPlural, [{
        type: Directive,
        args: [{
          selector: "[ngPlural]",
          standalone: true
        }]
      }], function() {
        return [{
          type: NgLocalization
        }];
      }, {
        ngPlural: [{
          type: Input
        }]
      });
    })();
    NgPluralCase = class {
      constructor(value, template, viewContainer, ngPlural) {
        this.value = value;
        const isANumber = !isNaN(Number(value));
        ngPlural.addCase(isANumber ? `=${value}` : value, new SwitchView(viewContainer, template));
      }
    };
    NgPluralCase.\u0275fac = function NgPluralCase_Factory(t) {
      return new (t || NgPluralCase)(\u0275\u0275injectAttribute("ngPluralCase"), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(NgPlural, 1));
    };
    NgPluralCase.\u0275dir = \u0275\u0275defineDirective({
      type: NgPluralCase,
      selectors: [["", "ngPluralCase", ""]],
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgPluralCase, [{
        type: Directive,
        args: [{
          selector: "[ngPluralCase]",
          standalone: true
        }]
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Attribute,
            args: ["ngPluralCase"]
          }]
        }, {
          type: TemplateRef
        }, {
          type: ViewContainerRef
        }, {
          type: NgPlural,
          decorators: [{
            type: Host
          }]
        }];
      }, null);
    })();
    NgStyle = class {
      constructor(_ngEl, _differs, _renderer) {
        this._ngEl = _ngEl;
        this._differs = _differs;
        this._renderer = _renderer;
        this._ngStyle = null;
        this._differ = null;
      }
      set ngStyle(values) {
        this._ngStyle = values;
        if (!this._differ && values) {
          this._differ = this._differs.find(values).create();
        }
      }
      ngDoCheck() {
        if (this._differ) {
          const changes = this._differ.diff(this._ngStyle);
          if (changes) {
            this._applyChanges(changes);
          }
        }
      }
      _setStyle(nameAndUnit, value) {
        const [name, unit] = nameAndUnit.split(".");
        const flags = name.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
        if (value != null) {
          this._renderer.setStyle(this._ngEl.nativeElement, name, unit ? `${value}${unit}` : value, flags);
        } else {
          this._renderer.removeStyle(this._ngEl.nativeElement, name, flags);
        }
      }
      _applyChanges(changes) {
        changes.forEachRemovedItem((record) => this._setStyle(record.key, null));
        changes.forEachAddedItem((record) => this._setStyle(record.key, record.currentValue));
        changes.forEachChangedItem((record) => this._setStyle(record.key, record.currentValue));
      }
    };
    NgStyle.\u0275fac = function NgStyle_Factory(t) {
      return new (t || NgStyle)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(KeyValueDiffers), \u0275\u0275directiveInject(Renderer2));
    };
    NgStyle.\u0275dir = \u0275\u0275defineDirective({
      type: NgStyle,
      selectors: [["", "ngStyle", ""]],
      inputs: {
        ngStyle: "ngStyle"
      },
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgStyle, [{
        type: Directive,
        args: [{
          selector: "[ngStyle]",
          standalone: true
        }]
      }], function() {
        return [{
          type: ElementRef
        }, {
          type: KeyValueDiffers
        }, {
          type: Renderer2
        }];
      }, {
        ngStyle: [{
          type: Input,
          args: ["ngStyle"]
        }]
      });
    })();
    NgTemplateOutlet = class {
      constructor(_viewContainerRef) {
        this._viewContainerRef = _viewContainerRef;
        this._viewRef = null;
        this.ngTemplateOutletContext = null;
        this.ngTemplateOutlet = null;
        this.ngTemplateOutletInjector = null;
      }
      ngOnChanges(changes) {
        if (changes["ngTemplateOutlet"] || changes["ngTemplateOutletInjector"]) {
          const viewContainerRef = this._viewContainerRef;
          if (this._viewRef) {
            viewContainerRef.remove(viewContainerRef.indexOf(this._viewRef));
          }
          if (this.ngTemplateOutlet) {
            const {
              ngTemplateOutlet: template,
              ngTemplateOutletContext: context2,
              ngTemplateOutletInjector: injector
            } = this;
            this._viewRef = viewContainerRef.createEmbeddedView(template, context2, injector ? {
              injector
            } : void 0);
          } else {
            this._viewRef = null;
          }
        } else if (this._viewRef && changes["ngTemplateOutletContext"] && this.ngTemplateOutletContext) {
          this._viewRef.context = this.ngTemplateOutletContext;
        }
      }
    };
    NgTemplateOutlet.\u0275fac = function NgTemplateOutlet_Factory(t) {
      return new (t || NgTemplateOutlet)(\u0275\u0275directiveInject(ViewContainerRef));
    };
    NgTemplateOutlet.\u0275dir = \u0275\u0275defineDirective({
      type: NgTemplateOutlet,
      selectors: [["", "ngTemplateOutlet", ""]],
      inputs: {
        ngTemplateOutletContext: "ngTemplateOutletContext",
        ngTemplateOutlet: "ngTemplateOutlet",
        ngTemplateOutletInjector: "ngTemplateOutletInjector"
      },
      standalone: true,
      features: [\u0275\u0275NgOnChangesFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgTemplateOutlet, [{
        type: Directive,
        args: [{
          selector: "[ngTemplateOutlet]",
          standalone: true
        }]
      }], function() {
        return [{
          type: ViewContainerRef
        }];
      }, {
        ngTemplateOutletContext: [{
          type: Input
        }],
        ngTemplateOutlet: [{
          type: Input
        }],
        ngTemplateOutletInjector: [{
          type: Input
        }]
      });
    })();
    COMMON_DIRECTIVES = [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase];
    SubscribableStrategy = class {
      createSubscription(async2, updateLatestValue) {
        return async2.subscribe({
          next: updateLatestValue,
          error: (e) => {
            throw e;
          }
        });
      }
      dispose(subscription) {
        subscription.unsubscribe();
      }
    };
    PromiseStrategy = class {
      createSubscription(async2, updateLatestValue) {
        return async2.then(updateLatestValue, (e) => {
          throw e;
        });
      }
      dispose(subscription) {
      }
    };
    _promiseStrategy = new PromiseStrategy();
    _subscribableStrategy = new SubscribableStrategy();
    AsyncPipe = class {
      constructor(ref) {
        this._latestValue = null;
        this._subscription = null;
        this._obj = null;
        this._strategy = null;
        this._ref = ref;
      }
      ngOnDestroy() {
        if (this._subscription) {
          this._dispose();
        }
        this._ref = null;
      }
      transform(obj) {
        if (!this._obj) {
          if (obj) {
            this._subscribe(obj);
          }
          return this._latestValue;
        }
        if (obj !== this._obj) {
          this._dispose();
          return this.transform(obj);
        }
        return this._latestValue;
      }
      _subscribe(obj) {
        this._obj = obj;
        this._strategy = this._selectStrategy(obj);
        this._subscription = this._strategy.createSubscription(obj, (value) => this._updateLatestValue(obj, value));
      }
      _selectStrategy(obj) {
        if (isPromise2(obj)) {
          return _promiseStrategy;
        }
        if (isSubscribable(obj)) {
          return _subscribableStrategy;
        }
        throw invalidPipeArgumentError(AsyncPipe, obj);
      }
      _dispose() {
        this._strategy.dispose(this._subscription);
        this._latestValue = null;
        this._subscription = null;
        this._obj = null;
      }
      _updateLatestValue(async2, value) {
        if (async2 === this._obj) {
          this._latestValue = value;
          this._ref.markForCheck();
        }
      }
    };
    AsyncPipe.\u0275fac = function AsyncPipe_Factory(t) {
      return new (t || AsyncPipe)(\u0275\u0275directiveInject(ChangeDetectorRef, 16));
    };
    AsyncPipe.\u0275pipe = \u0275\u0275definePipe({
      name: "async",
      type: AsyncPipe,
      pure: false,
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(AsyncPipe, [{
        type: Pipe,
        args: [{
          name: "async",
          pure: false,
          standalone: true
        }]
      }], function() {
        return [{
          type: ChangeDetectorRef
        }];
      }, null);
    })();
    LowerCasePipe = class {
      transform(value) {
        if (value == null)
          return null;
        if (typeof value !== "string") {
          throw invalidPipeArgumentError(LowerCasePipe, value);
        }
        return value.toLowerCase();
      }
    };
    LowerCasePipe.\u0275fac = function LowerCasePipe_Factory(t) {
      return new (t || LowerCasePipe)();
    };
    LowerCasePipe.\u0275pipe = \u0275\u0275definePipe({
      name: "lowercase",
      type: LowerCasePipe,
      pure: true,
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(LowerCasePipe, [{
        type: Pipe,
        args: [{
          name: "lowercase",
          standalone: true
        }]
      }], null, null);
    })();
    unicodeWordMatch = /(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])\S*/g;
    TitleCasePipe = class {
      transform(value) {
        if (value == null)
          return null;
        if (typeof value !== "string") {
          throw invalidPipeArgumentError(TitleCasePipe, value);
        }
        return value.replace(unicodeWordMatch, (txt) => txt[0].toUpperCase() + txt.slice(1).toLowerCase());
      }
    };
    TitleCasePipe.\u0275fac = function TitleCasePipe_Factory(t) {
      return new (t || TitleCasePipe)();
    };
    TitleCasePipe.\u0275pipe = \u0275\u0275definePipe({
      name: "titlecase",
      type: TitleCasePipe,
      pure: true,
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(TitleCasePipe, [{
        type: Pipe,
        args: [{
          name: "titlecase",
          standalone: true
        }]
      }], null, null);
    })();
    UpperCasePipe = class {
      transform(value) {
        if (value == null)
          return null;
        if (typeof value !== "string") {
          throw invalidPipeArgumentError(UpperCasePipe, value);
        }
        return value.toUpperCase();
      }
    };
    UpperCasePipe.\u0275fac = function UpperCasePipe_Factory(t) {
      return new (t || UpperCasePipe)();
    };
    UpperCasePipe.\u0275pipe = \u0275\u0275definePipe({
      name: "uppercase",
      type: UpperCasePipe,
      pure: true,
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(UpperCasePipe, [{
        type: Pipe,
        args: [{
          name: "uppercase",
          standalone: true
        }]
      }], null, null);
    })();
    DATE_PIPE_DEFAULT_TIMEZONE = new InjectionToken("DATE_PIPE_DEFAULT_TIMEZONE");
    DatePipe = class {
      constructor(locale, defaultTimezone) {
        this.locale = locale;
        this.defaultTimezone = defaultTimezone;
      }
      transform(value, format = "mediumDate", timezone, locale) {
        var _a;
        if (value == null || value === "" || value !== value)
          return null;
        try {
          return formatDate(value, format, locale || this.locale, (_a = timezone !== null && timezone !== void 0 ? timezone : this.defaultTimezone) !== null && _a !== void 0 ? _a : void 0);
        } catch (error2) {
          throw invalidPipeArgumentError(DatePipe, error2.message);
        }
      }
    };
    DatePipe.\u0275fac = function DatePipe_Factory(t) {
      return new (t || DatePipe)(\u0275\u0275directiveInject(LOCALE_ID, 16), \u0275\u0275directiveInject(DATE_PIPE_DEFAULT_TIMEZONE, 24));
    };
    DatePipe.\u0275pipe = \u0275\u0275definePipe({
      name: "date",
      type: DatePipe,
      pure: true,
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(DatePipe, [{
        type: Pipe,
        args: [{
          name: "date",
          pure: true,
          standalone: true
        }]
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Inject,
            args: [LOCALE_ID]
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Inject,
            args: [DATE_PIPE_DEFAULT_TIMEZONE]
          }, {
            type: Optional
          }]
        }];
      }, null);
    })();
    _INTERPOLATION_REGEXP = /#/g;
    I18nPluralPipe = class {
      constructor(_localization) {
        this._localization = _localization;
      }
      transform(value, pluralMap, locale) {
        if (value == null)
          return "";
        if (typeof pluralMap !== "object" || pluralMap === null) {
          throw invalidPipeArgumentError(I18nPluralPipe, pluralMap);
        }
        const key = getPluralCategory(value, Object.keys(pluralMap), this._localization, locale);
        return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
      }
    };
    I18nPluralPipe.\u0275fac = function I18nPluralPipe_Factory(t) {
      return new (t || I18nPluralPipe)(\u0275\u0275directiveInject(NgLocalization, 16));
    };
    I18nPluralPipe.\u0275pipe = \u0275\u0275definePipe({
      name: "i18nPlural",
      type: I18nPluralPipe,
      pure: true,
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(I18nPluralPipe, [{
        type: Pipe,
        args: [{
          name: "i18nPlural",
          pure: true,
          standalone: true
        }]
      }], function() {
        return [{
          type: NgLocalization
        }];
      }, null);
    })();
    I18nSelectPipe = class {
      transform(value, mapping) {
        if (value == null)
          return "";
        if (typeof mapping !== "object" || typeof value !== "string") {
          throw invalidPipeArgumentError(I18nSelectPipe, mapping);
        }
        if (mapping.hasOwnProperty(value)) {
          return mapping[value];
        }
        if (mapping.hasOwnProperty("other")) {
          return mapping["other"];
        }
        return "";
      }
    };
    I18nSelectPipe.\u0275fac = function I18nSelectPipe_Factory(t) {
      return new (t || I18nSelectPipe)();
    };
    I18nSelectPipe.\u0275pipe = \u0275\u0275definePipe({
      name: "i18nSelect",
      type: I18nSelectPipe,
      pure: true,
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(I18nSelectPipe, [{
        type: Pipe,
        args: [{
          name: "i18nSelect",
          pure: true,
          standalone: true
        }]
      }], null, null);
    })();
    JsonPipe = class {
      transform(value) {
        return JSON.stringify(value, null, 2);
      }
    };
    JsonPipe.\u0275fac = function JsonPipe_Factory(t) {
      return new (t || JsonPipe)();
    };
    JsonPipe.\u0275pipe = \u0275\u0275definePipe({
      name: "json",
      type: JsonPipe,
      pure: false,
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(JsonPipe, [{
        type: Pipe,
        args: [{
          name: "json",
          pure: false,
          standalone: true
        }]
      }], null, null);
    })();
    KeyValuePipe = class {
      constructor(differs) {
        this.differs = differs;
        this.keyValues = [];
        this.compareFn = defaultComparator;
      }
      transform(input, compareFn = defaultComparator) {
        if (!input || !(input instanceof Map) && typeof input !== "object") {
          return null;
        }
        if (!this.differ) {
          this.differ = this.differs.find(input).create();
        }
        const differChanges = this.differ.diff(input);
        const compareFnChanged = compareFn !== this.compareFn;
        if (differChanges) {
          this.keyValues = [];
          differChanges.forEachItem((r) => {
            this.keyValues.push(makeKeyValuePair(r.key, r.currentValue));
          });
        }
        if (differChanges || compareFnChanged) {
          this.keyValues.sort(compareFn);
          this.compareFn = compareFn;
        }
        return this.keyValues;
      }
    };
    KeyValuePipe.\u0275fac = function KeyValuePipe_Factory(t) {
      return new (t || KeyValuePipe)(\u0275\u0275directiveInject(KeyValueDiffers, 16));
    };
    KeyValuePipe.\u0275pipe = \u0275\u0275definePipe({
      name: "keyvalue",
      type: KeyValuePipe,
      pure: false,
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(KeyValuePipe, [{
        type: Pipe,
        args: [{
          name: "keyvalue",
          pure: false,
          standalone: true
        }]
      }], function() {
        return [{
          type: KeyValueDiffers
        }];
      }, null);
    })();
    DecimalPipe = class {
      constructor(_locale) {
        this._locale = _locale;
      }
      transform(value, digitsInfo, locale) {
        if (!isValue(value))
          return null;
        locale = locale || this._locale;
        try {
          const num = strToNumber(value);
          return formatNumber(num, locale, digitsInfo);
        } catch (error2) {
          throw invalidPipeArgumentError(DecimalPipe, error2.message);
        }
      }
    };
    DecimalPipe.\u0275fac = function DecimalPipe_Factory(t) {
      return new (t || DecimalPipe)(\u0275\u0275directiveInject(LOCALE_ID, 16));
    };
    DecimalPipe.\u0275pipe = \u0275\u0275definePipe({
      name: "number",
      type: DecimalPipe,
      pure: true,
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(DecimalPipe, [{
        type: Pipe,
        args: [{
          name: "number",
          standalone: true
        }]
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Inject,
            args: [LOCALE_ID]
          }]
        }];
      }, null);
    })();
    PercentPipe = class {
      constructor(_locale) {
        this._locale = _locale;
      }
      transform(value, digitsInfo, locale) {
        if (!isValue(value))
          return null;
        locale = locale || this._locale;
        try {
          const num = strToNumber(value);
          return formatPercent(num, locale, digitsInfo);
        } catch (error2) {
          throw invalidPipeArgumentError(PercentPipe, error2.message);
        }
      }
    };
    PercentPipe.\u0275fac = function PercentPipe_Factory(t) {
      return new (t || PercentPipe)(\u0275\u0275directiveInject(LOCALE_ID, 16));
    };
    PercentPipe.\u0275pipe = \u0275\u0275definePipe({
      name: "percent",
      type: PercentPipe,
      pure: true,
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(PercentPipe, [{
        type: Pipe,
        args: [{
          name: "percent",
          standalone: true
        }]
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Inject,
            args: [LOCALE_ID]
          }]
        }];
      }, null);
    })();
    CurrencyPipe = class {
      constructor(_locale, _defaultCurrencyCode = "USD") {
        this._locale = _locale;
        this._defaultCurrencyCode = _defaultCurrencyCode;
      }
      transform(value, currencyCode = this._defaultCurrencyCode, display = "symbol", digitsInfo, locale) {
        if (!isValue(value))
          return null;
        locale = locale || this._locale;
        if (typeof display === "boolean") {
          if ((typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && console && console.warn) {
            console.warn(`Warning: the currency pipe has been changed in Angular v5. The symbolDisplay option (third parameter) is now a string instead of a boolean. The accepted values are "code", "symbol" or "symbol-narrow".`);
          }
          display = display ? "symbol" : "code";
        }
        let currency = currencyCode || this._defaultCurrencyCode;
        if (display !== "code") {
          if (display === "symbol" || display === "symbol-narrow") {
            currency = getCurrencySymbol(currency, display === "symbol" ? "wide" : "narrow", locale);
          } else {
            currency = display;
          }
        }
        try {
          const num = strToNumber(value);
          return formatCurrency(num, locale, currency, currencyCode, digitsInfo);
        } catch (error2) {
          throw invalidPipeArgumentError(CurrencyPipe, error2.message);
        }
      }
    };
    CurrencyPipe.\u0275fac = function CurrencyPipe_Factory(t) {
      return new (t || CurrencyPipe)(\u0275\u0275directiveInject(LOCALE_ID, 16), \u0275\u0275directiveInject(DEFAULT_CURRENCY_CODE, 16));
    };
    CurrencyPipe.\u0275pipe = \u0275\u0275definePipe({
      name: "currency",
      type: CurrencyPipe,
      pure: true,
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(CurrencyPipe, [{
        type: Pipe,
        args: [{
          name: "currency",
          standalone: true
        }]
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Inject,
            args: [LOCALE_ID]
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Inject,
            args: [DEFAULT_CURRENCY_CODE]
          }]
        }];
      }, null);
    })();
    SlicePipe = class {
      transform(value, start, end) {
        if (value == null)
          return null;
        if (!this.supports(value)) {
          throw invalidPipeArgumentError(SlicePipe, value);
        }
        return value.slice(start, end);
      }
      supports(obj) {
        return typeof obj === "string" || Array.isArray(obj);
      }
    };
    SlicePipe.\u0275fac = function SlicePipe_Factory(t) {
      return new (t || SlicePipe)();
    };
    SlicePipe.\u0275pipe = \u0275\u0275definePipe({
      name: "slice",
      type: SlicePipe,
      pure: false,
      standalone: true
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(SlicePipe, [{
        type: Pipe,
        args: [{
          name: "slice",
          pure: false,
          standalone: true
        }]
      }], null, null);
    })();
    COMMON_PIPES = [AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe];
    CommonModule = class {
    };
    CommonModule.\u0275fac = function CommonModule_Factory(t) {
      return new (t || CommonModule)();
    };
    CommonModule.\u0275mod = \u0275\u0275defineNgModule({
      type: CommonModule
    });
    CommonModule.\u0275inj = \u0275\u0275defineInjector({});
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(CommonModule, [{
        type: NgModule,
        args: [{
          imports: [COMMON_DIRECTIVES, COMMON_PIPES],
          exports: [COMMON_DIRECTIVES, COMMON_PIPES]
        }]
      }], null, null);
    })();
    PLATFORM_BROWSER_ID = "browser";
    VERSION2 = new Version("14.1.1");
    ViewportScroller = class {
    };
    ViewportScroller.\u0275prov = \u0275\u0275defineInjectable({
      token: ViewportScroller,
      providedIn: "root",
      factory: () => new BrowserViewportScroller(\u0275\u0275inject(DOCUMENT2), window)
    });
    BrowserViewportScroller = class {
      constructor(document2, window3) {
        this.document = document2;
        this.window = window3;
        this.offset = () => [0, 0];
      }
      setOffset(offset) {
        if (Array.isArray(offset)) {
          this.offset = () => offset;
        } else {
          this.offset = offset;
        }
      }
      getScrollPosition() {
        if (this.supportsScrolling()) {
          return [this.window.pageXOffset, this.window.pageYOffset];
        } else {
          return [0, 0];
        }
      }
      scrollToPosition(position) {
        if (this.supportsScrolling()) {
          this.window.scrollTo(position[0], position[1]);
        }
      }
      scrollToAnchor(target) {
        if (!this.supportsScrolling()) {
          return;
        }
        const elSelected = findAnchorFromDocument(this.document, target);
        if (elSelected) {
          this.scrollToElement(elSelected);
          elSelected.focus();
        }
      }
      setHistoryScrollRestoration(scrollRestoration) {
        if (this.supportScrollRestoration()) {
          const history = this.window.history;
          if (history && history.scrollRestoration) {
            history.scrollRestoration = scrollRestoration;
          }
        }
      }
      scrollToElement(el) {
        const rect = el.getBoundingClientRect();
        const left = rect.left + this.window.pageXOffset;
        const top = rect.top + this.window.pageYOffset;
        const offset = this.offset();
        this.window.scrollTo(left - offset[0], top - offset[1]);
      }
      supportScrollRestoration() {
        try {
          if (!this.supportsScrolling()) {
            return false;
          }
          const scrollRestorationDescriptor = getScrollRestorationProperty(this.window.history) || getScrollRestorationProperty(Object.getPrototypeOf(this.window.history));
          return !!scrollRestorationDescriptor && !!(scrollRestorationDescriptor.writable || scrollRestorationDescriptor.set);
        } catch (_a) {
          return false;
        }
      }
      supportsScrolling() {
        try {
          return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window;
        } catch (_a) {
          return false;
        }
      }
    };
    XhrFactory = class {
    };
  }
});

// node_modules/@angular/forms/fesm2015/forms.mjs
var forms_exports = {};
__export(forms_exports, {
  AbstractControl: () => AbstractControl,
  AbstractControlDirective: () => AbstractControlDirective,
  AbstractFormGroupDirective: () => AbstractFormGroupDirective,
  COMPOSITION_BUFFER_MODE: () => COMPOSITION_BUFFER_MODE,
  CheckboxControlValueAccessor: () => CheckboxControlValueAccessor,
  CheckboxRequiredValidator: () => CheckboxRequiredValidator,
  ControlContainer: () => ControlContainer,
  DefaultValueAccessor: () => DefaultValueAccessor,
  EmailValidator: () => EmailValidator,
  FormArray: () => FormArray,
  FormArrayName: () => FormArrayName,
  FormBuilder: () => FormBuilder,
  FormControl: () => FormControl,
  FormControlDirective: () => FormControlDirective,
  FormControlName: () => FormControlName,
  FormGroup: () => FormGroup,
  FormGroupDirective: () => FormGroupDirective,
  FormGroupName: () => FormGroupName,
  FormRecord: () => FormRecord,
  FormsModule: () => FormsModule,
  MaxLengthValidator: () => MaxLengthValidator,
  MaxValidator: () => MaxValidator,
  MinLengthValidator: () => MinLengthValidator,
  MinValidator: () => MinValidator,
  NG_ASYNC_VALIDATORS: () => NG_ASYNC_VALIDATORS,
  NG_VALIDATORS: () => NG_VALIDATORS,
  NG_VALUE_ACCESSOR: () => NG_VALUE_ACCESSOR,
  NgControl: () => NgControl,
  NgControlStatus: () => NgControlStatus,
  NgControlStatusGroup: () => NgControlStatusGroup,
  NgForm: () => NgForm,
  NgModel: () => NgModel,
  NgModelGroup: () => NgModelGroup,
  NgSelectOption: () => NgSelectOption,
  NonNullableFormBuilder: () => NonNullableFormBuilder,
  NumberValueAccessor: () => NumberValueAccessor,
  PatternValidator: () => PatternValidator,
  RadioControlValueAccessor: () => RadioControlValueAccessor,
  RangeValueAccessor: () => RangeValueAccessor,
  ReactiveFormsModule: () => ReactiveFormsModule,
  RequiredValidator: () => RequiredValidator,
  SelectControlValueAccessor: () => SelectControlValueAccessor,
  SelectMultipleControlValueAccessor: () => SelectMultipleControlValueAccessor,
  UntypedFormArray: () => UntypedFormArray,
  UntypedFormBuilder: () => UntypedFormBuilder,
  UntypedFormControl: () => UntypedFormControl,
  UntypedFormGroup: () => UntypedFormGroup,
  VERSION: () => VERSION3,
  Validators: () => Validators,
  \u0275InternalFormsSharedModule: () => \u0275InternalFormsSharedModule,
  \u0275NgNoValidate: () => \u0275NgNoValidate,
  \u0275NgSelectMultipleOption: () => \u0275NgSelectMultipleOption
});
function _isAndroid() {
  const userAgent = getDOM() ? getDOM().getUserAgent() : "";
  return /android (\d+)/.test(userAgent.toLowerCase());
}
function isEmptyInputValue(value) {
  return value == null || (typeof value === "string" || Array.isArray(value)) && value.length === 0;
}
function hasValidLength(value) {
  return value != null && typeof value.length === "number";
}
function minValidator(min2) {
  return (control) => {
    if (isEmptyInputValue(control.value) || isEmptyInputValue(min2)) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value < min2 ? {
      "min": {
        "min": min2,
        "actual": control.value
      }
    } : null;
  };
}
function maxValidator(max2) {
  return (control) => {
    if (isEmptyInputValue(control.value) || isEmptyInputValue(max2)) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value > max2 ? {
      "max": {
        "max": max2,
        "actual": control.value
      }
    } : null;
  };
}
function requiredValidator(control) {
  return isEmptyInputValue(control.value) ? {
    "required": true
  } : null;
}
function requiredTrueValidator(control) {
  return control.value === true ? null : {
    "required": true
  };
}
function emailValidator(control) {
  if (isEmptyInputValue(control.value)) {
    return null;
  }
  return EMAIL_REGEXP.test(control.value) ? null : {
    "email": true
  };
}
function minLengthValidator(minLength) {
  return (control) => {
    if (isEmptyInputValue(control.value) || !hasValidLength(control.value)) {
      return null;
    }
    return control.value.length < minLength ? {
      "minlength": {
        "requiredLength": minLength,
        "actualLength": control.value.length
      }
    } : null;
  };
}
function maxLengthValidator(maxLength) {
  return (control) => {
    return hasValidLength(control.value) && control.value.length > maxLength ? {
      "maxlength": {
        "requiredLength": maxLength,
        "actualLength": control.value.length
      }
    } : null;
  };
}
function patternValidator(pattern) {
  if (!pattern)
    return nullValidator;
  let regex;
  let regexStr;
  if (typeof pattern === "string") {
    regexStr = "";
    if (pattern.charAt(0) !== "^")
      regexStr += "^";
    regexStr += pattern;
    if (pattern.charAt(pattern.length - 1) !== "$")
      regexStr += "$";
    regex = new RegExp(regexStr);
  } else {
    regexStr = pattern.toString();
    regex = pattern;
  }
  return (control) => {
    if (isEmptyInputValue(control.value)) {
      return null;
    }
    const value = control.value;
    return regex.test(value) ? null : {
      "pattern": {
        "requiredPattern": regexStr,
        "actualValue": value
      }
    };
  };
}
function nullValidator(control) {
  return null;
}
function isPresent(o) {
  return o != null;
}
function toObservable(value) {
  const obs = isPromise2(value) ? from(value) : value;
  if (NG_DEV_MODE$1 && !isObservable2(obs)) {
    let errorMessage = `Expected async validator to return Promise or Observable.`;
    if (typeof value === "object") {
      errorMessage += " Are you using a synchronous validator where an async validator is expected?";
    }
    throw new RuntimeError(
      -1101,
      errorMessage
    );
  }
  return obs;
}
function mergeErrors(arrayOfErrors) {
  let res = {};
  arrayOfErrors.forEach((errors) => {
    res = errors != null ? Object.assign(Object.assign({}, res), errors) : res;
  });
  return Object.keys(res).length === 0 ? null : res;
}
function executeValidators(control, validators) {
  return validators.map((validator) => validator(control));
}
function isValidatorFn(validator) {
  return !validator.validate;
}
function normalizeValidators(validators) {
  return validators.map((validator) => {
    return isValidatorFn(validator) ? validator : (c) => validator.validate(c);
  });
}
function compose(validators) {
  if (!validators)
    return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0)
    return null;
  return function(control) {
    return mergeErrors(executeValidators(control, presentValidators));
  };
}
function composeValidators(validators) {
  return validators != null ? compose(normalizeValidators(validators)) : null;
}
function composeAsync(validators) {
  if (!validators)
    return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0)
    return null;
  return function(control) {
    const observables = executeValidators(control, presentValidators).map(toObservable);
    return forkJoin(observables).pipe(map(mergeErrors));
  };
}
function composeAsyncValidators(validators) {
  return validators != null ? composeAsync(normalizeValidators(validators)) : null;
}
function mergeValidators(controlValidators, dirValidator) {
  if (controlValidators === null)
    return [dirValidator];
  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];
}
function getControlValidators(control) {
  return control._rawValidators;
}
function getControlAsyncValidators(control) {
  return control._rawAsyncValidators;
}
function makeValidatorsArray(validators) {
  if (!validators)
    return [];
  return Array.isArray(validators) ? validators : [validators];
}
function hasValidator(validators, validator) {
  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
}
function addValidators(validators, currentValidators) {
  const current = makeValidatorsArray(currentValidators);
  const validatorsToAdd = makeValidatorsArray(validators);
  validatorsToAdd.forEach((v) => {
    if (!hasValidator(current, v)) {
      current.push(v);
    }
  });
  return current;
}
function removeValidators(validators, currentValidators) {
  return makeValidatorsArray(currentValidators).filter((v) => !hasValidator(validators, v));
}
function controlParentException() {
  return new RuntimeError(
    1050,
    `formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formControlNameExample}`
  );
}
function ngModelGroupException() {
  return new RuntimeError(
    1051,
    `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents
      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.

      Option 1:  Update the parent to be formGroupName (reactive form strategy)

      ${formGroupNameExample}

      Option 2: Use ngModel instead of formControlName (template-driven strategy)

      ${ngModelGroupExample}`
  );
}
function missingFormException() {
  return new RuntimeError(
    1052,
    `formGroup expects a FormGroup instance. Please pass one in.

      Example:

      ${formControlNameExample}`
  );
}
function groupParentException() {
  return new RuntimeError(
    1053,
    `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup
    directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formGroupNameExample}`
  );
}
function arrayParentException() {
  return new RuntimeError(
    1054,
    `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      Example:

      ${formArrayNameExample}`
  );
}
function ngModelWarning(directiveName) {
  return `
  It looks like you're using ngModel on the same form field as ${directiveName}.
  Support for using the ngModel input property and ngModelChange event with
  reactive form directives has been deprecated in Angular v6 and will be removed
  in a future version of Angular.

  For more information on this, see our API docs here:
  https://angular.io/api/forms/${directiveName === "formControl" ? "FormControlDirective" : "FormControlName"}#use-with-ngmodel
  `;
}
function describeKey(isFormGroup, key) {
  return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;
}
function noControlsError(isFormGroup) {
  return `
    There are no form controls registered with this ${isFormGroup ? "group" : "array"} yet. If you're using ngModel,
    you may want to check next tick (e.g. use setTimeout).
  `;
}
function missingControlError(isFormGroup, key) {
  return `Cannot find form control ${describeKey(isFormGroup, key)}`;
}
function missingControlValueError(isFormGroup, key) {
  return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;
}
function pickValidators(validatorOrOpts) {
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
}
function coerceToValidator(validator) {
  return Array.isArray(validator) ? composeValidators(validator) : validator || null;
}
function pickAsyncValidators(asyncValidator, validatorOrOpts) {
  if (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) {
    if (isOptionsObj(validatorOrOpts) && asyncValidator) {
      console.warn(asyncValidatorsDroppedWithOptsWarning);
    }
  }
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
}
function coerceToAsyncValidator(asyncValidator) {
  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;
}
function isOptionsObj(validatorOrOpts) {
  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === "object";
}
function assertControlPresent(parent, isGroup, key) {
  const controls = parent.controls;
  const collection = isGroup ? Object.keys(controls) : controls;
  if (!collection.length) {
    throw new RuntimeError(
      1e3,
      NG_DEV_MODE3 ? noControlsError(isGroup) : ""
    );
  }
  if (!controls[key]) {
    throw new RuntimeError(
      1001,
      NG_DEV_MODE3 ? missingControlError(isGroup, key) : ""
    );
  }
}
function assertAllValuesPresent(control, isGroup, value) {
  control._forEachChild((_, key) => {
    if (value[key] === void 0) {
      throw new RuntimeError(
        1002,
        NG_DEV_MODE3 ? missingControlValueError(isGroup, key) : ""
      );
    }
  });
}
function controlPath(name, parent) {
  return [...parent.path, name];
}
function setUpControl(control, dir) {
  var _a, _b;
  if (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) {
    if (!control)
      _throwError(dir, "Cannot find control with");
    if (!dir.valueAccessor)
      _throwError(dir, "No value accessor for form control with");
  }
  setUpValidators(control, dir);
  dir.valueAccessor.writeValue(control.value);
  if (control.disabled) {
    (_b = (_a = dir.valueAccessor).setDisabledState) === null || _b === void 0 ? void 0 : _b.call(_a, true);
  }
  setUpViewChangePipeline(control, dir);
  setUpModelChangePipeline(control, dir);
  setUpBlurPipeline(control, dir);
  setUpDisabledChangeHandler(control, dir);
}
function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
  const noop3 = () => {
    if (validateControlPresenceOnChange && (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default)) {
      _noControlError(dir);
    }
  };
  if (dir.valueAccessor) {
    dir.valueAccessor.registerOnChange(noop3);
    dir.valueAccessor.registerOnTouched(noop3);
  }
  cleanUpValidators(control, dir);
  if (control) {
    dir._invokeOnDestroyCallbacks();
    control._registerOnCollectionChange(() => {
    });
  }
}
function registerOnValidatorChange(validators, onChange) {
  validators.forEach((validator) => {
    if (validator.registerOnValidatorChange)
      validator.registerOnValidatorChange(onChange);
  });
}
function setUpDisabledChangeHandler(control, dir) {
  if (dir.valueAccessor.setDisabledState) {
    const onDisabledChange = (isDisabled) => {
      dir.valueAccessor.setDisabledState(isDisabled);
    };
    control.registerOnDisabledChange(onDisabledChange);
    dir._registerOnDestroy(() => {
      control._unregisterOnDisabledChange(onDisabledChange);
    });
  }
}
function setUpValidators(control, dir) {
  const validators = getControlValidators(control);
  if (dir.validator !== null) {
    control.setValidators(mergeValidators(validators, dir.validator));
  } else if (typeof validators === "function") {
    control.setValidators([validators]);
  }
  const asyncValidators = getControlAsyncValidators(control);
  if (dir.asyncValidator !== null) {
    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
  } else if (typeof asyncValidators === "function") {
    control.setAsyncValidators([asyncValidators]);
  }
  const onValidatorChange = () => control.updateValueAndValidity();
  registerOnValidatorChange(dir._rawValidators, onValidatorChange);
  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
}
function cleanUpValidators(control, dir) {
  let isControlUpdated = false;
  if (control !== null) {
    if (dir.validator !== null) {
      const validators = getControlValidators(control);
      if (Array.isArray(validators) && validators.length > 0) {
        const updatedValidators = validators.filter((validator) => validator !== dir.validator);
        if (updatedValidators.length !== validators.length) {
          isControlUpdated = true;
          control.setValidators(updatedValidators);
        }
      }
    }
    if (dir.asyncValidator !== null) {
      const asyncValidators = getControlAsyncValidators(control);
      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
        const updatedAsyncValidators = asyncValidators.filter((asyncValidator) => asyncValidator !== dir.asyncValidator);
        if (updatedAsyncValidators.length !== asyncValidators.length) {
          isControlUpdated = true;
          control.setAsyncValidators(updatedAsyncValidators);
        }
      }
    }
  }
  const noop3 = () => {
  };
  registerOnValidatorChange(dir._rawValidators, noop3);
  registerOnValidatorChange(dir._rawAsyncValidators, noop3);
  return isControlUpdated;
}
function setUpViewChangePipeline(control, dir) {
  dir.valueAccessor.registerOnChange((newValue) => {
    control._pendingValue = newValue;
    control._pendingChange = true;
    control._pendingDirty = true;
    if (control.updateOn === "change")
      updateControl(control, dir);
  });
}
function setUpBlurPipeline(control, dir) {
  dir.valueAccessor.registerOnTouched(() => {
    control._pendingTouched = true;
    if (control.updateOn === "blur" && control._pendingChange)
      updateControl(control, dir);
    if (control.updateOn !== "submit")
      control.markAsTouched();
  });
}
function updateControl(control, dir) {
  if (control._pendingDirty)
    control.markAsDirty();
  control.setValue(control._pendingValue, {
    emitModelToViewChange: false
  });
  dir.viewToModelUpdate(control._pendingValue);
  control._pendingChange = false;
}
function setUpModelChangePipeline(control, dir) {
  const onChange = (newValue, emitModelEvent) => {
    dir.valueAccessor.writeValue(newValue);
    if (emitModelEvent)
      dir.viewToModelUpdate(newValue);
  };
  control.registerOnChange(onChange);
  dir._registerOnDestroy(() => {
    control._unregisterOnChange(onChange);
  });
}
function setUpFormContainer(control, dir) {
  if (control == null && (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default))
    _throwError(dir, "Cannot find control with");
  setUpValidators(control, dir);
}
function cleanUpFormContainer(control, dir) {
  return cleanUpValidators(control, dir);
}
function _noControlError(dir) {
  return _throwError(dir, "There is no FormControl instance attached to form control element with");
}
function _throwError(dir, message) {
  const messageEnd = _describeControlLocation(dir);
  throw new Error(`${message} ${messageEnd}`);
}
function _describeControlLocation(dir) {
  const path = dir.path;
  if (path && path.length > 1)
    return `path: '${path.join(" -> ")}'`;
  if (path === null || path === void 0 ? void 0 : path[0])
    return `name: '${path}'`;
  return "unspecified name attribute";
}
function _throwInvalidValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(
    1200,
    `Value accessor was not provided as an array for form control with ${loc}. Check that the \`NG_VALUE_ACCESSOR\` token is configured as a \`multi: true\` provider.`
  );
}
function isPropertyUpdated(changes, viewModel) {
  if (!changes.hasOwnProperty("model"))
    return false;
  const change = changes["model"];
  if (change.isFirstChange())
    return true;
  return !Object.is(viewModel, change.currentValue);
}
function isBuiltInAccessor(valueAccessor) {
  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
}
function syncPendingControls(form, directives) {
  form._syncPendingControls();
  directives.forEach((dir) => {
    const control = dir.control;
    if (control.updateOn === "submit" && control._pendingChange) {
      dir.viewToModelUpdate(control._pendingValue);
      control._pendingChange = false;
    }
  });
}
function selectValueAccessor(dir, valueAccessors) {
  if (!valueAccessors)
    return null;
  if (!Array.isArray(valueAccessors) && (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default))
    _throwInvalidValueAccessorError(dir);
  let defaultAccessor = void 0;
  let builtinAccessor = void 0;
  let customAccessor = void 0;
  valueAccessors.forEach((v) => {
    if (v.constructor === DefaultValueAccessor) {
      defaultAccessor = v;
    } else if (isBuiltInAccessor(v)) {
      if (builtinAccessor && (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default))
        _throwError(dir, "More than one built-in value accessor matches form control with");
      builtinAccessor = v;
    } else {
      if (customAccessor && (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default))
        _throwError(dir, "More than one custom value accessor matches form control with");
      customAccessor = v;
    }
  });
  if (customAccessor)
    return customAccessor;
  if (builtinAccessor)
    return builtinAccessor;
  if (defaultAccessor)
    return defaultAccessor;
  if (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) {
    _throwError(dir, "No valid value accessor for form control with");
  }
  return null;
}
function removeListItem$1(list, el) {
  const index = list.indexOf(el);
  if (index > -1)
    list.splice(index, 1);
}
function _ngModelWarning(name, type, instance, warningConfig) {
  if (warningConfig === "never")
    return;
  if ((warningConfig === null || warningConfig === "once") && !type._ngModelWarningSentOnce || warningConfig === "always" && !instance._ngModelWarningSent) {
    console.warn(ngModelWarning(name));
    type._ngModelWarningSentOnce = true;
    instance._ngModelWarningSent = true;
  }
}
function removeListItem(list, el) {
  const index = list.indexOf(el);
  if (index > -1)
    list.splice(index, 1);
}
function isFormControlState(formState) {
  return typeof formState === "object" && formState !== null && Object.keys(formState).length === 2 && "value" in formState && "disabled" in formState;
}
function modelParentException() {
  return new RuntimeError(
    1350,
    `
    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using
    formGroup's partner directive "formControlName" instead.  Example:

    ${formControlNameExample}

    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:

    Example:

    ${ngModelWithFormGroupExample}`
  );
}
function formGroupNameException() {
  return new RuntimeError(
    1351,
    `
    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.

    Option 1: Use formControlName instead of ngModel (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):

    ${ngModelGroupExample}`
  );
}
function missingNameException() {
  return new RuntimeError(
    1352,
    `If ngModel is used within a form tag, either the name attribute must be set or the form
    control must be defined as 'standalone' in ngModelOptions.

    Example 1: <input [(ngModel)]="person.firstName" name="first">
    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`
  );
}
function modelGroupParentException() {
  return new RuntimeError(
    1353,
    `
    ngModelGroup cannot be used with a parent formGroup directive.

    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):

    ${ngModelGroupExample}`
  );
}
function throwNameError() {
  throw new RuntimeError(
    1202,
    `
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <input type="radio" formControlName="food" name="food">
    `
  );
}
function _hasInvalidParent(parent) {
  return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName);
}
function _buildValueString$1(id, value) {
  if (id == null)
    return `${value}`;
  if (value && typeof value === "object")
    value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId$1(valueString) {
  return valueString.split(":")[0];
}
function _buildValueString(id, value) {
  if (id == null)
    return `${value}`;
  if (typeof value === "string")
    value = `'${value}'`;
  if (value && typeof value === "object")
    value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId(valueString) {
  return valueString.split(":")[0];
}
function toInteger(value) {
  return typeof value === "number" ? value : parseInt(value, 10);
}
function toFloat(value) {
  return typeof value === "number" ? value : parseFloat(value);
}
function isAbstractControlOptions(options) {
  return !!options && (options.asyncValidators !== void 0 || options.validators !== void 0 || options.updateOn !== void 0);
}
var BaseControlValueAccessor, BuiltInControlValueAccessor, NG_VALUE_ACCESSOR, CHECKBOX_VALUE_ACCESSOR, CheckboxControlValueAccessor, DEFAULT_VALUE_ACCESSOR, COMPOSITION_BUFFER_MODE, DefaultValueAccessor, NG_DEV_MODE$1, NG_VALIDATORS, NG_ASYNC_VALIDATORS, EMAIL_REGEXP, Validators, AbstractControlDirective, NgControl, ControlContainer, AbstractControlStatus, ngControlStatusHost, ngGroupStatusHost, NgControlStatus, NgControlStatusGroup, formControlNameExample, formGroupNameExample, formArrayNameExample, ngModelGroupExample, ngModelWithFormGroupExample, disabledAttrWarning, asyncValidatorsDroppedWithOptsWarning, NG_DEV_MODE3, VALID, INVALID, PENDING, DISABLED, AbstractControl, FormGroup, UntypedFormGroup, FormRecord, formDirectiveProvider$1, resolvedPromise$1, NgForm, FormControl, UntypedFormControl, isFormControl, AbstractFormGroupDirective, modelGroupProvider, NgModelGroup, formControlBinding$1, resolvedPromise, NgModel, \u0275NgNoValidate, NUMBER_VALUE_ACCESSOR, NumberValueAccessor, RADIO_VALUE_ACCESSOR, RadioControlRegistryModule, RadioControlRegistry, RadioControlValueAccessor, RANGE_VALUE_ACCESSOR, RangeValueAccessor, NG_MODEL_WITH_FORM_CONTROL_WARNING, formControlBinding, FormControlDirective, formDirectiveProvider, FormGroupDirective, formGroupNameProvider, FormGroupName, formArrayNameProvider, FormArrayName, controlNameBinding, FormControlName, SELECT_VALUE_ACCESSOR, SelectControlValueAccessor, NgSelectOption, SELECT_MULTIPLE_VALUE_ACCESSOR, SelectMultipleControlValueAccessor, \u0275NgSelectMultipleOption, AbstractValidatorDirective, MAX_VALIDATOR, MaxValidator, MIN_VALIDATOR, MinValidator, REQUIRED_VALIDATOR, CHECKBOX_REQUIRED_VALIDATOR, RequiredValidator, CheckboxRequiredValidator, EMAIL_VALIDATOR, EmailValidator, MIN_LENGTH_VALIDATOR, MinLengthValidator, MAX_LENGTH_VALIDATOR, MaxLengthValidator, PATTERN_VALIDATOR, PatternValidator, SHARED_FORM_DIRECTIVES, TEMPLATE_DRIVEN_DIRECTIVES, REACTIVE_DRIVEN_DIRECTIVES, \u0275InternalFormsSharedModule, FormsModule, ReactiveFormsModule, FormArray, UntypedFormArray, FormBuilder, NonNullableFormBuilder, UntypedFormBuilder, VERSION3;
var init_forms = __esm({
  "node_modules/@angular/forms/fesm2015/forms.mjs"() {
    init_define_ngDevMode();
    init_core();
    init_core();
    init_common();
    init_esm5();
    init_operators();
    BaseControlValueAccessor = class {
      constructor(_renderer, _elementRef) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this.onChange = (_) => {
        };
        this.onTouched = () => {
        };
      }
      setProperty(key, value) {
        this._renderer.setProperty(this._elementRef.nativeElement, key, value);
      }
      registerOnTouched(fn2) {
        this.onTouched = fn2;
      }
      registerOnChange(fn2) {
        this.onChange = fn2;
      }
      setDisabledState(isDisabled) {
        this.setProperty("disabled", isDisabled);
      }
    };
    BaseControlValueAccessor.\u0275fac = function BaseControlValueAccessor_Factory(t) {
      return new (t || BaseControlValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef));
    };
    BaseControlValueAccessor.\u0275dir = \u0275\u0275defineDirective({
      type: BaseControlValueAccessor
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(BaseControlValueAccessor, [{
        type: Directive
      }], function() {
        return [{
          type: Renderer2
        }, {
          type: ElementRef
        }];
      }, null);
    })();
    BuiltInControlValueAccessor = class extends BaseControlValueAccessor {
    };
    BuiltInControlValueAccessor.\u0275fac = function() {
      let \u0275BuiltInControlValueAccessor_BaseFactory;
      return function BuiltInControlValueAccessor_Factory(t) {
        return (\u0275BuiltInControlValueAccessor_BaseFactory || (\u0275BuiltInControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(BuiltInControlValueAccessor)))(t || BuiltInControlValueAccessor);
      };
    }();
    BuiltInControlValueAccessor.\u0275dir = \u0275\u0275defineDirective({
      type: BuiltInControlValueAccessor,
      features: [\u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(BuiltInControlValueAccessor, [{
        type: Directive
      }], null, null);
    })();
    NG_VALUE_ACCESSOR = new InjectionToken("NgValueAccessor");
    CHECKBOX_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => CheckboxControlValueAccessor),
      multi: true
    };
    CheckboxControlValueAccessor = class extends BuiltInControlValueAccessor {
      writeValue(value) {
        this.setProperty("checked", value);
      }
    };
    CheckboxControlValueAccessor.\u0275fac = function() {
      let \u0275CheckboxControlValueAccessor_BaseFactory;
      return function CheckboxControlValueAccessor_Factory(t) {
        return (\u0275CheckboxControlValueAccessor_BaseFactory || (\u0275CheckboxControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(CheckboxControlValueAccessor)))(t || CheckboxControlValueAccessor);
      };
    }();
    CheckboxControlValueAccessor.\u0275dir = \u0275\u0275defineDirective({
      type: CheckboxControlValueAccessor,
      selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]],
      hostBindings: function CheckboxControlValueAccessor_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("change", function CheckboxControlValueAccessor_change_HostBindingHandler($event) {
            return ctx.onChange($event.target.checked);
          })("blur", function CheckboxControlValueAccessor_blur_HostBindingHandler() {
            return ctx.onTouched();
          });
        }
      },
      features: [\u0275\u0275ProvidersFeature([CHECKBOX_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(CheckboxControlValueAccessor, [{
        type: Directive,
        args: [{
          selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]",
          host: {
            "(change)": "onChange($event.target.checked)",
            "(blur)": "onTouched()"
          },
          providers: [CHECKBOX_VALUE_ACCESSOR]
        }]
      }], null, null);
    })();
    DEFAULT_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => DefaultValueAccessor),
      multi: true
    };
    COMPOSITION_BUFFER_MODE = new InjectionToken("CompositionEventMode");
    DefaultValueAccessor = class extends BaseControlValueAccessor {
      constructor(renderer, elementRef, _compositionMode) {
        super(renderer, elementRef);
        this._compositionMode = _compositionMode;
        this._composing = false;
        if (this._compositionMode == null) {
          this._compositionMode = !_isAndroid();
        }
      }
      writeValue(value) {
        const normalizedValue = value == null ? "" : value;
        this.setProperty("value", normalizedValue);
      }
      _handleInput(value) {
        if (!this._compositionMode || this._compositionMode && !this._composing) {
          this.onChange(value);
        }
      }
      _compositionStart() {
        this._composing = true;
      }
      _compositionEnd(value) {
        this._composing = false;
        this._compositionMode && this.onChange(value);
      }
    };
    DefaultValueAccessor.\u0275fac = function DefaultValueAccessor_Factory(t) {
      return new (t || DefaultValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(COMPOSITION_BUFFER_MODE, 8));
    };
    DefaultValueAccessor.\u0275dir = \u0275\u0275defineDirective({
      type: DefaultValueAccessor,
      selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]],
      hostBindings: function DefaultValueAccessor_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("input", function DefaultValueAccessor_input_HostBindingHandler($event) {
            return ctx._handleInput($event.target.value);
          })("blur", function DefaultValueAccessor_blur_HostBindingHandler() {
            return ctx.onTouched();
          })("compositionstart", function DefaultValueAccessor_compositionstart_HostBindingHandler() {
            return ctx._compositionStart();
          })("compositionend", function DefaultValueAccessor_compositionend_HostBindingHandler($event) {
            return ctx._compositionEnd($event.target.value);
          });
        }
      },
      features: [\u0275\u0275ProvidersFeature([DEFAULT_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(DefaultValueAccessor, [{
        type: Directive,
        args: [{
          selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]",
          host: {
            "(input)": "$any(this)._handleInput($event.target.value)",
            "(blur)": "onTouched()",
            "(compositionstart)": "$any(this)._compositionStart()",
            "(compositionend)": "$any(this)._compositionEnd($event.target.value)"
          },
          providers: [DEFAULT_VALUE_ACCESSOR]
        }]
      }], function() {
        return [{
          type: Renderer2
        }, {
          type: ElementRef
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Inject,
            args: [COMPOSITION_BUFFER_MODE]
          }]
        }];
      }, null);
    })();
    NG_DEV_MODE$1 = typeof define_ngDevMode_default === "undefined" || !!define_ngDevMode_default;
    NG_VALIDATORS = new InjectionToken("NgValidators");
    NG_ASYNC_VALIDATORS = new InjectionToken("NgAsyncValidators");
    EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    Validators = class {
      static min(min2) {
        return minValidator(min2);
      }
      static max(max2) {
        return maxValidator(max2);
      }
      static required(control) {
        return requiredValidator(control);
      }
      static requiredTrue(control) {
        return requiredTrueValidator(control);
      }
      static email(control) {
        return emailValidator(control);
      }
      static minLength(minLength) {
        return minLengthValidator(minLength);
      }
      static maxLength(maxLength) {
        return maxLengthValidator(maxLength);
      }
      static pattern(pattern) {
        return patternValidator(pattern);
      }
      static nullValidator(control) {
        return nullValidator(control);
      }
      static compose(validators) {
        return compose(validators);
      }
      static composeAsync(validators) {
        return composeAsync(validators);
      }
    };
    AbstractControlDirective = class {
      constructor() {
        this._rawValidators = [];
        this._rawAsyncValidators = [];
        this._onDestroyCallbacks = [];
      }
      get value() {
        return this.control ? this.control.value : null;
      }
      get valid() {
        return this.control ? this.control.valid : null;
      }
      get invalid() {
        return this.control ? this.control.invalid : null;
      }
      get pending() {
        return this.control ? this.control.pending : null;
      }
      get disabled() {
        return this.control ? this.control.disabled : null;
      }
      get enabled() {
        return this.control ? this.control.enabled : null;
      }
      get errors() {
        return this.control ? this.control.errors : null;
      }
      get pristine() {
        return this.control ? this.control.pristine : null;
      }
      get dirty() {
        return this.control ? this.control.dirty : null;
      }
      get touched() {
        return this.control ? this.control.touched : null;
      }
      get status() {
        return this.control ? this.control.status : null;
      }
      get untouched() {
        return this.control ? this.control.untouched : null;
      }
      get statusChanges() {
        return this.control ? this.control.statusChanges : null;
      }
      get valueChanges() {
        return this.control ? this.control.valueChanges : null;
      }
      get path() {
        return null;
      }
      _setValidators(validators) {
        this._rawValidators = validators || [];
        this._composedValidatorFn = composeValidators(this._rawValidators);
      }
      _setAsyncValidators(validators) {
        this._rawAsyncValidators = validators || [];
        this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
      }
      get validator() {
        return this._composedValidatorFn || null;
      }
      get asyncValidator() {
        return this._composedAsyncValidatorFn || null;
      }
      _registerOnDestroy(fn2) {
        this._onDestroyCallbacks.push(fn2);
      }
      _invokeOnDestroyCallbacks() {
        this._onDestroyCallbacks.forEach((fn2) => fn2());
        this._onDestroyCallbacks = [];
      }
      reset(value = void 0) {
        if (this.control)
          this.control.reset(value);
      }
      hasError(errorCode, path) {
        return this.control ? this.control.hasError(errorCode, path) : false;
      }
      getError(errorCode, path) {
        return this.control ? this.control.getError(errorCode, path) : null;
      }
    };
    NgControl = class extends AbstractControlDirective {
      constructor() {
        super(...arguments);
        this._parent = null;
        this.name = null;
        this.valueAccessor = null;
      }
    };
    ControlContainer = class extends AbstractControlDirective {
      get formDirective() {
        return null;
      }
      get path() {
        return null;
      }
    };
    AbstractControlStatus = class {
      constructor(cd) {
        this._cd = cd;
      }
      get isTouched() {
        var _a, _b;
        return !!((_b = (_a = this._cd) === null || _a === void 0 ? void 0 : _a.control) === null || _b === void 0 ? void 0 : _b.touched);
      }
      get isUntouched() {
        var _a, _b;
        return !!((_b = (_a = this._cd) === null || _a === void 0 ? void 0 : _a.control) === null || _b === void 0 ? void 0 : _b.untouched);
      }
      get isPristine() {
        var _a, _b;
        return !!((_b = (_a = this._cd) === null || _a === void 0 ? void 0 : _a.control) === null || _b === void 0 ? void 0 : _b.pristine);
      }
      get isDirty() {
        var _a, _b;
        return !!((_b = (_a = this._cd) === null || _a === void 0 ? void 0 : _a.control) === null || _b === void 0 ? void 0 : _b.dirty);
      }
      get isValid() {
        var _a, _b;
        return !!((_b = (_a = this._cd) === null || _a === void 0 ? void 0 : _a.control) === null || _b === void 0 ? void 0 : _b.valid);
      }
      get isInvalid() {
        var _a, _b;
        return !!((_b = (_a = this._cd) === null || _a === void 0 ? void 0 : _a.control) === null || _b === void 0 ? void 0 : _b.invalid);
      }
      get isPending() {
        var _a, _b;
        return !!((_b = (_a = this._cd) === null || _a === void 0 ? void 0 : _a.control) === null || _b === void 0 ? void 0 : _b.pending);
      }
      get isSubmitted() {
        var _a;
        return !!((_a = this._cd) === null || _a === void 0 ? void 0 : _a.submitted);
      }
    };
    ngControlStatusHost = {
      "[class.ng-untouched]": "isUntouched",
      "[class.ng-touched]": "isTouched",
      "[class.ng-pristine]": "isPristine",
      "[class.ng-dirty]": "isDirty",
      "[class.ng-valid]": "isValid",
      "[class.ng-invalid]": "isInvalid",
      "[class.ng-pending]": "isPending"
    };
    ngGroupStatusHost = Object.assign(Object.assign({}, ngControlStatusHost), {
      "[class.ng-submitted]": "isSubmitted"
    });
    NgControlStatus = class extends AbstractControlStatus {
      constructor(cd) {
        super(cd);
      }
    };
    NgControlStatus.\u0275fac = function NgControlStatus_Factory(t) {
      return new (t || NgControlStatus)(\u0275\u0275directiveInject(NgControl, 2));
    };
    NgControlStatus.\u0275dir = \u0275\u0275defineDirective({
      type: NgControlStatus,
      selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]],
      hostVars: 14,
      hostBindings: function NgControlStatus_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending);
        }
      },
      features: [\u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgControlStatus, [{
        type: Directive,
        args: [{
          selector: "[formControlName],[ngModel],[formControl]",
          host: ngControlStatusHost
        }]
      }], function() {
        return [{
          type: NgControl,
          decorators: [{
            type: Self
          }]
        }];
      }, null);
    })();
    NgControlStatusGroup = class extends AbstractControlStatus {
      constructor(cd) {
        super(cd);
      }
    };
    NgControlStatusGroup.\u0275fac = function NgControlStatusGroup_Factory(t) {
      return new (t || NgControlStatusGroup)(\u0275\u0275directiveInject(ControlContainer, 10));
    };
    NgControlStatusGroup.\u0275dir = \u0275\u0275defineDirective({
      type: NgControlStatusGroup,
      selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]],
      hostVars: 16,
      hostBindings: function NgControlStatusGroup_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending)("ng-submitted", ctx.isSubmitted);
        }
      },
      features: [\u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgControlStatusGroup, [{
        type: Directive,
        args: [{
          selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]",
          host: ngGroupStatusHost
        }]
      }], function() {
        return [{
          type: ControlContainer,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }]
        }];
      }, null);
    })();
    formControlNameExample = `
  <div [formGroup]="myGroup">
    <input formControlName="firstName">
  </div>

  In your class:

  this.myGroup = new FormGroup({
      firstName: new FormControl()
  });`;
    formGroupNameExample = `
  <div [formGroup]="myGroup">
      <div formGroupName="person">
        <input formControlName="firstName">
      </div>
  </div>

  In your class:

  this.myGroup = new FormGroup({
      person: new FormGroup({ firstName: new FormControl() })
  });`;
    formArrayNameExample = `
  <div [formGroup]="myGroup">
    <div formArrayName="cities">
      <div *ngFor="let city of cityArray.controls; index as i">
        <input [formControlName]="i">
      </div>
    </div>
  </div>

  In your class:

  this.cityArray = new FormArray([new FormControl('SF')]);
  this.myGroup = new FormGroup({
    cities: this.cityArray
  });`;
    ngModelGroupExample = `
  <form>
      <div ngModelGroup="person">
        <input [(ngModel)]="person.name" name="firstName">
      </div>
  </form>`;
    ngModelWithFormGroupExample = `
  <div [formGroup]="myGroup">
      <input formControlName="firstName">
      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">
  </div>
`;
    disabledAttrWarning = `
  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true
  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for
  you. We recommend using this approach to avoid 'changed after checked' errors.

  Example:
  form = new FormGroup({
    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),
    last: new FormControl('Drew', Validators.required)
  });
`;
    asyncValidatorsDroppedWithOptsWarning = `
  It looks like you're constructing using a FormControl with both an options argument and an
  async validators argument. Mixing these arguments will cause your async validators to be dropped.
  You should either put all your validators in the options object, or in separate validators
  arguments. For example:

  // Using validators arguments
  fc = new FormControl(42, Validators.required, myAsyncValidator);

  // Using AbstractControlOptions
  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});

  // Do NOT mix them: async validators will be dropped!
  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);
`;
    NG_DEV_MODE3 = typeof define_ngDevMode_default === "undefined" || !!define_ngDevMode_default;
    VALID = "VALID";
    INVALID = "INVALID";
    PENDING = "PENDING";
    DISABLED = "DISABLED";
    AbstractControl = class {
      constructor(validators, asyncValidators) {
        this._pendingDirty = false;
        this._hasOwnPendingAsyncValidator = false;
        this._pendingTouched = false;
        this._onCollectionChange = () => {
        };
        this._parent = null;
        this.pristine = true;
        this.touched = false;
        this._onDisabledChange = [];
        this._rawValidators = validators;
        this._rawAsyncValidators = asyncValidators;
        this._composedValidatorFn = coerceToValidator(this._rawValidators);
        this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
      }
      get validator() {
        return this._composedValidatorFn;
      }
      set validator(validatorFn) {
        this._rawValidators = this._composedValidatorFn = validatorFn;
      }
      get asyncValidator() {
        return this._composedAsyncValidatorFn;
      }
      set asyncValidator(asyncValidatorFn) {
        this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
      }
      get parent() {
        return this._parent;
      }
      get valid() {
        return this.status === VALID;
      }
      get invalid() {
        return this.status === INVALID;
      }
      get pending() {
        return this.status == PENDING;
      }
      get disabled() {
        return this.status === DISABLED;
      }
      get enabled() {
        return this.status !== DISABLED;
      }
      get dirty() {
        return !this.pristine;
      }
      get untouched() {
        return !this.touched;
      }
      get updateOn() {
        return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change";
      }
      setValidators(validators) {
        this._rawValidators = validators;
        this._composedValidatorFn = coerceToValidator(validators);
      }
      setAsyncValidators(validators) {
        this._rawAsyncValidators = validators;
        this._composedAsyncValidatorFn = coerceToAsyncValidator(validators);
      }
      addValidators(validators) {
        this.setValidators(addValidators(validators, this._rawValidators));
      }
      addAsyncValidators(validators) {
        this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
      }
      removeValidators(validators) {
        this.setValidators(removeValidators(validators, this._rawValidators));
      }
      removeAsyncValidators(validators) {
        this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
      }
      hasValidator(validator) {
        return hasValidator(this._rawValidators, validator);
      }
      hasAsyncValidator(validator) {
        return hasValidator(this._rawAsyncValidators, validator);
      }
      clearValidators() {
        this.validator = null;
      }
      clearAsyncValidators() {
        this.asyncValidator = null;
      }
      markAsTouched(opts = {}) {
        this.touched = true;
        if (this._parent && !opts.onlySelf) {
          this._parent.markAsTouched(opts);
        }
      }
      markAllAsTouched() {
        this.markAsTouched({
          onlySelf: true
        });
        this._forEachChild((control) => control.markAllAsTouched());
      }
      markAsUntouched(opts = {}) {
        this.touched = false;
        this._pendingTouched = false;
        this._forEachChild((control) => {
          control.markAsUntouched({
            onlySelf: true
          });
        });
        if (this._parent && !opts.onlySelf) {
          this._parent._updateTouched(opts);
        }
      }
      markAsDirty(opts = {}) {
        this.pristine = false;
        if (this._parent && !opts.onlySelf) {
          this._parent.markAsDirty(opts);
        }
      }
      markAsPristine(opts = {}) {
        this.pristine = true;
        this._pendingDirty = false;
        this._forEachChild((control) => {
          control.markAsPristine({
            onlySelf: true
          });
        });
        if (this._parent && !opts.onlySelf) {
          this._parent._updatePristine(opts);
        }
      }
      markAsPending(opts = {}) {
        this.status = PENDING;
        if (opts.emitEvent !== false) {
          this.statusChanges.emit(this.status);
        }
        if (this._parent && !opts.onlySelf) {
          this._parent.markAsPending(opts);
        }
      }
      disable(opts = {}) {
        const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
        this.status = DISABLED;
        this.errors = null;
        this._forEachChild((control) => {
          control.disable(Object.assign(Object.assign({}, opts), {
            onlySelf: true
          }));
        });
        this._updateValue();
        if (opts.emitEvent !== false) {
          this.valueChanges.emit(this.value);
          this.statusChanges.emit(this.status);
        }
        this._updateAncestors(Object.assign(Object.assign({}, opts), {
          skipPristineCheck
        }));
        this._onDisabledChange.forEach((changeFn) => changeFn(true));
      }
      enable(opts = {}) {
        const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
        this.status = VALID;
        this._forEachChild((control) => {
          control.enable(Object.assign(Object.assign({}, opts), {
            onlySelf: true
          }));
        });
        this.updateValueAndValidity({
          onlySelf: true,
          emitEvent: opts.emitEvent
        });
        this._updateAncestors(Object.assign(Object.assign({}, opts), {
          skipPristineCheck
        }));
        this._onDisabledChange.forEach((changeFn) => changeFn(false));
      }
      _updateAncestors(opts) {
        if (this._parent && !opts.onlySelf) {
          this._parent.updateValueAndValidity(opts);
          if (!opts.skipPristineCheck) {
            this._parent._updatePristine();
          }
          this._parent._updateTouched();
        }
      }
      setParent(parent) {
        this._parent = parent;
      }
      getRawValue() {
        return this.value;
      }
      updateValueAndValidity(opts = {}) {
        this._setInitialStatus();
        this._updateValue();
        if (this.enabled) {
          this._cancelExistingSubscription();
          this.errors = this._runValidator();
          this.status = this._calculateStatus();
          if (this.status === VALID || this.status === PENDING) {
            this._runAsyncValidator(opts.emitEvent);
          }
        }
        if (opts.emitEvent !== false) {
          this.valueChanges.emit(this.value);
          this.statusChanges.emit(this.status);
        }
        if (this._parent && !opts.onlySelf) {
          this._parent.updateValueAndValidity(opts);
        }
      }
      _updateTreeValidity(opts = {
        emitEvent: true
      }) {
        this._forEachChild((ctrl) => ctrl._updateTreeValidity(opts));
        this.updateValueAndValidity({
          onlySelf: true,
          emitEvent: opts.emitEvent
        });
      }
      _setInitialStatus() {
        this.status = this._allControlsDisabled() ? DISABLED : VALID;
      }
      _runValidator() {
        return this.validator ? this.validator(this) : null;
      }
      _runAsyncValidator(emitEvent) {
        if (this.asyncValidator) {
          this.status = PENDING;
          this._hasOwnPendingAsyncValidator = true;
          const obs = toObservable(this.asyncValidator(this));
          this._asyncValidationSubscription = obs.subscribe((errors) => {
            this._hasOwnPendingAsyncValidator = false;
            this.setErrors(errors, {
              emitEvent
            });
          });
        }
      }
      _cancelExistingSubscription() {
        if (this._asyncValidationSubscription) {
          this._asyncValidationSubscription.unsubscribe();
          this._hasOwnPendingAsyncValidator = false;
        }
      }
      setErrors(errors, opts = {}) {
        this.errors = errors;
        this._updateControlsErrors(opts.emitEvent !== false);
      }
      get(path) {
        let currPath = path;
        if (currPath == null)
          return null;
        if (!Array.isArray(currPath))
          currPath = currPath.split(".");
        if (currPath.length === 0)
          return null;
        return currPath.reduce((control, name) => control && control._find(name), this);
      }
      getError(errorCode, path) {
        const control = path ? this.get(path) : this;
        return control && control.errors ? control.errors[errorCode] : null;
      }
      hasError(errorCode, path) {
        return !!this.getError(errorCode, path);
      }
      get root() {
        let x = this;
        while (x._parent) {
          x = x._parent;
        }
        return x;
      }
      _updateControlsErrors(emitEvent) {
        this.status = this._calculateStatus();
        if (emitEvent) {
          this.statusChanges.emit(this.status);
        }
        if (this._parent) {
          this._parent._updateControlsErrors(emitEvent);
        }
      }
      _initObservables() {
        this.valueChanges = new EventEmitter();
        this.statusChanges = new EventEmitter();
      }
      _calculateStatus() {
        if (this._allControlsDisabled())
          return DISABLED;
        if (this.errors)
          return INVALID;
        if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING))
          return PENDING;
        if (this._anyControlsHaveStatus(INVALID))
          return INVALID;
        return VALID;
      }
      _anyControlsHaveStatus(status) {
        return this._anyControls((control) => control.status === status);
      }
      _anyControlsDirty() {
        return this._anyControls((control) => control.dirty);
      }
      _anyControlsTouched() {
        return this._anyControls((control) => control.touched);
      }
      _updatePristine(opts = {}) {
        this.pristine = !this._anyControlsDirty();
        if (this._parent && !opts.onlySelf) {
          this._parent._updatePristine(opts);
        }
      }
      _updateTouched(opts = {}) {
        this.touched = this._anyControlsTouched();
        if (this._parent && !opts.onlySelf) {
          this._parent._updateTouched(opts);
        }
      }
      _registerOnCollectionChange(fn2) {
        this._onCollectionChange = fn2;
      }
      _setUpdateStrategy(opts) {
        if (isOptionsObj(opts) && opts.updateOn != null) {
          this._updateOn = opts.updateOn;
        }
      }
      _parentMarkedDirty(onlySelf) {
        const parentDirty = this._parent && this._parent.dirty;
        return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
      }
      _find(name) {
        return null;
      }
    };
    FormGroup = class extends AbstractControl {
      constructor(controls, validatorOrOpts, asyncValidator) {
        super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
        this.controls = controls;
        this._initObservables();
        this._setUpdateStrategy(validatorOrOpts);
        this._setUpControls();
        this.updateValueAndValidity({
          onlySelf: true,
          emitEvent: !!this.asyncValidator
        });
      }
      registerControl(name, control) {
        if (this.controls[name])
          return this.controls[name];
        this.controls[name] = control;
        control.setParent(this);
        control._registerOnCollectionChange(this._onCollectionChange);
        return control;
      }
      addControl(name, control, options = {}) {
        this.registerControl(name, control);
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
        this._onCollectionChange();
      }
      removeControl(name, options = {}) {
        if (this.controls[name])
          this.controls[name]._registerOnCollectionChange(() => {
          });
        delete this.controls[name];
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
        this._onCollectionChange();
      }
      setControl(name, control, options = {}) {
        if (this.controls[name])
          this.controls[name]._registerOnCollectionChange(() => {
          });
        delete this.controls[name];
        if (control)
          this.registerControl(name, control);
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
        this._onCollectionChange();
      }
      contains(controlName) {
        return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
      }
      setValue(value, options = {}) {
        assertAllValuesPresent(this, true, value);
        Object.keys(value).forEach((name) => {
          assertControlPresent(this, true, name);
          this.controls[name].setValue(value[name], {
            onlySelf: true,
            emitEvent: options.emitEvent
          });
        });
        this.updateValueAndValidity(options);
      }
      patchValue(value, options = {}) {
        if (value == null)
          return;
        Object.keys(value).forEach((name) => {
          const control = this.controls[name];
          if (control) {
            control.patchValue(
              value[name],
              {
                onlySelf: true,
                emitEvent: options.emitEvent
              }
            );
          }
        });
        this.updateValueAndValidity(options);
      }
      reset(value = {}, options = {}) {
        this._forEachChild((control, name) => {
          control.reset(value[name], {
            onlySelf: true,
            emitEvent: options.emitEvent
          });
        });
        this._updatePristine(options);
        this._updateTouched(options);
        this.updateValueAndValidity(options);
      }
      getRawValue() {
        return this._reduceChildren({}, (acc, control, name) => {
          acc[name] = control.getRawValue();
          return acc;
        });
      }
      _syncPendingControls() {
        let subtreeUpdated = this._reduceChildren(false, (updated, child) => {
          return child._syncPendingControls() ? true : updated;
        });
        if (subtreeUpdated)
          this.updateValueAndValidity({
            onlySelf: true
          });
        return subtreeUpdated;
      }
      _forEachChild(cb) {
        Object.keys(this.controls).forEach((key) => {
          const control = this.controls[key];
          control && cb(control, key);
        });
      }
      _setUpControls() {
        this._forEachChild((control) => {
          control.setParent(this);
          control._registerOnCollectionChange(this._onCollectionChange);
        });
      }
      _updateValue() {
        this.value = this._reduceValue();
      }
      _anyControls(condition) {
        for (const [controlName, control] of Object.entries(this.controls)) {
          if (this.contains(controlName) && condition(control)) {
            return true;
          }
        }
        return false;
      }
      _reduceValue() {
        let acc = {};
        return this._reduceChildren(acc, (acc2, control, name) => {
          if (control.enabled || this.disabled) {
            acc2[name] = control.value;
          }
          return acc2;
        });
      }
      _reduceChildren(initValue, fn2) {
        let res = initValue;
        this._forEachChild((control, name) => {
          res = fn2(res, control, name);
        });
        return res;
      }
      _allControlsDisabled() {
        for (const controlName of Object.keys(this.controls)) {
          if (this.controls[controlName].enabled) {
            return false;
          }
        }
        return Object.keys(this.controls).length > 0 || this.disabled;
      }
      _find(name) {
        return this.controls.hasOwnProperty(name) ? this.controls[name] : null;
      }
    };
    UntypedFormGroup = FormGroup;
    FormRecord = class extends FormGroup {
    };
    formDirectiveProvider$1 = {
      provide: ControlContainer,
      useExisting: forwardRef(() => NgForm)
    };
    resolvedPromise$1 = (() => Promise.resolve(null))();
    NgForm = class extends ControlContainer {
      constructor(validators, asyncValidators) {
        super();
        this.submitted = false;
        this._directives = /* @__PURE__ */ new Set();
        this.ngSubmit = new EventEmitter();
        this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
      }
      ngAfterViewInit() {
        this._setUpdateStrategy();
      }
      get formDirective() {
        return this;
      }
      get control() {
        return this.form;
      }
      get path() {
        return [];
      }
      get controls() {
        return this.form.controls;
      }
      addControl(dir) {
        resolvedPromise$1.then(() => {
          const container = this._findContainer(dir.path);
          dir.control = container.registerControl(dir.name, dir.control);
          setUpControl(dir.control, dir);
          dir.control.updateValueAndValidity({
            emitEvent: false
          });
          this._directives.add(dir);
        });
      }
      getControl(dir) {
        return this.form.get(dir.path);
      }
      removeControl(dir) {
        resolvedPromise$1.then(() => {
          const container = this._findContainer(dir.path);
          if (container) {
            container.removeControl(dir.name);
          }
          this._directives.delete(dir);
        });
      }
      addFormGroup(dir) {
        resolvedPromise$1.then(() => {
          const container = this._findContainer(dir.path);
          const group = new FormGroup({});
          setUpFormContainer(group, dir);
          container.registerControl(dir.name, group);
          group.updateValueAndValidity({
            emitEvent: false
          });
        });
      }
      removeFormGroup(dir) {
        resolvedPromise$1.then(() => {
          const container = this._findContainer(dir.path);
          if (container) {
            container.removeControl(dir.name);
          }
        });
      }
      getFormGroup(dir) {
        return this.form.get(dir.path);
      }
      updateModel(dir, value) {
        resolvedPromise$1.then(() => {
          const ctrl = this.form.get(dir.path);
          ctrl.setValue(value);
        });
      }
      setValue(value) {
        this.control.setValue(value);
      }
      onSubmit($event) {
        this.submitted = true;
        syncPendingControls(this.form, this._directives);
        this.ngSubmit.emit($event);
        return false;
      }
      onReset() {
        this.resetForm();
      }
      resetForm(value = void 0) {
        this.form.reset(value);
        this.submitted = false;
      }
      _setUpdateStrategy() {
        if (this.options && this.options.updateOn != null) {
          this.form._updateOn = this.options.updateOn;
        }
      }
      _findContainer(path) {
        path.pop();
        return path.length ? this.form.get(path) : this.form;
      }
    };
    NgForm.\u0275fac = function NgForm_Factory(t) {
      return new (t || NgForm)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
    };
    NgForm.\u0275dir = \u0275\u0275defineDirective({
      type: NgForm,
      selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]],
      hostBindings: function NgForm_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("submit", function NgForm_submit_HostBindingHandler($event) {
            return ctx.onSubmit($event);
          })("reset", function NgForm_reset_HostBindingHandler() {
            return ctx.onReset();
          });
        }
      },
      inputs: {
        options: ["ngFormOptions", "options"]
      },
      outputs: {
        ngSubmit: "ngSubmit"
      },
      exportAs: ["ngForm"],
      features: [\u0275\u0275ProvidersFeature([formDirectiveProvider$1]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgForm, [{
        type: Directive,
        args: [{
          selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]",
          providers: [formDirectiveProvider$1],
          host: {
            "(submit)": "onSubmit($event)",
            "(reset)": "onReset()"
          },
          outputs: ["ngSubmit"],
          exportAs: "ngForm"
        }]
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_VALIDATORS]
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_ASYNC_VALIDATORS]
          }]
        }];
      }, {
        options: [{
          type: Input,
          args: ["ngFormOptions"]
        }]
      });
    })();
    FormControl = class FormControl2 extends AbstractControl {
      constructor(formState = null, validatorOrOpts, asyncValidator) {
        super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
        this.defaultValue = null;
        this._onChange = [];
        this._pendingChange = false;
        this._applyFormState(formState);
        this._setUpdateStrategy(validatorOrOpts);
        this._initObservables();
        this.updateValueAndValidity({
          onlySelf: true,
          emitEvent: !!this.asyncValidator
        });
        if (isOptionsObj(validatorOrOpts) && (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {
          if (isFormControlState(formState)) {
            this.defaultValue = formState.value;
          } else {
            this.defaultValue = formState;
          }
        }
      }
      setValue(value, options = {}) {
        this.value = this._pendingValue = value;
        if (this._onChange.length && options.emitModelToViewChange !== false) {
          this._onChange.forEach((changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));
        }
        this.updateValueAndValidity(options);
      }
      patchValue(value, options = {}) {
        this.setValue(value, options);
      }
      reset(formState = this.defaultValue, options = {}) {
        this._applyFormState(formState);
        this.markAsPristine(options);
        this.markAsUntouched(options);
        this.setValue(this.value, options);
        this._pendingChange = false;
      }
      _updateValue() {
      }
      _anyControls(condition) {
        return false;
      }
      _allControlsDisabled() {
        return this.disabled;
      }
      registerOnChange(fn2) {
        this._onChange.push(fn2);
      }
      _unregisterOnChange(fn2) {
        removeListItem(this._onChange, fn2);
      }
      registerOnDisabledChange(fn2) {
        this._onDisabledChange.push(fn2);
      }
      _unregisterOnDisabledChange(fn2) {
        removeListItem(this._onDisabledChange, fn2);
      }
      _forEachChild(cb) {
      }
      _syncPendingControls() {
        if (this.updateOn === "submit") {
          if (this._pendingDirty)
            this.markAsDirty();
          if (this._pendingTouched)
            this.markAsTouched();
          if (this._pendingChange) {
            this.setValue(this._pendingValue, {
              onlySelf: true,
              emitModelToViewChange: false
            });
            return true;
          }
        }
        return false;
      }
      _applyFormState(formState) {
        if (isFormControlState(formState)) {
          this.value = this._pendingValue = formState.value;
          formState.disabled ? this.disable({
            onlySelf: true,
            emitEvent: false
          }) : this.enable({
            onlySelf: true,
            emitEvent: false
          });
        } else {
          this.value = this._pendingValue = formState;
        }
      }
    };
    UntypedFormControl = FormControl;
    isFormControl = (control) => control instanceof FormControl;
    AbstractFormGroupDirective = class extends ControlContainer {
      ngOnInit() {
        this._checkParentType();
        this.formDirective.addFormGroup(this);
      }
      ngOnDestroy() {
        if (this.formDirective) {
          this.formDirective.removeFormGroup(this);
        }
      }
      get control() {
        return this.formDirective.getFormGroup(this);
      }
      get path() {
        return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
      }
      get formDirective() {
        return this._parent ? this._parent.formDirective : null;
      }
      _checkParentType() {
      }
    };
    AbstractFormGroupDirective.\u0275fac = function() {
      let \u0275AbstractFormGroupDirective_BaseFactory;
      return function AbstractFormGroupDirective_Factory(t) {
        return (\u0275AbstractFormGroupDirective_BaseFactory || (\u0275AbstractFormGroupDirective_BaseFactory = \u0275\u0275getInheritedFactory(AbstractFormGroupDirective)))(t || AbstractFormGroupDirective);
      };
    }();
    AbstractFormGroupDirective.\u0275dir = \u0275\u0275defineDirective({
      type: AbstractFormGroupDirective,
      features: [\u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(AbstractFormGroupDirective, [{
        type: Directive
      }], null, null);
    })();
    modelGroupProvider = {
      provide: ControlContainer,
      useExisting: forwardRef(() => NgModelGroup)
    };
    NgModelGroup = class extends AbstractFormGroupDirective {
      constructor(parent, validators, asyncValidators) {
        super();
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
      }
      _checkParentType() {
        if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm) && (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default)) {
          throw modelGroupParentException();
        }
      }
    };
    NgModelGroup.\u0275fac = function NgModelGroup_Factory(t) {
      return new (t || NgModelGroup)(\u0275\u0275directiveInject(ControlContainer, 5), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
    };
    NgModelGroup.\u0275dir = \u0275\u0275defineDirective({
      type: NgModelGroup,
      selectors: [["", "ngModelGroup", ""]],
      inputs: {
        name: ["ngModelGroup", "name"]
      },
      exportAs: ["ngModelGroup"],
      features: [\u0275\u0275ProvidersFeature([modelGroupProvider]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgModelGroup, [{
        type: Directive,
        args: [{
          selector: "[ngModelGroup]",
          providers: [modelGroupProvider],
          exportAs: "ngModelGroup"
        }]
      }], function() {
        return [{
          type: ControlContainer,
          decorators: [{
            type: Host
          }, {
            type: SkipSelf
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_VALIDATORS]
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_ASYNC_VALIDATORS]
          }]
        }];
      }, {
        name: [{
          type: Input,
          args: ["ngModelGroup"]
        }]
      });
    })();
    formControlBinding$1 = {
      provide: NgControl,
      useExisting: forwardRef(() => NgModel)
    };
    resolvedPromise = (() => Promise.resolve(null))();
    NgModel = class extends NgControl {
      constructor(parent, validators, asyncValidators, valueAccessors, _changeDetectorRef) {
        super();
        this._changeDetectorRef = _changeDetectorRef;
        this.control = new FormControl();
        this._registered = false;
        this.update = new EventEmitter();
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
        this.valueAccessor = selectValueAccessor(this, valueAccessors);
      }
      ngOnChanges(changes) {
        this._checkForErrors();
        if (!this._registered || "name" in changes) {
          if (this._registered) {
            this._checkName();
            if (this.formDirective) {
              const oldName = changes["name"].previousValue;
              this.formDirective.removeControl({
                name: oldName,
                path: this._getPath(oldName)
              });
            }
          }
          this._setUpControl();
        }
        if ("isDisabled" in changes) {
          this._updateDisabled(changes);
        }
        if (isPropertyUpdated(changes, this.viewModel)) {
          this._updateValue(this.model);
          this.viewModel = this.model;
        }
      }
      ngOnDestroy() {
        this.formDirective && this.formDirective.removeControl(this);
      }
      get path() {
        return this._getPath(this.name);
      }
      get formDirective() {
        return this._parent ? this._parent.formDirective : null;
      }
      viewToModelUpdate(newValue) {
        this.viewModel = newValue;
        this.update.emit(newValue);
      }
      _setUpControl() {
        this._setUpdateStrategy();
        this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
        this._registered = true;
      }
      _setUpdateStrategy() {
        if (this.options && this.options.updateOn != null) {
          this.control._updateOn = this.options.updateOn;
        }
      }
      _isStandalone() {
        return !this._parent || !!(this.options && this.options.standalone);
      }
      _setUpStandalone() {
        setUpControl(this.control, this);
        this.control.updateValueAndValidity({
          emitEvent: false
        });
      }
      _checkForErrors() {
        if (!this._isStandalone()) {
          this._checkParentType();
        }
        this._checkName();
      }
      _checkParentType() {
        if (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) {
          if (!(this._parent instanceof NgModelGroup) && this._parent instanceof AbstractFormGroupDirective) {
            throw formGroupNameException();
          } else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
            throw modelParentException();
          }
        }
      }
      _checkName() {
        if (this.options && this.options.name)
          this.name = this.options.name;
        if (!this._isStandalone() && !this.name && (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default)) {
          throw missingNameException();
        }
      }
      _updateValue(value) {
        resolvedPromise.then(() => {
          var _a;
          this.control.setValue(value, {
            emitViewToModelChange: false
          });
          (_a = this._changeDetectorRef) === null || _a === void 0 ? void 0 : _a.markForCheck();
        });
      }
      _updateDisabled(changes) {
        const disabledValue = changes["isDisabled"].currentValue;
        const isDisabled = disabledValue !== 0 && coerceToBoolean(disabledValue);
        resolvedPromise.then(() => {
          var _a;
          if (isDisabled && !this.control.disabled) {
            this.control.disable();
          } else if (!isDisabled && this.control.disabled) {
            this.control.enable();
          }
          (_a = this._changeDetectorRef) === null || _a === void 0 ? void 0 : _a.markForCheck();
        });
      }
      _getPath(controlName) {
        return this._parent ? controlPath(controlName, this._parent) : [controlName];
      }
    };
    NgModel.\u0275fac = function NgModel_Factory(t) {
      return new (t || NgModel)(\u0275\u0275directiveInject(ControlContainer, 9), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(ChangeDetectorRef, 8));
    };
    NgModel.\u0275dir = \u0275\u0275defineDirective({
      type: NgModel,
      selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]],
      inputs: {
        name: "name",
        isDisabled: ["disabled", "isDisabled"],
        model: ["ngModel", "model"],
        options: ["ngModelOptions", "options"]
      },
      outputs: {
        update: "ngModelChange"
      },
      exportAs: ["ngModel"],
      features: [\u0275\u0275ProvidersFeature([formControlBinding$1]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgModel, [{
        type: Directive,
        args: [{
          selector: "[ngModel]:not([formControlName]):not([formControl])",
          providers: [formControlBinding$1],
          exportAs: "ngModel"
        }]
      }], function() {
        return [{
          type: ControlContainer,
          decorators: [{
            type: Optional
          }, {
            type: Host
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_VALIDATORS]
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_ASYNC_VALIDATORS]
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_VALUE_ACCESSOR]
          }]
        }, {
          type: ChangeDetectorRef,
          decorators: [{
            type: Optional
          }, {
            type: Inject,
            args: [ChangeDetectorRef]
          }]
        }];
      }, {
        name: [{
          type: Input
        }],
        isDisabled: [{
          type: Input,
          args: ["disabled"]
        }],
        model: [{
          type: Input,
          args: ["ngModel"]
        }],
        options: [{
          type: Input,
          args: ["ngModelOptions"]
        }],
        update: [{
          type: Output,
          args: ["ngModelChange"]
        }]
      });
    })();
    \u0275NgNoValidate = class {
    };
    \u0275NgNoValidate.\u0275fac = function \u0275NgNoValidate_Factory(t) {
      return new (t || \u0275NgNoValidate)();
    };
    \u0275NgNoValidate.\u0275dir = \u0275\u0275defineDirective({
      type: \u0275NgNoValidate,
      selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]],
      hostAttrs: ["novalidate", ""]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(\u0275NgNoValidate, [{
        type: Directive,
        args: [{
          selector: "form:not([ngNoForm]):not([ngNativeValidate])",
          host: {
            "novalidate": ""
          }
        }]
      }], null, null);
    })();
    NUMBER_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => NumberValueAccessor),
      multi: true
    };
    NumberValueAccessor = class extends BuiltInControlValueAccessor {
      writeValue(value) {
        const normalizedValue = value == null ? "" : value;
        this.setProperty("value", normalizedValue);
      }
      registerOnChange(fn2) {
        this.onChange = (value) => {
          fn2(value == "" ? null : parseFloat(value));
        };
      }
    };
    NumberValueAccessor.\u0275fac = function() {
      let \u0275NumberValueAccessor_BaseFactory;
      return function NumberValueAccessor_Factory(t) {
        return (\u0275NumberValueAccessor_BaseFactory || (\u0275NumberValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(NumberValueAccessor)))(t || NumberValueAccessor);
      };
    }();
    NumberValueAccessor.\u0275dir = \u0275\u0275defineDirective({
      type: NumberValueAccessor,
      selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]],
      hostBindings: function NumberValueAccessor_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("input", function NumberValueAccessor_input_HostBindingHandler($event) {
            return ctx.onChange($event.target.value);
          })("blur", function NumberValueAccessor_blur_HostBindingHandler() {
            return ctx.onTouched();
          });
        }
      },
      features: [\u0275\u0275ProvidersFeature([NUMBER_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NumberValueAccessor, [{
        type: Directive,
        args: [{
          selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]",
          host: {
            "(input)": "onChange($event.target.value)",
            "(blur)": "onTouched()"
          },
          providers: [NUMBER_VALUE_ACCESSOR]
        }]
      }], null, null);
    })();
    RADIO_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => RadioControlValueAccessor),
      multi: true
    };
    RadioControlRegistryModule = class {
    };
    RadioControlRegistryModule.\u0275fac = function RadioControlRegistryModule_Factory(t) {
      return new (t || RadioControlRegistryModule)();
    };
    RadioControlRegistryModule.\u0275mod = \u0275\u0275defineNgModule({
      type: RadioControlRegistryModule
    });
    RadioControlRegistryModule.\u0275inj = \u0275\u0275defineInjector({});
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(RadioControlRegistryModule, [{
        type: NgModule
      }], null, null);
    })();
    RadioControlRegistry = class {
      constructor() {
        this._accessors = [];
      }
      add(control, accessor) {
        this._accessors.push([control, accessor]);
      }
      remove(accessor) {
        for (let i = this._accessors.length - 1; i >= 0; --i) {
          if (this._accessors[i][1] === accessor) {
            this._accessors.splice(i, 1);
            return;
          }
        }
      }
      select(accessor) {
        this._accessors.forEach((c) => {
          if (this._isSameGroup(c, accessor) && c[1] !== accessor) {
            c[1].fireUncheck(accessor.value);
          }
        });
      }
      _isSameGroup(controlPair, accessor) {
        if (!controlPair[0].control)
          return false;
        return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;
      }
    };
    RadioControlRegistry.\u0275fac = function RadioControlRegistry_Factory(t) {
      return new (t || RadioControlRegistry)();
    };
    RadioControlRegistry.\u0275prov = \u0275\u0275defineInjectable({
      token: RadioControlRegistry,
      factory: RadioControlRegistry.\u0275fac,
      providedIn: RadioControlRegistryModule
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(RadioControlRegistry, [{
        type: Injectable,
        args: [{
          providedIn: RadioControlRegistryModule
        }]
      }], null, null);
    })();
    RadioControlValueAccessor = class extends BuiltInControlValueAccessor {
      constructor(renderer, elementRef, _registry, _injector) {
        super(renderer, elementRef);
        this._registry = _registry;
        this._injector = _injector;
        this.onChange = () => {
        };
      }
      ngOnInit() {
        this._control = this._injector.get(NgControl);
        this._checkName();
        this._registry.add(this._control, this);
      }
      ngOnDestroy() {
        this._registry.remove(this);
      }
      writeValue(value) {
        this._state = value === this.value;
        this.setProperty("checked", this._state);
      }
      registerOnChange(fn2) {
        this._fn = fn2;
        this.onChange = () => {
          fn2(this.value);
          this._registry.select(this);
        };
      }
      fireUncheck(value) {
        this.writeValue(value);
      }
      _checkName() {
        if (this.name && this.formControlName && this.name !== this.formControlName && (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default)) {
          throwNameError();
        }
        if (!this.name && this.formControlName)
          this.name = this.formControlName;
      }
    };
    RadioControlValueAccessor.\u0275fac = function RadioControlValueAccessor_Factory(t) {
      return new (t || RadioControlValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(RadioControlRegistry), \u0275\u0275directiveInject(Injector));
    };
    RadioControlValueAccessor.\u0275dir = \u0275\u0275defineDirective({
      type: RadioControlValueAccessor,
      selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]],
      hostBindings: function RadioControlValueAccessor_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("change", function RadioControlValueAccessor_change_HostBindingHandler() {
            return ctx.onChange();
          })("blur", function RadioControlValueAccessor_blur_HostBindingHandler() {
            return ctx.onTouched();
          });
        }
      },
      inputs: {
        name: "name",
        formControlName: "formControlName",
        value: "value"
      },
      features: [\u0275\u0275ProvidersFeature([RADIO_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(RadioControlValueAccessor, [{
        type: Directive,
        args: [{
          selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]",
          host: {
            "(change)": "onChange()",
            "(blur)": "onTouched()"
          },
          providers: [RADIO_VALUE_ACCESSOR]
        }]
      }], function() {
        return [{
          type: Renderer2
        }, {
          type: ElementRef
        }, {
          type: RadioControlRegistry
        }, {
          type: Injector
        }];
      }, {
        name: [{
          type: Input
        }],
        formControlName: [{
          type: Input
        }],
        value: [{
          type: Input
        }]
      });
    })();
    RANGE_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => RangeValueAccessor),
      multi: true
    };
    RangeValueAccessor = class extends BuiltInControlValueAccessor {
      writeValue(value) {
        this.setProperty("value", parseFloat(value));
      }
      registerOnChange(fn2) {
        this.onChange = (value) => {
          fn2(value == "" ? null : parseFloat(value));
        };
      }
    };
    RangeValueAccessor.\u0275fac = function() {
      let \u0275RangeValueAccessor_BaseFactory;
      return function RangeValueAccessor_Factory(t) {
        return (\u0275RangeValueAccessor_BaseFactory || (\u0275RangeValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(RangeValueAccessor)))(t || RangeValueAccessor);
      };
    }();
    RangeValueAccessor.\u0275dir = \u0275\u0275defineDirective({
      type: RangeValueAccessor,
      selectors: [["input", "type", "range", "formControlName", ""], ["input", "type", "range", "formControl", ""], ["input", "type", "range", "ngModel", ""]],
      hostBindings: function RangeValueAccessor_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("change", function RangeValueAccessor_change_HostBindingHandler($event) {
            return ctx.onChange($event.target.value);
          })("input", function RangeValueAccessor_input_HostBindingHandler($event) {
            return ctx.onChange($event.target.value);
          })("blur", function RangeValueAccessor_blur_HostBindingHandler() {
            return ctx.onTouched();
          });
        }
      },
      features: [\u0275\u0275ProvidersFeature([RANGE_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(RangeValueAccessor, [{
        type: Directive,
        args: [{
          selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]",
          host: {
            "(change)": "onChange($event.target.value)",
            "(input)": "onChange($event.target.value)",
            "(blur)": "onTouched()"
          },
          providers: [RANGE_VALUE_ACCESSOR]
        }]
      }], null, null);
    })();
    NG_MODEL_WITH_FORM_CONTROL_WARNING = new InjectionToken("NgModelWithFormControlWarning");
    formControlBinding = {
      provide: NgControl,
      useExisting: forwardRef(() => FormControlDirective)
    };
    FormControlDirective = class extends NgControl {
      constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
        super();
        this._ngModelWarningConfig = _ngModelWarningConfig;
        this.update = new EventEmitter();
        this._ngModelWarningSent = false;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
        this.valueAccessor = selectValueAccessor(this, valueAccessors);
      }
      set isDisabled(isDisabled) {
        if (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) {
          console.warn(disabledAttrWarning);
        }
      }
      ngOnChanges(changes) {
        if (this._isControlChanged(changes)) {
          const previousForm = changes["form"].previousValue;
          if (previousForm) {
            cleanUpControl(
              previousForm,
              this,
              false
            );
          }
          setUpControl(this.form, this);
          this.form.updateValueAndValidity({
            emitEvent: false
          });
        }
        if (isPropertyUpdated(changes, this.viewModel)) {
          if (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) {
            _ngModelWarning("formControl", FormControlDirective, this, this._ngModelWarningConfig);
          }
          this.form.setValue(this.model);
          this.viewModel = this.model;
        }
      }
      ngOnDestroy() {
        if (this.form) {
          cleanUpControl(
            this.form,
            this,
            false
          );
        }
      }
      get path() {
        return [];
      }
      get control() {
        return this.form;
      }
      viewToModelUpdate(newValue) {
        this.viewModel = newValue;
        this.update.emit(newValue);
      }
      _isControlChanged(changes) {
        return changes.hasOwnProperty("form");
      }
    };
    FormControlDirective._ngModelWarningSentOnce = false;
    FormControlDirective.\u0275fac = function FormControlDirective_Factory(t) {
      return new (t || FormControlDirective)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
    };
    FormControlDirective.\u0275dir = \u0275\u0275defineDirective({
      type: FormControlDirective,
      selectors: [["", "formControl", ""]],
      inputs: {
        form: ["formControl", "form"],
        isDisabled: ["disabled", "isDisabled"],
        model: ["ngModel", "model"]
      },
      outputs: {
        update: "ngModelChange"
      },
      exportAs: ["ngForm"],
      features: [\u0275\u0275ProvidersFeature([formControlBinding]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(FormControlDirective, [{
        type: Directive,
        args: [{
          selector: "[formControl]",
          providers: [formControlBinding],
          exportAs: "ngForm"
        }]
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_VALIDATORS]
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_ASYNC_VALIDATORS]
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_VALUE_ACCESSOR]
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Inject,
            args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
          }]
        }];
      }, {
        form: [{
          type: Input,
          args: ["formControl"]
        }],
        isDisabled: [{
          type: Input,
          args: ["disabled"]
        }],
        model: [{
          type: Input,
          args: ["ngModel"]
        }],
        update: [{
          type: Output,
          args: ["ngModelChange"]
        }]
      });
    })();
    formDirectiveProvider = {
      provide: ControlContainer,
      useExisting: forwardRef(() => FormGroupDirective)
    };
    FormGroupDirective = class extends ControlContainer {
      constructor(validators, asyncValidators) {
        super();
        this.validators = validators;
        this.asyncValidators = asyncValidators;
        this.submitted = false;
        this._onCollectionChange = () => this._updateDomValue();
        this.directives = [];
        this.form = null;
        this.ngSubmit = new EventEmitter();
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
      }
      ngOnChanges(changes) {
        this._checkFormPresent();
        if (changes.hasOwnProperty("form")) {
          this._updateValidators();
          this._updateDomValue();
          this._updateRegistrations();
          this._oldForm = this.form;
        }
      }
      ngOnDestroy() {
        if (this.form) {
          cleanUpValidators(this.form, this);
          if (this.form._onCollectionChange === this._onCollectionChange) {
            this.form._registerOnCollectionChange(() => {
            });
          }
        }
      }
      get formDirective() {
        return this;
      }
      get control() {
        return this.form;
      }
      get path() {
        return [];
      }
      addControl(dir) {
        const ctrl = this.form.get(dir.path);
        setUpControl(ctrl, dir);
        ctrl.updateValueAndValidity({
          emitEvent: false
        });
        this.directives.push(dir);
        return ctrl;
      }
      getControl(dir) {
        return this.form.get(dir.path);
      }
      removeControl(dir) {
        cleanUpControl(
          dir.control || null,
          dir,
          false
        );
        removeListItem$1(this.directives, dir);
      }
      addFormGroup(dir) {
        this._setUpFormContainer(dir);
      }
      removeFormGroup(dir) {
        this._cleanUpFormContainer(dir);
      }
      getFormGroup(dir) {
        return this.form.get(dir.path);
      }
      addFormArray(dir) {
        this._setUpFormContainer(dir);
      }
      removeFormArray(dir) {
        this._cleanUpFormContainer(dir);
      }
      getFormArray(dir) {
        return this.form.get(dir.path);
      }
      updateModel(dir, value) {
        const ctrl = this.form.get(dir.path);
        ctrl.setValue(value);
      }
      onSubmit($event) {
        this.submitted = true;
        syncPendingControls(this.form, this.directives);
        this.ngSubmit.emit($event);
        return false;
      }
      onReset() {
        this.resetForm();
      }
      resetForm(value = void 0) {
        this.form.reset(value);
        this.submitted = false;
      }
      _updateDomValue() {
        this.directives.forEach((dir) => {
          const oldCtrl = dir.control;
          const newCtrl = this.form.get(dir.path);
          if (oldCtrl !== newCtrl) {
            cleanUpControl(oldCtrl || null, dir);
            if (isFormControl(newCtrl)) {
              setUpControl(newCtrl, dir);
              dir.control = newCtrl;
            }
          }
        });
        this.form._updateTreeValidity({
          emitEvent: false
        });
      }
      _setUpFormContainer(dir) {
        const ctrl = this.form.get(dir.path);
        setUpFormContainer(ctrl, dir);
        ctrl.updateValueAndValidity({
          emitEvent: false
        });
      }
      _cleanUpFormContainer(dir) {
        if (this.form) {
          const ctrl = this.form.get(dir.path);
          if (ctrl) {
            const isControlUpdated = cleanUpFormContainer(ctrl, dir);
            if (isControlUpdated) {
              ctrl.updateValueAndValidity({
                emitEvent: false
              });
            }
          }
        }
      }
      _updateRegistrations() {
        this.form._registerOnCollectionChange(this._onCollectionChange);
        if (this._oldForm) {
          this._oldForm._registerOnCollectionChange(() => {
          });
        }
      }
      _updateValidators() {
        setUpValidators(this.form, this);
        if (this._oldForm) {
          cleanUpValidators(this._oldForm, this);
        }
      }
      _checkFormPresent() {
        if (!this.form && (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default)) {
          throw missingFormException();
        }
      }
    };
    FormGroupDirective.\u0275fac = function FormGroupDirective_Factory(t) {
      return new (t || FormGroupDirective)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
    };
    FormGroupDirective.\u0275dir = \u0275\u0275defineDirective({
      type: FormGroupDirective,
      selectors: [["", "formGroup", ""]],
      hostBindings: function FormGroupDirective_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("submit", function FormGroupDirective_submit_HostBindingHandler($event) {
            return ctx.onSubmit($event);
          })("reset", function FormGroupDirective_reset_HostBindingHandler() {
            return ctx.onReset();
          });
        }
      },
      inputs: {
        form: ["formGroup", "form"]
      },
      outputs: {
        ngSubmit: "ngSubmit"
      },
      exportAs: ["ngForm"],
      features: [\u0275\u0275ProvidersFeature([formDirectiveProvider]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(FormGroupDirective, [{
        type: Directive,
        args: [{
          selector: "[formGroup]",
          providers: [formDirectiveProvider],
          host: {
            "(submit)": "onSubmit($event)",
            "(reset)": "onReset()"
          },
          exportAs: "ngForm"
        }]
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_VALIDATORS]
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_ASYNC_VALIDATORS]
          }]
        }];
      }, {
        form: [{
          type: Input,
          args: ["formGroup"]
        }],
        ngSubmit: [{
          type: Output
        }]
      });
    })();
    formGroupNameProvider = {
      provide: ControlContainer,
      useExisting: forwardRef(() => FormGroupName)
    };
    FormGroupName = class extends AbstractFormGroupDirective {
      constructor(parent, validators, asyncValidators) {
        super();
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
      }
      _checkParentType() {
        if (_hasInvalidParent(this._parent) && (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default)) {
          throw groupParentException();
        }
      }
    };
    FormGroupName.\u0275fac = function FormGroupName_Factory(t) {
      return new (t || FormGroupName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
    };
    FormGroupName.\u0275dir = \u0275\u0275defineDirective({
      type: FormGroupName,
      selectors: [["", "formGroupName", ""]],
      inputs: {
        name: ["formGroupName", "name"]
      },
      features: [\u0275\u0275ProvidersFeature([formGroupNameProvider]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(FormGroupName, [{
        type: Directive,
        args: [{
          selector: "[formGroupName]",
          providers: [formGroupNameProvider]
        }]
      }], function() {
        return [{
          type: ControlContainer,
          decorators: [{
            type: Optional
          }, {
            type: Host
          }, {
            type: SkipSelf
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_VALIDATORS]
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_ASYNC_VALIDATORS]
          }]
        }];
      }, {
        name: [{
          type: Input,
          args: ["formGroupName"]
        }]
      });
    })();
    formArrayNameProvider = {
      provide: ControlContainer,
      useExisting: forwardRef(() => FormArrayName)
    };
    FormArrayName = class extends ControlContainer {
      constructor(parent, validators, asyncValidators) {
        super();
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
      }
      ngOnInit() {
        this._checkParentType();
        this.formDirective.addFormArray(this);
      }
      ngOnDestroy() {
        if (this.formDirective) {
          this.formDirective.removeFormArray(this);
        }
      }
      get control() {
        return this.formDirective.getFormArray(this);
      }
      get formDirective() {
        return this._parent ? this._parent.formDirective : null;
      }
      get path() {
        return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
      }
      _checkParentType() {
        if (_hasInvalidParent(this._parent) && (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default)) {
          throw arrayParentException();
        }
      }
    };
    FormArrayName.\u0275fac = function FormArrayName_Factory(t) {
      return new (t || FormArrayName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
    };
    FormArrayName.\u0275dir = \u0275\u0275defineDirective({
      type: FormArrayName,
      selectors: [["", "formArrayName", ""]],
      inputs: {
        name: ["formArrayName", "name"]
      },
      features: [\u0275\u0275ProvidersFeature([formArrayNameProvider]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(FormArrayName, [{
        type: Directive,
        args: [{
          selector: "[formArrayName]",
          providers: [formArrayNameProvider]
        }]
      }], function() {
        return [{
          type: ControlContainer,
          decorators: [{
            type: Optional
          }, {
            type: Host
          }, {
            type: SkipSelf
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_VALIDATORS]
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_ASYNC_VALIDATORS]
          }]
        }];
      }, {
        name: [{
          type: Input,
          args: ["formArrayName"]
        }]
      });
    })();
    controlNameBinding = {
      provide: NgControl,
      useExisting: forwardRef(() => FormControlName)
    };
    FormControlName = class extends NgControl {
      constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
        super();
        this._ngModelWarningConfig = _ngModelWarningConfig;
        this._added = false;
        this.update = new EventEmitter();
        this._ngModelWarningSent = false;
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
        this.valueAccessor = selectValueAccessor(this, valueAccessors);
      }
      set isDisabled(isDisabled) {
        if (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) {
          console.warn(disabledAttrWarning);
        }
      }
      ngOnChanges(changes) {
        if (!this._added)
          this._setUpControl();
        if (isPropertyUpdated(changes, this.viewModel)) {
          if (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) {
            _ngModelWarning("formControlName", FormControlName, this, this._ngModelWarningConfig);
          }
          this.viewModel = this.model;
          this.formDirective.updateModel(this, this.model);
        }
      }
      ngOnDestroy() {
        if (this.formDirective) {
          this.formDirective.removeControl(this);
        }
      }
      viewToModelUpdate(newValue) {
        this.viewModel = newValue;
        this.update.emit(newValue);
      }
      get path() {
        return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
      }
      get formDirective() {
        return this._parent ? this._parent.formDirective : null;
      }
      _checkParentType() {
        if (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) {
          if (!(this._parent instanceof FormGroupName) && this._parent instanceof AbstractFormGroupDirective) {
            throw ngModelGroupException();
          } else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) && !(this._parent instanceof FormArrayName)) {
            throw controlParentException();
          }
        }
      }
      _setUpControl() {
        this._checkParentType();
        this.control = this.formDirective.addControl(this);
        this._added = true;
      }
    };
    FormControlName._ngModelWarningSentOnce = false;
    FormControlName.\u0275fac = function FormControlName_Factory(t) {
      return new (t || FormControlName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
    };
    FormControlName.\u0275dir = \u0275\u0275defineDirective({
      type: FormControlName,
      selectors: [["", "formControlName", ""]],
      inputs: {
        name: ["formControlName", "name"],
        isDisabled: ["disabled", "isDisabled"],
        model: ["ngModel", "model"]
      },
      outputs: {
        update: "ngModelChange"
      },
      features: [\u0275\u0275ProvidersFeature([controlNameBinding]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(FormControlName, [{
        type: Directive,
        args: [{
          selector: "[formControlName]",
          providers: [controlNameBinding]
        }]
      }], function() {
        return [{
          type: ControlContainer,
          decorators: [{
            type: Optional
          }, {
            type: Host
          }, {
            type: SkipSelf
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_VALIDATORS]
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_ASYNC_VALIDATORS]
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Self
          }, {
            type: Inject,
            args: [NG_VALUE_ACCESSOR]
          }]
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Inject,
            args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
          }]
        }];
      }, {
        name: [{
          type: Input,
          args: ["formControlName"]
        }],
        isDisabled: [{
          type: Input,
          args: ["disabled"]
        }],
        model: [{
          type: Input,
          args: ["ngModel"]
        }],
        update: [{
          type: Output,
          args: ["ngModelChange"]
        }]
      });
    })();
    SELECT_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => SelectControlValueAccessor),
      multi: true
    };
    SelectControlValueAccessor = class extends BuiltInControlValueAccessor {
      constructor() {
        super(...arguments);
        this._optionMap = /* @__PURE__ */ new Map();
        this._idCounter = 0;
        this._compareWith = Object.is;
      }
      set compareWith(fn2) {
        if (typeof fn2 !== "function" && (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default)) {
          throw new RuntimeError(
            1201,
            `compareWith must be a function, but received ${JSON.stringify(fn2)}`
          );
        }
        this._compareWith = fn2;
      }
      writeValue(value) {
        this.value = value;
        const id = this._getOptionId(value);
        const valueString = _buildValueString$1(id, value);
        this.setProperty("value", valueString);
      }
      registerOnChange(fn2) {
        this.onChange = (valueString) => {
          this.value = this._getOptionValue(valueString);
          fn2(this.value);
        };
      }
      _registerOption() {
        return (this._idCounter++).toString();
      }
      _getOptionId(value) {
        for (const id of Array.from(this._optionMap.keys())) {
          if (this._compareWith(this._optionMap.get(id), value))
            return id;
        }
        return null;
      }
      _getOptionValue(valueString) {
        const id = _extractId$1(valueString);
        return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
      }
    };
    SelectControlValueAccessor.\u0275fac = function() {
      let \u0275SelectControlValueAccessor_BaseFactory;
      return function SelectControlValueAccessor_Factory(t) {
        return (\u0275SelectControlValueAccessor_BaseFactory || (\u0275SelectControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(SelectControlValueAccessor)))(t || SelectControlValueAccessor);
      };
    }();
    SelectControlValueAccessor.\u0275dir = \u0275\u0275defineDirective({
      type: SelectControlValueAccessor,
      selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]],
      hostBindings: function SelectControlValueAccessor_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("change", function SelectControlValueAccessor_change_HostBindingHandler($event) {
            return ctx.onChange($event.target.value);
          })("blur", function SelectControlValueAccessor_blur_HostBindingHandler() {
            return ctx.onTouched();
          });
        }
      },
      inputs: {
        compareWith: "compareWith"
      },
      features: [\u0275\u0275ProvidersFeature([SELECT_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(SelectControlValueAccessor, [{
        type: Directive,
        args: [{
          selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]",
          host: {
            "(change)": "onChange($event.target.value)",
            "(blur)": "onTouched()"
          },
          providers: [SELECT_VALUE_ACCESSOR]
        }]
      }], null, {
        compareWith: [{
          type: Input
        }]
      });
    })();
    NgSelectOption = class {
      constructor(_element, _renderer, _select) {
        this._element = _element;
        this._renderer = _renderer;
        this._select = _select;
        if (this._select)
          this.id = this._select._registerOption();
      }
      set ngValue(value) {
        if (this._select == null)
          return;
        this._select._optionMap.set(this.id, value);
        this._setElementValue(_buildValueString$1(this.id, value));
        this._select.writeValue(this._select.value);
      }
      set value(value) {
        this._setElementValue(value);
        if (this._select)
          this._select.writeValue(this._select.value);
      }
      _setElementValue(value) {
        this._renderer.setProperty(this._element.nativeElement, "value", value);
      }
      ngOnDestroy() {
        if (this._select) {
          this._select._optionMap.delete(this.id);
          this._select.writeValue(this._select.value);
        }
      }
    };
    NgSelectOption.\u0275fac = function NgSelectOption_Factory(t) {
      return new (t || NgSelectOption)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(SelectControlValueAccessor, 9));
    };
    NgSelectOption.\u0275dir = \u0275\u0275defineDirective({
      type: NgSelectOption,
      selectors: [["option"]],
      inputs: {
        ngValue: "ngValue",
        value: "value"
      }
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NgSelectOption, [{
        type: Directive,
        args: [{
          selector: "option"
        }]
      }], function() {
        return [{
          type: ElementRef
        }, {
          type: Renderer2
        }, {
          type: SelectControlValueAccessor,
          decorators: [{
            type: Optional
          }, {
            type: Host
          }]
        }];
      }, {
        ngValue: [{
          type: Input,
          args: ["ngValue"]
        }],
        value: [{
          type: Input,
          args: ["value"]
        }]
      });
    })();
    SELECT_MULTIPLE_VALUE_ACCESSOR = {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => SelectMultipleControlValueAccessor),
      multi: true
    };
    SelectMultipleControlValueAccessor = class extends BuiltInControlValueAccessor {
      constructor() {
        super(...arguments);
        this._optionMap = /* @__PURE__ */ new Map();
        this._idCounter = 0;
        this._compareWith = Object.is;
      }
      set compareWith(fn2) {
        if (typeof fn2 !== "function" && (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default)) {
          throw new RuntimeError(
            1201,
            `compareWith must be a function, but received ${JSON.stringify(fn2)}`
          );
        }
        this._compareWith = fn2;
      }
      writeValue(value) {
        this.value = value;
        let optionSelectedStateSetter;
        if (Array.isArray(value)) {
          const ids = value.map((v) => this._getOptionId(v));
          optionSelectedStateSetter = (opt, o) => {
            opt._setSelected(ids.indexOf(o.toString()) > -1);
          };
        } else {
          optionSelectedStateSetter = (opt, o) => {
            opt._setSelected(false);
          };
        }
        this._optionMap.forEach(optionSelectedStateSetter);
      }
      registerOnChange(fn2) {
        this.onChange = (element) => {
          const selected = [];
          const selectedOptions = element.selectedOptions;
          if (selectedOptions !== void 0) {
            const options = selectedOptions;
            for (let i = 0; i < options.length; i++) {
              const opt = options[i];
              const val = this._getOptionValue(opt.value);
              selected.push(val);
            }
          } else {
            const options = element.options;
            for (let i = 0; i < options.length; i++) {
              const opt = options[i];
              if (opt.selected) {
                const val = this._getOptionValue(opt.value);
                selected.push(val);
              }
            }
          }
          this.value = selected;
          fn2(selected);
        };
      }
      _registerOption(value) {
        const id = (this._idCounter++).toString();
        this._optionMap.set(id, value);
        return id;
      }
      _getOptionId(value) {
        for (const id of Array.from(this._optionMap.keys())) {
          if (this._compareWith(this._optionMap.get(id)._value, value))
            return id;
        }
        return null;
      }
      _getOptionValue(valueString) {
        const id = _extractId(valueString);
        return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
      }
    };
    SelectMultipleControlValueAccessor.\u0275fac = function() {
      let \u0275SelectMultipleControlValueAccessor_BaseFactory;
      return function SelectMultipleControlValueAccessor_Factory(t) {
        return (\u0275SelectMultipleControlValueAccessor_BaseFactory || (\u0275SelectMultipleControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(SelectMultipleControlValueAccessor)))(t || SelectMultipleControlValueAccessor);
      };
    }();
    SelectMultipleControlValueAccessor.\u0275dir = \u0275\u0275defineDirective({
      type: SelectMultipleControlValueAccessor,
      selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]],
      hostBindings: function SelectMultipleControlValueAccessor_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("change", function SelectMultipleControlValueAccessor_change_HostBindingHandler($event) {
            return ctx.onChange($event.target);
          })("blur", function SelectMultipleControlValueAccessor_blur_HostBindingHandler() {
            return ctx.onTouched();
          });
        }
      },
      inputs: {
        compareWith: "compareWith"
      },
      features: [\u0275\u0275ProvidersFeature([SELECT_MULTIPLE_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(SelectMultipleControlValueAccessor, [{
        type: Directive,
        args: [{
          selector: "select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]",
          host: {
            "(change)": "onChange($event.target)",
            "(blur)": "onTouched()"
          },
          providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]
        }]
      }], null, {
        compareWith: [{
          type: Input
        }]
      });
    })();
    \u0275NgSelectMultipleOption = class {
      constructor(_element, _renderer, _select) {
        this._element = _element;
        this._renderer = _renderer;
        this._select = _select;
        if (this._select) {
          this.id = this._select._registerOption(this);
        }
      }
      set ngValue(value) {
        if (this._select == null)
          return;
        this._value = value;
        this._setElementValue(_buildValueString(this.id, value));
        this._select.writeValue(this._select.value);
      }
      set value(value) {
        if (this._select) {
          this._value = value;
          this._setElementValue(_buildValueString(this.id, value));
          this._select.writeValue(this._select.value);
        } else {
          this._setElementValue(value);
        }
      }
      _setElementValue(value) {
        this._renderer.setProperty(this._element.nativeElement, "value", value);
      }
      _setSelected(selected) {
        this._renderer.setProperty(this._element.nativeElement, "selected", selected);
      }
      ngOnDestroy() {
        if (this._select) {
          this._select._optionMap.delete(this.id);
          this._select.writeValue(this._select.value);
        }
      }
    };
    \u0275NgSelectMultipleOption.\u0275fac = function \u0275NgSelectMultipleOption_Factory(t) {
      return new (t || \u0275NgSelectMultipleOption)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(SelectMultipleControlValueAccessor, 9));
    };
    \u0275NgSelectMultipleOption.\u0275dir = \u0275\u0275defineDirective({
      type: \u0275NgSelectMultipleOption,
      selectors: [["option"]],
      inputs: {
        ngValue: "ngValue",
        value: "value"
      }
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(\u0275NgSelectMultipleOption, [{
        type: Directive,
        args: [{
          selector: "option"
        }]
      }], function() {
        return [{
          type: ElementRef
        }, {
          type: Renderer2
        }, {
          type: SelectMultipleControlValueAccessor,
          decorators: [{
            type: Optional
          }, {
            type: Host
          }]
        }];
      }, {
        ngValue: [{
          type: Input,
          args: ["ngValue"]
        }],
        value: [{
          type: Input,
          args: ["value"]
        }]
      });
    })();
    AbstractValidatorDirective = class {
      constructor() {
        this._validator = nullValidator;
      }
      ngOnChanges(changes) {
        if (this.inputName in changes) {
          const input = this.normalizeInput(changes[this.inputName].currentValue);
          this._enabled = this.enabled(input);
          this._validator = this._enabled ? this.createValidator(input) : nullValidator;
          if (this._onChange) {
            this._onChange();
          }
        }
      }
      validate(control) {
        return this._validator(control);
      }
      registerOnValidatorChange(fn2) {
        this._onChange = fn2;
      }
      enabled(input) {
        return input != null;
      }
    };
    AbstractValidatorDirective.\u0275fac = function AbstractValidatorDirective_Factory(t) {
      return new (t || AbstractValidatorDirective)();
    };
    AbstractValidatorDirective.\u0275dir = \u0275\u0275defineDirective({
      type: AbstractValidatorDirective,
      features: [\u0275\u0275NgOnChangesFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(AbstractValidatorDirective, [{
        type: Directive
      }], null, null);
    })();
    MAX_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => MaxValidator),
      multi: true
    };
    MaxValidator = class extends AbstractValidatorDirective {
      constructor() {
        super(...arguments);
        this.inputName = "max";
        this.normalizeInput = (input) => toFloat(input);
        this.createValidator = (max2) => maxValidator(max2);
      }
    };
    MaxValidator.\u0275fac = function() {
      let \u0275MaxValidator_BaseFactory;
      return function MaxValidator_Factory(t) {
        return (\u0275MaxValidator_BaseFactory || (\u0275MaxValidator_BaseFactory = \u0275\u0275getInheritedFactory(MaxValidator)))(t || MaxValidator);
      };
    }();
    MaxValidator.\u0275dir = \u0275\u0275defineDirective({
      type: MaxValidator,
      selectors: [["input", "type", "number", "max", "", "formControlName", ""], ["input", "type", "number", "max", "", "formControl", ""], ["input", "type", "number", "max", "", "ngModel", ""]],
      hostVars: 1,
      hostBindings: function MaxValidator_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275attribute("max", ctx._enabled ? ctx.max : null);
        }
      },
      inputs: {
        max: "max"
      },
      features: [\u0275\u0275ProvidersFeature([MAX_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(MaxValidator, [{
        type: Directive,
        args: [{
          selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]",
          providers: [MAX_VALIDATOR],
          host: {
            "[attr.max]": "_enabled ? max : null"
          }
        }]
      }], null, {
        max: [{
          type: Input
        }]
      });
    })();
    MIN_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => MinValidator),
      multi: true
    };
    MinValidator = class extends AbstractValidatorDirective {
      constructor() {
        super(...arguments);
        this.inputName = "min";
        this.normalizeInput = (input) => toFloat(input);
        this.createValidator = (min2) => minValidator(min2);
      }
    };
    MinValidator.\u0275fac = function() {
      let \u0275MinValidator_BaseFactory;
      return function MinValidator_Factory(t) {
        return (\u0275MinValidator_BaseFactory || (\u0275MinValidator_BaseFactory = \u0275\u0275getInheritedFactory(MinValidator)))(t || MinValidator);
      };
    }();
    MinValidator.\u0275dir = \u0275\u0275defineDirective({
      type: MinValidator,
      selectors: [["input", "type", "number", "min", "", "formControlName", ""], ["input", "type", "number", "min", "", "formControl", ""], ["input", "type", "number", "min", "", "ngModel", ""]],
      hostVars: 1,
      hostBindings: function MinValidator_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275attribute("min", ctx._enabled ? ctx.min : null);
        }
      },
      inputs: {
        min: "min"
      },
      features: [\u0275\u0275ProvidersFeature([MIN_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(MinValidator, [{
        type: Directive,
        args: [{
          selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]",
          providers: [MIN_VALIDATOR],
          host: {
            "[attr.min]": "_enabled ? min : null"
          }
        }]
      }], null, {
        min: [{
          type: Input
        }]
      });
    })();
    REQUIRED_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => RequiredValidator),
      multi: true
    };
    CHECKBOX_REQUIRED_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => CheckboxRequiredValidator),
      multi: true
    };
    RequiredValidator = class extends AbstractValidatorDirective {
      constructor() {
        super(...arguments);
        this.inputName = "required";
        this.normalizeInput = coerceToBoolean;
        this.createValidator = (input) => requiredValidator;
      }
      enabled(input) {
        return input;
      }
    };
    RequiredValidator.\u0275fac = function() {
      let \u0275RequiredValidator_BaseFactory;
      return function RequiredValidator_Factory(t) {
        return (\u0275RequiredValidator_BaseFactory || (\u0275RequiredValidator_BaseFactory = \u0275\u0275getInheritedFactory(RequiredValidator)))(t || RequiredValidator);
      };
    }();
    RequiredValidator.\u0275dir = \u0275\u0275defineDirective({
      type: RequiredValidator,
      selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]],
      hostVars: 1,
      hostBindings: function RequiredValidator_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275attribute("required", ctx._enabled ? "" : null);
        }
      },
      inputs: {
        required: "required"
      },
      features: [\u0275\u0275ProvidersFeature([REQUIRED_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(RequiredValidator, [{
        type: Directive,
        args: [{
          selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]",
          providers: [REQUIRED_VALIDATOR],
          host: {
            "[attr.required]": '_enabled ? "" : null'
          }
        }]
      }], null, {
        required: [{
          type: Input
        }]
      });
    })();
    CheckboxRequiredValidator = class extends RequiredValidator {
      constructor() {
        super(...arguments);
        this.createValidator = (input) => requiredTrueValidator;
      }
    };
    CheckboxRequiredValidator.\u0275fac = function() {
      let \u0275CheckboxRequiredValidator_BaseFactory;
      return function CheckboxRequiredValidator_Factory(t) {
        return (\u0275CheckboxRequiredValidator_BaseFactory || (\u0275CheckboxRequiredValidator_BaseFactory = \u0275\u0275getInheritedFactory(CheckboxRequiredValidator)))(t || CheckboxRequiredValidator);
      };
    }();
    CheckboxRequiredValidator.\u0275dir = \u0275\u0275defineDirective({
      type: CheckboxRequiredValidator,
      selectors: [["input", "type", "checkbox", "required", "", "formControlName", ""], ["input", "type", "checkbox", "required", "", "formControl", ""], ["input", "type", "checkbox", "required", "", "ngModel", ""]],
      hostVars: 1,
      hostBindings: function CheckboxRequiredValidator_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275attribute("required", ctx._enabled ? "" : null);
        }
      },
      features: [\u0275\u0275ProvidersFeature([CHECKBOX_REQUIRED_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(CheckboxRequiredValidator, [{
        type: Directive,
        args: [{
          selector: "input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]",
          providers: [CHECKBOX_REQUIRED_VALIDATOR],
          host: {
            "[attr.required]": '_enabled ? "" : null'
          }
        }]
      }], null, null);
    })();
    EMAIL_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => EmailValidator),
      multi: true
    };
    EmailValidator = class extends AbstractValidatorDirective {
      constructor() {
        super(...arguments);
        this.inputName = "email";
        this.normalizeInput = coerceToBoolean;
        this.createValidator = (input) => emailValidator;
      }
      enabled(input) {
        return input;
      }
    };
    EmailValidator.\u0275fac = function() {
      let \u0275EmailValidator_BaseFactory;
      return function EmailValidator_Factory(t) {
        return (\u0275EmailValidator_BaseFactory || (\u0275EmailValidator_BaseFactory = \u0275\u0275getInheritedFactory(EmailValidator)))(t || EmailValidator);
      };
    }();
    EmailValidator.\u0275dir = \u0275\u0275defineDirective({
      type: EmailValidator,
      selectors: [["", "email", "", "formControlName", ""], ["", "email", "", "formControl", ""], ["", "email", "", "ngModel", ""]],
      inputs: {
        email: "email"
      },
      features: [\u0275\u0275ProvidersFeature([EMAIL_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(EmailValidator, [{
        type: Directive,
        args: [{
          selector: "[email][formControlName],[email][formControl],[email][ngModel]",
          providers: [EMAIL_VALIDATOR]
        }]
      }], null, {
        email: [{
          type: Input
        }]
      });
    })();
    MIN_LENGTH_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => MinLengthValidator),
      multi: true
    };
    MinLengthValidator = class extends AbstractValidatorDirective {
      constructor() {
        super(...arguments);
        this.inputName = "minlength";
        this.normalizeInput = (input) => toInteger(input);
        this.createValidator = (minlength) => minLengthValidator(minlength);
      }
    };
    MinLengthValidator.\u0275fac = function() {
      let \u0275MinLengthValidator_BaseFactory;
      return function MinLengthValidator_Factory(t) {
        return (\u0275MinLengthValidator_BaseFactory || (\u0275MinLengthValidator_BaseFactory = \u0275\u0275getInheritedFactory(MinLengthValidator)))(t || MinLengthValidator);
      };
    }();
    MinLengthValidator.\u0275dir = \u0275\u0275defineDirective({
      type: MinLengthValidator,
      selectors: [["", "minlength", "", "formControlName", ""], ["", "minlength", "", "formControl", ""], ["", "minlength", "", "ngModel", ""]],
      hostVars: 1,
      hostBindings: function MinLengthValidator_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275attribute("minlength", ctx._enabled ? ctx.minlength : null);
        }
      },
      inputs: {
        minlength: "minlength"
      },
      features: [\u0275\u0275ProvidersFeature([MIN_LENGTH_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(MinLengthValidator, [{
        type: Directive,
        args: [{
          selector: "[minlength][formControlName],[minlength][formControl],[minlength][ngModel]",
          providers: [MIN_LENGTH_VALIDATOR],
          host: {
            "[attr.minlength]": "_enabled ? minlength : null"
          }
        }]
      }], null, {
        minlength: [{
          type: Input
        }]
      });
    })();
    MAX_LENGTH_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => MaxLengthValidator),
      multi: true
    };
    MaxLengthValidator = class extends AbstractValidatorDirective {
      constructor() {
        super(...arguments);
        this.inputName = "maxlength";
        this.normalizeInput = (input) => toInteger(input);
        this.createValidator = (maxlength) => maxLengthValidator(maxlength);
      }
    };
    MaxLengthValidator.\u0275fac = function() {
      let \u0275MaxLengthValidator_BaseFactory;
      return function MaxLengthValidator_Factory(t) {
        return (\u0275MaxLengthValidator_BaseFactory || (\u0275MaxLengthValidator_BaseFactory = \u0275\u0275getInheritedFactory(MaxLengthValidator)))(t || MaxLengthValidator);
      };
    }();
    MaxLengthValidator.\u0275dir = \u0275\u0275defineDirective({
      type: MaxLengthValidator,
      selectors: [["", "maxlength", "", "formControlName", ""], ["", "maxlength", "", "formControl", ""], ["", "maxlength", "", "ngModel", ""]],
      hostVars: 1,
      hostBindings: function MaxLengthValidator_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275attribute("maxlength", ctx._enabled ? ctx.maxlength : null);
        }
      },
      inputs: {
        maxlength: "maxlength"
      },
      features: [\u0275\u0275ProvidersFeature([MAX_LENGTH_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(MaxLengthValidator, [{
        type: Directive,
        args: [{
          selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]",
          providers: [MAX_LENGTH_VALIDATOR],
          host: {
            "[attr.maxlength]": "_enabled ? maxlength : null"
          }
        }]
      }], null, {
        maxlength: [{
          type: Input
        }]
      });
    })();
    PATTERN_VALIDATOR = {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => PatternValidator),
      multi: true
    };
    PatternValidator = class extends AbstractValidatorDirective {
      constructor() {
        super(...arguments);
        this.inputName = "pattern";
        this.normalizeInput = (input) => input;
        this.createValidator = (input) => patternValidator(input);
      }
    };
    PatternValidator.\u0275fac = function() {
      let \u0275PatternValidator_BaseFactory;
      return function PatternValidator_Factory(t) {
        return (\u0275PatternValidator_BaseFactory || (\u0275PatternValidator_BaseFactory = \u0275\u0275getInheritedFactory(PatternValidator)))(t || PatternValidator);
      };
    }();
    PatternValidator.\u0275dir = \u0275\u0275defineDirective({
      type: PatternValidator,
      selectors: [["", "pattern", "", "formControlName", ""], ["", "pattern", "", "formControl", ""], ["", "pattern", "", "ngModel", ""]],
      hostVars: 1,
      hostBindings: function PatternValidator_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275attribute("pattern", ctx._enabled ? ctx.pattern : null);
        }
      },
      inputs: {
        pattern: "pattern"
      },
      features: [\u0275\u0275ProvidersFeature([PATTERN_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(PatternValidator, [{
        type: Directive,
        args: [{
          selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]",
          providers: [PATTERN_VALIDATOR],
          host: {
            "[attr.pattern]": "_enabled ? pattern : null"
          }
        }]
      }], null, {
        pattern: [{
          type: Input
        }]
      });
    })();
    SHARED_FORM_DIRECTIVES = [\u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator];
    TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
    REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
    \u0275InternalFormsSharedModule = class {
    };
    \u0275InternalFormsSharedModule.\u0275fac = function \u0275InternalFormsSharedModule_Factory(t) {
      return new (t || \u0275InternalFormsSharedModule)();
    };
    \u0275InternalFormsSharedModule.\u0275mod = \u0275\u0275defineNgModule({
      type: \u0275InternalFormsSharedModule
    });
    \u0275InternalFormsSharedModule.\u0275inj = \u0275\u0275defineInjector({
      imports: [RadioControlRegistryModule]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(\u0275InternalFormsSharedModule, [{
        type: NgModule,
        args: [{
          declarations: SHARED_FORM_DIRECTIVES,
          imports: [RadioControlRegistryModule],
          exports: SHARED_FORM_DIRECTIVES
        }]
      }], null, null);
    })();
    FormsModule = class {
    };
    FormsModule.\u0275fac = function FormsModule_Factory(t) {
      return new (t || FormsModule)();
    };
    FormsModule.\u0275mod = \u0275\u0275defineNgModule({
      type: FormsModule
    });
    FormsModule.\u0275inj = \u0275\u0275defineInjector({
      imports: [\u0275InternalFormsSharedModule]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(FormsModule, [{
        type: NgModule,
        args: [{
          declarations: TEMPLATE_DRIVEN_DIRECTIVES,
          exports: [\u0275InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
        }]
      }], null, null);
    })();
    ReactiveFormsModule = class {
      static withConfig(opts) {
        return {
          ngModule: ReactiveFormsModule,
          providers: [{
            provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
            useValue: opts.warnOnNgModelWithFormControl
          }]
        };
      }
    };
    ReactiveFormsModule.\u0275fac = function ReactiveFormsModule_Factory(t) {
      return new (t || ReactiveFormsModule)();
    };
    ReactiveFormsModule.\u0275mod = \u0275\u0275defineNgModule({
      type: ReactiveFormsModule
    });
    ReactiveFormsModule.\u0275inj = \u0275\u0275defineInjector({
      imports: [\u0275InternalFormsSharedModule]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(ReactiveFormsModule, [{
        type: NgModule,
        args: [{
          declarations: [REACTIVE_DRIVEN_DIRECTIVES],
          exports: [\u0275InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
        }]
      }], null, null);
    })();
    FormArray = class extends AbstractControl {
      constructor(controls, validatorOrOpts, asyncValidator) {
        super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
        this.controls = controls;
        this._initObservables();
        this._setUpdateStrategy(validatorOrOpts);
        this._setUpControls();
        this.updateValueAndValidity({
          onlySelf: true,
          emitEvent: !!this.asyncValidator
        });
      }
      at(index) {
        return this.controls[this._adjustIndex(index)];
      }
      push(control, options = {}) {
        this.controls.push(control);
        this._registerControl(control);
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
        this._onCollectionChange();
      }
      insert(index, control, options = {}) {
        this.controls.splice(index, 0, control);
        this._registerControl(control);
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
      }
      removeAt(index, options = {}) {
        let adjustedIndex = this._adjustIndex(index);
        if (adjustedIndex < 0)
          adjustedIndex = 0;
        if (this.controls[adjustedIndex])
          this.controls[adjustedIndex]._registerOnCollectionChange(() => {
          });
        this.controls.splice(adjustedIndex, 1);
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
      }
      setControl(index, control, options = {}) {
        let adjustedIndex = this._adjustIndex(index);
        if (adjustedIndex < 0)
          adjustedIndex = 0;
        if (this.controls[adjustedIndex])
          this.controls[adjustedIndex]._registerOnCollectionChange(() => {
          });
        this.controls.splice(adjustedIndex, 1);
        if (control) {
          this.controls.splice(adjustedIndex, 0, control);
          this._registerControl(control);
        }
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
        this._onCollectionChange();
      }
      get length() {
        return this.controls.length;
      }
      setValue(value, options = {}) {
        assertAllValuesPresent(this, false, value);
        value.forEach((newValue, index) => {
          assertControlPresent(this, false, index);
          this.at(index).setValue(newValue, {
            onlySelf: true,
            emitEvent: options.emitEvent
          });
        });
        this.updateValueAndValidity(options);
      }
      patchValue(value, options = {}) {
        if (value == null)
          return;
        value.forEach((newValue, index) => {
          if (this.at(index)) {
            this.at(index).patchValue(newValue, {
              onlySelf: true,
              emitEvent: options.emitEvent
            });
          }
        });
        this.updateValueAndValidity(options);
      }
      reset(value = [], options = {}) {
        this._forEachChild((control, index) => {
          control.reset(value[index], {
            onlySelf: true,
            emitEvent: options.emitEvent
          });
        });
        this._updatePristine(options);
        this._updateTouched(options);
        this.updateValueAndValidity(options);
      }
      getRawValue() {
        return this.controls.map((control) => control.getRawValue());
      }
      clear(options = {}) {
        if (this.controls.length < 1)
          return;
        this._forEachChild((control) => control._registerOnCollectionChange(() => {
        }));
        this.controls.splice(0);
        this.updateValueAndValidity({
          emitEvent: options.emitEvent
        });
      }
      _adjustIndex(index) {
        return index < 0 ? index + this.length : index;
      }
      _syncPendingControls() {
        let subtreeUpdated = this.controls.reduce((updated, child) => {
          return child._syncPendingControls() ? true : updated;
        }, false);
        if (subtreeUpdated)
          this.updateValueAndValidity({
            onlySelf: true
          });
        return subtreeUpdated;
      }
      _forEachChild(cb) {
        this.controls.forEach((control, index) => {
          cb(control, index);
        });
      }
      _updateValue() {
        this.value = this.controls.filter((control) => control.enabled || this.disabled).map((control) => control.value);
      }
      _anyControls(condition) {
        return this.controls.some((control) => control.enabled && condition(control));
      }
      _setUpControls() {
        this._forEachChild((control) => this._registerControl(control));
      }
      _allControlsDisabled() {
        for (const control of this.controls) {
          if (control.enabled)
            return false;
        }
        return this.controls.length > 0 || this.disabled;
      }
      _registerControl(control) {
        control.setParent(this);
        control._registerOnCollectionChange(this._onCollectionChange);
      }
      _find(name) {
        var _a;
        return (_a = this.at(name)) !== null && _a !== void 0 ? _a : null;
      }
    };
    UntypedFormArray = FormArray;
    FormBuilder = class {
      constructor() {
        this.useNonNullable = false;
      }
      get nonNullable() {
        const nnfb = new FormBuilder();
        nnfb.useNonNullable = true;
        return nnfb;
      }
      group(controls, options = null) {
        const reducedControls = this._reduceControls(controls);
        let newOptions = {};
        if (isAbstractControlOptions(options)) {
          newOptions = options;
        } else if (options !== null) {
          newOptions.validators = options.validator;
          newOptions.asyncValidators = options.asyncValidator;
        }
        return new FormGroup(reducedControls, newOptions);
      }
      control(formState, validatorOrOpts, asyncValidator) {
        let newOptions = {};
        if (!this.useNonNullable) {
          return new FormControl(formState, validatorOrOpts, asyncValidator);
        }
        if (isAbstractControlOptions(validatorOrOpts)) {
          newOptions = validatorOrOpts;
        } else {
          newOptions.validators = validatorOrOpts;
          newOptions.asyncValidators = asyncValidator;
        }
        return new FormControl(formState, Object.assign(Object.assign({}, newOptions), {
          nonNullable: true
        }));
      }
      array(controls, validatorOrOpts, asyncValidator) {
        const createdControls = controls.map((c) => this._createControl(c));
        return new FormArray(createdControls, validatorOrOpts, asyncValidator);
      }
      _reduceControls(controls) {
        const createdControls = {};
        Object.keys(controls).forEach((controlName) => {
          createdControls[controlName] = this._createControl(controls[controlName]);
        });
        return createdControls;
      }
      _createControl(controls) {
        if (controls instanceof FormControl) {
          return controls;
        } else if (controls instanceof AbstractControl) {
          return controls;
        } else if (Array.isArray(controls)) {
          const value = controls[0];
          const validator = controls.length > 1 ? controls[1] : null;
          const asyncValidator = controls.length > 2 ? controls[2] : null;
          return this.control(value, validator, asyncValidator);
        } else {
          return this.control(controls);
        }
      }
    };
    FormBuilder.\u0275fac = function FormBuilder_Factory(t) {
      return new (t || FormBuilder)();
    };
    FormBuilder.\u0275prov = \u0275\u0275defineInjectable({
      token: FormBuilder,
      factory: FormBuilder.\u0275fac,
      providedIn: ReactiveFormsModule
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(FormBuilder, [{
        type: Injectable,
        args: [{
          providedIn: ReactiveFormsModule
        }]
      }], null, null);
    })();
    NonNullableFormBuilder = class {
    };
    NonNullableFormBuilder.\u0275fac = function NonNullableFormBuilder_Factory(t) {
      return new (t || NonNullableFormBuilder)();
    };
    NonNullableFormBuilder.\u0275prov = \u0275\u0275defineInjectable({
      token: NonNullableFormBuilder,
      factory: function() {
        return (() => inject(FormBuilder).nonNullable)();
      },
      providedIn: ReactiveFormsModule
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(NonNullableFormBuilder, [{
        type: Injectable,
        args: [{
          providedIn: ReactiveFormsModule,
          useFactory: () => inject(FormBuilder).nonNullable
        }]
      }], null, null);
    })();
    UntypedFormBuilder = class extends FormBuilder {
      group(controlsConfig, options = null) {
        return super.group(controlsConfig, options);
      }
      control(formState, validatorOrOpts, asyncValidator) {
        return super.control(formState, validatorOrOpts, asyncValidator);
      }
      array(controlsConfig, validatorOrOpts, asyncValidator) {
        return super.array(controlsConfig, validatorOrOpts, asyncValidator);
      }
    };
    UntypedFormBuilder.\u0275fac = function() {
      let \u0275UntypedFormBuilder_BaseFactory;
      return function UntypedFormBuilder_Factory(t) {
        return (\u0275UntypedFormBuilder_BaseFactory || (\u0275UntypedFormBuilder_BaseFactory = \u0275\u0275getInheritedFactory(UntypedFormBuilder)))(t || UntypedFormBuilder);
      };
    }();
    UntypedFormBuilder.\u0275prov = \u0275\u0275defineInjectable({
      token: UntypedFormBuilder,
      factory: UntypedFormBuilder.\u0275fac,
      providedIn: ReactiveFormsModule
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(UntypedFormBuilder, [{
        type: Injectable,
        args: [{
          providedIn: ReactiveFormsModule
        }]
      }], null, null);
    })();
    VERSION3 = new Version("14.1.1");
  }
});

// node_modules/@angular/compiler/fesm2015/compiler.mjs
function splitNsName(elementName) {
  if (elementName[0] != ":") {
    return [null, elementName];
  }
  const colonIndex = elementName.indexOf(":", 1);
  if (colonIndex === -1) {
    throw new Error(`Unsupported format "${elementName}" expecting ":namespace:name"`);
  }
  return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];
}
function isNgContainer(tagName) {
  return splitNsName(tagName)[1] === "ng-container";
}
function isNgContent(tagName) {
  return splitNsName(tagName)[1] === "ng-content";
}
function isNgTemplate(tagName) {
  return splitNsName(tagName)[1] === "ng-template";
}
function getNsPrefix(fullName) {
  return fullName === null ? null : splitNsName(fullName)[0];
}
function mergeNsAndName(prefix, localName) {
  return prefix ? `:${prefix}:${localName}` : localName;
}
function getHtmlTagDefinition(tagName) {
  var _a, _b;
  if (!TAG_DEFINITIONS) {
    _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();
    TAG_DEFINITIONS = {
      "base": new HtmlTagDefinition({
        isVoid: true
      }),
      "meta": new HtmlTagDefinition({
        isVoid: true
      }),
      "area": new HtmlTagDefinition({
        isVoid: true
      }),
      "embed": new HtmlTagDefinition({
        isVoid: true
      }),
      "link": new HtmlTagDefinition({
        isVoid: true
      }),
      "img": new HtmlTagDefinition({
        isVoid: true
      }),
      "input": new HtmlTagDefinition({
        isVoid: true
      }),
      "param": new HtmlTagDefinition({
        isVoid: true
      }),
      "hr": new HtmlTagDefinition({
        isVoid: true
      }),
      "br": new HtmlTagDefinition({
        isVoid: true
      }),
      "source": new HtmlTagDefinition({
        isVoid: true
      }),
      "track": new HtmlTagDefinition({
        isVoid: true
      }),
      "wbr": new HtmlTagDefinition({
        isVoid: true
      }),
      "p": new HtmlTagDefinition({
        closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"],
        closedByParent: true
      }),
      "thead": new HtmlTagDefinition({
        closedByChildren: ["tbody", "tfoot"]
      }),
      "tbody": new HtmlTagDefinition({
        closedByChildren: ["tbody", "tfoot"],
        closedByParent: true
      }),
      "tfoot": new HtmlTagDefinition({
        closedByChildren: ["tbody"],
        closedByParent: true
      }),
      "tr": new HtmlTagDefinition({
        closedByChildren: ["tr"],
        closedByParent: true
      }),
      "td": new HtmlTagDefinition({
        closedByChildren: ["td", "th"],
        closedByParent: true
      }),
      "th": new HtmlTagDefinition({
        closedByChildren: ["td", "th"],
        closedByParent: true
      }),
      "col": new HtmlTagDefinition({
        isVoid: true
      }),
      "svg": new HtmlTagDefinition({
        implicitNamespacePrefix: "svg"
      }),
      "foreignObject": new HtmlTagDefinition({
        implicitNamespacePrefix: "svg",
        preventNamespaceInheritance: true
      }),
      "math": new HtmlTagDefinition({
        implicitNamespacePrefix: "math"
      }),
      "li": new HtmlTagDefinition({
        closedByChildren: ["li"],
        closedByParent: true
      }),
      "dt": new HtmlTagDefinition({
        closedByChildren: ["dt", "dd"]
      }),
      "dd": new HtmlTagDefinition({
        closedByChildren: ["dt", "dd"],
        closedByParent: true
      }),
      "rb": new HtmlTagDefinition({
        closedByChildren: ["rb", "rt", "rtc", "rp"],
        closedByParent: true
      }),
      "rt": new HtmlTagDefinition({
        closedByChildren: ["rb", "rt", "rtc", "rp"],
        closedByParent: true
      }),
      "rtc": new HtmlTagDefinition({
        closedByChildren: ["rb", "rtc", "rp"],
        closedByParent: true
      }),
      "rp": new HtmlTagDefinition({
        closedByChildren: ["rb", "rt", "rtc", "rp"],
        closedByParent: true
      }),
      "optgroup": new HtmlTagDefinition({
        closedByChildren: ["optgroup"],
        closedByParent: true
      }),
      "option": new HtmlTagDefinition({
        closedByChildren: ["option", "optgroup"],
        closedByParent: true
      }),
      "pre": new HtmlTagDefinition({
        ignoreFirstLf: true
      }),
      "listing": new HtmlTagDefinition({
        ignoreFirstLf: true
      }),
      "style": new HtmlTagDefinition({
        contentType: TagContentType.RAW_TEXT
      }),
      "script": new HtmlTagDefinition({
        contentType: TagContentType.RAW_TEXT
      }),
      "title": new HtmlTagDefinition({
        contentType: {
          default: TagContentType.ESCAPABLE_RAW_TEXT,
          svg: TagContentType.PARSABLE_DATA
        }
      }),
      "textarea": new HtmlTagDefinition({
        contentType: TagContentType.ESCAPABLE_RAW_TEXT,
        ignoreFirstLf: true
      })
    };
  }
  return (_b = (_a = TAG_DEFINITIONS[tagName]) !== null && _a !== void 0 ? _a : TAG_DEFINITIONS[tagName.toLowerCase()]) !== null && _b !== void 0 ? _b : _DEFAULT_TAG_DEFINITION;
}
function parserSelectorToSimpleSelector(selector) {
  const classes = selector.classNames && selector.classNames.length ? [
    8,
    ...selector.classNames
  ] : [];
  const elementName = selector.element && selector.element !== "*" ? selector.element : "";
  return [elementName, ...selector.attrs, ...classes];
}
function parserSelectorToNegativeSelector(selector) {
  const classes = selector.classNames && selector.classNames.length ? [
    8,
    ...selector.classNames
  ] : [];
  if (selector.element) {
    return [
      1 | 4,
      selector.element,
      ...selector.attrs,
      ...classes
    ];
  } else if (selector.attrs.length) {
    return [
      1 | 2,
      ...selector.attrs,
      ...classes
    ];
  } else {
    return selector.classNames && selector.classNames.length ? [
      1 | 8,
      ...selector.classNames
    ] : [];
  }
}
function parserSelectorToR3Selector(selector) {
  const positive = parserSelectorToSimpleSelector(selector);
  const negative = selector.notSelectors && selector.notSelectors.length ? selector.notSelectors.map((notSelector) => parserSelectorToNegativeSelector(notSelector)) : [];
  return positive.concat(...negative);
}
function parseSelectorToR3Selector(selector) {
  return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];
}
function dashCaseToCamelCase(input) {
  return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
}
function splitAtColon(input, defaultValues) {
  return _splitAt(input, ":", defaultValues);
}
function splitAtPeriod(input, defaultValues) {
  return _splitAt(input, ".", defaultValues);
}
function _splitAt(input, character, defaultValues) {
  const characterIndex = input.indexOf(character);
  if (characterIndex == -1)
    return defaultValues;
  return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];
}
function noUndefined(val) {
  return val === void 0 ? null : val;
}
function error(msg) {
  throw new Error(`Internal Error: ${msg}`);
}
function utf8Encode(str) {
  let encoded = [];
  for (let index = 0; index < str.length; index++) {
    let codePoint = str.charCodeAt(index);
    if (codePoint >= 55296 && codePoint <= 56319 && str.length > index + 1) {
      const low = str.charCodeAt(index + 1);
      if (low >= 56320 && low <= 57343) {
        index++;
        codePoint = (codePoint - 55296 << 10) + low - 56320 + 65536;
      }
    }
    if (codePoint <= 127) {
      encoded.push(codePoint);
    } else if (codePoint <= 2047) {
      encoded.push(codePoint >> 6 & 31 | 192, codePoint & 63 | 128);
    } else if (codePoint <= 65535) {
      encoded.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint <= 2097151) {
      encoded.push(codePoint >> 18 & 7 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    }
  }
  return encoded;
}
function stringify2(token) {
  if (typeof token === "string") {
    return token;
  }
  if (Array.isArray(token)) {
    return "[" + token.map(stringify2).join(", ") + "]";
  }
  if (token == null) {
    return "" + token;
  }
  if (token.overriddenName) {
    return `${token.overriddenName}`;
  }
  if (token.name) {
    return `${token.name}`;
  }
  if (!token.toString) {
    return "object";
  }
  const res = token.toString();
  if (res == null) {
    return "" + res;
  }
  const newLineIndex = res.indexOf("\n");
  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
}
function newArray2(size, value) {
  const list = [];
  for (let i = 0; i < size; i++) {
    list.push(value);
  }
  return list;
}
function partitionArray(arr, conditionFn) {
  const truthy = [];
  const falsy = [];
  for (const item of arr) {
    (conditionFn(item) ? truthy : falsy).push(item);
  }
  return [truthy, falsy];
}
function computeDigest(message) {
  return sha1(serializeNodes(message.nodes).join("") + `[${message.meaning}]`);
}
function decimalDigest(message) {
  return message.id || computeDecimalDigest(message);
}
function computeDecimalDigest(message) {
  const visitor = new _SerializerIgnoreIcuExpVisitor();
  const parts = message.nodes.map((a) => a.visit(visitor, null));
  return computeMsgId(parts.join(""), message.meaning);
}
function serializeNodes(nodes) {
  return nodes.map((a) => a.visit(serializerVisitor$1, null));
}
function sha1(str) {
  const utf8 = utf8Encode(str);
  const words32 = bytesToWords32(utf8, Endian.Big);
  const len = utf8.length * 8;
  const w = newArray2(80);
  let a = 1732584193, b = 4023233417, c = 2562383102, d = 271733878, e = 3285377520;
  words32[len >> 5] |= 128 << 24 - len % 32;
  words32[(len + 64 >> 9 << 4) + 15] = len;
  for (let i = 0; i < words32.length; i += 16) {
    const h0 = a, h1 = b, h2 = c, h3 = d, h4 = e;
    for (let j = 0; j < 80; j++) {
      if (j < 16) {
        w[j] = words32[i + j];
      } else {
        w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
      }
      const fkVal = fk(j, b, c, d);
      const f = fkVal[0];
      const k = fkVal[1];
      const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
      e = d;
      d = c;
      c = rol32(b, 30);
      b = a;
      a = temp;
    }
    a = add32(a, h0);
    b = add32(b, h1);
    c = add32(c, h2);
    d = add32(d, h3);
    e = add32(e, h4);
  }
  return bytesToHexString(words32ToByteString([a, b, c, d, e]));
}
function fk(index, b, c, d) {
  if (index < 20) {
    return [b & c | ~b & d, 1518500249];
  }
  if (index < 40) {
    return [b ^ c ^ d, 1859775393];
  }
  if (index < 60) {
    return [b & c | b & d | c & d, 2400959708];
  }
  return [b ^ c ^ d, 3395469782];
}
function fingerprint(str) {
  const utf8 = utf8Encode(str);
  let hi = hash32(utf8, 0);
  let lo = hash32(utf8, 102072);
  if (hi == 0 && (lo == 0 || lo == 1)) {
    hi = hi ^ 319790063;
    lo = lo ^ -1801410264;
  }
  return [hi, lo];
}
function computeMsgId(msg, meaning = "") {
  let msgFingerprint = fingerprint(msg);
  if (meaning) {
    const meaningFingerprint = fingerprint(meaning);
    msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);
  }
  const hi = msgFingerprint[0];
  const lo = msgFingerprint[1];
  return wordsToDecimalString(hi & 2147483647, lo);
}
function hash32(bytes, c) {
  let a = 2654435769, b = 2654435769;
  let i;
  const len = bytes.length;
  for (i = 0; i + 12 <= len; i += 12) {
    a = add32(a, wordAt(bytes, i, Endian.Little));
    b = add32(b, wordAt(bytes, i + 4, Endian.Little));
    c = add32(c, wordAt(bytes, i + 8, Endian.Little));
    const res = mix(a, b, c);
    a = res[0], b = res[1], c = res[2];
  }
  a = add32(a, wordAt(bytes, i, Endian.Little));
  b = add32(b, wordAt(bytes, i + 4, Endian.Little));
  c = add32(c, len);
  c = add32(c, wordAt(bytes, i + 8, Endian.Little) << 8);
  return mix(a, b, c)[2];
}
function mix(a, b, c) {
  a = sub32(a, b);
  a = sub32(a, c);
  a ^= c >>> 13;
  b = sub32(b, c);
  b = sub32(b, a);
  b ^= a << 8;
  c = sub32(c, a);
  c = sub32(c, b);
  c ^= b >>> 13;
  a = sub32(a, b);
  a = sub32(a, c);
  a ^= c >>> 12;
  b = sub32(b, c);
  b = sub32(b, a);
  b ^= a << 16;
  c = sub32(c, a);
  c = sub32(c, b);
  c ^= b >>> 5;
  a = sub32(a, b);
  a = sub32(a, c);
  a ^= c >>> 3;
  b = sub32(b, c);
  b = sub32(b, a);
  b ^= a << 10;
  c = sub32(c, a);
  c = sub32(c, b);
  c ^= b >>> 15;
  return [a, b, c];
}
function add32(a, b) {
  return add32to64(a, b)[1];
}
function add32to64(a, b) {
  const low = (a & 65535) + (b & 65535);
  const high = (a >>> 16) + (b >>> 16) + (low >>> 16);
  return [high >>> 16, high << 16 | low & 65535];
}
function add64(a, b) {
  const ah = a[0], al = a[1];
  const bh = b[0], bl = b[1];
  const result = add32to64(al, bl);
  const carry = result[0];
  const l = result[1];
  const h = add32(add32(ah, bh), carry);
  return [h, l];
}
function sub32(a, b) {
  const low = (a & 65535) - (b & 65535);
  const high = (a >> 16) - (b >> 16) + (low >> 16);
  return high << 16 | low & 65535;
}
function rol32(a, count2) {
  return a << count2 | a >>> 32 - count2;
}
function rol64(num, count2) {
  const hi = num[0], lo = num[1];
  const h = hi << count2 | lo >>> 32 - count2;
  const l = lo << count2 | hi >>> 32 - count2;
  return [h, l];
}
function bytesToWords32(bytes, endian) {
  const size = bytes.length + 3 >>> 2;
  const words32 = [];
  for (let i = 0; i < size; i++) {
    words32[i] = wordAt(bytes, i * 4, endian);
  }
  return words32;
}
function byteAt(bytes, index) {
  return index >= bytes.length ? 0 : bytes[index];
}
function wordAt(bytes, index, endian) {
  let word = 0;
  if (endian === Endian.Big) {
    for (let i = 0; i < 4; i++) {
      word += byteAt(bytes, index + i) << 24 - 8 * i;
    }
  } else {
    for (let i = 0; i < 4; i++) {
      word += byteAt(bytes, index + i) << 8 * i;
    }
  }
  return word;
}
function words32ToByteString(words32) {
  return words32.reduce((bytes, word) => bytes.concat(word32ToByteString(word)), []);
}
function word32ToByteString(word) {
  let bytes = [];
  for (let i = 0; i < 4; i++) {
    bytes.push(word >>> 8 * (3 - i) & 255);
  }
  return bytes;
}
function bytesToHexString(bytes) {
  let hex = "";
  for (let i = 0; i < bytes.length; i++) {
    const b = byteAt(bytes, i);
    hex += (b >>> 4).toString(16) + (b & 15).toString(16);
  }
  return hex.toLowerCase();
}
function wordsToDecimalString(hi, lo) {
  const decimal = base256.toThePowerOf(0).multiplyBy(lo);
  base256.toThePowerOf(4).multiplyByAndAddTo(hi, decimal);
  return decimal.toString();
}
function nullSafeIsEquivalent(base, other) {
  if (base == null || other == null) {
    return base == other;
  }
  return base.isEquivalent(other);
}
function areAllEquivalentPredicate(base, other, equivalentPredicate) {
  const len = base.length;
  if (len !== other.length) {
    return false;
  }
  for (let i = 0; i < len; i++) {
    if (!equivalentPredicate(base[i], other[i])) {
      return false;
    }
  }
  return true;
}
function areAllEquivalent(base, other) {
  return areAllEquivalentPredicate(base, other, (baseElement2, otherElement) => baseElement2.isEquivalent(otherElement));
}
function createCookedRawString(metaBlock, messagePart, range2) {
  if (metaBlock === "") {
    return {
      cooked: messagePart,
      raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),
      range: range2
    };
  } else {
    return {
      cooked: `:${metaBlock}:${messagePart}`,
      raw: escapeForTemplateLiteral(`:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`),
      range: range2
    };
  }
}
function leadingComment(text, multiline = false, trailingNewline = true) {
  return new LeadingComment(text, multiline, trailingNewline);
}
function jsDocComment(tags = []) {
  return new JSDocComment(tags);
}
function variable(name, type, sourceSpan) {
  return new ReadVarExpr(name, type, sourceSpan);
}
function importExpr(id, typeParams = null, sourceSpan) {
  return new ExternalExpr(id, null, typeParams, sourceSpan);
}
function importType(id, typeParams, typeModifiers) {
  return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;
}
function expressionType(expr, typeModifiers, typeParams) {
  return new ExpressionType(expr, typeModifiers, typeParams);
}
function typeofExpr(expr) {
  return new TypeofExpr(expr);
}
function literalArr(values, type, sourceSpan) {
  return new LiteralArrayExpr(values, type, sourceSpan);
}
function literalMap(values, type = null) {
  return new LiteralMapExpr(values.map((e) => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);
}
function unary(operator, expr, type, sourceSpan) {
  return new UnaryOperatorExpr(operator, expr, type, sourceSpan);
}
function not2(expr, sourceSpan) {
  return new NotExpr(expr, sourceSpan);
}
function fn(params, body, type, sourceSpan, name) {
  return new FunctionExpr(params, body, type, sourceSpan, name);
}
function ifStmt(condition, thenClause, elseClause, sourceSpan, leadingComments) {
  return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);
}
function taggedTemplate(tag, template, type, sourceSpan) {
  return new TaggedTemplateExpr(tag, template, type, sourceSpan);
}
function literal(value, type, sourceSpan) {
  return new LiteralExpr(value, type, sourceSpan);
}
function localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {
  return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);
}
function isNull(exp) {
  return exp instanceof LiteralExpr && exp.value === null;
}
function tagToString(tag) {
  let out = "";
  if (tag.tagName) {
    out += ` @${tag.tagName}`;
  }
  if (tag.text) {
    if (tag.text.match(/\/\*|\*\//)) {
      throw new Error('JSDoc text cannot contain "/*" and "*/"');
    }
    out += " " + tag.text.replace(/@/g, "\\@");
  }
  return out;
}
function serializeTags(tags) {
  if (tags.length === 0)
    return "";
  if (tags.length === 1 && tags[0].tagName && !tags[0].text) {
    return `*${tagToString(tags[0])} `;
  }
  let out = "*\n";
  for (const tag of tags) {
    out += " *";
    out += tagToString(tag).replace(/\n/g, "\n * ");
    out += "\n";
  }
  out += " ";
  return out;
}
function invalid$1(arg) {
  throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);
}
function isVariable(e) {
  return e instanceof ReadVarExpr;
}
function isLongStringLiteral(expr) {
  return expr instanceof LiteralExpr && typeof expr.value === "string" && expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;
}
function toBase64String(value) {
  let b64 = "";
  const encoded = utf8Encode(value);
  for (let i = 0; i < encoded.length; ) {
    const i1 = encoded[i++];
    const i2 = i < encoded.length ? encoded[i++] : null;
    const i3 = i < encoded.length ? encoded[i++] : null;
    b64 += toBase64Digit(i1 >> 2);
    b64 += toBase64Digit((i1 & 3) << 4 | (i2 === null ? 0 : i2 >> 4));
    b64 += i2 === null ? "=" : toBase64Digit((i2 & 15) << 2 | (i3 === null ? 0 : i3 >> 6));
    b64 += i2 === null || i3 === null ? "=" : toBase64Digit(i3 & 63);
  }
  return b64;
}
function toBase64VLQ(value) {
  value = value < 0 ? (-value << 1) + 1 : value << 1;
  let out = "";
  do {
    let digit = value & 31;
    value = value >> 5;
    if (value > 0) {
      digit = digit | 32;
    }
    out += toBase64Digit(digit);
  } while (value > 0);
  return out;
}
function toBase64Digit(value) {
  if (value < 0 || value >= 64) {
    throw new Error(`Can only encode value in the range [0, 63]`);
  }
  return B64_DIGITS[value];
}
function escapeIdentifier(input, escapeDollar, alwaysQuote = true) {
  if (input == null) {
    return null;
  }
  const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match) => {
    if (match[0] == "$") {
      return escapeDollar ? "\\$" : "$";
    } else if (match[0] == "\n") {
      return "\\n";
    } else if (match[0] == "\r") {
      return "\\r";
    } else {
      return `\\${match[0]}`;
    }
  });
  const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);
  return requiresQuotes ? `'${body}'` : body;
}
function _createIndent(count2) {
  let res = "";
  for (let i = 0; i < count2; i++) {
    res += _INDENT_WITH;
  }
  return res;
}
function typeWithParameters(type, numParams) {
  if (numParams === 0) {
    return expressionType(type);
  }
  const params = [];
  for (let i = 0; i < numParams; i++) {
    params.push(DYNAMIC_TYPE);
  }
  return expressionType(type, void 0, params);
}
function prepareSyntheticPropertyName(name) {
  return `${ANIMATE_SYMBOL_PREFIX}${name}`;
}
function prepareSyntheticListenerName(name, phase) {
  return `${ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;
}
function getSafePropertyAccessString(accessor, name) {
  const escapedName = escapeIdentifier(name, false, false);
  return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;
}
function prepareSyntheticListenerFunctionName(name, phase) {
  return `animation_${name}_${phase}`;
}
function jitOnlyGuardedExpression(expr) {
  return guardedExpression("ngJitMode", expr);
}
function guardedExpression(guard, expr) {
  const guardExpr = new ExternalExpr({
    name: guard,
    moduleName: null
  });
  const guardNotDefined = new BinaryOperatorExpr(BinaryOperator.Identical, new TypeofExpr(guardExpr), literal("undefined"));
  const guardUndefinedOrTrue = new BinaryOperatorExpr(
    BinaryOperator.Or,
    guardNotDefined,
    guardExpr,
    void 0,
    void 0,
    true
  );
  return new BinaryOperatorExpr(BinaryOperator.And, guardUndefinedOrTrue, expr);
}
function wrapReference(value) {
  const wrapped = new WrappedNodeExpr(value);
  return {
    value: wrapped,
    type: wrapped
  };
}
function refsToArray(refs, shouldForwardDeclare) {
  const values = literalArr(refs.map((ref) => ref.value));
  return shouldForwardDeclare ? fn([], [new ReturnStatement(values)]) : values;
}
function createMayBeForwardRefExpression(expression, forwardRef2) {
  return {
    expression,
    forwardRef: forwardRef2
  };
}
function convertFromMaybeForwardRefExpression({
  expression,
  forwardRef: forwardRef2
}) {
  switch (forwardRef2) {
    case 0:
    case 1:
      return expression;
    case 2:
      return generateForwardRef(expression);
  }
}
function generateForwardRef(expr) {
  return importExpr(Identifiers.forwardRef).callFn([fn([], [new ReturnStatement(expr)])]);
}
function compileFactoryFunction(meta) {
  const t = variable("t");
  let baseFactoryVar = null;
  const typeForCtor = !isDelegatedFactoryMetadata(meta) ? new BinaryOperatorExpr(BinaryOperator.Or, t, meta.internalType) : t;
  let ctorExpr = null;
  if (meta.deps !== null) {
    if (meta.deps !== "invalid") {
      ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));
    }
  } else {
    baseFactoryVar = variable(`\u0275${meta.name}_BaseFactory`);
    ctorExpr = baseFactoryVar.callFn([typeForCtor]);
  }
  const body = [];
  let retExpr = null;
  function makeConditionalFactory(nonCtorExpr) {
    const r = variable("r");
    body.push(r.set(NULL_EXPR).toDeclStmt());
    const ctorStmt = ctorExpr !== null ? r.set(ctorExpr).toStmt() : importExpr(Identifiers.invalidFactory).callFn([]).toStmt();
    body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));
    return r;
  }
  if (isDelegatedFactoryMetadata(meta)) {
    const delegateArgs = injectDependencies(meta.delegateDeps, meta.target);
    const factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ? InstantiateExpr : InvokeFunctionExpr)(meta.delegate, delegateArgs);
    retExpr = makeConditionalFactory(factoryExpr);
  } else if (isExpressionFactoryMetadata(meta)) {
    retExpr = makeConditionalFactory(meta.expression);
  } else {
    retExpr = ctorExpr;
  }
  if (retExpr === null) {
    body.push(importExpr(Identifiers.invalidFactory).callFn([]).toStmt());
  } else if (baseFactoryVar !== null) {
    const getInheritedFactoryCall = importExpr(Identifiers.getInheritedFactory).callFn([meta.internalType]);
    const baseFactory = new BinaryOperatorExpr(BinaryOperator.Or, baseFactoryVar, baseFactoryVar.set(getInheritedFactoryCall));
    body.push(new ReturnStatement(baseFactory.callFn([typeForCtor])));
  } else {
    body.push(new ReturnStatement(retExpr));
  }
  let factoryFn = fn([new FnParam("t", DYNAMIC_TYPE)], body, INFERRED_TYPE, void 0, `${meta.name}_Factory`);
  if (baseFactoryVar !== null) {
    factoryFn = fn([], [new DeclareVarStmt(baseFactoryVar.name), new ReturnStatement(factoryFn)]).callFn(
      [],
      void 0,
      true
    );
  }
  return {
    expression: factoryFn,
    statements: [],
    type: createFactoryType(meta)
  };
}
function createFactoryType(meta) {
  const ctorDepsType = meta.deps !== null && meta.deps !== "invalid" ? createCtorDepsType(meta.deps) : NONE_TYPE;
  return expressionType(importExpr(Identifiers.FactoryDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]));
}
function injectDependencies(deps, target) {
  return deps.map((dep, index) => compileInjectDependency(dep, target, index));
}
function compileInjectDependency(dep, target, index) {
  if (dep.token === null) {
    return importExpr(Identifiers.invalidFactoryDep).callFn([literal(index)]);
  } else if (dep.attributeNameType === null) {
    const flags = 0 | (dep.self ? 2 : 0) | (dep.skipSelf ? 4 : 0) | (dep.host ? 1 : 0) | (dep.optional ? 8 : 0) | (target === FactoryTarget$1.Pipe ? 16 : 0);
    let flagsParam = flags !== 0 || dep.optional ? literal(flags) : null;
    const injectArgs2 = [dep.token];
    if (flagsParam) {
      injectArgs2.push(flagsParam);
    }
    const injectFn = getInjectFn(target);
    return importExpr(injectFn).callFn(injectArgs2);
  } else {
    return importExpr(Identifiers.injectAttribute).callFn([dep.token]);
  }
}
function createCtorDepsType(deps) {
  let hasTypes = false;
  const attributeTypes = deps.map((dep) => {
    const type = createCtorDepType(dep);
    if (type !== null) {
      hasTypes = true;
      return type;
    } else {
      return literal(null);
    }
  });
  if (hasTypes) {
    return expressionType(literalArr(attributeTypes));
  } else {
    return NONE_TYPE;
  }
}
function createCtorDepType(dep) {
  const entries = [];
  if (dep.attributeNameType !== null) {
    entries.push({
      key: "attribute",
      value: dep.attributeNameType,
      quoted: false
    });
  }
  if (dep.optional) {
    entries.push({
      key: "optional",
      value: literal(true),
      quoted: false
    });
  }
  if (dep.host) {
    entries.push({
      key: "host",
      value: literal(true),
      quoted: false
    });
  }
  if (dep.self) {
    entries.push({
      key: "self",
      value: literal(true),
      quoted: false
    });
  }
  if (dep.skipSelf) {
    entries.push({
      key: "skipSelf",
      value: literal(true),
      quoted: false
    });
  }
  return entries.length > 0 ? literalMap(entries) : null;
}
function isDelegatedFactoryMetadata(meta) {
  return meta.delegateType !== void 0;
}
function isExpressionFactoryMetadata(meta) {
  return meta.expression !== void 0;
}
function getInjectFn(target) {
  switch (target) {
    case FactoryTarget$1.Component:
    case FactoryTarget$1.Directive:
    case FactoryTarget$1.Pipe:
      return Identifiers.directiveInject;
    case FactoryTarget$1.NgModule:
    case FactoryTarget$1.Injectable:
    default:
      return Identifiers.inject;
  }
}
function visitAll$1(visitor, nodes) {
  const result = [];
  if (visitor.visit) {
    for (const node of nodes) {
      const newNode = visitor.visit(node) || node.visit(visitor);
    }
  } else {
    for (const node of nodes) {
      const newNode = node.visit(visitor);
      if (newNode) {
        result.push(newNode);
      }
    }
  }
  return result;
}
function serializeMessage(messageNodes) {
  const visitor = new LocalizeMessageStringVisitor();
  const str = messageNodes.map((n) => n.visit(visitor)).join("");
  return str;
}
function toPublicName(internalName) {
  return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, "_");
}
function isI18nAttribute(name) {
  return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);
}
function isI18nRootNode(meta) {
  return meta instanceof Message;
}
function isSingleI18nIcu(meta) {
  return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu;
}
function hasI18nMeta(node) {
  return !!node.i18n;
}
function hasI18nAttrs(element) {
  return element.attrs.some((attr) => isI18nAttribute(attr.name));
}
function icuFromI18nMessage(message) {
  return message.nodes[0];
}
function wrapI18nPlaceholder(content, contextId = 0) {
  const blockId = contextId > 0 ? `:${contextId}` : "";
  return `${I18N_PLACEHOLDER_SYMBOL}${content}${blockId}${I18N_PLACEHOLDER_SYMBOL}`;
}
function assembleI18nBoundString(strings, bindingStartIndex = 0, contextId = 0) {
  if (!strings.length)
    return "";
  let acc = "";
  const lastIdx = strings.length - 1;
  for (let i = 0; i < lastIdx; i++) {
    acc += `${strings[i]}${wrapI18nPlaceholder(bindingStartIndex + i, contextId)}`;
  }
  acc += strings[lastIdx];
  return acc;
}
function getSeqNumberGenerator(startsAt = 0) {
  let current = startsAt;
  return () => current++;
}
function placeholdersToParams(placeholders) {
  const params = {};
  placeholders.forEach((values, key) => {
    params[key] = literal(values.length > 1 ? `[${values.join("|")}]` : values[0]);
  });
  return params;
}
function updatePlaceholderMap(map2, name, ...values) {
  const current = map2.get(name) || [];
  current.push(...values);
  map2.set(name, current);
}
function assembleBoundTextPlaceholders(meta, bindingStartIndex = 0, contextId = 0) {
  const startIdx = bindingStartIndex;
  const placeholders = /* @__PURE__ */ new Map();
  const node = meta instanceof Message ? meta.nodes.find((node2) => node2 instanceof Container) : meta;
  if (node) {
    node.children.filter((child) => child instanceof Placeholder).forEach((child, idx) => {
      const content = wrapI18nPlaceholder(startIdx + idx, contextId);
      updatePlaceholderMap(placeholders, child.name, content);
    });
  }
  return placeholders;
}
function formatI18nPlaceholderNamesInMap(params = {}, useCamelCase) {
  const _params = {};
  if (params && Object.keys(params).length) {
    Object.keys(params).forEach((key) => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);
  }
  return _params;
}
function formatI18nPlaceholderName(name, useCamelCase = true) {
  const publicName = toPublicName(name);
  if (!useCamelCase) {
    return publicName;
  }
  const chunks = publicName.split("_");
  if (chunks.length === 1) {
    return name.toLowerCase();
  }
  let postfix;
  if (/^\d+$/.test(chunks[chunks.length - 1])) {
    postfix = chunks.pop();
  }
  let raw = chunks.shift().toLowerCase();
  if (chunks.length) {
    raw += chunks.map((c) => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join("");
  }
  return postfix ? `${raw}_${postfix}` : raw;
}
function getTranslationConstPrefix(extra) {
  return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();
}
function declareI18nVariable(variable2) {
  return new DeclareVarStmt(variable2.name, void 0, INFERRED_TYPE, void 0, variable2.sourceSpan);
}
function invokeInstruction(span, reference, params) {
  return importExpr(reference, null, span).callFn(params, span);
}
function temporaryAllocator(statements, name) {
  let temp = null;
  return () => {
    if (!temp) {
      statements.push(new DeclareVarStmt(TEMPORARY_NAME, void 0, DYNAMIC_TYPE));
      temp = variable(name);
    }
    return temp;
  };
}
function invalid(arg) {
  throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);
}
function asLiteral(value) {
  if (Array.isArray(value)) {
    return literalArr(value.map(asLiteral));
  }
  return literal(value, INFERRED_TYPE);
}
function conditionallyCreateMapObjectLiteral(keys, keepDeclared) {
  if (Object.getOwnPropertyNames(keys).length > 0) {
    return mapToExpression(keys, keepDeclared);
  }
  return null;
}
function mapToExpression(map2, keepDeclared) {
  return literalMap(Object.getOwnPropertyNames(map2).map((key) => {
    const value = map2[key];
    let declaredName;
    let publicName;
    let minifiedName;
    let needsDeclaredName;
    if (Array.isArray(value)) {
      [publicName, declaredName] = value;
      minifiedName = key;
      needsDeclaredName = publicName !== declaredName;
    } else {
      minifiedName = declaredName = key;
      publicName = value;
      needsDeclaredName = false;
    }
    return {
      key: minifiedName,
      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),
      value: keepDeclared && needsDeclaredName ? literalArr([asLiteral(publicName), asLiteral(declaredName)]) : asLiteral(publicName)
    };
  }));
}
function trimTrailingNulls(parameters) {
  while (isNull(parameters[parameters.length - 1])) {
    parameters.pop();
  }
  return parameters;
}
function getQueryPredicate(query, constantPool) {
  if (Array.isArray(query.predicate)) {
    let predicate = [];
    query.predicate.forEach((selector) => {
      const selectors = selector.split(",").map((token) => literal(token.trim()));
      predicate.push(...selectors);
    });
    return constantPool.getConstLiteral(literalArr(predicate), true);
  } else {
    switch (query.predicate.forwardRef) {
      case 0:
      case 2:
        return query.predicate.expression;
      case 1:
        return importExpr(Identifiers.resolveForwardRef).callFn([query.predicate.expression]);
    }
  }
}
function getInterpolationArgsLength(interpolation) {
  const {
    expressions,
    strings
  } = interpolation;
  if (expressions.length === 1 && strings.length === 2 && strings[0] === "" && strings[1] === "") {
    return 1;
  } else {
    return expressions.length + strings.length;
  }
}
function getInstructionStatements(instructions) {
  var _a;
  const statements = [];
  let pendingExpression = null;
  let pendingExpressionType = null;
  let chainLength = 0;
  for (const current of instructions) {
    const resolvedParams = (_a = typeof current.paramsOrFn === "function" ? current.paramsOrFn() : current.paramsOrFn) !== null && _a !== void 0 ? _a : [];
    const params = Array.isArray(resolvedParams) ? resolvedParams : [resolvedParams];
    if (chainLength < MAX_CHAIN_LENGTH && pendingExpressionType === current.reference && CHAINABLE_INSTRUCTIONS.has(pendingExpressionType)) {
      pendingExpression = pendingExpression.callFn(params, pendingExpression.sourceSpan);
      chainLength++;
    } else {
      if (pendingExpression !== null) {
        statements.push(pendingExpression.toStmt());
      }
      pendingExpression = invokeInstruction(current.span, current.reference, params);
      pendingExpressionType = current.reference;
      chainLength = 0;
    }
  }
  if (pendingExpression !== null) {
    statements.push(pendingExpression.toStmt());
  }
  return statements;
}
function compileInjectable2(meta, resolveForwardRefs) {
  let result = null;
  const factoryMeta = {
    name: meta.name,
    type: meta.type,
    internalType: meta.internalType,
    typeArgumentCount: meta.typeArgumentCount,
    deps: [],
    target: FactoryTarget$1.Injectable
  };
  if (meta.useClass !== void 0) {
    const useClassOnSelf = meta.useClass.expression.isEquivalent(meta.internalType);
    let deps = void 0;
    if (meta.deps !== void 0) {
      deps = meta.deps;
    }
    if (deps !== void 0) {
      result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {
        delegate: meta.useClass.expression,
        delegateDeps: deps,
        delegateType: R3FactoryDelegateType.Class
      }));
    } else if (useClassOnSelf) {
      result = compileFactoryFunction(factoryMeta);
    } else {
      result = {
        statements: [],
        expression: delegateToFactory(meta.type.value, meta.useClass.expression, resolveForwardRefs)
      };
    }
  } else if (meta.useFactory !== void 0) {
    if (meta.deps !== void 0) {
      result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {
        delegate: meta.useFactory,
        delegateDeps: meta.deps || [],
        delegateType: R3FactoryDelegateType.Function
      }));
    } else {
      result = {
        statements: [],
        expression: fn([], [new ReturnStatement(meta.useFactory.callFn([]))])
      };
    }
  } else if (meta.useValue !== void 0) {
    result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {
      expression: meta.useValue.expression
    }));
  } else if (meta.useExisting !== void 0) {
    result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {
      expression: importExpr(Identifiers.inject).callFn([meta.useExisting.expression])
    }));
  } else {
    result = {
      statements: [],
      expression: delegateToFactory(meta.type.value, meta.internalType, resolveForwardRefs)
    };
  }
  const token = meta.internalType;
  const injectableProps = new DefinitionMap();
  injectableProps.set("token", token);
  injectableProps.set("factory", result.expression);
  if (meta.providedIn.expression.value !== null) {
    injectableProps.set("providedIn", convertFromMaybeForwardRefExpression(meta.providedIn));
  }
  const expression = importExpr(Identifiers.\u0275\u0275defineInjectable).callFn([injectableProps.toLiteralMap()], void 0, true);
  return {
    expression,
    type: createInjectableType(meta),
    statements: result.statements
  };
}
function createInjectableType(meta) {
  return new ExpressionType(importExpr(Identifiers.InjectableDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));
}
function delegateToFactory(type, internalType, unwrapForwardRefs) {
  if (type.node === internalType.node) {
    return internalType.prop("\u0275fac");
  }
  if (!unwrapForwardRefs) {
    return createFactoryFunction(internalType);
  }
  const unwrappedType = importExpr(Identifiers.resolveForwardRef).callFn([internalType]);
  return createFactoryFunction(unwrappedType);
}
function createFactoryFunction(type) {
  return fn([new FnParam("t", DYNAMIC_TYPE)], [new ReturnStatement(type.prop("\u0275fac").callFn([variable("t")]))]);
}
function assertInterpolationSymbols(identifier, value) {
  if (value != null && !(Array.isArray(value) && value.length == 2)) {
    throw new Error(`Expected '${identifier}' to be an array, [start, end].`);
  } else if (value != null) {
    const start = value[0];
    const end = value[1];
    UNUSABLE_INTERPOLATION_REGEXPS.forEach((regexp) => {
      if (regexp.test(start) || regexp.test(end)) {
        throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);
      }
    });
  }
}
function isWhitespace(code) {
  return code >= $TAB && code <= $SPACE || code == $NBSP;
}
function isDigit(code) {
  return $0 <= code && code <= $9;
}
function isAsciiLetter(code) {
  return code >= $a && code <= $z || code >= $A && code <= $Z;
}
function isAsciiHexDigit(code) {
  return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);
}
function isNewLine(code) {
  return code === $LF || code === $CR;
}
function isOctalDigit(code) {
  return $0 <= code && code <= $7;
}
function isQuote(code) {
  return code === $SQ || code === $DQ || code === $BT;
}
function r3JitTypeSourceSpan(kind, typeName, sourceUrl) {
  const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;
  const sourceFile = new ParseSourceFile("", sourceFileName);
  return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));
}
function identifierName(compileIdentifier) {
  if (!compileIdentifier || !compileIdentifier.reference) {
    return null;
  }
  const ref = compileIdentifier.reference;
  if (ref["__anonymousType"]) {
    return ref["__anonymousType"];
  }
  if (ref["__forward_ref__"]) {
    return "__forward_ref__";
  }
  let identifier = stringify2(ref);
  if (identifier.indexOf("(") >= 0) {
    identifier = `anonymous_${_anonymousTypeIndex++}`;
    ref["__anonymousType"] = identifier;
  } else {
    identifier = sanitizeIdentifier(identifier);
  }
  return identifier;
}
function sanitizeIdentifier(name) {
  return name.replace(/\W/g, "_");
}
function getPolicy2() {
  if (policy2 === void 0) {
    policy2 = null;
    if (_global2.trustedTypes) {
      try {
        policy2 = _global2.trustedTypes.createPolicy("angular#unsafe-jit", {
          createScript: (s) => s
        });
      } catch (_a) {
      }
    }
  }
  return policy2;
}
function trustedScriptFromString2(script) {
  var _a;
  return ((_a = getPolicy2()) === null || _a === void 0 ? void 0 : _a.createScript(script)) || script;
}
function newTrustedFunctionForJIT(...args) {
  if (!_global2.trustedTypes) {
    return new Function(...args);
  }
  const fnArgs = args.slice(0, -1).join(",");
  const fnBody = args[args.length - 1];
  const body = `(function anonymous(${fnArgs}
) { ${fnBody}
})`;
  const fn2 = _global2["eval"](trustedScriptFromString2(body));
  if (fn2.bind === void 0) {
    return new Function(...args);
  }
  fn2.toString = () => body;
  return fn2.bind(_global2);
}
function isUseStrictStatement(statement) {
  return statement.isEquivalent(literal("use strict").toStmt());
}
function compileInjector(meta) {
  const definitionMap = new DefinitionMap();
  if (meta.providers !== null) {
    definitionMap.set("providers", meta.providers);
  }
  if (meta.imports.length > 0) {
    definitionMap.set("imports", literalArr(meta.imports));
  }
  const expression = importExpr(Identifiers.defineInjector).callFn([definitionMap.toLiteralMap()], void 0, true);
  const type = createInjectorType(meta);
  return {
    expression,
    type,
    statements: []
  };
}
function createInjectorType(meta) {
  return new ExpressionType(importExpr(Identifiers.InjectorDeclaration, [new ExpressionType(meta.type.type)]));
}
function compileNgModule2(meta) {
  const {
    adjacentType,
    internalType,
    bootstrap,
    declarations,
    imports,
    exports,
    schemas,
    containsForwardDecls,
    selectorScopeMode,
    id
  } = meta;
  const statements = [];
  const definitionMap = new DefinitionMap();
  definitionMap.set("type", internalType);
  if (bootstrap.length > 0) {
    definitionMap.set("bootstrap", refsToArray(bootstrap, containsForwardDecls));
  }
  if (selectorScopeMode === R3SelectorScopeMode.Inline) {
    if (declarations.length > 0) {
      definitionMap.set("declarations", refsToArray(declarations, containsForwardDecls));
    }
    if (imports.length > 0) {
      definitionMap.set("imports", refsToArray(imports, containsForwardDecls));
    }
    if (exports.length > 0) {
      definitionMap.set("exports", refsToArray(exports, containsForwardDecls));
    }
  } else if (selectorScopeMode === R3SelectorScopeMode.SideEffect) {
    const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);
    if (setNgModuleScopeCall !== null) {
      statements.push(setNgModuleScopeCall);
    }
  } else {
  }
  if (schemas !== null && schemas.length > 0) {
    definitionMap.set("schemas", literalArr(schemas.map((ref) => ref.value)));
  }
  if (id !== null) {
    definitionMap.set("id", id);
    statements.push(importExpr(Identifiers.registerNgModuleType).callFn([adjacentType, id]).toStmt());
  }
  const expression = importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()], void 0, true);
  const type = createNgModuleType(meta);
  return {
    expression,
    type,
    statements
  };
}
function compileNgModuleDeclarationExpression(meta) {
  const definitionMap = new DefinitionMap();
  definitionMap.set("type", new WrappedNodeExpr(meta.type));
  if (meta.bootstrap !== void 0) {
    definitionMap.set("bootstrap", new WrappedNodeExpr(meta.bootstrap));
  }
  if (meta.declarations !== void 0) {
    definitionMap.set("declarations", new WrappedNodeExpr(meta.declarations));
  }
  if (meta.imports !== void 0) {
    definitionMap.set("imports", new WrappedNodeExpr(meta.imports));
  }
  if (meta.exports !== void 0) {
    definitionMap.set("exports", new WrappedNodeExpr(meta.exports));
  }
  if (meta.schemas !== void 0) {
    definitionMap.set("schemas", new WrappedNodeExpr(meta.schemas));
  }
  if (meta.id !== void 0) {
    definitionMap.set("id", new WrappedNodeExpr(meta.id));
  }
  return importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()]);
}
function createNgModuleType({
  type: moduleType,
  declarations,
  exports,
  imports,
  includeImportTypes,
  publicDeclarationTypes
}) {
  return new ExpressionType(importExpr(Identifiers.NgModuleDeclaration, [new ExpressionType(moduleType.type), publicDeclarationTypes === null ? tupleTypeOf(declarations) : tupleOfTypes(publicDeclarationTypes), includeImportTypes ? tupleTypeOf(imports) : NONE_TYPE, tupleTypeOf(exports)]));
}
function generateSetNgModuleScopeCall(meta) {
  const {
    adjacentType: moduleType,
    declarations,
    imports,
    exports,
    containsForwardDecls
  } = meta;
  const scopeMap = new DefinitionMap();
  if (declarations.length > 0) {
    scopeMap.set("declarations", refsToArray(declarations, containsForwardDecls));
  }
  if (imports.length > 0) {
    scopeMap.set("imports", refsToArray(imports, containsForwardDecls));
  }
  if (exports.length > 0) {
    scopeMap.set("exports", refsToArray(exports, containsForwardDecls));
  }
  if (Object.keys(scopeMap.values).length === 0) {
    return null;
  }
  const fnCall = new InvokeFunctionExpr(
    importExpr(Identifiers.setNgModuleScope),
    [moduleType, scopeMap.toLiteralMap()]
  );
  const guardedCall = jitOnlyGuardedExpression(fnCall);
  const iife = new FunctionExpr(
    [],
    [guardedCall.toStmt()]
  );
  const iifeCall = new InvokeFunctionExpr(
    iife,
    []
  );
  return iifeCall.toStmt();
}
function tupleTypeOf(exp) {
  const types = exp.map((ref) => typeofExpr(ref.type));
  return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;
}
function tupleOfTypes(types) {
  const typeofTypes = types.map((type) => typeofExpr(type));
  return types.length > 0 ? expressionType(literalArr(typeofTypes)) : NONE_TYPE;
}
function compilePipeFromMetadata(metadata) {
  const definitionMapValues = [];
  definitionMapValues.push({
    key: "name",
    value: literal(metadata.pipeName),
    quoted: false
  });
  definitionMapValues.push({
    key: "type",
    value: metadata.type.value,
    quoted: false
  });
  definitionMapValues.push({
    key: "pure",
    value: literal(metadata.pure),
    quoted: false
  });
  if (metadata.isStandalone) {
    definitionMapValues.push({
      key: "standalone",
      value: literal(true),
      quoted: false
    });
  }
  const expression = importExpr(Identifiers.definePipe).callFn([literalMap(definitionMapValues)], void 0, true);
  const type = createPipeType(metadata);
  return {
    expression,
    type,
    statements: []
  };
}
function createPipeType(metadata) {
  return new ExpressionType(importExpr(Identifiers.PipeDeclaration, [typeWithParameters(metadata.type.type, metadata.typeArgumentCount), new ExpressionType(new LiteralExpr(metadata.pipeName)), new ExpressionType(new LiteralExpr(metadata.isStandalone))]));
}
function convertActionBinding(localResolver, implicitReceiver, action, bindingId, baseSourceSpan, implicitReceiverAccesses, globals) {
  if (!localResolver) {
    localResolver = new DefaultLocalResolver(globals);
  }
  const actionWithoutBuiltins = convertPropertyBindingBuiltins({
    createLiteralArrayConverter: (argCount) => {
      return (args) => literalArr(args);
    },
    createLiteralMapConverter: (keys) => {
      return (values) => {
        const entries = keys.map((k, i) => ({
          key: k.key,
          value: values[i],
          quoted: k.quoted
        }));
        return literalMap(entries);
      };
    },
    createPipeConverter: (name) => {
      throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);
    }
  }, action);
  const visitor = new _AstToIrVisitor(
    localResolver,
    implicitReceiver,
    bindingId,
    false,
    baseSourceSpan,
    implicitReceiverAccesses
  );
  const actionStmts = [];
  flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);
  prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);
  if (visitor.usesImplicitReceiver) {
    localResolver.notifyImplicitReceiverUse();
  }
  const lastIndex = actionStmts.length - 1;
  if (lastIndex >= 0) {
    const lastStatement = actionStmts[lastIndex];
    if (lastStatement instanceof ExpressionStatement) {
      actionStmts[lastIndex] = new ReturnStatement(lastStatement.expr);
    }
  }
  return actionStmts;
}
function convertPropertyBindingBuiltins(converterFactory, ast) {
  return convertBuiltins(converterFactory, ast);
}
function convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId) {
  if (!localResolver) {
    localResolver = new DefaultLocalResolver();
  }
  const visitor = new _AstToIrVisitor(
    localResolver,
    implicitReceiver,
    bindingId,
    false
  );
  const outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);
  const stmts = getStatementsFromVisitor(visitor, bindingId);
  if (visitor.usesImplicitReceiver) {
    localResolver.notifyImplicitReceiverUse();
  }
  return new ConvertPropertyBindingResult(stmts, outputExpr);
}
function convertUpdateArguments(localResolver, contextVariableExpression, expressionWithArgumentsToExtract, bindingId) {
  const visitor = new _AstToIrVisitor(
    localResolver,
    contextVariableExpression,
    bindingId,
    true
  );
  const outputExpr = visitor.visitInterpolation(expressionWithArgumentsToExtract, _Mode.Expression);
  if (visitor.usesImplicitReceiver) {
    localResolver.notifyImplicitReceiverUse();
  }
  const stmts = getStatementsFromVisitor(visitor, bindingId);
  const args = outputExpr.args;
  return {
    stmts,
    args
  };
}
function getStatementsFromVisitor(visitor, bindingId) {
  const stmts = [];
  for (let i = 0; i < visitor.temporaryCount; i++) {
    stmts.push(temporaryDeclaration(bindingId, i));
  }
  return stmts;
}
function convertBuiltins(converterFactory, ast) {
  const visitor = new _BuiltinAstConverter(converterFactory);
  return ast.visit(visitor);
}
function temporaryName(bindingId, temporaryNumber) {
  return `tmp_${bindingId}_${temporaryNumber}`;
}
function temporaryDeclaration(bindingId, temporaryNumber) {
  return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber));
}
function prependTemporaryDecls(temporaryCount, bindingId, statements) {
  for (let i = temporaryCount - 1; i >= 0; i--) {
    statements.unshift(temporaryDeclaration(bindingId, i));
  }
}
function ensureStatementMode(mode, ast) {
  if (mode !== _Mode.Statement) {
    throw new Error(`Expected a statement, but saw ${ast}`);
  }
}
function ensureExpressionMode(mode, ast) {
  if (mode !== _Mode.Expression) {
    throw new Error(`Expected an expression, but saw ${ast}`);
  }
}
function convertToStatementIfNeeded(mode, expr) {
  if (mode === _Mode.Statement) {
    return expr.toStmt();
  } else {
    return expr;
  }
}
function flattenStatements(arg, output) {
  if (Array.isArray(arg)) {
    arg.forEach((entry) => flattenStatements(entry, output));
  } else {
    output.push(arg);
  }
}
function unsupported() {
  throw new Error("Unsupported operation");
}
function stripComments(input) {
  return input.replace(_commentRe, "");
}
function extractCommentsWithHash(input) {
  return input.match(_commentWithHashRe) || [];
}
function processRules(input, ruleCallback) {
  const inputWithEscapedQuotes = escapeBlocks(input, QUOTE_PAIRS, QUOTE_PLACEHOLDER);
  const inputWithEscapedBlocks = escapeBlocks(inputWithEscapedQuotes.escapedString, CONTENT_PAIRS, BLOCK_PLACEHOLDER);
  let nextBlockIndex = 0;
  let nextQuoteIndex = 0;
  return inputWithEscapedBlocks.escapedString.replace(_ruleRe, (...m) => {
    const selector = m[2];
    let content = "";
    let suffix = m[4];
    let contentPrefix = "";
    if (suffix && suffix.startsWith("{" + BLOCK_PLACEHOLDER)) {
      content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
      suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
      contentPrefix = "{";
    }
    const rule = ruleCallback(new CssRule(selector, content));
    return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;
  }).replace(_quotedRe, () => inputWithEscapedQuotes.blocks[nextQuoteIndex++]);
}
function escapeBlocks(input, charPairs, placeholder) {
  const resultParts = [];
  const escapedBlocks = [];
  let openCharCount = 0;
  let nonBlockStartIndex = 0;
  let blockStartIndex = -1;
  let openChar;
  let closeChar;
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    if (char === "\\") {
      i++;
    } else if (char === closeChar) {
      openCharCount--;
      if (openCharCount === 0) {
        escapedBlocks.push(input.substring(blockStartIndex, i));
        resultParts.push(placeholder);
        nonBlockStartIndex = i;
        blockStartIndex = -1;
        openChar = closeChar = void 0;
      }
    } else if (char === openChar) {
      openCharCount++;
    } else if (openCharCount === 0 && charPairs.has(char)) {
      openChar = char;
      closeChar = charPairs.get(char);
      openCharCount = 1;
      blockStartIndex = i + 1;
      resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));
    }
  }
  if (blockStartIndex !== -1) {
    escapedBlocks.push(input.substring(blockStartIndex));
    resultParts.push(placeholder);
  } else {
    resultParts.push(input.substring(nonBlockStartIndex));
  }
  return new StringWithEscapedBlocks(resultParts.join(""), escapedBlocks);
}
function combineHostContextSelectors(contextSelectors, otherSelectors) {
  const hostMarker = _polyfillHostNoCombinator;
  _polyfillHostRe.lastIndex = 0;
  const otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors);
  if (contextSelectors.length === 0) {
    return hostMarker + otherSelectors;
  }
  const combined = [contextSelectors.pop() || ""];
  while (contextSelectors.length > 0) {
    const length = combined.length;
    const contextSelector = contextSelectors.pop();
    for (let i = 0; i < length; i++) {
      const previousSelectors = combined[i];
      combined[length * 2 + i] = previousSelectors + " " + contextSelector;
      combined[length + i] = contextSelector + " " + previousSelectors;
      combined[i] = contextSelector + previousSelectors;
    }
  }
  return combined.map((s) => otherSelectorsHasHost ? `${s}${otherSelectors}` : `${s}${hostMarker}${otherSelectors}, ${s} ${hostMarker}${otherSelectors}`).join(",");
}
function repeatGroups(groups, multiples) {
  const length = groups.length;
  for (let i = 1; i < multiples; i++) {
    for (let j = 0; j < length; j++) {
      groups[j + i * length] = groups[j].slice(0);
    }
  }
}
function parse(value) {
  const styles = [];
  let i = 0;
  let parenDepth = 0;
  let quote = 0;
  let valueStart = 0;
  let propStart = 0;
  let currentProp = null;
  let valueHasQuotes = false;
  while (i < value.length) {
    const token = value.charCodeAt(i++);
    switch (token) {
      case 40:
        parenDepth++;
        break;
      case 41:
        parenDepth--;
        break;
      case 39:
        valueHasQuotes = valueHasQuotes || valueStart > 0;
        if (quote === 0) {
          quote = 39;
        } else if (quote === 39 && value.charCodeAt(i - 1) !== 92) {
          quote = 0;
        }
        break;
      case 34:
        valueHasQuotes = valueHasQuotes || valueStart > 0;
        if (quote === 0) {
          quote = 34;
        } else if (quote === 34 && value.charCodeAt(i - 1) !== 92) {
          quote = 0;
        }
        break;
      case 58:
        if (!currentProp && parenDepth === 0 && quote === 0) {
          currentProp = hyphenate(value.substring(propStart, i - 1).trim());
          valueStart = i;
        }
        break;
      case 59:
        if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0) {
          const styleVal = value.substring(valueStart, i - 1).trim();
          styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);
          propStart = i;
          valueStart = 0;
          currentProp = null;
          valueHasQuotes = false;
        }
        break;
    }
  }
  if (currentProp && valueStart) {
    const styleVal = value.slice(valueStart).trim();
    styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);
  }
  return styles;
}
function stripUnnecessaryQuotes(value) {
  const qS = value.charCodeAt(0);
  const qE = value.charCodeAt(value.length - 1);
  if (qS == qE && (qS == 39 || qS == 34)) {
    const tempValue = value.substring(1, value.length - 1);
    if (tempValue.indexOf("'") == -1 && tempValue.indexOf('"') == -1) {
      value = tempValue;
    }
  }
  return value;
}
function hyphenate(value) {
  return value.replace(/[a-z][A-Z]/g, (v) => {
    return v.charAt(0) + "-" + v.charAt(1);
  }).toLowerCase();
}
function registerIntoMap(map2, key) {
  if (!map2.has(key)) {
    map2.set(key, map2.size);
  }
}
function parseProperty(name) {
  let hasOverrideFlag = false;
  const overrideIndex = name.indexOf(IMPORTANT_FLAG);
  if (overrideIndex !== -1) {
    name = overrideIndex > 0 ? name.substring(0, overrideIndex) : "";
    hasOverrideFlag = true;
  }
  let suffix = null;
  let property = name;
  const unitIndex = name.lastIndexOf(".");
  if (unitIndex > 0) {
    suffix = name.slice(unitIndex + 1);
    property = name.substring(0, unitIndex);
  }
  return {
    property,
    suffix,
    hasOverrideFlag
  };
}
function getClassMapInterpolationExpression(interpolation) {
  switch (getInterpolationArgsLength(interpolation)) {
    case 1:
      return Identifiers.classMap;
    case 3:
      return Identifiers.classMapInterpolate1;
    case 5:
      return Identifiers.classMapInterpolate2;
    case 7:
      return Identifiers.classMapInterpolate3;
    case 9:
      return Identifiers.classMapInterpolate4;
    case 11:
      return Identifiers.classMapInterpolate5;
    case 13:
      return Identifiers.classMapInterpolate6;
    case 15:
      return Identifiers.classMapInterpolate7;
    case 17:
      return Identifiers.classMapInterpolate8;
    default:
      return Identifiers.classMapInterpolateV;
  }
}
function getStyleMapInterpolationExpression(interpolation) {
  switch (getInterpolationArgsLength(interpolation)) {
    case 1:
      return Identifiers.styleMap;
    case 3:
      return Identifiers.styleMapInterpolate1;
    case 5:
      return Identifiers.styleMapInterpolate2;
    case 7:
      return Identifiers.styleMapInterpolate3;
    case 9:
      return Identifiers.styleMapInterpolate4;
    case 11:
      return Identifiers.styleMapInterpolate5;
    case 13:
      return Identifiers.styleMapInterpolate6;
    case 15:
      return Identifiers.styleMapInterpolate7;
    case 17:
      return Identifiers.styleMapInterpolate8;
    default:
      return Identifiers.styleMapInterpolateV;
  }
}
function getStylePropInterpolationExpression(interpolation) {
  switch (getInterpolationArgsLength(interpolation)) {
    case 1:
      return Identifiers.styleProp;
    case 3:
      return Identifiers.stylePropInterpolate1;
    case 5:
      return Identifiers.stylePropInterpolate2;
    case 7:
      return Identifiers.stylePropInterpolate3;
    case 9:
      return Identifiers.stylePropInterpolate4;
    case 11:
      return Identifiers.stylePropInterpolate5;
    case 13:
      return Identifiers.stylePropInterpolate6;
    case 15:
      return Identifiers.stylePropInterpolate7;
    case 17:
      return Identifiers.stylePropInterpolate8;
    default:
      return Identifiers.stylePropInterpolateV;
  }
}
function isCssCustomProperty(name) {
  return name.startsWith("--");
}
function isEmptyExpression(ast) {
  if (ast instanceof ASTWithSource) {
    ast = ast.ast;
  }
  return ast instanceof EmptyExpr;
}
function newCharacterToken(index, end, code) {
  return new Token(index, end, TokenType.Character, code, String.fromCharCode(code));
}
function newIdentifierToken(index, end, text) {
  return new Token(index, end, TokenType.Identifier, 0, text);
}
function newPrivateIdentifierToken(index, end, text) {
  return new Token(index, end, TokenType.PrivateIdentifier, 0, text);
}
function newKeywordToken(index, end, text) {
  return new Token(index, end, TokenType.Keyword, 0, text);
}
function newOperatorToken(index, end, text) {
  return new Token(index, end, TokenType.Operator, 0, text);
}
function newStringToken(index, end, text) {
  return new Token(index, end, TokenType.String, 0, text);
}
function newNumberToken(index, end, n) {
  return new Token(index, end, TokenType.Number, n, "");
}
function newErrorToken(index, end, message) {
  return new Token(index, end, TokenType.Error, 0, message);
}
function isIdentifierStart(code) {
  return $a <= code && code <= $z || $A <= code && code <= $Z || code == $_ || code == $$;
}
function isIdentifierPart(code) {
  return isAsciiLetter(code) || isDigit(code) || code == $_ || code == $$;
}
function isExponentStart(code) {
  return code == $e || code == $E;
}
function isExponentSign(code) {
  return code == $MINUS || code == $PLUS;
}
function unescape(code) {
  switch (code) {
    case $n:
      return $LF;
    case $f:
      return $FF;
    case $r:
      return $CR;
    case $t:
      return $TAB;
    case $v:
      return $VTAB;
    default:
      return code;
  }
}
function parseIntAutoRadix2(text) {
  const result = parseInt(text);
  if (isNaN(result)) {
    throw new Error("Invalid integer literal when parsing " + text);
  }
  return result;
}
function getIndexMapForOriginalTemplate(interpolatedTokens) {
  let offsetMap = /* @__PURE__ */ new Map();
  let consumedInOriginalTemplate = 0;
  let consumedInInput = 0;
  let tokenIndex = 0;
  while (tokenIndex < interpolatedTokens.length) {
    const currentToken = interpolatedTokens[tokenIndex];
    if (currentToken.type === 9) {
      const [decoded, encoded] = currentToken.parts;
      consumedInOriginalTemplate += encoded.length;
      consumedInInput += decoded.length;
    } else {
      const lengthOfParts = currentToken.parts.reduce((sum, current) => sum + current.length, 0);
      consumedInInput += lengthOfParts;
      consumedInOriginalTemplate += lengthOfParts;
    }
    offsetMap.set(consumedInInput, consumedInOriginalTemplate);
    tokenIndex++;
  }
  return offsetMap;
}
function visitAll(visitor, nodes, context2 = null) {
  const result = [];
  const visit = visitor.visit ? (ast) => visitor.visit(ast, context2) || ast.visit(visitor, context2) : (ast) => ast.visit(visitor, context2);
  nodes.forEach((ast) => {
    const astResult = visit(ast);
    if (astResult) {
      result.push(astResult);
    }
  });
  return result;
}
function tokenize(source, url, getTagDefinition, options = {}) {
  const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);
  tokenizer.tokenize();
  return new TokenizeResult(mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);
}
function _unexpectedCharacterErrorMsg(charCode) {
  const char = charCode === $EOF ? "EOF" : String.fromCharCode(charCode);
  return `Unexpected character "${char}"`;
}
function _unknownEntityErrorMsg(entitySrc) {
  return `Unknown entity "${entitySrc}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
}
function _unparsableEntityErrorMsg(type, entityStr) {
  return `Unable to parse entity "${entityStr}" - ${type} character reference entities must end with ";"`;
}
function isNotWhitespace(code) {
  return !isWhitespace(code) || code === $EOF;
}
function isNameEnd(code) {
  return isWhitespace(code) || code === $GT || code === $LT || code === $SLASH || code === $SQ || code === $DQ || code === $EQ || code === $EOF;
}
function isPrefixEnd(code) {
  return (code < $a || $z < code) && (code < $A || $Z < code) && (code < $0 || code > $9);
}
function isDigitEntityEnd(code) {
  return code === $SEMICOLON || code === $EOF || !isAsciiHexDigit(code);
}
function isNamedEntityEnd(code) {
  return code === $SEMICOLON || code === $EOF || !isAsciiLetter(code);
}
function isExpansionCaseStart(peek) {
  return peek !== $RBRACE;
}
function compareCharCodeCaseInsensitive(code1, code2) {
  return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);
}
function toUpperCaseCharCode(code) {
  return code >= $a && code <= $z ? code - $a + $A : code;
}
function mergeTextTokens(srcTokens) {
  const dstTokens = [];
  let lastDstToken = void 0;
  for (let i = 0; i < srcTokens.length; i++) {
    const token = srcTokens[i];
    if (lastDstToken && lastDstToken.type === 5 && token.type === 5 || lastDstToken && lastDstToken.type === 16 && token.type === 16) {
      lastDstToken.parts[0] += token.parts[0];
      lastDstToken.sourceSpan.end = token.sourceSpan.end;
    } else {
      lastDstToken = token;
      dstTokens.push(lastDstToken);
    }
  }
  return dstTokens;
}
function lastOnStack(stack, element) {
  return stack.length > 0 && stack[stack.length - 1] === element;
}
function decodeEntity(match, entity) {
  if (NAMED_ENTITIES[entity] !== void 0) {
    return NAMED_ENTITIES[entity] || match;
  }
  if (/^#x[a-f0-9]+$/i.test(entity)) {
    return String.fromCodePoint(parseInt(entity.slice(2), 16));
  }
  if (/^#\d+$/.test(entity)) {
    return String.fromCodePoint(parseInt(entity.slice(1), 10));
  }
  return match;
}
function hasPreserveWhitespacesAttr(attrs) {
  return attrs.some((attr) => attr.name === PRESERVE_WS_ATTR_NAME);
}
function replaceNgsp2(value) {
  return value.replace(new RegExp(NGSP_UNICODE, "g"), " ");
}
function createWhitespaceProcessedTextToken({
  type,
  parts,
  sourceSpan
}) {
  return {
    type,
    parts: [processWhitespace(parts[0])],
    sourceSpan
  };
}
function processWhitespace(text) {
  return replaceNgsp2(text).replace(WS_REPLACE_REGEXP, " ");
}
function visitAllWithSiblings(visitor, nodes) {
  const result = [];
  nodes.forEach((ast, i) => {
    const context2 = {
      prev: nodes[i - 1],
      next: nodes[i + 1]
    };
    const astResult = ast.visit(visitor, context2);
    if (astResult) {
      result.push(astResult);
    }
  });
  return result;
}
function mapLiteral(obj, quoted = false) {
  return literalMap(Object.keys(obj).map((key) => ({
    key,
    quoted,
    value: obj[key]
  })));
}
function SECURITY_SCHEMA() {
  if (!_SECURITY_SCHEMA) {
    _SECURITY_SCHEMA = {};
    registerContext(SecurityContext2.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]);
    registerContext(SecurityContext2.STYLE, ["*|style"]);
    registerContext(SecurityContext2.URL, ["*|formAction", "area|href", "area|ping", "audio|src", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "form|action", "img|src", "img|srcset", "input|src", "ins|cite", "q|cite", "source|src", "source|srcset", "track|src", "video|poster", "video|src"]);
    registerContext(SecurityContext2.RESOURCE_URL, ["applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"]);
  }
  return _SECURITY_SCHEMA;
}
function registerContext(ctx, specs) {
  for (const spec of specs)
    _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;
}
function _isPixelDimensionStyle(prop) {
  switch (prop) {
    case "width":
    case "height":
    case "minWidth":
    case "minHeight":
    case "maxWidth":
    case "maxHeight":
    case "left":
    case "top":
    case "bottom":
    case "right":
    case "fontSize":
    case "outlineWidth":
    case "outlineOffset":
    case "paddingTop":
    case "paddingLeft":
    case "paddingBottom":
    case "paddingRight":
    case "marginTop":
    case "marginLeft":
    case "marginBottom":
    case "marginRight":
    case "borderRadius":
    case "borderWidth":
    case "borderTopWidth":
    case "borderLeftWidth":
    case "borderRightWidth":
    case "borderBottomWidth":
    case "textIndent":
      return true;
    default:
      return false;
  }
}
function isTrustedTypesSink(tagName, propName) {
  tagName = tagName.toLowerCase();
  propName = propName.toLowerCase();
  return TRUSTED_TYPES_SINKS.has(tagName + "|" + propName) || TRUSTED_TYPES_SINKS.has("*|" + propName);
}
function isAnimationLabel(name) {
  return name[0] == "@";
}
function calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {
  const ctxs = [];
  CssSelector.parse(selector).forEach((selector2) => {
    const elementNames = selector2.element ? [selector2.element] : registry.allKnownElementNames();
    const notElementNames = new Set(selector2.notSelectors.filter((selector3) => selector3.isElementSelector()).map((selector3) => selector3.element));
    const possibleElementNames = elementNames.filter((elementName) => !notElementNames.has(elementName));
    ctxs.push(...possibleElementNames.map((elementName) => registry.securityContext(elementName, propName, isAttribute)));
  });
  return ctxs.length === 0 ? [SecurityContext2.NONE] : Array.from(new Set(ctxs)).sort();
}
function moveParseSourceSpan(sourceSpan, absoluteSpan) {
  const startDiff = absoluteSpan.start - sourceSpan.start.offset;
  const endDiff = absoluteSpan.end - sourceSpan.end.offset;
  return new ParseSourceSpan(sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff), sourceSpan.fullStart.moveBy(startDiff), sourceSpan.details);
}
function isStyleUrlResolvable(url) {
  if (url == null || url.length === 0 || url[0] == "/")
    return false;
  const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);
  return schemeMatch === null || schemeMatch[1] == "package" || schemeMatch[1] == "asset";
}
function preparseElement(ast) {
  let selectAttr = null;
  let hrefAttr = null;
  let relAttr = null;
  let nonBindable = false;
  let projectAs = "";
  ast.attrs.forEach((attr) => {
    const lcAttrName = attr.name.toLowerCase();
    if (lcAttrName == NG_CONTENT_SELECT_ATTR$1) {
      selectAttr = attr.value;
    } else if (lcAttrName == LINK_STYLE_HREF_ATTR) {
      hrefAttr = attr.value;
    } else if (lcAttrName == LINK_STYLE_REL_ATTR) {
      relAttr = attr.value;
    } else if (attr.name == NG_NON_BINDABLE_ATTR) {
      nonBindable = true;
    } else if (attr.name == NG_PROJECT_AS) {
      if (attr.value.length > 0) {
        projectAs = attr.value;
      }
    }
  });
  selectAttr = normalizeNgContentSelect(selectAttr);
  const nodeName = ast.name.toLowerCase();
  let type = PreparsedElementType.OTHER;
  if (isNgContent(nodeName)) {
    type = PreparsedElementType.NG_CONTENT;
  } else if (nodeName == STYLE_ELEMENT) {
    type = PreparsedElementType.STYLE;
  } else if (nodeName == SCRIPT_ELEMENT) {
    type = PreparsedElementType.SCRIPT;
  } else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
    type = PreparsedElementType.STYLESHEET;
  }
  return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);
}
function normalizeNgContentSelect(selectAttr) {
  if (selectAttr === null || selectAttr.length === 0) {
    return "*";
  }
  return selectAttr;
}
function htmlAstToRender3Ast(htmlNodes, bindingParser, options) {
  const transformer = new HtmlAstToIvyAst(bindingParser, options);
  const ivyNodes = visitAll(transformer, htmlNodes);
  const allErrors = bindingParser.errors.concat(transformer.errors);
  const result = {
    nodes: ivyNodes,
    errors: allErrors,
    styleUrls: transformer.styleUrls,
    styles: transformer.styles,
    ngContentSelectors: transformer.ngContentSelectors
  };
  if (options.collectCommentNodes) {
    result.commentNodes = transformer.commentNodes;
  }
  return result;
}
function normalizeAttributeName(attrName) {
  return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;
}
function addEvents(events, boundEvents) {
  boundEvents.push(...events.map((e) => BoundEvent.fromParsedEvent(e)));
}
function isEmptyTextNode(node) {
  return node instanceof Text2 && node.value.trim().length == 0;
}
function isCommentNode(node) {
  return node instanceof Comment;
}
function textContents(node) {
  if (node.children.length !== 1 || !(node.children[0] instanceof Text2)) {
    return null;
  } else {
    return node.children[0].value;
  }
}
function setupRegistry() {
  return {
    getUniqueId: getSeqNumberGenerator(),
    icus: /* @__PURE__ */ new Map()
  };
}
function wrap(symbol, index, contextId, closed) {
  const state = closed ? "/" : "";
  return wrapI18nPlaceholder(`${state}${symbol}${index}`, contextId);
}
function wrapTag(symbol, {
  index,
  ctx,
  isVoid
}, closed) {
  return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) : wrap(symbol, index, ctx, closed);
}
function findTemplateFn(ctx, templateIndex) {
  return (token) => typeof token === "object" && token.type === TagType.TEMPLATE && token.index === templateIndex && token.ctx === ctx;
}
function serializePlaceholderValue(value) {
  const element = (data, closed) => wrapTag("#", data, closed);
  const template = (data, closed) => wrapTag("*", data, closed);
  const projection = (data, closed) => wrapTag("!", data, closed);
  switch (value.type) {
    case TagType.ELEMENT:
      if (value.closed) {
        return element(value, true) + (value.tmpl ? template(value.tmpl, true) : "");
      }
      if (value.tmpl) {
        return template(value.tmpl) + element(value) + (value.isVoid ? template(value.tmpl, true) : "");
      }
      return element(value);
    case TagType.TEMPLATE:
      return template(value, value.closed);
    default:
      return value;
  }
}
function serializeIcuNode(icu) {
  return icu.visit(serializer);
}
function createI18nMessageFactory(interpolationConfig) {
  const visitor = new _I18nVisitor(_expParser, interpolationConfig);
  return (nodes, meaning, description, customId, visitNodeFn) => visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);
}
function noopVisitNodeFn(_html, i18n) {
  return i18n;
}
function reusePreviousSourceSpans(nodes, previousI18n) {
  if (previousI18n instanceof Message) {
    assertSingleContainerMessage(previousI18n);
    previousI18n = previousI18n.nodes[0];
  }
  if (previousI18n instanceof Container) {
    assertEquivalentNodes(previousI18n.children, nodes);
    for (let i = 0; i < nodes.length; i++) {
      nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;
    }
  }
}
function assertSingleContainerMessage(message) {
  const nodes = message.nodes;
  if (nodes.length !== 1 || !(nodes[0] instanceof Container)) {
    throw new Error("Unexpected previous i18n message - expected it to consist of only a single `Container` node.");
  }
}
function assertEquivalentNodes(previousNodes, nodes) {
  if (previousNodes.length !== nodes.length) {
    throw new Error("The number of i18n message children changed between first and second pass.");
  }
  if (previousNodes.some((node, i) => nodes[i].constructor !== node.constructor)) {
    throw new Error("The types of the i18n message children changed between first and second pass.");
  }
}
function extractPlaceholderName(input) {
  return input.split(_CUSTOM_PH_EXP)[2];
}
function parseI18nMeta(meta = "") {
  let customId;
  let meaning;
  let description;
  meta = meta.trim();
  if (meta) {
    const idIndex = meta.indexOf(I18N_ID_SEPARATOR);
    const descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);
    let meaningAndDesc;
    [meaningAndDesc, customId] = idIndex > -1 ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ""];
    [meaning, description] = descIndex > -1 ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ["", meaningAndDesc];
  }
  return {
    customId,
    meaning,
    description
  };
}
function i18nMetaToJSDoc(meta) {
  const tags = [];
  if (meta.description) {
    tags.push({
      tagName: "desc",
      text: meta.description
    });
  } else {
    tags.push({
      tagName: "suppress",
      text: "{msgDescriptions}"
    });
  }
  if (meta.meaning) {
    tags.push({
      tagName: "meaning",
      text: meta.meaning
    });
  }
  return jsDocComment(tags);
}
function createGoogleGetMsgStatements(variable$1, message, closureVar, placeholderValues) {
  const messageString = serializeI18nMessageForGetMsg(message);
  const args = [literal(messageString)];
  if (Object.keys(placeholderValues).length) {
    args.push(mapLiteral(
      formatI18nPlaceholderNamesInMap(
        placeholderValues,
        true
      ),
      true
    ));
    args.push(mapLiteral({
      original_code: literalMap(Object.keys(placeholderValues).map((param) => ({
        key: formatI18nPlaceholderName(param),
        quoted: true,
        value: message.placeholders[param] ? literal(message.placeholders[param].sourceSpan.toString()) : literal(message.placeholderToMessage[param].nodes.map((node) => node.sourceSpan.toString()).join(""))
      })))
    }));
  }
  const googGetMsgStmt = closureVar.set(variable(GOOG_GET_MSG).callFn(args)).toConstDecl();
  googGetMsgStmt.addLeadingComment(i18nMetaToJSDoc(message));
  const i18nAssignmentStmt = new ExpressionStatement(variable$1.set(closureVar));
  return [googGetMsgStmt, i18nAssignmentStmt];
}
function serializeI18nMessageForGetMsg(message) {
  return message.nodes.map((node) => node.visit(serializerVisitor, null)).join("");
}
function createLocalizeStatements(variable2, message, params) {
  const {
    messageParts,
    placeHolders
  } = serializeI18nMessageForLocalize(message);
  const sourceSpan = getSourceSpan(message);
  const expressions = placeHolders.map((ph) => params[ph.text]);
  const localizedString$1 = localizedString(message, messageParts, placeHolders, expressions, sourceSpan);
  const variableInitialization = variable2.set(localizedString$1);
  return [new ExpressionStatement(variableInitialization)];
}
function serializeI18nMessageForLocalize(message) {
  const pieces = [];
  const serializerVisitor2 = new LocalizeSerializerVisitor(message.placeholderToMessage, pieces);
  message.nodes.forEach((node) => node.visit(serializerVisitor2));
  return processMessagePieces(pieces);
}
function getSourceSpan(message) {
  const startNode = message.nodes[0];
  const endNode = message.nodes[message.nodes.length - 1];
  return new ParseSourceSpan(startNode.sourceSpan.fullStart, endNode.sourceSpan.end, startNode.sourceSpan.fullStart, startNode.sourceSpan.details);
}
function processMessagePieces(pieces) {
  const messageParts = [];
  const placeHolders = [];
  if (pieces[0] instanceof PlaceholderPiece) {
    messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));
  }
  for (let i = 0; i < pieces.length; i++) {
    const part = pieces[i];
    if (part instanceof LiteralPiece) {
      messageParts.push(part);
    } else {
      placeHolders.push(part);
      if (pieces[i - 1] instanceof PlaceholderPiece) {
        messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));
      }
    }
  }
  if (pieces[pieces.length - 1] instanceof PlaceholderPiece) {
    messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));
  }
  return {
    messageParts,
    placeHolders
  };
}
function createEmptyMessagePart(location2) {
  return new LiteralPiece("", new ParseSourceSpan(location2, location2));
}
function renderFlagCheckIfStmt(flags, statements) {
  return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null, false), statements);
}
function prepareEventListenerParameters(eventAst, handlerName = null, scope = null) {
  const {
    type,
    name,
    target,
    phase,
    handler
  } = eventAst;
  if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {
    throw new Error(`Unexpected global target '${target}' defined for '${name}' event.
        Supported list of global targets: ${Array.from(GLOBAL_TARGET_RESOLVERS.keys())}.`);
  }
  const eventArgumentName = "$event";
  const implicitReceiverAccesses = /* @__PURE__ */ new Set();
  const implicitReceiverExpr = scope === null || scope.bindingLevel === 0 ? variable(CONTEXT_NAME) : scope.getOrCreateSharedContextVar(0);
  const bindingStatements = convertActionBinding(scope, implicitReceiverExpr, handler, "b", eventAst.handlerSpan, implicitReceiverAccesses, EVENT_BINDING_SCOPE_GLOBALS);
  const statements = [];
  const variableDeclarations = scope === null || scope === void 0 ? void 0 : scope.variableDeclarations();
  const restoreViewStatement = scope === null || scope === void 0 ? void 0 : scope.restoreViewStatement();
  if (variableDeclarations) {
    statements.push(...variableDeclarations);
  }
  statements.push(...bindingStatements);
  if (restoreViewStatement) {
    statements.unshift(restoreViewStatement);
    const lastStatement = statements[statements.length - 1];
    if (lastStatement instanceof ReturnStatement) {
      statements[statements.length - 1] = new ReturnStatement(invokeInstruction(lastStatement.value.sourceSpan, Identifiers.resetView, [lastStatement.value]));
    } else {
      statements.push(new ExpressionStatement(invokeInstruction(null, Identifiers.resetView, [])));
    }
  }
  const eventName = type === 1 ? prepareSyntheticListenerName(name, phase) : name;
  const fnName = handlerName && sanitizeIdentifier(handlerName);
  const fnArgs = [];
  if (implicitReceiverAccesses.has(eventArgumentName)) {
    fnArgs.push(new FnParam(eventArgumentName, DYNAMIC_TYPE));
  }
  const handlerFn = fn(fnArgs, statements, INFERRED_TYPE, null, fnName);
  const params = [literal(eventName), handlerFn];
  if (target) {
    params.push(
      literal(false),
      importExpr(GLOBAL_TARGET_RESOLVERS.get(target))
    );
  }
  return params;
}
function createComponentDefConsts() {
  return {
    prepareStatements: [],
    constExpressions: [],
    i18nVarRefsCache: /* @__PURE__ */ new Map()
  };
}
function pipeBindingCallInfo(args) {
  const identifier = pipeBindingIdentifiers[args.length];
  return {
    identifier: identifier || Identifiers.pipeBindV,
    isVarLength: !identifier
  };
}
function pureFunctionCallInfo(args) {
  const identifier = pureFunctionIdentifiers[args.length];
  return {
    identifier: identifier || Identifiers.pureFunctionV,
    isVarLength: !identifier
  };
}
function generateNextContextExpr(relativeLevelDiff) {
  return importExpr(Identifiers.nextContext).callFn(relativeLevelDiff > 1 ? [literal(relativeLevelDiff)] : []);
}
function getLiteralFactory(constantPool, literal$1, allocateSlots) {
  const {
    literalFactory,
    literalFactoryArguments
  } = constantPool.getLiteralFactory(literal$1);
  const startSlot = allocateSlots(1 + literalFactoryArguments.length);
  const {
    identifier,
    isVarLength
  } = pureFunctionCallInfo(literalFactoryArguments);
  const args = [literal(startSlot), literalFactory];
  if (isVarLength) {
    args.push(literalArr(literalFactoryArguments));
  } else {
    args.push(...literalFactoryArguments);
  }
  return importExpr(identifier).callFn(args);
}
function getAttributeNameLiterals(name) {
  const [attributeNamespace, attributeName] = splitNsName(name);
  const nameLiteral = literal(attributeName);
  if (attributeNamespace) {
    return [literal(
      0
    ), literal(attributeNamespace), nameLiteral];
  }
  return [nameLiteral];
}
function getNgProjectAsLiteral(attribute) {
  const parsedR3Selector = parseSelectorToR3Selector(attribute.value)[0];
  return [literal(
    5
  ), asLiteral(parsedR3Selector)];
}
function getPropertyInterpolationExpression(interpolation) {
  switch (getInterpolationArgsLength(interpolation)) {
    case 1:
      return Identifiers.propertyInterpolate;
    case 3:
      return Identifiers.propertyInterpolate1;
    case 5:
      return Identifiers.propertyInterpolate2;
    case 7:
      return Identifiers.propertyInterpolate3;
    case 9:
      return Identifiers.propertyInterpolate4;
    case 11:
      return Identifiers.propertyInterpolate5;
    case 13:
      return Identifiers.propertyInterpolate6;
    case 15:
      return Identifiers.propertyInterpolate7;
    case 17:
      return Identifiers.propertyInterpolate8;
    default:
      return Identifiers.propertyInterpolateV;
  }
}
function getAttributeInterpolationExpression(interpolation) {
  switch (getInterpolationArgsLength(interpolation)) {
    case 3:
      return Identifiers.attributeInterpolate1;
    case 5:
      return Identifiers.attributeInterpolate2;
    case 7:
      return Identifiers.attributeInterpolate3;
    case 9:
      return Identifiers.attributeInterpolate4;
    case 11:
      return Identifiers.attributeInterpolate5;
    case 13:
      return Identifiers.attributeInterpolate6;
    case 15:
      return Identifiers.attributeInterpolate7;
    case 17:
      return Identifiers.attributeInterpolate8;
    default:
      return Identifiers.attributeInterpolateV;
  }
}
function getTextInterpolationExpression(interpolation) {
  switch (getInterpolationArgsLength(interpolation)) {
    case 1:
      return Identifiers.textInterpolate;
    case 3:
      return Identifiers.textInterpolate1;
    case 5:
      return Identifiers.textInterpolate2;
    case 7:
      return Identifiers.textInterpolate3;
    case 9:
      return Identifiers.textInterpolate4;
    case 11:
      return Identifiers.textInterpolate5;
    case 13:
      return Identifiers.textInterpolate6;
    case 15:
      return Identifiers.textInterpolate7;
    case 17:
      return Identifiers.textInterpolate8;
    default:
      return Identifiers.textInterpolateV;
  }
}
function parseTemplate(template, templateUrl, options = {}) {
  const {
    interpolationConfig,
    preserveWhitespaces,
    enableI18nLegacyMessageIdFormat
  } = options;
  const bindingParser = makeBindingParser(interpolationConfig);
  const htmlParser = new HtmlParser();
  const parseResult = htmlParser.parse(template, templateUrl, Object.assign(Object.assign({
    leadingTriviaChars: LEADING_TRIVIA_CHARS
  }, options), {
    tokenizeExpansionForms: true
  }));
  if (!options.alwaysAttemptHtmlToR3AstConversion && parseResult.errors && parseResult.errors.length > 0) {
    const parsedTemplate2 = {
      interpolationConfig,
      preserveWhitespaces,
      errors: parseResult.errors,
      nodes: [],
      styleUrls: [],
      styles: [],
      ngContentSelectors: []
    };
    if (options.collectCommentNodes) {
      parsedTemplate2.commentNodes = [];
    }
    return parsedTemplate2;
  }
  let rootNodes = parseResult.rootNodes;
  const i18nMetaVisitor = new I18nMetaVisitor(
    interpolationConfig,
    !preserveWhitespaces,
    enableI18nLegacyMessageIdFormat
  );
  const i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);
  if (!options.alwaysAttemptHtmlToR3AstConversion && i18nMetaResult.errors && i18nMetaResult.errors.length > 0) {
    const parsedTemplate2 = {
      interpolationConfig,
      preserveWhitespaces,
      errors: i18nMetaResult.errors,
      nodes: [],
      styleUrls: [],
      styles: [],
      ngContentSelectors: []
    };
    if (options.collectCommentNodes) {
      parsedTemplate2.commentNodes = [];
    }
    return parsedTemplate2;
  }
  rootNodes = i18nMetaResult.rootNodes;
  if (!preserveWhitespaces) {
    rootNodes = visitAll(new WhitespaceVisitor(), rootNodes);
    if (i18nMetaVisitor.hasI18nMeta) {
      rootNodes = visitAll(new I18nMetaVisitor(
        interpolationConfig,
        false
      ), rootNodes);
    }
  }
  const {
    nodes,
    errors,
    styleUrls,
    styles,
    ngContentSelectors,
    commentNodes
  } = htmlAstToRender3Ast(rootNodes, bindingParser, {
    collectCommentNodes: !!options.collectCommentNodes
  });
  errors.push(...parseResult.errors, ...i18nMetaResult.errors);
  const parsedTemplate = {
    interpolationConfig,
    preserveWhitespaces,
    errors: errors.length > 0 ? errors : null,
    nodes,
    styleUrls,
    styles,
    ngContentSelectors
  };
  if (options.collectCommentNodes) {
    parsedTemplate.commentNodes = commentNodes;
  }
  return parsedTemplate;
}
function makeBindingParser(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
  return new BindingParser(new Parser$1(new Lexer()), interpolationConfig, elementRegistry, []);
}
function resolveSanitizationFn(context2, isAttribute) {
  switch (context2) {
    case SecurityContext2.HTML:
      return importExpr(Identifiers.sanitizeHtml);
    case SecurityContext2.SCRIPT:
      return importExpr(Identifiers.sanitizeScript);
    case SecurityContext2.STYLE:
      return isAttribute ? importExpr(Identifiers.sanitizeStyle) : null;
    case SecurityContext2.URL:
      return importExpr(Identifiers.sanitizeUrl);
    case SecurityContext2.RESOURCE_URL:
      return importExpr(Identifiers.sanitizeResourceUrl);
    default:
      return null;
  }
}
function trustedConstAttribute(tagName, attr) {
  const value = asLiteral(attr.value);
  if (isTrustedTypesSink(tagName, attr.name)) {
    switch (elementRegistry.securityContext(
      tagName,
      attr.name,
      true
    )) {
      case SecurityContext2.HTML:
        return taggedTemplate(importExpr(Identifiers.trustConstantHtml), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), void 0, attr.valueSpan);
      case SecurityContext2.RESOURCE_URL:
        return taggedTemplate(importExpr(Identifiers.trustConstantResourceUrl), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), void 0, attr.valueSpan);
      default:
        return value;
    }
  } else {
    return value;
  }
}
function isSingleElementTemplate(children) {
  return children.length === 1 && children[0] instanceof Element$1;
}
function isTextNode(node) {
  return node instanceof Text$3 || node instanceof BoundText || node instanceof Icu$1;
}
function hasTextChildrenOnly(children) {
  return children.every(isTextNode);
}
function getBindingFunctionParams(deferredParams, name, eagerParams) {
  return () => {
    const value = deferredParams();
    const fnParams = Array.isArray(value) ? value : [value];
    if (eagerParams) {
      fnParams.push(...eagerParams);
    }
    if (name) {
      fnParams.unshift(literal(name));
    }
    return fnParams;
  };
}
function getTranslationDeclStmts(message, variable2, closureVar, params = {}, transformFn) {
  const statements = [declareI18nVariable(variable2), ifStmt(createClosureModeGuard(), createGoogleGetMsgStatements(variable2, message, closureVar, params), createLocalizeStatements(variable2, message, formatI18nPlaceholderNamesInMap(
    params,
    false
  )))];
  if (transformFn) {
    statements.push(new ExpressionStatement(variable2.set(transformFn(variable2))));
  }
  return statements;
}
function createClosureModeGuard() {
  return typeofExpr(variable(NG_I18N_CLOSURE_MODE)).notIdentical(literal("undefined", STRING_TYPE)).and(variable(NG_I18N_CLOSURE_MODE));
}
function flatten2(list) {
  return list.reduce((flat, item) => {
    const flatItem = Array.isArray(item) ? flatten2(item) : item;
    return flat.concat(flatItem);
  }, []);
}
function baseDirectiveFields(meta, constantPool, bindingParser) {
  const definitionMap = new DefinitionMap();
  const selectors = parseSelectorToR3Selector(meta.selector);
  definitionMap.set("type", meta.internalType);
  if (selectors.length > 0) {
    definitionMap.set("selectors", asLiteral(selectors));
  }
  if (meta.queries.length > 0) {
    definitionMap.set("contentQueries", createContentQueriesFunction(meta.queries, constantPool, meta.name));
  }
  if (meta.viewQueries.length) {
    definitionMap.set("viewQuery", createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));
  }
  definitionMap.set("hostBindings", createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || "", meta.name, definitionMap));
  definitionMap.set("inputs", conditionallyCreateMapObjectLiteral(meta.inputs, true));
  definitionMap.set("outputs", conditionallyCreateMapObjectLiteral(meta.outputs));
  if (meta.exportAs !== null) {
    definitionMap.set("exportAs", literalArr(meta.exportAs.map((e) => literal(e))));
  }
  if (meta.isStandalone) {
    definitionMap.set("standalone", literal(true));
  }
  return definitionMap;
}
function addFeatures(definitionMap, meta) {
  const features = [];
  const providers = meta.providers;
  const viewProviders = meta.viewProviders;
  if (providers || viewProviders) {
    const args = [providers || new LiteralArrayExpr([])];
    if (viewProviders) {
      args.push(viewProviders);
    }
    features.push(importExpr(Identifiers.ProvidersFeature).callFn(args));
  }
  if (meta.usesInheritance) {
    features.push(importExpr(Identifiers.InheritDefinitionFeature));
  }
  if (meta.fullInheritance) {
    features.push(importExpr(Identifiers.CopyDefinitionFeature));
  }
  if (meta.lifecycle.usesOnChanges) {
    features.push(importExpr(Identifiers.NgOnChangesFeature));
  }
  if (meta.hasOwnProperty("template") && meta.isStandalone) {
    features.push(importExpr(Identifiers.StandaloneFeature));
  }
  if (features.length) {
    definitionMap.set("features", literalArr(features));
  }
}
function compileDirectiveFromMetadata(meta, constantPool, bindingParser) {
  const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);
  addFeatures(definitionMap, meta);
  const expression = importExpr(Identifiers.defineDirective).callFn([definitionMap.toLiteralMap()], void 0, true);
  const type = createDirectiveType(meta);
  return {
    expression,
    type,
    statements: []
  };
}
function compileComponentFromMetadata(meta, constantPool, bindingParser) {
  const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);
  addFeatures(definitionMap, meta);
  const selector = meta.selector && CssSelector.parse(meta.selector);
  const firstSelector = selector && selector[0];
  if (firstSelector) {
    const selectorAttributes = firstSelector.getAttrs();
    if (selectorAttributes.length) {
      definitionMap.set("attrs", constantPool.getConstLiteral(
        literalArr(selectorAttributes.map((value) => value != null ? literal(value) : literal(void 0))),
        true
      ));
    }
  }
  const templateTypeName = meta.name;
  const templateName = templateTypeName ? `${templateTypeName}_Template` : null;
  const changeDetection = meta.changeDetection;
  const template = meta.template;
  const templateBuilder = new TemplateDefinitionBuilder(constantPool, BindingScope.createRootScope(), 0, templateTypeName, null, null, templateName, Identifiers.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);
  const templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []);
  const ngContentSelectors = templateBuilder.getNgContentSelectors();
  if (ngContentSelectors) {
    definitionMap.set("ngContentSelectors", ngContentSelectors);
  }
  definitionMap.set("decls", literal(templateBuilder.getConstCount()));
  definitionMap.set("vars", literal(templateBuilder.getVarCount()));
  const {
    constExpressions,
    prepareStatements
  } = templateBuilder.getConsts();
  if (constExpressions.length > 0) {
    let constsExpr = literalArr(constExpressions);
    if (prepareStatements.length > 0) {
      constsExpr = fn([], [...prepareStatements, new ReturnStatement(constsExpr)]);
    }
    definitionMap.set("consts", constsExpr);
  }
  definitionMap.set("template", templateFunctionExpression);
  if (meta.declarations.length > 0) {
    definitionMap.set("dependencies", compileDeclarationList(literalArr(meta.declarations.map((decl) => decl.type)), meta.declarationListEmitMode));
  }
  if (meta.encapsulation === null) {
    meta.encapsulation = ViewEncapsulation2.Emulated;
  }
  if (meta.styles && meta.styles.length) {
    const styleValues = meta.encapsulation == ViewEncapsulation2.Emulated ? compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) : meta.styles;
    const styleNodes = styleValues.reduce((result, style) => {
      if (style.trim().length > 0) {
        result.push(constantPool.getConstLiteral(literal(style)));
      }
      return result;
    }, []);
    if (styleNodes.length > 0) {
      definitionMap.set("styles", literalArr(styleNodes));
    }
  } else if (meta.encapsulation === ViewEncapsulation2.Emulated) {
    meta.encapsulation = ViewEncapsulation2.None;
  }
  if (meta.encapsulation !== ViewEncapsulation2.Emulated) {
    definitionMap.set("encapsulation", literal(meta.encapsulation));
  }
  if (meta.animations !== null) {
    definitionMap.set("data", literalMap([{
      key: "animation",
      value: meta.animations,
      quoted: false
    }]));
  }
  if (changeDetection != null && changeDetection !== ChangeDetectionStrategy2.Default) {
    definitionMap.set("changeDetection", literal(changeDetection));
  }
  const expression = importExpr(Identifiers.defineComponent).callFn([definitionMap.toLiteralMap()], void 0, true);
  const type = createComponentType(meta);
  return {
    expression,
    type,
    statements: []
  };
}
function createComponentType(meta) {
  const typeParams = createBaseDirectiveTypeParams(meta);
  typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));
  typeParams.push(expressionType(literal(meta.isStandalone)));
  return expressionType(importExpr(Identifiers.ComponentDeclaration, typeParams));
}
function compileDeclarationList(list, mode) {
  switch (mode) {
    case 0:
      return list;
    case 1:
      return fn([], [new ReturnStatement(list)]);
    case 2:
      const resolvedList = list.prop("map").callFn([importExpr(Identifiers.resolveForwardRef)]);
      return fn([], [new ReturnStatement(resolvedList)]);
  }
}
function prepareQueryParams(query, constantPool) {
  const parameters = [getQueryPredicate(query, constantPool), literal(toQueryFlags(query))];
  if (query.read) {
    parameters.push(query.read);
  }
  return parameters;
}
function toQueryFlags(query) {
  return (query.descendants ? 1 : 0) | (query.static ? 2 : 0) | (query.emitDistinctChangesOnly ? 4 : 0);
}
function convertAttributesToExpressions(attributes) {
  const values = [];
  for (let key of Object.getOwnPropertyNames(attributes)) {
    const value = attributes[key];
    values.push(literal(key), value);
  }
  return values;
}
function createContentQueriesFunction(queries, constantPool, name) {
  const createStatements = [];
  const updateStatements = [];
  const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);
  for (const query of queries) {
    createStatements.push(importExpr(Identifiers.contentQuery).callFn([variable("dirIndex"), ...prepareQueryParams(query, constantPool)]).toStmt());
    const temporary = tempAllocator();
    const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);
    const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);
    const updateDirective = variable(CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop("first") : temporary);
    updateStatements.push(refresh.and(updateDirective).toStmt());
  }
  const contentQueriesFnName = name ? `${name}_ContentQueries` : null;
  return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null), new FnParam("dirIndex", null)], [renderFlagCheckIfStmt(
    1,
    createStatements
  ), renderFlagCheckIfStmt(
    2,
    updateStatements
  )], INFERRED_TYPE, null, contentQueriesFnName);
}
function stringAsType(str) {
  return expressionType(literal(str));
}
function stringMapAsType(map2) {
  const mapValues = Object.keys(map2).map((key) => {
    const value = Array.isArray(map2[key]) ? map2[key][0] : map2[key];
    return {
      key,
      value: literal(value),
      quoted: true
    };
  });
  return expressionType(literalMap(mapValues));
}
function stringArrayAsType(arr) {
  return arr.length > 0 ? expressionType(literalArr(arr.map((value) => literal(value)))) : NONE_TYPE;
}
function createBaseDirectiveTypeParams(meta) {
  const selectorForType = meta.selector !== null ? meta.selector.replace(/\n/g, "") : null;
  return [typeWithParameters(meta.type.type, meta.typeArgumentCount), selectorForType !== null ? stringAsType(selectorForType) : NONE_TYPE, meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : NONE_TYPE, stringMapAsType(meta.inputs), stringMapAsType(meta.outputs), stringArrayAsType(meta.queries.map((q) => q.propertyName))];
}
function createDirectiveType(meta) {
  const typeParams = createBaseDirectiveTypeParams(meta);
  typeParams.push(NONE_TYPE);
  typeParams.push(expressionType(literal(meta.isStandalone)));
  return expressionType(importExpr(Identifiers.DirectiveDeclaration, typeParams));
}
function createViewQueriesFunction(viewQueries, constantPool, name) {
  const createStatements = [];
  const updateStatements = [];
  const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);
  viewQueries.forEach((query) => {
    const queryDefinition = importExpr(Identifiers.viewQuery).callFn(prepareQueryParams(query, constantPool));
    createStatements.push(queryDefinition.toStmt());
    const temporary = tempAllocator();
    const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);
    const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);
    const updateDirective = variable(CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop("first") : temporary);
    updateStatements.push(refresh.and(updateDirective).toStmt());
  });
  const viewQueryFnName = name ? `${name}_Query` : null;
  return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [renderFlagCheckIfStmt(
    1,
    createStatements
  ), renderFlagCheckIfStmt(
    2,
    updateStatements
  )], INFERRED_TYPE, null, viewQueryFnName);
}
function createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name, definitionMap) {
  const bindingContext = variable(CONTEXT_NAME);
  const styleBuilder = new StylingBuilder(bindingContext);
  const {
    styleAttr,
    classAttr
  } = hostBindingsMetadata.specialAttributes;
  if (styleAttr !== void 0) {
    styleBuilder.registerStyleAttr(styleAttr);
  }
  if (classAttr !== void 0) {
    styleBuilder.registerClassAttr(classAttr);
  }
  const createInstructions = [];
  const updateInstructions = [];
  const updateVariables = [];
  const hostBindingSourceSpan = typeSourceSpan;
  const eventBindings = bindingParser.createDirectiveHostEventAsts(hostBindingsMetadata.listeners, hostBindingSourceSpan);
  if (eventBindings && eventBindings.length) {
    createInstructions.push(...createHostListeners(eventBindings, name));
  }
  const bindings = bindingParser.createBoundHostProperties(hostBindingsMetadata.properties, hostBindingSourceSpan);
  const allOtherBindings = [];
  let totalHostVarsCount = 0;
  bindings && bindings.forEach((binding) => {
    const stylingInputWasSet = styleBuilder.registerInputBasedOnName(binding.name, binding.expression, hostBindingSourceSpan);
    if (stylingInputWasSet) {
      totalHostVarsCount += MIN_STYLING_BINDING_SLOTS_REQUIRED;
    } else {
      allOtherBindings.push(binding);
      totalHostVarsCount++;
    }
  });
  let valueConverter;
  const getValueConverter = () => {
    if (!valueConverter) {
      const hostVarsCountFn = (numSlots) => {
        const originalVarsCount = totalHostVarsCount;
        totalHostVarsCount += numSlots;
        return originalVarsCount;
      };
      valueConverter = new ValueConverter(
        constantPool,
        () => error("Unexpected node"),
        hostVarsCountFn,
        () => error("Unexpected pipe")
      );
    }
    return valueConverter;
  };
  const propertyBindings = [];
  const attributeBindings = [];
  const syntheticHostBindings = [];
  for (const binding of allOtherBindings) {
    const value = binding.expression.visit(getValueConverter());
    const bindingExpr = bindingFn(bindingContext, value);
    const {
      bindingName,
      instruction,
      isAttribute
    } = getBindingNameAndInstruction(binding);
    const securityContexts = bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute).filter((context2) => context2 !== SecurityContext2.NONE);
    let sanitizerFn = null;
    if (securityContexts.length) {
      if (securityContexts.length === 2 && securityContexts.indexOf(SecurityContext2.URL) > -1 && securityContexts.indexOf(SecurityContext2.RESOURCE_URL) > -1) {
        sanitizerFn = importExpr(Identifiers.sanitizeUrlOrResourceUrl);
      } else {
        sanitizerFn = resolveSanitizationFn(securityContexts[0], isAttribute);
      }
    }
    const instructionParams = [literal(bindingName), bindingExpr.currValExpr];
    if (sanitizerFn) {
      instructionParams.push(sanitizerFn);
    }
    updateVariables.push(...bindingExpr.stmts);
    if (instruction === Identifiers.hostProperty) {
      propertyBindings.push(instructionParams);
    } else if (instruction === Identifiers.attribute) {
      attributeBindings.push(instructionParams);
    } else if (instruction === Identifiers.syntheticHostProperty) {
      syntheticHostBindings.push(instructionParams);
    } else {
      updateInstructions.push({
        reference: instruction,
        paramsOrFn: instructionParams,
        span: null
      });
    }
  }
  for (const bindingParams of propertyBindings) {
    updateInstructions.push({
      reference: Identifiers.hostProperty,
      paramsOrFn: bindingParams,
      span: null
    });
  }
  for (const bindingParams of attributeBindings) {
    updateInstructions.push({
      reference: Identifiers.attribute,
      paramsOrFn: bindingParams,
      span: null
    });
  }
  for (const bindingParams of syntheticHostBindings) {
    updateInstructions.push({
      reference: Identifiers.syntheticHostProperty,
      paramsOrFn: bindingParams,
      span: null
    });
  }
  const hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);
  styleBuilder.assignHostAttrs(hostAttrs, definitionMap);
  if (styleBuilder.hasBindings) {
    styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach((instruction) => {
      for (const call of instruction.calls) {
        totalHostVarsCount += Math.max(call.allocateBindingSlots - MIN_STYLING_BINDING_SLOTS_REQUIRED, 0);
        updateInstructions.push({
          reference: instruction.reference,
          paramsOrFn: convertStylingCall(call, bindingContext, bindingFn),
          span: null
        });
      }
    });
  }
  if (totalHostVarsCount) {
    definitionMap.set("hostVars", literal(totalHostVarsCount));
  }
  if (createInstructions.length > 0 || updateInstructions.length > 0) {
    const hostBindingsFnName = name ? `${name}_HostBindings` : null;
    const statements = [];
    if (createInstructions.length > 0) {
      statements.push(renderFlagCheckIfStmt(
        1,
        getInstructionStatements(createInstructions)
      ));
    }
    if (updateInstructions.length > 0) {
      statements.push(renderFlagCheckIfStmt(
        2,
        updateVariables.concat(getInstructionStatements(updateInstructions))
      ));
    }
    return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], statements, INFERRED_TYPE, null, hostBindingsFnName);
  }
  return null;
}
function bindingFn(implicit, value) {
  return convertPropertyBinding(null, implicit, value, "b");
}
function convertStylingCall(call, bindingContext, bindingFn2) {
  return call.params((value) => bindingFn2(bindingContext, value).currValExpr);
}
function getBindingNameAndInstruction(binding) {
  let bindingName = binding.name;
  let instruction;
  const attrMatches = bindingName.match(ATTR_REGEX);
  if (attrMatches) {
    bindingName = attrMatches[1];
    instruction = Identifiers.attribute;
  } else {
    if (binding.isAnimation) {
      bindingName = prepareSyntheticPropertyName(bindingName);
      instruction = Identifiers.syntheticHostProperty;
    } else {
      instruction = Identifiers.hostProperty;
    }
  }
  return {
    bindingName,
    instruction,
    isAttribute: !!attrMatches
  };
}
function createHostListeners(eventBindings, name) {
  const listenerParams = [];
  const syntheticListenerParams = [];
  const instructions = [];
  for (const binding of eventBindings) {
    let bindingName = binding.name && sanitizeIdentifier(binding.name);
    const bindingFnName = binding.type === 1 ? prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) : bindingName;
    const handlerName = name && bindingName ? `${name}_${bindingFnName}_HostBindingHandler` : null;
    const params = prepareEventListenerParameters(BoundEvent.fromParsedEvent(binding), handlerName);
    if (binding.type == 1) {
      syntheticListenerParams.push(params);
    } else {
      listenerParams.push(params);
    }
  }
  for (const params of syntheticListenerParams) {
    instructions.push({
      reference: Identifiers.syntheticHostListener,
      paramsOrFn: params,
      span: null
    });
  }
  for (const params of listenerParams) {
    instructions.push({
      reference: Identifiers.listener,
      paramsOrFn: params,
      span: null
    });
  }
  return instructions;
}
function parseHostBindings(host) {
  const attributes = {};
  const listeners = {};
  const properties = {};
  const specialAttributes = {};
  for (const key of Object.keys(host)) {
    const value = host[key];
    const matches = key.match(HOST_REG_EXP);
    if (matches === null) {
      switch (key) {
        case "class":
          if (typeof value !== "string") {
            throw new Error(`Class binding must be string`);
          }
          specialAttributes.classAttr = value;
          break;
        case "style":
          if (typeof value !== "string") {
            throw new Error(`Style binding must be string`);
          }
          specialAttributes.styleAttr = value;
          break;
        default:
          if (typeof value === "string") {
            attributes[key] = literal(value);
          } else {
            attributes[key] = value;
          }
      }
    } else if (matches[1] != null) {
      if (typeof value !== "string") {
        throw new Error(`Property binding must be string`);
      }
      properties[matches[1]] = value;
    } else if (matches[2] != null) {
      if (typeof value !== "string") {
        throw new Error(`Event binding must be string`);
      }
      listeners[matches[2]] = value;
    }
  }
  return {
    attributes,
    listeners,
    properties,
    specialAttributes
  };
}
function verifyHostBindings(bindings, sourceSpan) {
  const bindingParser = makeBindingParser();
  bindingParser.createDirectiveHostEventAsts(bindings.listeners, sourceSpan);
  bindingParser.createBoundHostProperties(bindings.properties, sourceSpan);
  return bindingParser.errors;
}
function compileStyles(styles, selector, hostSelector) {
  const shadowCss = new ShadowCss();
  return styles.map((style) => {
    return shadowCss.shimCssText(style, selector, hostSelector);
  });
}
function convertToR3QueryMetadata2(facade) {
  return Object.assign(Object.assign({}, facade), {
    predicate: convertQueryPredicate(facade.predicate),
    read: facade.read ? new WrappedNodeExpr(facade.read) : null,
    static: facade.static,
    emitDistinctChangesOnly: facade.emitDistinctChangesOnly
  });
}
function convertQueryDeclarationToMetadata(declaration) {
  var _a, _b, _c, _d;
  return {
    propertyName: declaration.propertyName,
    first: (_a = declaration.first) !== null && _a !== void 0 ? _a : false,
    predicate: convertQueryPredicate(declaration.predicate),
    descendants: (_b = declaration.descendants) !== null && _b !== void 0 ? _b : false,
    read: declaration.read ? new WrappedNodeExpr(declaration.read) : null,
    static: (_c = declaration.static) !== null && _c !== void 0 ? _c : false,
    emitDistinctChangesOnly: (_d = declaration.emitDistinctChangesOnly) !== null && _d !== void 0 ? _d : true
  };
}
function convertQueryPredicate(predicate) {
  return Array.isArray(predicate) ? predicate : createMayBeForwardRefExpression(
    new WrappedNodeExpr(predicate),
    1
  );
}
function convertDirectiveFacadeToMetadata(facade) {
  const inputsFromMetadata = parseInputOutputs(facade.inputs || []);
  const outputsFromMetadata = parseInputOutputs(facade.outputs || []);
  const propMetadata = facade.propMetadata;
  const inputsFromType = {};
  const outputsFromType = {};
  for (const field in propMetadata) {
    if (propMetadata.hasOwnProperty(field)) {
      propMetadata[field].forEach((ann) => {
        if (isInput(ann)) {
          inputsFromType[field] = ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;
        } else if (isOutput(ann)) {
          outputsFromType[field] = ann.bindingPropertyName || field;
        }
      });
    }
  }
  return Object.assign(Object.assign({}, facade), {
    typeArgumentCount: 0,
    typeSourceSpan: facade.typeSourceSpan,
    type: wrapReference(facade.type),
    internalType: new WrappedNodeExpr(facade.type),
    deps: null,
    host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host),
    inputs: Object.assign(Object.assign({}, inputsFromMetadata), inputsFromType),
    outputs: Object.assign(Object.assign({}, outputsFromMetadata), outputsFromType),
    queries: facade.queries.map(convertToR3QueryMetadata2),
    providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null,
    viewQueries: facade.viewQueries.map(convertToR3QueryMetadata2),
    fullInheritance: false
  });
}
function convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j;
  return {
    name: declaration.type.name,
    type: wrapReference(declaration.type),
    typeSourceSpan,
    internalType: new WrappedNodeExpr(declaration.type),
    selector: (_a = declaration.selector) !== null && _a !== void 0 ? _a : null,
    inputs: (_b = declaration.inputs) !== null && _b !== void 0 ? _b : {},
    outputs: (_c = declaration.outputs) !== null && _c !== void 0 ? _c : {},
    host: convertHostDeclarationToMetadata(declaration.host),
    queries: ((_d = declaration.queries) !== null && _d !== void 0 ? _d : []).map(convertQueryDeclarationToMetadata),
    viewQueries: ((_e = declaration.viewQueries) !== null && _e !== void 0 ? _e : []).map(convertQueryDeclarationToMetadata),
    providers: declaration.providers !== void 0 ? new WrappedNodeExpr(declaration.providers) : null,
    exportAs: (_f = declaration.exportAs) !== null && _f !== void 0 ? _f : null,
    usesInheritance: (_g = declaration.usesInheritance) !== null && _g !== void 0 ? _g : false,
    lifecycle: {
      usesOnChanges: (_h = declaration.usesOnChanges) !== null && _h !== void 0 ? _h : false
    },
    deps: null,
    typeArgumentCount: 0,
    fullInheritance: false,
    isStandalone: (_j = declaration.isStandalone) !== null && _j !== void 0 ? _j : false
  };
}
function convertHostDeclarationToMetadata(host = {}) {
  var _a, _b, _c;
  return {
    attributes: convertOpaqueValuesToExpressions((_a = host.attributes) !== null && _a !== void 0 ? _a : {}),
    listeners: (_b = host.listeners) !== null && _b !== void 0 ? _b : {},
    properties: (_c = host.properties) !== null && _c !== void 0 ? _c : {},
    specialAttributes: {
      classAttr: host.classAttribute,
      styleAttr: host.styleAttribute
    }
  };
}
function convertOpaqueValuesToExpressions(obj) {
  const result = {};
  for (const key of Object.keys(obj)) {
    result[key] = new WrappedNodeExpr(obj[key]);
  }
  return result;
}
function convertDeclareComponentFacadeToMetadata(decl, typeSourceSpan, sourceMapUrl) {
  var _a, _b, _c, _d;
  const {
    template,
    interpolation
  } = parseJitTemplate(decl.template, decl.type.name, sourceMapUrl, (_a = decl.preserveWhitespaces) !== null && _a !== void 0 ? _a : false, decl.interpolation);
  const declarations = [];
  if (decl.dependencies) {
    for (const innerDep of decl.dependencies) {
      switch (innerDep.kind) {
        case "directive":
        case "component":
          declarations.push(convertDirectiveDeclarationToMetadata(innerDep));
          break;
        case "pipe":
          declarations.push(convertPipeDeclarationToMetadata(innerDep));
          break;
      }
    }
  } else if (decl.components || decl.directives || decl.pipes) {
    decl.components && declarations.push(...decl.components.map((dir) => convertDirectiveDeclarationToMetadata(
      dir,
      true
    )));
    decl.directives && declarations.push(...decl.directives.map((dir) => convertDirectiveDeclarationToMetadata(dir)));
    decl.pipes && declarations.push(...convertPipeMapToMetadata(decl.pipes));
  }
  return Object.assign(Object.assign({}, convertDeclareDirectiveFacadeToMetadata(decl, typeSourceSpan)), {
    template,
    styles: (_b = decl.styles) !== null && _b !== void 0 ? _b : [],
    declarations,
    viewProviders: decl.viewProviders !== void 0 ? new WrappedNodeExpr(decl.viewProviders) : null,
    animations: decl.animations !== void 0 ? new WrappedNodeExpr(decl.animations) : null,
    changeDetection: (_c = decl.changeDetection) !== null && _c !== void 0 ? _c : ChangeDetectionStrategy2.Default,
    encapsulation: (_d = decl.encapsulation) !== null && _d !== void 0 ? _d : ViewEncapsulation2.Emulated,
    interpolation,
    declarationListEmitMode: 2,
    relativeContextFilePath: "",
    i18nUseExternalIds: true
  });
}
function convertDeclarationFacadeToMetadata(declaration) {
  return Object.assign(Object.assign({}, declaration), {
    type: new WrappedNodeExpr(declaration.type)
  });
}
function convertDirectiveDeclarationToMetadata(declaration, isComponent = null) {
  var _a, _b, _c;
  return {
    kind: R3TemplateDependencyKind2.Directive,
    isComponent: isComponent || declaration.kind === "component",
    selector: declaration.selector,
    type: new WrappedNodeExpr(declaration.type),
    inputs: (_a = declaration.inputs) !== null && _a !== void 0 ? _a : [],
    outputs: (_b = declaration.outputs) !== null && _b !== void 0 ? _b : [],
    exportAs: (_c = declaration.exportAs) !== null && _c !== void 0 ? _c : null
  };
}
function convertPipeMapToMetadata(pipes) {
  if (!pipes) {
    return [];
  }
  return Object.keys(pipes).map((name) => {
    return {
      kind: R3TemplateDependencyKind2.Pipe,
      name,
      type: new WrappedNodeExpr(pipes[name])
    };
  });
}
function convertPipeDeclarationToMetadata(pipe2) {
  return {
    kind: R3TemplateDependencyKind2.Pipe,
    name: pipe2.name,
    type: new WrappedNodeExpr(pipe2.type)
  };
}
function parseJitTemplate(template, typeName, sourceMapUrl, preserveWhitespaces, interpolation) {
  const interpolationConfig = interpolation ? InterpolationConfig.fromArray(interpolation) : DEFAULT_INTERPOLATION_CONFIG;
  const parsed = parseTemplate(template, sourceMapUrl, {
    preserveWhitespaces,
    interpolationConfig
  });
  if (parsed.errors !== null) {
    const errors = parsed.errors.map((err) => err.toString()).join(", ");
    throw new Error(`Errors during JIT compilation of template for ${typeName}: ${errors}`);
  }
  return {
    template: parsed,
    interpolation: interpolationConfig
  };
}
function convertToProviderExpression(obj, property) {
  if (obj.hasOwnProperty(property)) {
    return createMayBeForwardRefExpression(
      new WrappedNodeExpr(obj[property]),
      0
    );
  } else {
    return void 0;
  }
}
function wrapExpression(obj, property) {
  if (obj.hasOwnProperty(property)) {
    return new WrappedNodeExpr(obj[property]);
  } else {
    return void 0;
  }
}
function computeProvidedIn(providedIn) {
  const expression = typeof providedIn === "function" ? new WrappedNodeExpr(providedIn) : new LiteralExpr(providedIn !== null && providedIn !== void 0 ? providedIn : null);
  return createMayBeForwardRefExpression(
    expression,
    0
  );
}
function convertR3DependencyMetadataArray(facades) {
  return facades == null ? null : facades.map(convertR3DependencyMetadata);
}
function convertR3DependencyMetadata(facade) {
  const isAttributeDep = facade.attribute != null;
  const rawToken = facade.token === null ? null : new WrappedNodeExpr(facade.token);
  const token = isAttributeDep ? new WrappedNodeExpr(facade.attribute) : rawToken;
  return createR3DependencyMetadata(token, isAttributeDep, facade.host, facade.optional, facade.self, facade.skipSelf);
}
function convertR3DeclareDependencyMetadata(facade) {
  var _a, _b, _c, _d, _e;
  const isAttributeDep = (_a = facade.attribute) !== null && _a !== void 0 ? _a : false;
  const token = facade.token === null ? null : new WrappedNodeExpr(facade.token);
  return createR3DependencyMetadata(token, isAttributeDep, (_b = facade.host) !== null && _b !== void 0 ? _b : false, (_c = facade.optional) !== null && _c !== void 0 ? _c : false, (_d = facade.self) !== null && _d !== void 0 ? _d : false, (_e = facade.skipSelf) !== null && _e !== void 0 ? _e : false);
}
function createR3DependencyMetadata(token, isAttributeDep, host, optional, self2, skipSelf) {
  const attributeNameType = isAttributeDep ? literal("unknown") : null;
  return {
    token,
    attributeNameType,
    host,
    optional,
    self: self2,
    skipSelf
  };
}
function extractHostBindings(propMetadata, sourceSpan, host) {
  const bindings = parseHostBindings(host || {});
  const errors = verifyHostBindings(bindings, sourceSpan);
  if (errors.length) {
    throw new Error(errors.map((error2) => error2.msg).join("\n"));
  }
  for (const field in propMetadata) {
    if (propMetadata.hasOwnProperty(field)) {
      propMetadata[field].forEach((ann) => {
        if (isHostBinding(ann)) {
          bindings.properties[ann.hostPropertyName || field] = getSafePropertyAccessString("this", field);
        } else if (isHostListener(ann)) {
          bindings.listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(",")})`;
        }
      });
    }
  }
  return bindings;
}
function isHostBinding(value) {
  return value.ngMetadataName === "HostBinding";
}
function isHostListener(value) {
  return value.ngMetadataName === "HostListener";
}
function isInput(value) {
  return value.ngMetadataName === "Input";
}
function isOutput(value) {
  return value.ngMetadataName === "Output";
}
function parseInputOutputs(values) {
  return values.reduce((results, value) => {
    const [field, property] = value.split(":", 2).map((str) => str.trim());
    results[field] = property || field;
    return results;
  }, {});
}
function convertDeclarePipeFacadeToMetadata(declaration) {
  var _a, _b;
  return {
    name: declaration.type.name,
    type: wrapReference(declaration.type),
    internalType: new WrappedNodeExpr(declaration.type),
    typeArgumentCount: 0,
    pipeName: declaration.name,
    deps: null,
    pure: (_a = declaration.pure) !== null && _a !== void 0 ? _a : true,
    isStandalone: (_b = declaration.isStandalone) !== null && _b !== void 0 ? _b : false
  };
}
function convertDeclareInjectorFacadeToMetadata(declaration) {
  return {
    name: declaration.type.name,
    type: wrapReference(declaration.type),
    internalType: new WrappedNodeExpr(declaration.type),
    providers: declaration.providers !== void 0 && declaration.providers.length > 0 ? new WrappedNodeExpr(declaration.providers) : null,
    imports: declaration.imports !== void 0 ? declaration.imports.map((i) => new WrappedNodeExpr(i)) : []
  };
}
function publishFacade(global2) {
  const ng = global2.ng || (global2.ng = {});
  ng.\u0275compilerFacade = new CompilerFacadeImpl();
}
function preserveWhitespacesDefault(preserveWhitespacesOption, defaultSetting = false) {
  return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;
}
var TagContentType, HtmlTagDefinition, _DEFAULT_TAG_DEFINITION, TAG_DEFINITIONS, _SELECTOR_REGEXP, CssSelector, emitDistinctChangesOnlyDefaultValue2, ViewEncapsulation2, ChangeDetectionStrategy2, CUSTOM_ELEMENTS_SCHEMA2, NO_ERRORS_SCHEMA2, Type$1, SecurityContext2, MissingTranslationStrategy2, core, DASH_CASE_REGEXP, Version2, _global2, BigInteger, BigIntForMultiplication, BigIntExponentiation, _SerializerVisitor, serializerVisitor$1, _SerializerIgnoreIcuExpVisitor, Endian, base256, TypeModifier, Type2, BuiltinTypeName, BuiltinType, ExpressionType, ArrayType, MapType, DYNAMIC_TYPE, INFERRED_TYPE, BOOL_TYPE, INT_TYPE, NUMBER_TYPE, STRING_TYPE, FUNCTION_TYPE, NONE_TYPE, UnaryOperator, BinaryOperator, Expression, ReadVarExpr, TypeofExpr, WrappedNodeExpr, WriteVarExpr, WriteKeyExpr, WritePropExpr, InvokeFunctionExpr, TaggedTemplateExpr, InstantiateExpr, LiteralExpr, TemplateLiteral, TemplateLiteralElement, LiteralPiece, PlaceholderPiece, MEANING_SEPARATOR$1, ID_SEPARATOR$1, LEGACY_ID_INDICATOR, LocalizedString, escapeSlashes, escapeStartingColon, escapeColons, escapeForTemplateLiteral, ExternalExpr, ExternalReference, ConditionalExpr, NotExpr, FnParam, FunctionExpr, UnaryOperatorExpr, BinaryOperatorExpr, ReadPropExpr, ReadKeyExpr, LiteralArrayExpr, LiteralMapEntry, LiteralMapExpr, CommaExpr, NULL_EXPR, TYPED_NULL_EXPR, StmtModifier, LeadingComment, JSDocComment, Statement, DeclareVarStmt, DeclareFunctionStmt, ExpressionStatement, ReturnStatement, IfStmt, RecursiveAstVisitor$1, output_ast, CONSTANT_PREFIX, UNKNOWN_VALUE_KEY, KEY_CONTEXT, POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS, FixupExpression, ConstantPool, KeyVisitor, CORE, Identifiers, VERSION$1, JS_B64_PREFIX, SourceMapGenerator, B64_DIGITS, _SINGLE_QUOTE_ESCAPE_STRING_RE, _LEGAL_IDENTIFIER_RE, _INDENT_WITH, _EmittedLine, EmitterVisitorContext, AbstractEmitterVisitor, ANIMATE_SYMBOL_PREFIX, R3FactoryDelegateType, FactoryTarget$1, Comment$1, Text$3, BoundText, TextAttribute, BoundAttribute, BoundEvent, Element$1, Template, Content, Variable, Reference, Icu$1, Message, Text$2, Container, Icu, TagPlaceholder, Placeholder, IcuPlaceholder, LocalizeMessageStringVisitor, _Visitor$2, _visitor, CLOSURE_TRANSLATION_VAR_PREFIX, TRANSLATION_VAR_PREFIX, I18N_ATTR, I18N_ATTR_PREFIX, I18N_ICU_VAR_PREFIX, I18N_ICU_MAPPING_PREFIX, I18N_PLACEHOLDER_SYMBOL, UNSAFE_OBJECT_KEY_NAME_REGEXP, TEMPORARY_NAME, CONTEXT_NAME, RENDER_FLAGS, REFERENCE_PREFIX, IMPLICIT_REFERENCE, NON_BINDABLE_ATTR, RESTORED_VIEW_CONTEXT_NAME, MAX_CHAIN_LENGTH, CHAINABLE_INSTRUCTIONS, DefinitionMap, UNUSABLE_INTERPOLATION_REGEXPS, InterpolationConfig, DEFAULT_INTERPOLATION_CONFIG, $EOF, $BSPACE, $TAB, $LF, $VTAB, $FF, $CR, $SPACE, $BANG, $DQ, $HASH, $$, $PERCENT, $AMPERSAND, $SQ, $LPAREN, $RPAREN, $STAR, $PLUS, $COMMA, $MINUS, $PERIOD, $SLASH, $COLON, $SEMICOLON, $LT, $EQ, $GT, $QUESTION, $0, $7, $9, $A, $E, $F, $X, $Z, $LBRACKET, $BACKSLASH, $RBRACKET, $CARET, $_, $a, $b, $e, $f, $n, $r, $t, $u, $v, $x, $z, $LBRACE, $BAR, $RBRACE, $NBSP, $BT, ParseLocation, ParseSourceFile, ParseSourceSpan, ParseErrorLevel, ParseError, _anonymousTypeIndex, makeTemplateObjectPolyfill, AbstractJsEmitterVisitor, policy2, JitEvaluator, JitEmitterVisitor, R3JitReflector, R3SelectorScopeMode, R3TemplateDependencyKind2, ParserError, ParseSpan, AST, ASTWithName, EmptyExpr, ImplicitReceiver, ThisReceiver, Chain, Conditional, PropertyRead, PropertyWrite, SafePropertyRead, KeyedRead, SafeKeyedRead, KeyedWrite, BindingPipe, LiteralPrimitive, LiteralArray, LiteralMap, Interpolation, Binary, Unary, PrefixNot, NonNullAssert, Call, SafeCall, AbsoluteSourceSpan, ASTWithSource, VariableBinding, ExpressionBinding, RecursiveAstVisitor, AstTransformer, AstMemoryEfficientTransformer, ParsedProperty, ParsedPropertyType, ParsedEvent, ParsedVariable, BoundElementProperty, EventHandlerVars, ConvertPropertyBindingResult, _Mode, _BuiltinAstConverter, _AstToIrVisitor, InterpolationExpression, DefaultLocalResolver, BuiltinFunctionCall, ShadowCss, SafeSelector, _cssContentNextSelectorRe, _cssContentRuleRe, _cssContentUnscopedRuleRe, _polyfillHost, _polyfillHostContext, _parenSuffix, _cssColonHostRe, _cssColonHostContextReGlobal, _cssColonHostContextRe, _polyfillHostNoCombinator, _polyfillHostNoCombinatorRe, _shadowDOMSelectorsRe, _shadowDeepSelectors, _selectorReSuffix, _polyfillHostRe, _colonHostRe, _colonHostContextRe, _commentRe, _commentWithHashRe, BLOCK_PLACEHOLDER, QUOTE_PLACEHOLDER, _ruleRe, _quotedRe, CONTENT_PAIRS, QUOTE_PAIRS, CssRule, StringWithEscapedBlocks, IMPORTANT_FLAG, MIN_STYLING_BINDING_SLOTS_REQUIRED, StylingBuilder, TokenType, KEYWORDS, Lexer, Token, EOF, _Scanner, SplitInterpolation, TemplateBindingParseResult, Parser$1, ParseContextFlags, _ParseAST, SimpleExpressionChecker, NodeWithI18n, Text2, Expansion, ExpansionCase, Attribute2, Element2, Comment, NAMED_ENTITIES, NGSP_UNICODE, TokenError, TokenizeResult, _CR_OR_CRLF_REGEXP, CharacterReferenceType, _ControlFlowError, _Tokenizer, PlainCharacterCursor, EscapedCharacterCursor, CursorError, TreeError, ParseTreeResult, Parser, _TreeBuilder, HtmlParser, PRESERVE_WS_ATTR_NAME, SKIP_WS_TRIM_TAGS, WS_CHARS, NO_WS_REGEXP, WS_REPLACE_REGEXP, WhitespaceVisitor, _SECURITY_SCHEMA, ElementSchemaRegistry, BOOLEAN, NUMBER, STRING, OBJECT, SCHEMA, _ATTR_TO_PROP, _PROP_TO_ATTR, DomElementSchemaRegistry, TRUSTED_TYPES_SINKS, PROPERTY_PARTS_SEPARATOR, ATTRIBUTE_PREFIX, CLASS_PREFIX, STYLE_PREFIX, TEMPLATE_ATTR_PREFIX$1, ANIMATE_PROP_PREFIX, BindingParser, URL_WITH_SCHEMA_REGEXP, NG_CONTENT_SELECT_ATTR$1, LINK_ELEMENT, LINK_STYLE_REL_ATTR, LINK_STYLE_HREF_ATTR, LINK_STYLE_REL_VALUE, STYLE_ELEMENT, SCRIPT_ELEMENT, NG_NON_BINDABLE_ATTR, NG_PROJECT_AS, PreparsedElementType, PreparsedElement, BIND_NAME_REGEXP, KW_BIND_IDX, KW_LET_IDX, KW_REF_IDX, KW_ON_IDX, KW_BINDON_IDX, KW_AT_IDX, IDENT_KW_IDX, BINDING_DELIMS, TEMPLATE_ATTR_PREFIX, HtmlAstToIvyAst, NonBindableVisitor, NON_BINDABLE_VISITOR, TagType, I18nContext, IcuSerializerVisitor, serializer, TAG_TO_PLACEHOLDER_NAMES, PlaceholderRegistry, _expParser, _I18nVisitor, _CUSTOM_PH_EXP, I18nError, setI18nRefs, I18nMetaVisitor, I18N_MEANING_SEPARATOR, I18N_ID_SEPARATOR, GOOG_GET_MSG, GetMsgSerializerVisitor, serializerVisitor, LocalizeSerializerVisitor, NG_CONTENT_SELECT_ATTR, NG_PROJECT_AS_ATTR_NAME, EVENT_BINDING_SCOPE_GLOBALS, GLOBAL_TARGET_RESOLVERS, LEADING_TRIVIA_CHARS, TemplateDefinitionBuilder, ValueConverter, pipeBindingIdentifiers, pureFunctionIdentifiers, SHARED_CONTEXT_KEY, BindingScope, elementRegistry, NG_I18N_CLOSURE_MODE, ATTR_REGEX, COMPONENT_VARIABLE, HOST_ATTR, CONTENT_ATTR, HOST_REG_EXP, ResourceLoader, CompilerFacadeImpl, VERSION4, CompilerConfig, _VisitorMode, XmlTagDefinition, _TAG_DEFINITION, FactoryTarget2;
var init_compiler = __esm({
  "node_modules/@angular/compiler/fesm2015/compiler.mjs"() {
    init_define_ngDevMode();
    (function(TagContentType2) {
      TagContentType2[TagContentType2["RAW_TEXT"] = 0] = "RAW_TEXT";
      TagContentType2[TagContentType2["ESCAPABLE_RAW_TEXT"] = 1] = "ESCAPABLE_RAW_TEXT";
      TagContentType2[TagContentType2["PARSABLE_DATA"] = 2] = "PARSABLE_DATA";
    })(TagContentType || (TagContentType = {}));
    HtmlTagDefinition = class {
      constructor({
        closedByChildren,
        implicitNamespacePrefix,
        contentType = TagContentType.PARSABLE_DATA,
        closedByParent = false,
        isVoid = false,
        ignoreFirstLf = false,
        preventNamespaceInheritance = false
      } = {}) {
        this.closedByChildren = {};
        this.closedByParent = false;
        this.canSelfClose = false;
        if (closedByChildren && closedByChildren.length > 0) {
          closedByChildren.forEach((tagName) => this.closedByChildren[tagName] = true);
        }
        this.isVoid = isVoid;
        this.closedByParent = closedByParent || isVoid;
        this.implicitNamespacePrefix = implicitNamespacePrefix || null;
        this.contentType = contentType;
        this.ignoreFirstLf = ignoreFirstLf;
        this.preventNamespaceInheritance = preventNamespaceInheritance;
      }
      isClosedByChild(name) {
        return this.isVoid || name.toLowerCase() in this.closedByChildren;
      }
      getContentType(prefix) {
        if (typeof this.contentType === "object") {
          const overrideType = prefix === void 0 ? void 0 : this.contentType[prefix];
          return overrideType !== null && overrideType !== void 0 ? overrideType : this.contentType.default;
        }
        return this.contentType;
      }
    };
    _SELECTOR_REGEXP = new RegExp(
      `(\\:not\\()|(([\\.\\#]?)[-\\w]+)|(?:\\[([-.\\w*\\\\$]+)(?:=(["']?)([^\\]"']*)\\5)?\\])|(\\))|(\\s*,\\s*)`,
      "g"
    );
    CssSelector = class {
      constructor() {
        this.element = null;
        this.classNames = [];
        this.attrs = [];
        this.notSelectors = [];
      }
      static parse(selector) {
        const results = [];
        const _addResult = (res, cssSel) => {
          if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 && cssSel.attrs.length == 0) {
            cssSel.element = "*";
          }
          res.push(cssSel);
        };
        let cssSelector = new CssSelector();
        let match;
        let current = cssSelector;
        let inNot = false;
        _SELECTOR_REGEXP.lastIndex = 0;
        while (match = _SELECTOR_REGEXP.exec(selector)) {
          if (match[1]) {
            if (inNot) {
              throw new Error("Nesting :not in a selector is not allowed");
            }
            inNot = true;
            current = new CssSelector();
            cssSelector.notSelectors.push(current);
          }
          const tag = match[2];
          if (tag) {
            const prefix = match[3];
            if (prefix === "#") {
              current.addAttribute("id", tag.slice(1));
            } else if (prefix === ".") {
              current.addClassName(tag.slice(1));
            } else {
              current.setElement(tag);
            }
          }
          const attribute = match[4];
          if (attribute) {
            current.addAttribute(current.unescapeAttribute(attribute), match[6]);
          }
          if (match[7]) {
            inNot = false;
            current = cssSelector;
          }
          if (match[8]) {
            if (inNot) {
              throw new Error("Multiple selectors in :not are not supported");
            }
            _addResult(results, cssSelector);
            cssSelector = current = new CssSelector();
          }
        }
        _addResult(results, cssSelector);
        return results;
      }
      unescapeAttribute(attr) {
        let result = "";
        let escaping = false;
        for (let i = 0; i < attr.length; i++) {
          const char = attr.charAt(i);
          if (char === "\\") {
            escaping = true;
            continue;
          }
          if (char === "$" && !escaping) {
            throw new Error(`Error in attribute selector "${attr}". Unescaped "$" is not supported. Please escape with "\\$".`);
          }
          escaping = false;
          result += char;
        }
        return result;
      }
      escapeAttribute(attr) {
        return attr.replace(/\\/g, "\\\\").replace(/\$/g, "\\$");
      }
      isElementSelector() {
        return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 && this.notSelectors.length === 0;
      }
      hasElementSelector() {
        return !!this.element;
      }
      setElement(element = null) {
        this.element = element;
      }
      getMatchingElementTemplate() {
        const tagName = this.element || "div";
        const classAttr = this.classNames.length > 0 ? ` class="${this.classNames.join(" ")}"` : "";
        let attrs = "";
        for (let i = 0; i < this.attrs.length; i += 2) {
          const attrName = this.attrs[i];
          const attrValue = this.attrs[i + 1] !== "" ? `="${this.attrs[i + 1]}"` : "";
          attrs += ` ${attrName}${attrValue}`;
        }
        return getHtmlTagDefinition(tagName).isVoid ? `<${tagName}${classAttr}${attrs}/>` : `<${tagName}${classAttr}${attrs}></${tagName}>`;
      }
      getAttrs() {
        const result = [];
        if (this.classNames.length > 0) {
          result.push("class", this.classNames.join(" "));
        }
        return result.concat(this.attrs);
      }
      addAttribute(name, value = "") {
        this.attrs.push(name, value && value.toLowerCase() || "");
      }
      addClassName(name) {
        this.classNames.push(name.toLowerCase());
      }
      toString() {
        let res = this.element || "";
        if (this.classNames) {
          this.classNames.forEach((klass) => res += `.${klass}`);
        }
        if (this.attrs) {
          for (let i = 0; i < this.attrs.length; i += 2) {
            const name = this.escapeAttribute(this.attrs[i]);
            const value = this.attrs[i + 1];
            res += `[${name}${value ? "=" + value : ""}]`;
          }
        }
        this.notSelectors.forEach((notSelector) => res += `:not(${notSelector})`);
        return res;
      }
    };
    emitDistinctChangesOnlyDefaultValue2 = true;
    (function(ViewEncapsulation3) {
      ViewEncapsulation3[ViewEncapsulation3["Emulated"] = 0] = "Emulated";
      ViewEncapsulation3[ViewEncapsulation3["None"] = 2] = "None";
      ViewEncapsulation3[ViewEncapsulation3["ShadowDom"] = 3] = "ShadowDom";
    })(ViewEncapsulation2 || (ViewEncapsulation2 = {}));
    (function(ChangeDetectionStrategy3) {
      ChangeDetectionStrategy3[ChangeDetectionStrategy3["OnPush"] = 0] = "OnPush";
      ChangeDetectionStrategy3[ChangeDetectionStrategy3["Default"] = 1] = "Default";
    })(ChangeDetectionStrategy2 || (ChangeDetectionStrategy2 = {}));
    CUSTOM_ELEMENTS_SCHEMA2 = {
      name: "custom-elements"
    };
    NO_ERRORS_SCHEMA2 = {
      name: "no-errors-schema"
    };
    Type$1 = Function;
    (function(SecurityContext3) {
      SecurityContext3[SecurityContext3["NONE"] = 0] = "NONE";
      SecurityContext3[SecurityContext3["HTML"] = 1] = "HTML";
      SecurityContext3[SecurityContext3["STYLE"] = 2] = "STYLE";
      SecurityContext3[SecurityContext3["SCRIPT"] = 3] = "SCRIPT";
      SecurityContext3[SecurityContext3["URL"] = 4] = "URL";
      SecurityContext3[SecurityContext3["RESOURCE_URL"] = 5] = "RESOURCE_URL";
    })(SecurityContext2 || (SecurityContext2 = {}));
    (function(MissingTranslationStrategy3) {
      MissingTranslationStrategy3[MissingTranslationStrategy3["Error"] = 0] = "Error";
      MissingTranslationStrategy3[MissingTranslationStrategy3["Warning"] = 1] = "Warning";
      MissingTranslationStrategy3[MissingTranslationStrategy3["Ignore"] = 2] = "Ignore";
    })(MissingTranslationStrategy2 || (MissingTranslationStrategy2 = {}));
    core = Object.freeze({
      __proto__: null,
      emitDistinctChangesOnlyDefaultValue: emitDistinctChangesOnlyDefaultValue2,
      get ViewEncapsulation() {
        return ViewEncapsulation2;
      },
      get ChangeDetectionStrategy() {
        return ChangeDetectionStrategy2;
      },
      CUSTOM_ELEMENTS_SCHEMA: CUSTOM_ELEMENTS_SCHEMA2,
      NO_ERRORS_SCHEMA: NO_ERRORS_SCHEMA2,
      Type: Type$1,
      get SecurityContext() {
        return SecurityContext2;
      },
      get MissingTranslationStrategy() {
        return MissingTranslationStrategy2;
      },
      parseSelectorToR3Selector
    });
    DASH_CASE_REGEXP = /-+([a-z0-9])/g;
    Version2 = class {
      constructor(full) {
        this.full = full;
        const splits = full.split(".");
        this.major = splits[0];
        this.minor = splits[1];
        this.patch = splits.slice(2).join(".");
      }
    };
    _global2 = (() => typeof global !== "undefined" && global || typeof window !== "undefined" && window || typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && self)();
    BigInteger = class {
      constructor(digits) {
        this.digits = digits;
      }
      static zero() {
        return new BigInteger([0]);
      }
      static one() {
        return new BigInteger([1]);
      }
      clone() {
        return new BigInteger(this.digits.slice());
      }
      add(other) {
        const result = this.clone();
        result.addToSelf(other);
        return result;
      }
      addToSelf(other) {
        const maxNrOfDigits = Math.max(this.digits.length, other.digits.length);
        let carry = 0;
        for (let i = 0; i < maxNrOfDigits; i++) {
          let digitSum = carry;
          if (i < this.digits.length) {
            digitSum += this.digits[i];
          }
          if (i < other.digits.length) {
            digitSum += other.digits[i];
          }
          if (digitSum >= 10) {
            this.digits[i] = digitSum - 10;
            carry = 1;
          } else {
            this.digits[i] = digitSum;
            carry = 0;
          }
        }
        if (carry > 0) {
          this.digits[maxNrOfDigits] = 1;
        }
      }
      toString() {
        let res = "";
        for (let i = this.digits.length - 1; i >= 0; i--) {
          res += this.digits[i];
        }
        return res;
      }
    };
    BigIntForMultiplication = class {
      constructor(value) {
        this.powerOfTwos = [value];
      }
      getValue() {
        return this.powerOfTwos[0];
      }
      multiplyBy(num) {
        const product = BigInteger.zero();
        this.multiplyByAndAddTo(num, product);
        return product;
      }
      multiplyByAndAddTo(num, result) {
        for (let exponent = 0; num !== 0; num = num >>> 1, exponent++) {
          if (num & 1) {
            const value = this.getMultipliedByPowerOfTwo(exponent);
            result.addToSelf(value);
          }
        }
      }
      getMultipliedByPowerOfTwo(exponent) {
        for (let i = this.powerOfTwos.length; i <= exponent; i++) {
          const previousPower = this.powerOfTwos[i - 1];
          this.powerOfTwos[i] = previousPower.add(previousPower);
        }
        return this.powerOfTwos[exponent];
      }
    };
    BigIntExponentiation = class {
      constructor(base) {
        this.base = base;
        this.exponents = [new BigIntForMultiplication(BigInteger.one())];
      }
      toThePowerOf(exponent) {
        for (let i = this.exponents.length; i <= exponent; i++) {
          const value = this.exponents[i - 1].multiplyBy(this.base);
          this.exponents[i] = new BigIntForMultiplication(value);
        }
        return this.exponents[exponent];
      }
    };
    _SerializerVisitor = class {
      visitText(text, context2) {
        return text.value;
      }
      visitContainer(container, context2) {
        return `[${container.children.map((child) => child.visit(this)).join(", ")}]`;
      }
      visitIcu(icu, context2) {
        const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
        return `{${icu.expression}, ${icu.type}, ${strCases.join(", ")}}`;
      }
      visitTagPlaceholder(ph, context2) {
        return ph.isVoid ? `<ph tag name="${ph.startName}"/>` : `<ph tag name="${ph.startName}">${ph.children.map((child) => child.visit(this)).join(", ")}</ph name="${ph.closeName}">`;
      }
      visitPlaceholder(ph, context2) {
        return ph.value ? `<ph name="${ph.name}">${ph.value}</ph>` : `<ph name="${ph.name}"/>`;
      }
      visitIcuPlaceholder(ph, context2) {
        return `<ph icu name="${ph.name}">${ph.value.visit(this)}</ph>`;
      }
    };
    serializerVisitor$1 = new _SerializerVisitor();
    _SerializerIgnoreIcuExpVisitor = class extends _SerializerVisitor {
      visitIcu(icu, context2) {
        let strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
        return `{${icu.type}, ${strCases.join(", ")}}`;
      }
    };
    (function(Endian2) {
      Endian2[Endian2["Little"] = 0] = "Little";
      Endian2[Endian2["Big"] = 1] = "Big";
    })(Endian || (Endian = {}));
    base256 = new BigIntExponentiation(256);
    (function(TypeModifier2) {
      TypeModifier2[TypeModifier2["None"] = 0] = "None";
      TypeModifier2[TypeModifier2["Const"] = 1] = "Const";
    })(TypeModifier || (TypeModifier = {}));
    Type2 = class {
      constructor(modifiers = TypeModifier.None) {
        this.modifiers = modifiers;
      }
      hasModifier(modifier) {
        return (this.modifiers & modifier) !== 0;
      }
    };
    (function(BuiltinTypeName2) {
      BuiltinTypeName2[BuiltinTypeName2["Dynamic"] = 0] = "Dynamic";
      BuiltinTypeName2[BuiltinTypeName2["Bool"] = 1] = "Bool";
      BuiltinTypeName2[BuiltinTypeName2["String"] = 2] = "String";
      BuiltinTypeName2[BuiltinTypeName2["Int"] = 3] = "Int";
      BuiltinTypeName2[BuiltinTypeName2["Number"] = 4] = "Number";
      BuiltinTypeName2[BuiltinTypeName2["Function"] = 5] = "Function";
      BuiltinTypeName2[BuiltinTypeName2["Inferred"] = 6] = "Inferred";
      BuiltinTypeName2[BuiltinTypeName2["None"] = 7] = "None";
    })(BuiltinTypeName || (BuiltinTypeName = {}));
    BuiltinType = class extends Type2 {
      constructor(name, modifiers) {
        super(modifiers);
        this.name = name;
      }
      visitType(visitor, context2) {
        return visitor.visitBuiltinType(this, context2);
      }
    };
    ExpressionType = class extends Type2 {
      constructor(value, modifiers, typeParams = null) {
        super(modifiers);
        this.value = value;
        this.typeParams = typeParams;
      }
      visitType(visitor, context2) {
        return visitor.visitExpressionType(this, context2);
      }
    };
    ArrayType = class extends Type2 {
      constructor(of2, modifiers) {
        super(modifiers);
        this.of = of2;
      }
      visitType(visitor, context2) {
        return visitor.visitArrayType(this, context2);
      }
    };
    MapType = class extends Type2 {
      constructor(valueType, modifiers) {
        super(modifiers);
        this.valueType = valueType || null;
      }
      visitType(visitor, context2) {
        return visitor.visitMapType(this, context2);
      }
    };
    DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);
    INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);
    BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);
    INT_TYPE = new BuiltinType(BuiltinTypeName.Int);
    NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);
    STRING_TYPE = new BuiltinType(BuiltinTypeName.String);
    FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);
    NONE_TYPE = new BuiltinType(BuiltinTypeName.None);
    (function(UnaryOperator2) {
      UnaryOperator2[UnaryOperator2["Minus"] = 0] = "Minus";
      UnaryOperator2[UnaryOperator2["Plus"] = 1] = "Plus";
    })(UnaryOperator || (UnaryOperator = {}));
    (function(BinaryOperator2) {
      BinaryOperator2[BinaryOperator2["Equals"] = 0] = "Equals";
      BinaryOperator2[BinaryOperator2["NotEquals"] = 1] = "NotEquals";
      BinaryOperator2[BinaryOperator2["Identical"] = 2] = "Identical";
      BinaryOperator2[BinaryOperator2["NotIdentical"] = 3] = "NotIdentical";
      BinaryOperator2[BinaryOperator2["Minus"] = 4] = "Minus";
      BinaryOperator2[BinaryOperator2["Plus"] = 5] = "Plus";
      BinaryOperator2[BinaryOperator2["Divide"] = 6] = "Divide";
      BinaryOperator2[BinaryOperator2["Multiply"] = 7] = "Multiply";
      BinaryOperator2[BinaryOperator2["Modulo"] = 8] = "Modulo";
      BinaryOperator2[BinaryOperator2["And"] = 9] = "And";
      BinaryOperator2[BinaryOperator2["Or"] = 10] = "Or";
      BinaryOperator2[BinaryOperator2["BitwiseAnd"] = 11] = "BitwiseAnd";
      BinaryOperator2[BinaryOperator2["Lower"] = 12] = "Lower";
      BinaryOperator2[BinaryOperator2["LowerEquals"] = 13] = "LowerEquals";
      BinaryOperator2[BinaryOperator2["Bigger"] = 14] = "Bigger";
      BinaryOperator2[BinaryOperator2["BiggerEquals"] = 15] = "BiggerEquals";
      BinaryOperator2[BinaryOperator2["NullishCoalesce"] = 16] = "NullishCoalesce";
    })(BinaryOperator || (BinaryOperator = {}));
    Expression = class {
      constructor(type, sourceSpan) {
        this.type = type || null;
        this.sourceSpan = sourceSpan || null;
      }
      prop(name, sourceSpan) {
        return new ReadPropExpr(this, name, null, sourceSpan);
      }
      key(index, type, sourceSpan) {
        return new ReadKeyExpr(this, index, type, sourceSpan);
      }
      callFn(params, sourceSpan, pure) {
        return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);
      }
      instantiate(params, type, sourceSpan) {
        return new InstantiateExpr(this, params, type, sourceSpan);
      }
      conditional(trueCase, falseCase = null, sourceSpan) {
        return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);
      }
      equals(rhs, sourceSpan) {
        return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);
      }
      notEquals(rhs, sourceSpan) {
        return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);
      }
      identical(rhs, sourceSpan) {
        return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);
      }
      notIdentical(rhs, sourceSpan) {
        return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);
      }
      minus(rhs, sourceSpan) {
        return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);
      }
      plus(rhs, sourceSpan) {
        return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);
      }
      divide(rhs, sourceSpan) {
        return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);
      }
      multiply(rhs, sourceSpan) {
        return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);
      }
      modulo(rhs, sourceSpan) {
        return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);
      }
      and(rhs, sourceSpan) {
        return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);
      }
      bitwiseAnd(rhs, sourceSpan, parens = true) {
        return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);
      }
      or(rhs, sourceSpan) {
        return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);
      }
      lower(rhs, sourceSpan) {
        return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);
      }
      lowerEquals(rhs, sourceSpan) {
        return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);
      }
      bigger(rhs, sourceSpan) {
        return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);
      }
      biggerEquals(rhs, sourceSpan) {
        return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);
      }
      isBlank(sourceSpan) {
        return this.equals(TYPED_NULL_EXPR, sourceSpan);
      }
      nullishCoalesce(rhs, sourceSpan) {
        return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);
      }
      toStmt() {
        return new ExpressionStatement(this, null);
      }
    };
    ReadVarExpr = class extends Expression {
      constructor(name, type, sourceSpan) {
        super(type, sourceSpan);
        this.name = name;
      }
      isEquivalent(e) {
        return e instanceof ReadVarExpr && this.name === e.name;
      }
      isConstant() {
        return false;
      }
      visitExpression(visitor, context2) {
        return visitor.visitReadVarExpr(this, context2);
      }
      set(value) {
        return new WriteVarExpr(this.name, value, null, this.sourceSpan);
      }
    };
    TypeofExpr = class extends Expression {
      constructor(expr, type, sourceSpan) {
        super(type, sourceSpan);
        this.expr = expr;
      }
      visitExpression(visitor, context2) {
        return visitor.visitTypeofExpr(this, context2);
      }
      isEquivalent(e) {
        return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);
      }
      isConstant() {
        return this.expr.isConstant();
      }
    };
    WrappedNodeExpr = class extends Expression {
      constructor(node, type, sourceSpan) {
        super(type, sourceSpan);
        this.node = node;
      }
      isEquivalent(e) {
        return e instanceof WrappedNodeExpr && this.node === e.node;
      }
      isConstant() {
        return false;
      }
      visitExpression(visitor, context2) {
        return visitor.visitWrappedNodeExpr(this, context2);
      }
    };
    WriteVarExpr = class extends Expression {
      constructor(name, value, type, sourceSpan) {
        super(type || value.type, sourceSpan);
        this.name = name;
        this.value = value;
      }
      isEquivalent(e) {
        return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);
      }
      isConstant() {
        return false;
      }
      visitExpression(visitor, context2) {
        return visitor.visitWriteVarExpr(this, context2);
      }
      toDeclStmt(type, modifiers) {
        return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);
      }
      toConstDecl() {
        return this.toDeclStmt(INFERRED_TYPE, StmtModifier.Final);
      }
    };
    WriteKeyExpr = class extends Expression {
      constructor(receiver, index, value, type, sourceSpan) {
        super(type || value.type, sourceSpan);
        this.receiver = receiver;
        this.index = index;
        this.value = value;
      }
      isEquivalent(e) {
        return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);
      }
      isConstant() {
        return false;
      }
      visitExpression(visitor, context2) {
        return visitor.visitWriteKeyExpr(this, context2);
      }
    };
    WritePropExpr = class extends Expression {
      constructor(receiver, name, value, type, sourceSpan) {
        super(type || value.type, sourceSpan);
        this.receiver = receiver;
        this.name = name;
        this.value = value;
      }
      isEquivalent(e) {
        return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name && this.value.isEquivalent(e.value);
      }
      isConstant() {
        return false;
      }
      visitExpression(visitor, context2) {
        return visitor.visitWritePropExpr(this, context2);
      }
    };
    InvokeFunctionExpr = class extends Expression {
      constructor(fn2, args, type, sourceSpan, pure = false) {
        super(type, sourceSpan);
        this.fn = fn2;
        this.args = args;
        this.pure = pure;
      }
      isEquivalent(e) {
        return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) && areAllEquivalent(this.args, e.args) && this.pure === e.pure;
      }
      isConstant() {
        return false;
      }
      visitExpression(visitor, context2) {
        return visitor.visitInvokeFunctionExpr(this, context2);
      }
    };
    TaggedTemplateExpr = class extends Expression {
      constructor(tag, template, type, sourceSpan) {
        super(type, sourceSpan);
        this.tag = tag;
        this.template = template;
      }
      isEquivalent(e) {
        return e instanceof TaggedTemplateExpr && this.tag.isEquivalent(e.tag) && areAllEquivalentPredicate(this.template.elements, e.template.elements, (a, b) => a.text === b.text) && areAllEquivalent(this.template.expressions, e.template.expressions);
      }
      isConstant() {
        return false;
      }
      visitExpression(visitor, context2) {
        return visitor.visitTaggedTemplateExpr(this, context2);
      }
    };
    InstantiateExpr = class extends Expression {
      constructor(classExpr, args, type, sourceSpan) {
        super(type, sourceSpan);
        this.classExpr = classExpr;
        this.args = args;
      }
      isEquivalent(e) {
        return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) && areAllEquivalent(this.args, e.args);
      }
      isConstant() {
        return false;
      }
      visitExpression(visitor, context2) {
        return visitor.visitInstantiateExpr(this, context2);
      }
    };
    LiteralExpr = class extends Expression {
      constructor(value, type, sourceSpan) {
        super(type, sourceSpan);
        this.value = value;
      }
      isEquivalent(e) {
        return e instanceof LiteralExpr && this.value === e.value;
      }
      isConstant() {
        return true;
      }
      visitExpression(visitor, context2) {
        return visitor.visitLiteralExpr(this, context2);
      }
    };
    TemplateLiteral = class {
      constructor(elements, expressions) {
        this.elements = elements;
        this.expressions = expressions;
      }
    };
    TemplateLiteralElement = class {
      constructor(text, sourceSpan, rawText) {
        var _a;
        this.text = text;
        this.sourceSpan = sourceSpan;
        this.rawText = (_a = rawText !== null && rawText !== void 0 ? rawText : sourceSpan === null || sourceSpan === void 0 ? void 0 : sourceSpan.toString()) !== null && _a !== void 0 ? _a : escapeForTemplateLiteral(escapeSlashes(text));
      }
    };
    LiteralPiece = class {
      constructor(text, sourceSpan) {
        this.text = text;
        this.sourceSpan = sourceSpan;
      }
    };
    PlaceholderPiece = class {
      constructor(text, sourceSpan, associatedMessage) {
        this.text = text;
        this.sourceSpan = sourceSpan;
        this.associatedMessage = associatedMessage;
      }
    };
    MEANING_SEPARATOR$1 = "|";
    ID_SEPARATOR$1 = "@@";
    LEGACY_ID_INDICATOR = "\u241F";
    LocalizedString = class extends Expression {
      constructor(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {
        super(STRING_TYPE, sourceSpan);
        this.metaBlock = metaBlock;
        this.messageParts = messageParts;
        this.placeHolderNames = placeHolderNames;
        this.expressions = expressions;
      }
      isEquivalent(e) {
        return false;
      }
      isConstant() {
        return false;
      }
      visitExpression(visitor, context2) {
        return visitor.visitLocalizedString(this, context2);
      }
      serializeI18nHead() {
        let metaBlock = this.metaBlock.description || "";
        if (this.metaBlock.meaning) {
          metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR$1}${metaBlock}`;
        }
        if (this.metaBlock.customId) {
          metaBlock = `${metaBlock}${ID_SEPARATOR$1}${this.metaBlock.customId}`;
        }
        if (this.metaBlock.legacyIds) {
          this.metaBlock.legacyIds.forEach((legacyId) => {
            metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;
          });
        }
        return createCookedRawString(metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));
      }
      getMessagePartSourceSpan(i) {
        var _a, _b;
        return (_b = (_a = this.messageParts[i]) === null || _a === void 0 ? void 0 : _a.sourceSpan) !== null && _b !== void 0 ? _b : this.sourceSpan;
      }
      getPlaceholderSourceSpan(i) {
        var _a, _b, _c, _d;
        return (_d = (_b = (_a = this.placeHolderNames[i]) === null || _a === void 0 ? void 0 : _a.sourceSpan) !== null && _b !== void 0 ? _b : (_c = this.expressions[i]) === null || _c === void 0 ? void 0 : _c.sourceSpan) !== null && _d !== void 0 ? _d : this.sourceSpan;
      }
      serializeI18nTemplatePart(partIndex) {
        var _a;
        const placeholder = this.placeHolderNames[partIndex - 1];
        const messagePart = this.messageParts[partIndex];
        let metaBlock = placeholder.text;
        if (((_a = placeholder.associatedMessage) === null || _a === void 0 ? void 0 : _a.legacyIds.length) === 0) {
          metaBlock += `${ID_SEPARATOR$1}${computeMsgId(placeholder.associatedMessage.messageString, placeholder.associatedMessage.meaning)}`;
        }
        return createCookedRawString(metaBlock, messagePart.text, this.getMessagePartSourceSpan(partIndex));
      }
    };
    escapeSlashes = (str) => str.replace(/\\/g, "\\\\");
    escapeStartingColon = (str) => str.replace(/^:/, "\\:");
    escapeColons = (str) => str.replace(/:/g, "\\:");
    escapeForTemplateLiteral = (str) => str.replace(/`/g, "\\`").replace(/\${/g, "$\\{");
    ExternalExpr = class extends Expression {
      constructor(value, type, typeParams = null, sourceSpan) {
        super(type, sourceSpan);
        this.value = value;
        this.typeParams = typeParams;
      }
      isEquivalent(e) {
        return e instanceof ExternalExpr && this.value.name === e.value.name && this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;
      }
      isConstant() {
        return false;
      }
      visitExpression(visitor, context2) {
        return visitor.visitExternalExpr(this, context2);
      }
    };
    ExternalReference = class {
      constructor(moduleName, name, runtime) {
        this.moduleName = moduleName;
        this.name = name;
        this.runtime = runtime;
      }
    };
    ConditionalExpr = class extends Expression {
      constructor(condition, trueCase, falseCase = null, type, sourceSpan) {
        super(type || trueCase.type, sourceSpan);
        this.condition = condition;
        this.falseCase = falseCase;
        this.trueCase = trueCase;
      }
      isEquivalent(e) {
        return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) && this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);
      }
      isConstant() {
        return false;
      }
      visitExpression(visitor, context2) {
        return visitor.visitConditionalExpr(this, context2);
      }
    };
    NotExpr = class extends Expression {
      constructor(condition, sourceSpan) {
        super(BOOL_TYPE, sourceSpan);
        this.condition = condition;
      }
      isEquivalent(e) {
        return e instanceof NotExpr && this.condition.isEquivalent(e.condition);
      }
      isConstant() {
        return false;
      }
      visitExpression(visitor, context2) {
        return visitor.visitNotExpr(this, context2);
      }
    };
    FnParam = class {
      constructor(name, type = null) {
        this.name = name;
        this.type = type;
      }
      isEquivalent(param) {
        return this.name === param.name;
      }
    };
    FunctionExpr = class extends Expression {
      constructor(params, statements, type, sourceSpan, name) {
        super(type, sourceSpan);
        this.params = params;
        this.statements = statements;
        this.name = name;
      }
      isEquivalent(e) {
        return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) && areAllEquivalent(this.statements, e.statements);
      }
      isConstant() {
        return false;
      }
      visitExpression(visitor, context2) {
        return visitor.visitFunctionExpr(this, context2);
      }
      toDeclStmt(name, modifiers) {
        return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);
      }
    };
    UnaryOperatorExpr = class extends Expression {
      constructor(operator, expr, type, sourceSpan, parens = true) {
        super(type || NUMBER_TYPE, sourceSpan);
        this.operator = operator;
        this.expr = expr;
        this.parens = parens;
      }
      isEquivalent(e) {
        return e instanceof UnaryOperatorExpr && this.operator === e.operator && this.expr.isEquivalent(e.expr);
      }
      isConstant() {
        return false;
      }
      visitExpression(visitor, context2) {
        return visitor.visitUnaryOperatorExpr(this, context2);
      }
    };
    BinaryOperatorExpr = class extends Expression {
      constructor(operator, lhs, rhs, type, sourceSpan, parens = true) {
        super(type || lhs.type, sourceSpan);
        this.operator = operator;
        this.rhs = rhs;
        this.parens = parens;
        this.lhs = lhs;
      }
      isEquivalent(e) {
        return e instanceof BinaryOperatorExpr && this.operator === e.operator && this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);
      }
      isConstant() {
        return false;
      }
      visitExpression(visitor, context2) {
        return visitor.visitBinaryOperatorExpr(this, context2);
      }
    };
    ReadPropExpr = class extends Expression {
      constructor(receiver, name, type, sourceSpan) {
        super(type, sourceSpan);
        this.receiver = receiver;
        this.name = name;
      }
      isEquivalent(e) {
        return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name;
      }
      isConstant() {
        return false;
      }
      visitExpression(visitor, context2) {
        return visitor.visitReadPropExpr(this, context2);
      }
      set(value) {
        return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);
      }
    };
    ReadKeyExpr = class extends Expression {
      constructor(receiver, index, type, sourceSpan) {
        super(type, sourceSpan);
        this.receiver = receiver;
        this.index = index;
      }
      isEquivalent(e) {
        return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index);
      }
      isConstant() {
        return false;
      }
      visitExpression(visitor, context2) {
        return visitor.visitReadKeyExpr(this, context2);
      }
      set(value) {
        return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);
      }
    };
    LiteralArrayExpr = class extends Expression {
      constructor(entries, type, sourceSpan) {
        super(type, sourceSpan);
        this.entries = entries;
      }
      isConstant() {
        return this.entries.every((e) => e.isConstant());
      }
      isEquivalent(e) {
        return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);
      }
      visitExpression(visitor, context2) {
        return visitor.visitLiteralArrayExpr(this, context2);
      }
    };
    LiteralMapEntry = class {
      constructor(key, value, quoted) {
        this.key = key;
        this.value = value;
        this.quoted = quoted;
      }
      isEquivalent(e) {
        return this.key === e.key && this.value.isEquivalent(e.value);
      }
    };
    LiteralMapExpr = class extends Expression {
      constructor(entries, type, sourceSpan) {
        super(type, sourceSpan);
        this.entries = entries;
        this.valueType = null;
        if (type) {
          this.valueType = type.valueType;
        }
      }
      isEquivalent(e) {
        return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);
      }
      isConstant() {
        return this.entries.every((e) => e.value.isConstant());
      }
      visitExpression(visitor, context2) {
        return visitor.visitLiteralMapExpr(this, context2);
      }
    };
    CommaExpr = class extends Expression {
      constructor(parts, sourceSpan) {
        super(parts[parts.length - 1].type, sourceSpan);
        this.parts = parts;
      }
      isEquivalent(e) {
        return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);
      }
      isConstant() {
        return false;
      }
      visitExpression(visitor, context2) {
        return visitor.visitCommaExpr(this, context2);
      }
    };
    NULL_EXPR = new LiteralExpr(null, null, null);
    TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);
    (function(StmtModifier2) {
      StmtModifier2[StmtModifier2["None"] = 0] = "None";
      StmtModifier2[StmtModifier2["Final"] = 1] = "Final";
      StmtModifier2[StmtModifier2["Private"] = 2] = "Private";
      StmtModifier2[StmtModifier2["Exported"] = 4] = "Exported";
      StmtModifier2[StmtModifier2["Static"] = 8] = "Static";
    })(StmtModifier || (StmtModifier = {}));
    LeadingComment = class {
      constructor(text, multiline, trailingNewline) {
        this.text = text;
        this.multiline = multiline;
        this.trailingNewline = trailingNewline;
      }
      toString() {
        return this.multiline ? ` ${this.text} ` : this.text;
      }
    };
    JSDocComment = class extends LeadingComment {
      constructor(tags) {
        super(
          "",
          true,
          true
        );
        this.tags = tags;
      }
      toString() {
        return serializeTags(this.tags);
      }
    };
    Statement = class {
      constructor(modifiers = StmtModifier.None, sourceSpan = null, leadingComments) {
        this.modifiers = modifiers;
        this.sourceSpan = sourceSpan;
        this.leadingComments = leadingComments;
      }
      hasModifier(modifier) {
        return (this.modifiers & modifier) !== 0;
      }
      addLeadingComment(leadingComment2) {
        var _a;
        this.leadingComments = (_a = this.leadingComments) !== null && _a !== void 0 ? _a : [];
        this.leadingComments.push(leadingComment2);
      }
    };
    DeclareVarStmt = class extends Statement {
      constructor(name, value, type, modifiers, sourceSpan, leadingComments) {
        super(modifiers, sourceSpan, leadingComments);
        this.name = name;
        this.value = value;
        this.type = type || value && value.type || null;
      }
      isEquivalent(stmt) {
        return stmt instanceof DeclareVarStmt && this.name === stmt.name && (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);
      }
      visitStatement(visitor, context2) {
        return visitor.visitDeclareVarStmt(this, context2);
      }
    };
    DeclareFunctionStmt = class extends Statement {
      constructor(name, params, statements, type, modifiers, sourceSpan, leadingComments) {
        super(modifiers, sourceSpan, leadingComments);
        this.name = name;
        this.params = params;
        this.statements = statements;
        this.type = type || null;
      }
      isEquivalent(stmt) {
        return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) && areAllEquivalent(this.statements, stmt.statements);
      }
      visitStatement(visitor, context2) {
        return visitor.visitDeclareFunctionStmt(this, context2);
      }
    };
    ExpressionStatement = class extends Statement {
      constructor(expr, sourceSpan, leadingComments) {
        super(StmtModifier.None, sourceSpan, leadingComments);
        this.expr = expr;
      }
      isEquivalent(stmt) {
        return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);
      }
      visitStatement(visitor, context2) {
        return visitor.visitExpressionStmt(this, context2);
      }
    };
    ReturnStatement = class extends Statement {
      constructor(value, sourceSpan = null, leadingComments) {
        super(StmtModifier.None, sourceSpan, leadingComments);
        this.value = value;
      }
      isEquivalent(stmt) {
        return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);
      }
      visitStatement(visitor, context2) {
        return visitor.visitReturnStmt(this, context2);
      }
    };
    IfStmt = class extends Statement {
      constructor(condition, trueCase, falseCase = [], sourceSpan, leadingComments) {
        super(StmtModifier.None, sourceSpan, leadingComments);
        this.condition = condition;
        this.trueCase = trueCase;
        this.falseCase = falseCase;
      }
      isEquivalent(stmt) {
        return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) && areAllEquivalent(this.trueCase, stmt.trueCase) && areAllEquivalent(this.falseCase, stmt.falseCase);
      }
      visitStatement(visitor, context2) {
        return visitor.visitIfStmt(this, context2);
      }
    };
    RecursiveAstVisitor$1 = class {
      visitType(ast, context2) {
        return ast;
      }
      visitExpression(ast, context2) {
        if (ast.type) {
          ast.type.visitType(this, context2);
        }
        return ast;
      }
      visitBuiltinType(type, context2) {
        return this.visitType(type, context2);
      }
      visitExpressionType(type, context2) {
        type.value.visitExpression(this, context2);
        if (type.typeParams !== null) {
          type.typeParams.forEach((param) => this.visitType(param, context2));
        }
        return this.visitType(type, context2);
      }
      visitArrayType(type, context2) {
        return this.visitType(type, context2);
      }
      visitMapType(type, context2) {
        return this.visitType(type, context2);
      }
      visitWrappedNodeExpr(ast, context2) {
        return ast;
      }
      visitTypeofExpr(ast, context2) {
        return this.visitExpression(ast, context2);
      }
      visitReadVarExpr(ast, context2) {
        return this.visitExpression(ast, context2);
      }
      visitWriteVarExpr(ast, context2) {
        ast.value.visitExpression(this, context2);
        return this.visitExpression(ast, context2);
      }
      visitWriteKeyExpr(ast, context2) {
        ast.receiver.visitExpression(this, context2);
        ast.index.visitExpression(this, context2);
        ast.value.visitExpression(this, context2);
        return this.visitExpression(ast, context2);
      }
      visitWritePropExpr(ast, context2) {
        ast.receiver.visitExpression(this, context2);
        ast.value.visitExpression(this, context2);
        return this.visitExpression(ast, context2);
      }
      visitInvokeFunctionExpr(ast, context2) {
        ast.fn.visitExpression(this, context2);
        this.visitAllExpressions(ast.args, context2);
        return this.visitExpression(ast, context2);
      }
      visitTaggedTemplateExpr(ast, context2) {
        ast.tag.visitExpression(this, context2);
        this.visitAllExpressions(ast.template.expressions, context2);
        return this.visitExpression(ast, context2);
      }
      visitInstantiateExpr(ast, context2) {
        ast.classExpr.visitExpression(this, context2);
        this.visitAllExpressions(ast.args, context2);
        return this.visitExpression(ast, context2);
      }
      visitLiteralExpr(ast, context2) {
        return this.visitExpression(ast, context2);
      }
      visitLocalizedString(ast, context2) {
        return this.visitExpression(ast, context2);
      }
      visitExternalExpr(ast, context2) {
        if (ast.typeParams) {
          ast.typeParams.forEach((type) => type.visitType(this, context2));
        }
        return this.visitExpression(ast, context2);
      }
      visitConditionalExpr(ast, context2) {
        ast.condition.visitExpression(this, context2);
        ast.trueCase.visitExpression(this, context2);
        ast.falseCase.visitExpression(this, context2);
        return this.visitExpression(ast, context2);
      }
      visitNotExpr(ast, context2) {
        ast.condition.visitExpression(this, context2);
        return this.visitExpression(ast, context2);
      }
      visitFunctionExpr(ast, context2) {
        this.visitAllStatements(ast.statements, context2);
        return this.visitExpression(ast, context2);
      }
      visitUnaryOperatorExpr(ast, context2) {
        ast.expr.visitExpression(this, context2);
        return this.visitExpression(ast, context2);
      }
      visitBinaryOperatorExpr(ast, context2) {
        ast.lhs.visitExpression(this, context2);
        ast.rhs.visitExpression(this, context2);
        return this.visitExpression(ast, context2);
      }
      visitReadPropExpr(ast, context2) {
        ast.receiver.visitExpression(this, context2);
        return this.visitExpression(ast, context2);
      }
      visitReadKeyExpr(ast, context2) {
        ast.receiver.visitExpression(this, context2);
        ast.index.visitExpression(this, context2);
        return this.visitExpression(ast, context2);
      }
      visitLiteralArrayExpr(ast, context2) {
        this.visitAllExpressions(ast.entries, context2);
        return this.visitExpression(ast, context2);
      }
      visitLiteralMapExpr(ast, context2) {
        ast.entries.forEach((entry) => entry.value.visitExpression(this, context2));
        return this.visitExpression(ast, context2);
      }
      visitCommaExpr(ast, context2) {
        this.visitAllExpressions(ast.parts, context2);
        return this.visitExpression(ast, context2);
      }
      visitAllExpressions(exprs, context2) {
        exprs.forEach((expr) => expr.visitExpression(this, context2));
      }
      visitDeclareVarStmt(stmt, context2) {
        if (stmt.value) {
          stmt.value.visitExpression(this, context2);
        }
        if (stmt.type) {
          stmt.type.visitType(this, context2);
        }
        return stmt;
      }
      visitDeclareFunctionStmt(stmt, context2) {
        this.visitAllStatements(stmt.statements, context2);
        if (stmt.type) {
          stmt.type.visitType(this, context2);
        }
        return stmt;
      }
      visitExpressionStmt(stmt, context2) {
        stmt.expr.visitExpression(this, context2);
        return stmt;
      }
      visitReturnStmt(stmt, context2) {
        stmt.value.visitExpression(this, context2);
        return stmt;
      }
      visitIfStmt(stmt, context2) {
        stmt.condition.visitExpression(this, context2);
        this.visitAllStatements(stmt.trueCase, context2);
        this.visitAllStatements(stmt.falseCase, context2);
        return stmt;
      }
      visitAllStatements(stmts, context2) {
        stmts.forEach((stmt) => stmt.visitStatement(this, context2));
      }
    };
    output_ast = Object.freeze({
      __proto__: null,
      get TypeModifier() {
        return TypeModifier;
      },
      Type: Type2,
      get BuiltinTypeName() {
        return BuiltinTypeName;
      },
      BuiltinType,
      ExpressionType,
      ArrayType,
      MapType,
      DYNAMIC_TYPE,
      INFERRED_TYPE,
      BOOL_TYPE,
      INT_TYPE,
      NUMBER_TYPE,
      STRING_TYPE,
      FUNCTION_TYPE,
      NONE_TYPE,
      get UnaryOperator() {
        return UnaryOperator;
      },
      get BinaryOperator() {
        return BinaryOperator;
      },
      nullSafeIsEquivalent,
      areAllEquivalent,
      Expression,
      ReadVarExpr,
      TypeofExpr,
      WrappedNodeExpr,
      WriteVarExpr,
      WriteKeyExpr,
      WritePropExpr,
      InvokeFunctionExpr,
      TaggedTemplateExpr,
      InstantiateExpr,
      LiteralExpr,
      TemplateLiteral,
      TemplateLiteralElement,
      LiteralPiece,
      PlaceholderPiece,
      LocalizedString,
      ExternalExpr,
      ExternalReference,
      ConditionalExpr,
      NotExpr,
      FnParam,
      FunctionExpr,
      UnaryOperatorExpr,
      BinaryOperatorExpr,
      ReadPropExpr,
      ReadKeyExpr,
      LiteralArrayExpr,
      LiteralMapEntry,
      LiteralMapExpr,
      CommaExpr,
      NULL_EXPR,
      TYPED_NULL_EXPR,
      get StmtModifier() {
        return StmtModifier;
      },
      LeadingComment,
      JSDocComment,
      Statement,
      DeclareVarStmt,
      DeclareFunctionStmt,
      ExpressionStatement,
      ReturnStatement,
      IfStmt,
      RecursiveAstVisitor: RecursiveAstVisitor$1,
      leadingComment,
      jsDocComment,
      variable,
      importExpr,
      importType,
      expressionType,
      typeofExpr,
      literalArr,
      literalMap,
      unary,
      not: not2,
      fn,
      ifStmt,
      taggedTemplate,
      literal,
      localizedString,
      isNull
    });
    CONSTANT_PREFIX = "_c";
    UNKNOWN_VALUE_KEY = variable("<unknown>");
    KEY_CONTEXT = {};
    POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;
    FixupExpression = class extends Expression {
      constructor(resolved2) {
        super(resolved2.type);
        this.resolved = resolved2;
        this.original = resolved2;
      }
      visitExpression(visitor, context2) {
        if (context2 === KEY_CONTEXT) {
          return this.original.visitExpression(visitor, context2);
        } else {
          return this.resolved.visitExpression(visitor, context2);
        }
      }
      isEquivalent(e) {
        return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);
      }
      isConstant() {
        return true;
      }
      fixup(expression) {
        this.resolved = expression;
        this.shared = true;
      }
    };
    ConstantPool = class {
      constructor(isClosureCompilerEnabled = false) {
        this.isClosureCompilerEnabled = isClosureCompilerEnabled;
        this.statements = [];
        this.literals = /* @__PURE__ */ new Map();
        this.literalFactories = /* @__PURE__ */ new Map();
        this.nextNameIndex = 0;
      }
      getConstLiteral(literal2, forceShared) {
        if (literal2 instanceof LiteralExpr && !isLongStringLiteral(literal2) || literal2 instanceof FixupExpression) {
          return literal2;
        }
        const key = this.keyOf(literal2);
        let fixup = this.literals.get(key);
        let newValue = false;
        if (!fixup) {
          fixup = new FixupExpression(literal2);
          this.literals.set(key, fixup);
          newValue = true;
        }
        if (!newValue && !fixup.shared || newValue && forceShared) {
          const name = this.freshName();
          let definition;
          let usage;
          if (this.isClosureCompilerEnabled && isLongStringLiteral(literal2)) {
            definition = variable(name).set(new FunctionExpr(
              [],
              [
                new ReturnStatement(literal2)
              ]
            ));
            usage = variable(name).callFn([]);
          } else {
            definition = variable(name).set(literal2);
            usage = variable(name);
          }
          this.statements.push(definition.toDeclStmt(INFERRED_TYPE, StmtModifier.Final));
          fixup.fixup(usage);
        }
        return fixup;
      }
      getLiteralFactory(literal2) {
        if (literal2 instanceof LiteralArrayExpr) {
          const argumentsForKey = literal2.entries.map((e) => e.isConstant() ? e : UNKNOWN_VALUE_KEY);
          const key = this.keyOf(literalArr(argumentsForKey));
          return this._getLiteralFactory(key, literal2.entries, (entries) => literalArr(entries));
        } else {
          const expressionForKey = literalMap(literal2.entries.map((e) => ({
            key: e.key,
            value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,
            quoted: e.quoted
          })));
          const key = this.keyOf(expressionForKey);
          return this._getLiteralFactory(key, literal2.entries.map((e) => e.value), (entries) => literalMap(entries.map((value, index) => ({
            key: literal2.entries[index].key,
            value,
            quoted: literal2.entries[index].quoted
          }))));
        }
      }
      _getLiteralFactory(key, values, resultMap) {
        let literalFactory = this.literalFactories.get(key);
        const literalFactoryArguments = values.filter((e) => !e.isConstant());
        if (!literalFactory) {
          const resultExpressions = values.map((e, index) => e.isConstant() ? this.getConstLiteral(e, true) : variable(`a${index}`));
          const parameters = resultExpressions.filter(isVariable).map((e) => new FnParam(e.name, DYNAMIC_TYPE));
          const pureFunctionDeclaration = fn(parameters, [new ReturnStatement(resultMap(resultExpressions))], INFERRED_TYPE);
          const name = this.freshName();
          this.statements.push(variable(name).set(pureFunctionDeclaration).toDeclStmt(INFERRED_TYPE, StmtModifier.Final));
          literalFactory = variable(name);
          this.literalFactories.set(key, literalFactory);
        }
        return {
          literalFactory,
          literalFactoryArguments
        };
      }
      uniqueName(prefix) {
        return `${prefix}${this.nextNameIndex++}`;
      }
      freshName() {
        return this.uniqueName(CONSTANT_PREFIX);
      }
      keyOf(expression) {
        return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);
      }
    };
    KeyVisitor = class {
      constructor() {
        this.visitWrappedNodeExpr = invalid$1;
        this.visitWriteVarExpr = invalid$1;
        this.visitWriteKeyExpr = invalid$1;
        this.visitWritePropExpr = invalid$1;
        this.visitInvokeFunctionExpr = invalid$1;
        this.visitTaggedTemplateExpr = invalid$1;
        this.visitInstantiateExpr = invalid$1;
        this.visitConditionalExpr = invalid$1;
        this.visitNotExpr = invalid$1;
        this.visitAssertNotNullExpr = invalid$1;
        this.visitCastExpr = invalid$1;
        this.visitFunctionExpr = invalid$1;
        this.visitUnaryOperatorExpr = invalid$1;
        this.visitBinaryOperatorExpr = invalid$1;
        this.visitReadPropExpr = invalid$1;
        this.visitReadKeyExpr = invalid$1;
        this.visitCommaExpr = invalid$1;
        this.visitLocalizedString = invalid$1;
      }
      visitLiteralExpr(ast) {
        return `${typeof ast.value === "string" ? '"' + ast.value + '"' : ast.value}`;
      }
      visitLiteralArrayExpr(ast, context2) {
        return `[${ast.entries.map((entry) => entry.visitExpression(this, context2)).join(",")}]`;
      }
      visitLiteralMapExpr(ast, context2) {
        const mapKey = (entry) => {
          const quote = entry.quoted ? '"' : "";
          return `${quote}${entry.key}${quote}`;
        };
        const mapEntry = (entry) => `${mapKey(entry)}:${entry.value.visitExpression(this, context2)}`;
        return `{${ast.entries.map(mapEntry).join(",")}`;
      }
      visitExternalExpr(ast) {
        return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` : `EX:${ast.value.runtime.name}`;
      }
      visitReadVarExpr(node) {
        return `VAR:${node.name}`;
      }
      visitTypeofExpr(node, context2) {
        return `TYPEOF:${node.expr.visitExpression(this, context2)}`;
      }
    };
    CORE = "@angular/core";
    Identifiers = class {
    };
    Identifiers.NEW_METHOD = "factory";
    Identifiers.TRANSFORM_METHOD = "transform";
    Identifiers.PATCH_DEPS = "patchedDeps";
    Identifiers.core = {
      name: null,
      moduleName: CORE
    };
    Identifiers.namespaceHTML = {
      name: "\u0275\u0275namespaceHTML",
      moduleName: CORE
    };
    Identifiers.namespaceMathML = {
      name: "\u0275\u0275namespaceMathML",
      moduleName: CORE
    };
    Identifiers.namespaceSVG = {
      name: "\u0275\u0275namespaceSVG",
      moduleName: CORE
    };
    Identifiers.element = {
      name: "\u0275\u0275element",
      moduleName: CORE
    };
    Identifiers.elementStart = {
      name: "\u0275\u0275elementStart",
      moduleName: CORE
    };
    Identifiers.elementEnd = {
      name: "\u0275\u0275elementEnd",
      moduleName: CORE
    };
    Identifiers.advance = {
      name: "\u0275\u0275advance",
      moduleName: CORE
    };
    Identifiers.syntheticHostProperty = {
      name: "\u0275\u0275syntheticHostProperty",
      moduleName: CORE
    };
    Identifiers.syntheticHostListener = {
      name: "\u0275\u0275syntheticHostListener",
      moduleName: CORE
    };
    Identifiers.attribute = {
      name: "\u0275\u0275attribute",
      moduleName: CORE
    };
    Identifiers.attributeInterpolate1 = {
      name: "\u0275\u0275attributeInterpolate1",
      moduleName: CORE
    };
    Identifiers.attributeInterpolate2 = {
      name: "\u0275\u0275attributeInterpolate2",
      moduleName: CORE
    };
    Identifiers.attributeInterpolate3 = {
      name: "\u0275\u0275attributeInterpolate3",
      moduleName: CORE
    };
    Identifiers.attributeInterpolate4 = {
      name: "\u0275\u0275attributeInterpolate4",
      moduleName: CORE
    };
    Identifiers.attributeInterpolate5 = {
      name: "\u0275\u0275attributeInterpolate5",
      moduleName: CORE
    };
    Identifiers.attributeInterpolate6 = {
      name: "\u0275\u0275attributeInterpolate6",
      moduleName: CORE
    };
    Identifiers.attributeInterpolate7 = {
      name: "\u0275\u0275attributeInterpolate7",
      moduleName: CORE
    };
    Identifiers.attributeInterpolate8 = {
      name: "\u0275\u0275attributeInterpolate8",
      moduleName: CORE
    };
    Identifiers.attributeInterpolateV = {
      name: "\u0275\u0275attributeInterpolateV",
      moduleName: CORE
    };
    Identifiers.classProp = {
      name: "\u0275\u0275classProp",
      moduleName: CORE
    };
    Identifiers.elementContainerStart = {
      name: "\u0275\u0275elementContainerStart",
      moduleName: CORE
    };
    Identifiers.elementContainerEnd = {
      name: "\u0275\u0275elementContainerEnd",
      moduleName: CORE
    };
    Identifiers.elementContainer = {
      name: "\u0275\u0275elementContainer",
      moduleName: CORE
    };
    Identifiers.styleMap = {
      name: "\u0275\u0275styleMap",
      moduleName: CORE
    };
    Identifiers.styleMapInterpolate1 = {
      name: "\u0275\u0275styleMapInterpolate1",
      moduleName: CORE
    };
    Identifiers.styleMapInterpolate2 = {
      name: "\u0275\u0275styleMapInterpolate2",
      moduleName: CORE
    };
    Identifiers.styleMapInterpolate3 = {
      name: "\u0275\u0275styleMapInterpolate3",
      moduleName: CORE
    };
    Identifiers.styleMapInterpolate4 = {
      name: "\u0275\u0275styleMapInterpolate4",
      moduleName: CORE
    };
    Identifiers.styleMapInterpolate5 = {
      name: "\u0275\u0275styleMapInterpolate5",
      moduleName: CORE
    };
    Identifiers.styleMapInterpolate6 = {
      name: "\u0275\u0275styleMapInterpolate6",
      moduleName: CORE
    };
    Identifiers.styleMapInterpolate7 = {
      name: "\u0275\u0275styleMapInterpolate7",
      moduleName: CORE
    };
    Identifiers.styleMapInterpolate8 = {
      name: "\u0275\u0275styleMapInterpolate8",
      moduleName: CORE
    };
    Identifiers.styleMapInterpolateV = {
      name: "\u0275\u0275styleMapInterpolateV",
      moduleName: CORE
    };
    Identifiers.classMap = {
      name: "\u0275\u0275classMap",
      moduleName: CORE
    };
    Identifiers.classMapInterpolate1 = {
      name: "\u0275\u0275classMapInterpolate1",
      moduleName: CORE
    };
    Identifiers.classMapInterpolate2 = {
      name: "\u0275\u0275classMapInterpolate2",
      moduleName: CORE
    };
    Identifiers.classMapInterpolate3 = {
      name: "\u0275\u0275classMapInterpolate3",
      moduleName: CORE
    };
    Identifiers.classMapInterpolate4 = {
      name: "\u0275\u0275classMapInterpolate4",
      moduleName: CORE
    };
    Identifiers.classMapInterpolate5 = {
      name: "\u0275\u0275classMapInterpolate5",
      moduleName: CORE
    };
    Identifiers.classMapInterpolate6 = {
      name: "\u0275\u0275classMapInterpolate6",
      moduleName: CORE
    };
    Identifiers.classMapInterpolate7 = {
      name: "\u0275\u0275classMapInterpolate7",
      moduleName: CORE
    };
    Identifiers.classMapInterpolate8 = {
      name: "\u0275\u0275classMapInterpolate8",
      moduleName: CORE
    };
    Identifiers.classMapInterpolateV = {
      name: "\u0275\u0275classMapInterpolateV",
      moduleName: CORE
    };
    Identifiers.styleProp = {
      name: "\u0275\u0275styleProp",
      moduleName: CORE
    };
    Identifiers.stylePropInterpolate1 = {
      name: "\u0275\u0275stylePropInterpolate1",
      moduleName: CORE
    };
    Identifiers.stylePropInterpolate2 = {
      name: "\u0275\u0275stylePropInterpolate2",
      moduleName: CORE
    };
    Identifiers.stylePropInterpolate3 = {
      name: "\u0275\u0275stylePropInterpolate3",
      moduleName: CORE
    };
    Identifiers.stylePropInterpolate4 = {
      name: "\u0275\u0275stylePropInterpolate4",
      moduleName: CORE
    };
    Identifiers.stylePropInterpolate5 = {
      name: "\u0275\u0275stylePropInterpolate5",
      moduleName: CORE
    };
    Identifiers.stylePropInterpolate6 = {
      name: "\u0275\u0275stylePropInterpolate6",
      moduleName: CORE
    };
    Identifiers.stylePropInterpolate7 = {
      name: "\u0275\u0275stylePropInterpolate7",
      moduleName: CORE
    };
    Identifiers.stylePropInterpolate8 = {
      name: "\u0275\u0275stylePropInterpolate8",
      moduleName: CORE
    };
    Identifiers.stylePropInterpolateV = {
      name: "\u0275\u0275stylePropInterpolateV",
      moduleName: CORE
    };
    Identifiers.nextContext = {
      name: "\u0275\u0275nextContext",
      moduleName: CORE
    };
    Identifiers.resetView = {
      name: "\u0275\u0275resetView",
      moduleName: CORE
    };
    Identifiers.templateCreate = {
      name: "\u0275\u0275template",
      moduleName: CORE
    };
    Identifiers.text = {
      name: "\u0275\u0275text",
      moduleName: CORE
    };
    Identifiers.enableBindings = {
      name: "\u0275\u0275enableBindings",
      moduleName: CORE
    };
    Identifiers.disableBindings = {
      name: "\u0275\u0275disableBindings",
      moduleName: CORE
    };
    Identifiers.getCurrentView = {
      name: "\u0275\u0275getCurrentView",
      moduleName: CORE
    };
    Identifiers.textInterpolate = {
      name: "\u0275\u0275textInterpolate",
      moduleName: CORE
    };
    Identifiers.textInterpolate1 = {
      name: "\u0275\u0275textInterpolate1",
      moduleName: CORE
    };
    Identifiers.textInterpolate2 = {
      name: "\u0275\u0275textInterpolate2",
      moduleName: CORE
    };
    Identifiers.textInterpolate3 = {
      name: "\u0275\u0275textInterpolate3",
      moduleName: CORE
    };
    Identifiers.textInterpolate4 = {
      name: "\u0275\u0275textInterpolate4",
      moduleName: CORE
    };
    Identifiers.textInterpolate5 = {
      name: "\u0275\u0275textInterpolate5",
      moduleName: CORE
    };
    Identifiers.textInterpolate6 = {
      name: "\u0275\u0275textInterpolate6",
      moduleName: CORE
    };
    Identifiers.textInterpolate7 = {
      name: "\u0275\u0275textInterpolate7",
      moduleName: CORE
    };
    Identifiers.textInterpolate8 = {
      name: "\u0275\u0275textInterpolate8",
      moduleName: CORE
    };
    Identifiers.textInterpolateV = {
      name: "\u0275\u0275textInterpolateV",
      moduleName: CORE
    };
    Identifiers.restoreView = {
      name: "\u0275\u0275restoreView",
      moduleName: CORE
    };
    Identifiers.pureFunction0 = {
      name: "\u0275\u0275pureFunction0",
      moduleName: CORE
    };
    Identifiers.pureFunction1 = {
      name: "\u0275\u0275pureFunction1",
      moduleName: CORE
    };
    Identifiers.pureFunction2 = {
      name: "\u0275\u0275pureFunction2",
      moduleName: CORE
    };
    Identifiers.pureFunction3 = {
      name: "\u0275\u0275pureFunction3",
      moduleName: CORE
    };
    Identifiers.pureFunction4 = {
      name: "\u0275\u0275pureFunction4",
      moduleName: CORE
    };
    Identifiers.pureFunction5 = {
      name: "\u0275\u0275pureFunction5",
      moduleName: CORE
    };
    Identifiers.pureFunction6 = {
      name: "\u0275\u0275pureFunction6",
      moduleName: CORE
    };
    Identifiers.pureFunction7 = {
      name: "\u0275\u0275pureFunction7",
      moduleName: CORE
    };
    Identifiers.pureFunction8 = {
      name: "\u0275\u0275pureFunction8",
      moduleName: CORE
    };
    Identifiers.pureFunctionV = {
      name: "\u0275\u0275pureFunctionV",
      moduleName: CORE
    };
    Identifiers.pipeBind1 = {
      name: "\u0275\u0275pipeBind1",
      moduleName: CORE
    };
    Identifiers.pipeBind2 = {
      name: "\u0275\u0275pipeBind2",
      moduleName: CORE
    };
    Identifiers.pipeBind3 = {
      name: "\u0275\u0275pipeBind3",
      moduleName: CORE
    };
    Identifiers.pipeBind4 = {
      name: "\u0275\u0275pipeBind4",
      moduleName: CORE
    };
    Identifiers.pipeBindV = {
      name: "\u0275\u0275pipeBindV",
      moduleName: CORE
    };
    Identifiers.hostProperty = {
      name: "\u0275\u0275hostProperty",
      moduleName: CORE
    };
    Identifiers.property = {
      name: "\u0275\u0275property",
      moduleName: CORE
    };
    Identifiers.propertyInterpolate = {
      name: "\u0275\u0275propertyInterpolate",
      moduleName: CORE
    };
    Identifiers.propertyInterpolate1 = {
      name: "\u0275\u0275propertyInterpolate1",
      moduleName: CORE
    };
    Identifiers.propertyInterpolate2 = {
      name: "\u0275\u0275propertyInterpolate2",
      moduleName: CORE
    };
    Identifiers.propertyInterpolate3 = {
      name: "\u0275\u0275propertyInterpolate3",
      moduleName: CORE
    };
    Identifiers.propertyInterpolate4 = {
      name: "\u0275\u0275propertyInterpolate4",
      moduleName: CORE
    };
    Identifiers.propertyInterpolate5 = {
      name: "\u0275\u0275propertyInterpolate5",
      moduleName: CORE
    };
    Identifiers.propertyInterpolate6 = {
      name: "\u0275\u0275propertyInterpolate6",
      moduleName: CORE
    };
    Identifiers.propertyInterpolate7 = {
      name: "\u0275\u0275propertyInterpolate7",
      moduleName: CORE
    };
    Identifiers.propertyInterpolate8 = {
      name: "\u0275\u0275propertyInterpolate8",
      moduleName: CORE
    };
    Identifiers.propertyInterpolateV = {
      name: "\u0275\u0275propertyInterpolateV",
      moduleName: CORE
    };
    Identifiers.i18n = {
      name: "\u0275\u0275i18n",
      moduleName: CORE
    };
    Identifiers.i18nAttributes = {
      name: "\u0275\u0275i18nAttributes",
      moduleName: CORE
    };
    Identifiers.i18nExp = {
      name: "\u0275\u0275i18nExp",
      moduleName: CORE
    };
    Identifiers.i18nStart = {
      name: "\u0275\u0275i18nStart",
      moduleName: CORE
    };
    Identifiers.i18nEnd = {
      name: "\u0275\u0275i18nEnd",
      moduleName: CORE
    };
    Identifiers.i18nApply = {
      name: "\u0275\u0275i18nApply",
      moduleName: CORE
    };
    Identifiers.i18nPostprocess = {
      name: "\u0275\u0275i18nPostprocess",
      moduleName: CORE
    };
    Identifiers.pipe = {
      name: "\u0275\u0275pipe",
      moduleName: CORE
    };
    Identifiers.projection = {
      name: "\u0275\u0275projection",
      moduleName: CORE
    };
    Identifiers.projectionDef = {
      name: "\u0275\u0275projectionDef",
      moduleName: CORE
    };
    Identifiers.reference = {
      name: "\u0275\u0275reference",
      moduleName: CORE
    };
    Identifiers.inject = {
      name: "\u0275\u0275inject",
      moduleName: CORE
    };
    Identifiers.injectAttribute = {
      name: "\u0275\u0275injectAttribute",
      moduleName: CORE
    };
    Identifiers.directiveInject = {
      name: "\u0275\u0275directiveInject",
      moduleName: CORE
    };
    Identifiers.invalidFactory = {
      name: "\u0275\u0275invalidFactory",
      moduleName: CORE
    };
    Identifiers.invalidFactoryDep = {
      name: "\u0275\u0275invalidFactoryDep",
      moduleName: CORE
    };
    Identifiers.templateRefExtractor = {
      name: "\u0275\u0275templateRefExtractor",
      moduleName: CORE
    };
    Identifiers.forwardRef = {
      name: "forwardRef",
      moduleName: CORE
    };
    Identifiers.resolveForwardRef = {
      name: "resolveForwardRef",
      moduleName: CORE
    };
    Identifiers.\u0275\u0275defineInjectable = {
      name: "\u0275\u0275defineInjectable",
      moduleName: CORE
    };
    Identifiers.declareInjectable = {
      name: "\u0275\u0275ngDeclareInjectable",
      moduleName: CORE
    };
    Identifiers.InjectableDeclaration = {
      name: "\u0275\u0275InjectableDeclaration",
      moduleName: CORE
    };
    Identifiers.resolveWindow = {
      name: "\u0275\u0275resolveWindow",
      moduleName: CORE
    };
    Identifiers.resolveDocument = {
      name: "\u0275\u0275resolveDocument",
      moduleName: CORE
    };
    Identifiers.resolveBody = {
      name: "\u0275\u0275resolveBody",
      moduleName: CORE
    };
    Identifiers.defineComponent = {
      name: "\u0275\u0275defineComponent",
      moduleName: CORE
    };
    Identifiers.declareComponent = {
      name: "\u0275\u0275ngDeclareComponent",
      moduleName: CORE
    };
    Identifiers.setComponentScope = {
      name: "\u0275\u0275setComponentScope",
      moduleName: CORE
    };
    Identifiers.ChangeDetectionStrategy = {
      name: "ChangeDetectionStrategy",
      moduleName: CORE
    };
    Identifiers.ViewEncapsulation = {
      name: "ViewEncapsulation",
      moduleName: CORE
    };
    Identifiers.ComponentDeclaration = {
      name: "\u0275\u0275ComponentDeclaration",
      moduleName: CORE
    };
    Identifiers.FactoryDeclaration = {
      name: "\u0275\u0275FactoryDeclaration",
      moduleName: CORE
    };
    Identifiers.declareFactory = {
      name: "\u0275\u0275ngDeclareFactory",
      moduleName: CORE
    };
    Identifiers.FactoryTarget = {
      name: "\u0275\u0275FactoryTarget",
      moduleName: CORE
    };
    Identifiers.defineDirective = {
      name: "\u0275\u0275defineDirective",
      moduleName: CORE
    };
    Identifiers.declareDirective = {
      name: "\u0275\u0275ngDeclareDirective",
      moduleName: CORE
    };
    Identifiers.DirectiveDeclaration = {
      name: "\u0275\u0275DirectiveDeclaration",
      moduleName: CORE
    };
    Identifiers.InjectorDef = {
      name: "\u0275\u0275InjectorDef",
      moduleName: CORE
    };
    Identifiers.InjectorDeclaration = {
      name: "\u0275\u0275InjectorDeclaration",
      moduleName: CORE
    };
    Identifiers.defineInjector = {
      name: "\u0275\u0275defineInjector",
      moduleName: CORE
    };
    Identifiers.declareInjector = {
      name: "\u0275\u0275ngDeclareInjector",
      moduleName: CORE
    };
    Identifiers.NgModuleDeclaration = {
      name: "\u0275\u0275NgModuleDeclaration",
      moduleName: CORE
    };
    Identifiers.ModuleWithProviders = {
      name: "ModuleWithProviders",
      moduleName: CORE
    };
    Identifiers.defineNgModule = {
      name: "\u0275\u0275defineNgModule",
      moduleName: CORE
    };
    Identifiers.declareNgModule = {
      name: "\u0275\u0275ngDeclareNgModule",
      moduleName: CORE
    };
    Identifiers.setNgModuleScope = {
      name: "\u0275\u0275setNgModuleScope",
      moduleName: CORE
    };
    Identifiers.registerNgModuleType = {
      name: "\u0275\u0275registerNgModuleType",
      moduleName: CORE
    };
    Identifiers.PipeDeclaration = {
      name: "\u0275\u0275PipeDeclaration",
      moduleName: CORE
    };
    Identifiers.definePipe = {
      name: "\u0275\u0275definePipe",
      moduleName: CORE
    };
    Identifiers.declarePipe = {
      name: "\u0275\u0275ngDeclarePipe",
      moduleName: CORE
    };
    Identifiers.declareClassMetadata = {
      name: "\u0275\u0275ngDeclareClassMetadata",
      moduleName: CORE
    };
    Identifiers.setClassMetadata = {
      name: "\u0275setClassMetadata",
      moduleName: CORE
    };
    Identifiers.queryRefresh = {
      name: "\u0275\u0275queryRefresh",
      moduleName: CORE
    };
    Identifiers.viewQuery = {
      name: "\u0275\u0275viewQuery",
      moduleName: CORE
    };
    Identifiers.loadQuery = {
      name: "\u0275\u0275loadQuery",
      moduleName: CORE
    };
    Identifiers.contentQuery = {
      name: "\u0275\u0275contentQuery",
      moduleName: CORE
    };
    Identifiers.NgOnChangesFeature = {
      name: "\u0275\u0275NgOnChangesFeature",
      moduleName: CORE
    };
    Identifiers.InheritDefinitionFeature = {
      name: "\u0275\u0275InheritDefinitionFeature",
      moduleName: CORE
    };
    Identifiers.CopyDefinitionFeature = {
      name: "\u0275\u0275CopyDefinitionFeature",
      moduleName: CORE
    };
    Identifiers.StandaloneFeature = {
      name: "\u0275\u0275StandaloneFeature",
      moduleName: CORE
    };
    Identifiers.ProvidersFeature = {
      name: "\u0275\u0275ProvidersFeature",
      moduleName: CORE
    };
    Identifiers.listener = {
      name: "\u0275\u0275listener",
      moduleName: CORE
    };
    Identifiers.getInheritedFactory = {
      name: "\u0275\u0275getInheritedFactory",
      moduleName: CORE
    };
    Identifiers.sanitizeHtml = {
      name: "\u0275\u0275sanitizeHtml",
      moduleName: CORE
    };
    Identifiers.sanitizeStyle = {
      name: "\u0275\u0275sanitizeStyle",
      moduleName: CORE
    };
    Identifiers.sanitizeResourceUrl = {
      name: "\u0275\u0275sanitizeResourceUrl",
      moduleName: CORE
    };
    Identifiers.sanitizeScript = {
      name: "\u0275\u0275sanitizeScript",
      moduleName: CORE
    };
    Identifiers.sanitizeUrl = {
      name: "\u0275\u0275sanitizeUrl",
      moduleName: CORE
    };
    Identifiers.sanitizeUrlOrResourceUrl = {
      name: "\u0275\u0275sanitizeUrlOrResourceUrl",
      moduleName: CORE
    };
    Identifiers.trustConstantHtml = {
      name: "\u0275\u0275trustConstantHtml",
      moduleName: CORE
    };
    Identifiers.trustConstantResourceUrl = {
      name: "\u0275\u0275trustConstantResourceUrl",
      moduleName: CORE
    };
    VERSION$1 = 3;
    JS_B64_PREFIX = "# sourceMappingURL=data:application/json;base64,";
    SourceMapGenerator = class {
      constructor(file = null) {
        this.file = file;
        this.sourcesContent = /* @__PURE__ */ new Map();
        this.lines = [];
        this.lastCol0 = 0;
        this.hasMappings = false;
      }
      addSource(url, content = null) {
        if (!this.sourcesContent.has(url)) {
          this.sourcesContent.set(url, content);
        }
        return this;
      }
      addLine() {
        this.lines.push([]);
        this.lastCol0 = 0;
        return this;
      }
      addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {
        if (!this.currentLine) {
          throw new Error(`A line must be added before mappings can be added`);
        }
        if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {
          throw new Error(`Unknown source file "${sourceUrl}"`);
        }
        if (col0 == null) {
          throw new Error(`The column in the generated code must be provided`);
        }
        if (col0 < this.lastCol0) {
          throw new Error(`Mapping should be added in output order`);
        }
        if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {
          throw new Error(`The source location must be provided when a source url is provided`);
        }
        this.hasMappings = true;
        this.lastCol0 = col0;
        this.currentLine.push({
          col0,
          sourceUrl,
          sourceLine0,
          sourceCol0
        });
        return this;
      }
      get currentLine() {
        return this.lines.slice(-1)[0];
      }
      toJSON() {
        if (!this.hasMappings) {
          return null;
        }
        const sourcesIndex = /* @__PURE__ */ new Map();
        const sources = [];
        const sourcesContent = [];
        Array.from(this.sourcesContent.keys()).forEach((url, i) => {
          sourcesIndex.set(url, i);
          sources.push(url);
          sourcesContent.push(this.sourcesContent.get(url) || null);
        });
        let mappings = "";
        let lastCol0 = 0;
        let lastSourceIndex = 0;
        let lastSourceLine0 = 0;
        let lastSourceCol0 = 0;
        this.lines.forEach((segments) => {
          lastCol0 = 0;
          mappings += segments.map((segment) => {
            let segAsStr = toBase64VLQ(segment.col0 - lastCol0);
            lastCol0 = segment.col0;
            if (segment.sourceUrl != null) {
              segAsStr += toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);
              lastSourceIndex = sourcesIndex.get(segment.sourceUrl);
              segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);
              lastSourceLine0 = segment.sourceLine0;
              segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);
              lastSourceCol0 = segment.sourceCol0;
            }
            return segAsStr;
          }).join(",");
          mappings += ";";
        });
        mappings = mappings.slice(0, -1);
        return {
          "file": this.file || "",
          "version": VERSION$1,
          "sourceRoot": "",
          "sources": sources,
          "sourcesContent": sourcesContent,
          "mappings": mappings
        };
      }
      toJsComment() {
        return this.hasMappings ? "//" + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) : "";
      }
    };
    B64_DIGITS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\r|\$/g;
    _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;
    _INDENT_WITH = "  ";
    _EmittedLine = class {
      constructor(indent) {
        this.indent = indent;
        this.partsLength = 0;
        this.parts = [];
        this.srcSpans = [];
      }
    };
    EmitterVisitorContext = class {
      constructor(_indent) {
        this._indent = _indent;
        this._lines = [new _EmittedLine(_indent)];
      }
      static createRoot() {
        return new EmitterVisitorContext(0);
      }
      get _currentLine() {
        return this._lines[this._lines.length - 1];
      }
      println(from2, lastPart = "") {
        this.print(from2 || null, lastPart, true);
      }
      lineIsEmpty() {
        return this._currentLine.parts.length === 0;
      }
      lineLength() {
        return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;
      }
      print(from2, part, newLine = false) {
        if (part.length > 0) {
          this._currentLine.parts.push(part);
          this._currentLine.partsLength += part.length;
          this._currentLine.srcSpans.push(from2 && from2.sourceSpan || null);
        }
        if (newLine) {
          this._lines.push(new _EmittedLine(this._indent));
        }
      }
      removeEmptyLastLine() {
        if (this.lineIsEmpty()) {
          this._lines.pop();
        }
      }
      incIndent() {
        this._indent++;
        if (this.lineIsEmpty()) {
          this._currentLine.indent = this._indent;
        }
      }
      decIndent() {
        this._indent--;
        if (this.lineIsEmpty()) {
          this._currentLine.indent = this._indent;
        }
      }
      toSource() {
        return this.sourceLines.map((l) => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join("") : "").join("\n");
      }
      toSourceMapGenerator(genFilePath, startsAtLine = 0) {
        const map2 = new SourceMapGenerator(genFilePath);
        let firstOffsetMapped = false;
        const mapFirstOffsetIfNeeded = () => {
          if (!firstOffsetMapped) {
            map2.addSource(genFilePath, " ").addMapping(0, genFilePath, 0, 0);
            firstOffsetMapped = true;
          }
        };
        for (let i = 0; i < startsAtLine; i++) {
          map2.addLine();
          mapFirstOffsetIfNeeded();
        }
        this.sourceLines.forEach((line, lineIdx) => {
          map2.addLine();
          const spans = line.srcSpans;
          const parts = line.parts;
          let col0 = line.indent * _INDENT_WITH.length;
          let spanIdx = 0;
          while (spanIdx < spans.length && !spans[spanIdx]) {
            col0 += parts[spanIdx].length;
            spanIdx++;
          }
          if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {
            firstOffsetMapped = true;
          } else {
            mapFirstOffsetIfNeeded();
          }
          while (spanIdx < spans.length) {
            const span = spans[spanIdx];
            const source = span.start.file;
            const sourceLine = span.start.line;
            const sourceCol = span.start.col;
            map2.addSource(source.url, source.content).addMapping(col0, source.url, sourceLine, sourceCol);
            col0 += parts[spanIdx].length;
            spanIdx++;
            while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {
              col0 += parts[spanIdx].length;
              spanIdx++;
            }
          }
        });
        return map2;
      }
      spanOf(line, column) {
        const emittedLine = this._lines[line];
        if (emittedLine) {
          let columnsLeft = column - _createIndent(emittedLine.indent).length;
          for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {
            const part = emittedLine.parts[partIndex];
            if (part.length > columnsLeft) {
              return emittedLine.srcSpans[partIndex];
            }
            columnsLeft -= part.length;
          }
        }
        return null;
      }
      get sourceLines() {
        if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {
          return this._lines.slice(0, -1);
        }
        return this._lines;
      }
    };
    AbstractEmitterVisitor = class {
      constructor(_escapeDollarInStrings) {
        this._escapeDollarInStrings = _escapeDollarInStrings;
      }
      printLeadingComments(stmt, ctx) {
        if (stmt.leadingComments === void 0) {
          return;
        }
        for (const comment of stmt.leadingComments) {
          if (comment instanceof JSDocComment) {
            ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);
          } else {
            if (comment.multiline) {
              ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);
            } else {
              comment.text.split("\n").forEach((line) => {
                ctx.println(stmt, `// ${line}`);
              });
            }
          }
        }
      }
      visitExpressionStmt(stmt, ctx) {
        this.printLeadingComments(stmt, ctx);
        stmt.expr.visitExpression(this, ctx);
        ctx.println(stmt, ";");
        return null;
      }
      visitReturnStmt(stmt, ctx) {
        this.printLeadingComments(stmt, ctx);
        ctx.print(stmt, `return `);
        stmt.value.visitExpression(this, ctx);
        ctx.println(stmt, ";");
        return null;
      }
      visitIfStmt(stmt, ctx) {
        this.printLeadingComments(stmt, ctx);
        ctx.print(stmt, `if (`);
        stmt.condition.visitExpression(this, ctx);
        ctx.print(stmt, `) {`);
        const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;
        if (stmt.trueCase.length <= 1 && !hasElseCase) {
          ctx.print(stmt, ` `);
          this.visitAllStatements(stmt.trueCase, ctx);
          ctx.removeEmptyLastLine();
          ctx.print(stmt, ` `);
        } else {
          ctx.println();
          ctx.incIndent();
          this.visitAllStatements(stmt.trueCase, ctx);
          ctx.decIndent();
          if (hasElseCase) {
            ctx.println(stmt, `} else {`);
            ctx.incIndent();
            this.visitAllStatements(stmt.falseCase, ctx);
            ctx.decIndent();
          }
        }
        ctx.println(stmt, `}`);
        return null;
      }
      visitWriteVarExpr(expr, ctx) {
        const lineWasEmpty = ctx.lineIsEmpty();
        if (!lineWasEmpty) {
          ctx.print(expr, "(");
        }
        ctx.print(expr, `${expr.name} = `);
        expr.value.visitExpression(this, ctx);
        if (!lineWasEmpty) {
          ctx.print(expr, ")");
        }
        return null;
      }
      visitWriteKeyExpr(expr, ctx) {
        const lineWasEmpty = ctx.lineIsEmpty();
        if (!lineWasEmpty) {
          ctx.print(expr, "(");
        }
        expr.receiver.visitExpression(this, ctx);
        ctx.print(expr, `[`);
        expr.index.visitExpression(this, ctx);
        ctx.print(expr, `] = `);
        expr.value.visitExpression(this, ctx);
        if (!lineWasEmpty) {
          ctx.print(expr, ")");
        }
        return null;
      }
      visitWritePropExpr(expr, ctx) {
        const lineWasEmpty = ctx.lineIsEmpty();
        if (!lineWasEmpty) {
          ctx.print(expr, "(");
        }
        expr.receiver.visitExpression(this, ctx);
        ctx.print(expr, `.${expr.name} = `);
        expr.value.visitExpression(this, ctx);
        if (!lineWasEmpty) {
          ctx.print(expr, ")");
        }
        return null;
      }
      visitInvokeFunctionExpr(expr, ctx) {
        expr.fn.visitExpression(this, ctx);
        ctx.print(expr, `(`);
        this.visitAllExpressions(expr.args, ctx, ",");
        ctx.print(expr, `)`);
        return null;
      }
      visitTaggedTemplateExpr(expr, ctx) {
        expr.tag.visitExpression(this, ctx);
        ctx.print(expr, "`" + expr.template.elements[0].rawText);
        for (let i = 1; i < expr.template.elements.length; i++) {
          ctx.print(expr, "${");
          expr.template.expressions[i - 1].visitExpression(this, ctx);
          ctx.print(expr, `}${expr.template.elements[i].rawText}`);
        }
        ctx.print(expr, "`");
        return null;
      }
      visitWrappedNodeExpr(ast, ctx) {
        throw new Error("Abstract emitter cannot visit WrappedNodeExpr.");
      }
      visitTypeofExpr(expr, ctx) {
        ctx.print(expr, "typeof ");
        expr.expr.visitExpression(this, ctx);
      }
      visitReadVarExpr(ast, ctx) {
        ctx.print(ast, ast.name);
        return null;
      }
      visitInstantiateExpr(ast, ctx) {
        ctx.print(ast, `new `);
        ast.classExpr.visitExpression(this, ctx);
        ctx.print(ast, `(`);
        this.visitAllExpressions(ast.args, ctx, ",");
        ctx.print(ast, `)`);
        return null;
      }
      visitLiteralExpr(ast, ctx) {
        const value = ast.value;
        if (typeof value === "string") {
          ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));
        } else {
          ctx.print(ast, `${value}`);
        }
        return null;
      }
      visitLocalizedString(ast, ctx) {
        const head = ast.serializeI18nHead();
        ctx.print(ast, "$localize `" + head.raw);
        for (let i = 1; i < ast.messageParts.length; i++) {
          ctx.print(ast, "${");
          ast.expressions[i - 1].visitExpression(this, ctx);
          ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);
        }
        ctx.print(ast, "`");
        return null;
      }
      visitConditionalExpr(ast, ctx) {
        ctx.print(ast, `(`);
        ast.condition.visitExpression(this, ctx);
        ctx.print(ast, "? ");
        ast.trueCase.visitExpression(this, ctx);
        ctx.print(ast, ": ");
        ast.falseCase.visitExpression(this, ctx);
        ctx.print(ast, `)`);
        return null;
      }
      visitNotExpr(ast, ctx) {
        ctx.print(ast, "!");
        ast.condition.visitExpression(this, ctx);
        return null;
      }
      visitUnaryOperatorExpr(ast, ctx) {
        let opStr;
        switch (ast.operator) {
          case UnaryOperator.Plus:
            opStr = "+";
            break;
          case UnaryOperator.Minus:
            opStr = "-";
            break;
          default:
            throw new Error(`Unknown operator ${ast.operator}`);
        }
        if (ast.parens)
          ctx.print(ast, `(`);
        ctx.print(ast, opStr);
        ast.expr.visitExpression(this, ctx);
        if (ast.parens)
          ctx.print(ast, `)`);
        return null;
      }
      visitBinaryOperatorExpr(ast, ctx) {
        let opStr;
        switch (ast.operator) {
          case BinaryOperator.Equals:
            opStr = "==";
            break;
          case BinaryOperator.Identical:
            opStr = "===";
            break;
          case BinaryOperator.NotEquals:
            opStr = "!=";
            break;
          case BinaryOperator.NotIdentical:
            opStr = "!==";
            break;
          case BinaryOperator.And:
            opStr = "&&";
            break;
          case BinaryOperator.BitwiseAnd:
            opStr = "&";
            break;
          case BinaryOperator.Or:
            opStr = "||";
            break;
          case BinaryOperator.Plus:
            opStr = "+";
            break;
          case BinaryOperator.Minus:
            opStr = "-";
            break;
          case BinaryOperator.Divide:
            opStr = "/";
            break;
          case BinaryOperator.Multiply:
            opStr = "*";
            break;
          case BinaryOperator.Modulo:
            opStr = "%";
            break;
          case BinaryOperator.Lower:
            opStr = "<";
            break;
          case BinaryOperator.LowerEquals:
            opStr = "<=";
            break;
          case BinaryOperator.Bigger:
            opStr = ">";
            break;
          case BinaryOperator.BiggerEquals:
            opStr = ">=";
            break;
          case BinaryOperator.NullishCoalesce:
            opStr = "??";
            break;
          default:
            throw new Error(`Unknown operator ${ast.operator}`);
        }
        if (ast.parens)
          ctx.print(ast, `(`);
        ast.lhs.visitExpression(this, ctx);
        ctx.print(ast, ` ${opStr} `);
        ast.rhs.visitExpression(this, ctx);
        if (ast.parens)
          ctx.print(ast, `)`);
        return null;
      }
      visitReadPropExpr(ast, ctx) {
        ast.receiver.visitExpression(this, ctx);
        ctx.print(ast, `.`);
        ctx.print(ast, ast.name);
        return null;
      }
      visitReadKeyExpr(ast, ctx) {
        ast.receiver.visitExpression(this, ctx);
        ctx.print(ast, `[`);
        ast.index.visitExpression(this, ctx);
        ctx.print(ast, `]`);
        return null;
      }
      visitLiteralArrayExpr(ast, ctx) {
        ctx.print(ast, `[`);
        this.visitAllExpressions(ast.entries, ctx, ",");
        ctx.print(ast, `]`);
        return null;
      }
      visitLiteralMapExpr(ast, ctx) {
        ctx.print(ast, `{`);
        this.visitAllObjects((entry) => {
          ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);
          entry.value.visitExpression(this, ctx);
        }, ast.entries, ctx, ",");
        ctx.print(ast, `}`);
        return null;
      }
      visitCommaExpr(ast, ctx) {
        ctx.print(ast, "(");
        this.visitAllExpressions(ast.parts, ctx, ",");
        ctx.print(ast, ")");
        return null;
      }
      visitAllExpressions(expressions, ctx, separator) {
        this.visitAllObjects((expr) => expr.visitExpression(this, ctx), expressions, ctx, separator);
      }
      visitAllObjects(handler, expressions, ctx, separator) {
        let incrementedIndent = false;
        for (let i = 0; i < expressions.length; i++) {
          if (i > 0) {
            if (ctx.lineLength() > 80) {
              ctx.print(null, separator, true);
              if (!incrementedIndent) {
                ctx.incIndent();
                ctx.incIndent();
                incrementedIndent = true;
              }
            } else {
              ctx.print(null, separator, false);
            }
          }
          handler(expressions[i]);
        }
        if (incrementedIndent) {
          ctx.decIndent();
          ctx.decIndent();
        }
      }
      visitAllStatements(statements, ctx) {
        statements.forEach((stmt) => stmt.visitStatement(this, ctx));
      }
    };
    ANIMATE_SYMBOL_PREFIX = "@";
    (function(R3FactoryDelegateType2) {
      R3FactoryDelegateType2[R3FactoryDelegateType2["Class"] = 0] = "Class";
      R3FactoryDelegateType2[R3FactoryDelegateType2["Function"] = 1] = "Function";
    })(R3FactoryDelegateType || (R3FactoryDelegateType = {}));
    (function(FactoryTarget3) {
      FactoryTarget3[FactoryTarget3["Directive"] = 0] = "Directive";
      FactoryTarget3[FactoryTarget3["Component"] = 1] = "Component";
      FactoryTarget3[FactoryTarget3["Injectable"] = 2] = "Injectable";
      FactoryTarget3[FactoryTarget3["Pipe"] = 3] = "Pipe";
      FactoryTarget3[FactoryTarget3["NgModule"] = 4] = "NgModule";
    })(FactoryTarget$1 || (FactoryTarget$1 = {}));
    Comment$1 = class {
      constructor(value, sourceSpan) {
        this.value = value;
        this.sourceSpan = sourceSpan;
      }
      visit(_visitor2) {
        throw new Error("visit() not implemented for Comment");
      }
    };
    Text$3 = class {
      constructor(value, sourceSpan) {
        this.value = value;
        this.sourceSpan = sourceSpan;
      }
      visit(visitor) {
        return visitor.visitText(this);
      }
    };
    BoundText = class {
      constructor(value, sourceSpan, i18n) {
        this.value = value;
        this.sourceSpan = sourceSpan;
        this.i18n = i18n;
      }
      visit(visitor) {
        return visitor.visitBoundText(this);
      }
    };
    TextAttribute = class {
      constructor(name, value, sourceSpan, keySpan, valueSpan, i18n) {
        this.name = name;
        this.value = value;
        this.sourceSpan = sourceSpan;
        this.keySpan = keySpan;
        this.valueSpan = valueSpan;
        this.i18n = i18n;
      }
      visit(visitor) {
        return visitor.visitTextAttribute(this);
      }
    };
    BoundAttribute = class {
      constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan, i18n) {
        this.name = name;
        this.type = type;
        this.securityContext = securityContext;
        this.value = value;
        this.unit = unit;
        this.sourceSpan = sourceSpan;
        this.keySpan = keySpan;
        this.valueSpan = valueSpan;
        this.i18n = i18n;
      }
      static fromBoundElementProperty(prop, i18n) {
        if (prop.keySpan === void 0) {
          throw new Error(`Unexpected state: keySpan must be defined for bound attributes but was not for ${prop.name}: ${prop.sourceSpan}`);
        }
        return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n);
      }
      visit(visitor) {
        return visitor.visitBoundAttribute(this);
      }
    };
    BoundEvent = class {
      constructor(name, type, handler, target, phase, sourceSpan, handlerSpan, keySpan) {
        this.name = name;
        this.type = type;
        this.handler = handler;
        this.target = target;
        this.phase = phase;
        this.sourceSpan = sourceSpan;
        this.handlerSpan = handlerSpan;
        this.keySpan = keySpan;
      }
      static fromParsedEvent(event) {
        const target = event.type === 0 ? event.targetOrPhase : null;
        const phase = event.type === 1 ? event.targetOrPhase : null;
        if (event.keySpan === void 0) {
          throw new Error(`Unexpected state: keySpan must be defined for bound event but was not for ${event.name}: ${event.sourceSpan}`);
        }
        return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan, event.keySpan);
      }
      visit(visitor) {
        return visitor.visitBoundEvent(this);
      }
    };
    Element$1 = class {
      constructor(name, attributes, inputs, outputs, children, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {
        this.name = name;
        this.attributes = attributes;
        this.inputs = inputs;
        this.outputs = outputs;
        this.children = children;
        this.references = references;
        this.sourceSpan = sourceSpan;
        this.startSourceSpan = startSourceSpan;
        this.endSourceSpan = endSourceSpan;
        this.i18n = i18n;
      }
      visit(visitor) {
        return visitor.visitElement(this);
      }
    };
    Template = class {
      constructor(tagName, attributes, inputs, outputs, templateAttrs, children, references, variables, sourceSpan, startSourceSpan, endSourceSpan, i18n) {
        this.tagName = tagName;
        this.attributes = attributes;
        this.inputs = inputs;
        this.outputs = outputs;
        this.templateAttrs = templateAttrs;
        this.children = children;
        this.references = references;
        this.variables = variables;
        this.sourceSpan = sourceSpan;
        this.startSourceSpan = startSourceSpan;
        this.endSourceSpan = endSourceSpan;
        this.i18n = i18n;
      }
      visit(visitor) {
        return visitor.visitTemplate(this);
      }
    };
    Content = class {
      constructor(selector, attributes, sourceSpan, i18n) {
        this.selector = selector;
        this.attributes = attributes;
        this.sourceSpan = sourceSpan;
        this.i18n = i18n;
        this.name = "ng-content";
      }
      visit(visitor) {
        return visitor.visitContent(this);
      }
    };
    Variable = class {
      constructor(name, value, sourceSpan, keySpan, valueSpan) {
        this.name = name;
        this.value = value;
        this.sourceSpan = sourceSpan;
        this.keySpan = keySpan;
        this.valueSpan = valueSpan;
      }
      visit(visitor) {
        return visitor.visitVariable(this);
      }
    };
    Reference = class {
      constructor(name, value, sourceSpan, keySpan, valueSpan) {
        this.name = name;
        this.value = value;
        this.sourceSpan = sourceSpan;
        this.keySpan = keySpan;
        this.valueSpan = valueSpan;
      }
      visit(visitor) {
        return visitor.visitReference(this);
      }
    };
    Icu$1 = class {
      constructor(vars, placeholders, sourceSpan, i18n) {
        this.vars = vars;
        this.placeholders = placeholders;
        this.sourceSpan = sourceSpan;
        this.i18n = i18n;
      }
      visit(visitor) {
        return visitor.visitIcu(this);
      }
    };
    Message = class {
      constructor(nodes, placeholders, placeholderToMessage, meaning, description, customId) {
        this.nodes = nodes;
        this.placeholders = placeholders;
        this.placeholderToMessage = placeholderToMessage;
        this.meaning = meaning;
        this.description = description;
        this.customId = customId;
        this.id = this.customId;
        this.legacyIds = [];
        this.messageString = serializeMessage(this.nodes);
        if (nodes.length) {
          this.sources = [{
            filePath: nodes[0].sourceSpan.start.file.url,
            startLine: nodes[0].sourceSpan.start.line + 1,
            startCol: nodes[0].sourceSpan.start.col + 1,
            endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,
            endCol: nodes[0].sourceSpan.start.col + 1
          }];
        } else {
          this.sources = [];
        }
      }
    };
    Text$2 = class {
      constructor(value, sourceSpan) {
        this.value = value;
        this.sourceSpan = sourceSpan;
      }
      visit(visitor, context2) {
        return visitor.visitText(this, context2);
      }
    };
    Container = class {
      constructor(children, sourceSpan) {
        this.children = children;
        this.sourceSpan = sourceSpan;
      }
      visit(visitor, context2) {
        return visitor.visitContainer(this, context2);
      }
    };
    Icu = class {
      constructor(expression, type, cases, sourceSpan) {
        this.expression = expression;
        this.type = type;
        this.cases = cases;
        this.sourceSpan = sourceSpan;
      }
      visit(visitor, context2) {
        return visitor.visitIcu(this, context2);
      }
    };
    TagPlaceholder = class {
      constructor(tag, attrs, startName, closeName, children, isVoid, sourceSpan, startSourceSpan, endSourceSpan) {
        this.tag = tag;
        this.attrs = attrs;
        this.startName = startName;
        this.closeName = closeName;
        this.children = children;
        this.isVoid = isVoid;
        this.sourceSpan = sourceSpan;
        this.startSourceSpan = startSourceSpan;
        this.endSourceSpan = endSourceSpan;
      }
      visit(visitor, context2) {
        return visitor.visitTagPlaceholder(this, context2);
      }
    };
    Placeholder = class {
      constructor(value, name, sourceSpan) {
        this.value = value;
        this.name = name;
        this.sourceSpan = sourceSpan;
      }
      visit(visitor, context2) {
        return visitor.visitPlaceholder(this, context2);
      }
    };
    IcuPlaceholder = class {
      constructor(value, name, sourceSpan) {
        this.value = value;
        this.name = name;
        this.sourceSpan = sourceSpan;
      }
      visit(visitor, context2) {
        return visitor.visitIcuPlaceholder(this, context2);
      }
    };
    LocalizeMessageStringVisitor = class {
      visitText(text) {
        return text.value;
      }
      visitContainer(container) {
        return container.children.map((child) => child.visit(this)).join("");
      }
      visitIcu(icu) {
        const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
        return `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(" ")}}`;
      }
      visitTagPlaceholder(ph) {
        const children = ph.children.map((child) => child.visit(this)).join("");
        return `{$${ph.startName}}${children}{$${ph.closeName}}`;
      }
      visitPlaceholder(ph) {
        return `{$${ph.name}}`;
      }
      visitIcuPlaceholder(ph) {
        return `{$${ph.name}}`;
      }
    };
    _Visitor$2 = class {
      visitTag(tag) {
        const strAttrs = this._serializeAttributes(tag.attrs);
        if (tag.children.length == 0) {
          return `<${tag.name}${strAttrs}/>`;
        }
        const strChildren = tag.children.map((node) => node.visit(this));
        return `<${tag.name}${strAttrs}>${strChildren.join("")}</${tag.name}>`;
      }
      visitText(text) {
        return text.value;
      }
      visitDeclaration(decl) {
        return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;
      }
      _serializeAttributes(attrs) {
        const strAttrs = Object.keys(attrs).map((name) => `${name}="${attrs[name]}"`).join(" ");
        return strAttrs.length > 0 ? " " + strAttrs : "";
      }
      visitDoctype(doctype) {
        return `<!DOCTYPE ${doctype.rootTag} [
${doctype.dtd}
]>`;
      }
    };
    _visitor = new _Visitor$2();
    CLOSURE_TRANSLATION_VAR_PREFIX = "MSG_";
    TRANSLATION_VAR_PREFIX = "i18n_";
    I18N_ATTR = "i18n";
    I18N_ATTR_PREFIX = "i18n-";
    I18N_ICU_VAR_PREFIX = "VAR_";
    I18N_ICU_MAPPING_PREFIX = "I18N_EXP_";
    I18N_PLACEHOLDER_SYMBOL = "\uFFFD";
    UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;
    TEMPORARY_NAME = "_t";
    CONTEXT_NAME = "ctx";
    RENDER_FLAGS = "rf";
    REFERENCE_PREFIX = "_r";
    IMPLICIT_REFERENCE = "$implicit";
    NON_BINDABLE_ATTR = "ngNonBindable";
    RESTORED_VIEW_CONTEXT_NAME = "restoredCtx";
    MAX_CHAIN_LENGTH = 500;
    CHAINABLE_INSTRUCTIONS = /* @__PURE__ */ new Set([Identifiers.element, Identifiers.elementStart, Identifiers.elementEnd, Identifiers.elementContainer, Identifiers.elementContainerStart, Identifiers.elementContainerEnd, Identifiers.i18nExp, Identifiers.listener, Identifiers.classProp, Identifiers.syntheticHostListener, Identifiers.hostProperty, Identifiers.syntheticHostProperty, Identifiers.property, Identifiers.propertyInterpolate1, Identifiers.propertyInterpolate2, Identifiers.propertyInterpolate3, Identifiers.propertyInterpolate4, Identifiers.propertyInterpolate5, Identifiers.propertyInterpolate6, Identifiers.propertyInterpolate7, Identifiers.propertyInterpolate8, Identifiers.propertyInterpolateV, Identifiers.attribute, Identifiers.attributeInterpolate1, Identifiers.attributeInterpolate2, Identifiers.attributeInterpolate3, Identifiers.attributeInterpolate4, Identifiers.attributeInterpolate5, Identifiers.attributeInterpolate6, Identifiers.attributeInterpolate7, Identifiers.attributeInterpolate8, Identifiers.attributeInterpolateV, Identifiers.styleProp, Identifiers.stylePropInterpolate1, Identifiers.stylePropInterpolate2, Identifiers.stylePropInterpolate3, Identifiers.stylePropInterpolate4, Identifiers.stylePropInterpolate5, Identifiers.stylePropInterpolate6, Identifiers.stylePropInterpolate7, Identifiers.stylePropInterpolate8, Identifiers.stylePropInterpolateV, Identifiers.textInterpolate, Identifiers.textInterpolate1, Identifiers.textInterpolate2, Identifiers.textInterpolate3, Identifiers.textInterpolate4, Identifiers.textInterpolate5, Identifiers.textInterpolate6, Identifiers.textInterpolate7, Identifiers.textInterpolate8, Identifiers.textInterpolateV]);
    DefinitionMap = class {
      constructor() {
        this.values = [];
      }
      set(key, value) {
        if (value) {
          this.values.push({
            key,
            value,
            quoted: false
          });
        }
      }
      toLiteralMap() {
        return literalMap(this.values);
      }
    };
    UNUSABLE_INTERPOLATION_REGEXPS = [
      /^\s*$/,
      /[<>]/,
      /^[{}]$/,
      /&(#|[a-z])/i,
      /^\/\//
    ];
    InterpolationConfig = class {
      constructor(start, end) {
        this.start = start;
        this.end = end;
      }
      static fromArray(markers) {
        if (!markers) {
          return DEFAULT_INTERPOLATION_CONFIG;
        }
        assertInterpolationSymbols("interpolation", markers);
        return new InterpolationConfig(markers[0], markers[1]);
      }
    };
    DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig("{{", "}}");
    $EOF = 0;
    $BSPACE = 8;
    $TAB = 9;
    $LF = 10;
    $VTAB = 11;
    $FF = 12;
    $CR = 13;
    $SPACE = 32;
    $BANG = 33;
    $DQ = 34;
    $HASH = 35;
    $$ = 36;
    $PERCENT = 37;
    $AMPERSAND = 38;
    $SQ = 39;
    $LPAREN = 40;
    $RPAREN = 41;
    $STAR = 42;
    $PLUS = 43;
    $COMMA = 44;
    $MINUS = 45;
    $PERIOD = 46;
    $SLASH = 47;
    $COLON = 58;
    $SEMICOLON = 59;
    $LT = 60;
    $EQ = 61;
    $GT = 62;
    $QUESTION = 63;
    $0 = 48;
    $7 = 55;
    $9 = 57;
    $A = 65;
    $E = 69;
    $F = 70;
    $X = 88;
    $Z = 90;
    $LBRACKET = 91;
    $BACKSLASH = 92;
    $RBRACKET = 93;
    $CARET = 94;
    $_ = 95;
    $a = 97;
    $b = 98;
    $e = 101;
    $f = 102;
    $n = 110;
    $r = 114;
    $t = 116;
    $u = 117;
    $v = 118;
    $x = 120;
    $z = 122;
    $LBRACE = 123;
    $BAR = 124;
    $RBRACE = 125;
    $NBSP = 160;
    $BT = 96;
    ParseLocation = class {
      constructor(file, offset, line, col) {
        this.file = file;
        this.offset = offset;
        this.line = line;
        this.col = col;
      }
      toString() {
        return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
      }
      moveBy(delta) {
        const source = this.file.content;
        const len = source.length;
        let offset = this.offset;
        let line = this.line;
        let col = this.col;
        while (offset > 0 && delta < 0) {
          offset--;
          delta++;
          const ch = source.charCodeAt(offset);
          if (ch == $LF) {
            line--;
            const priorLine = source.substring(0, offset - 1).lastIndexOf(String.fromCharCode($LF));
            col = priorLine > 0 ? offset - priorLine : offset;
          } else {
            col--;
          }
        }
        while (offset < len && delta > 0) {
          const ch = source.charCodeAt(offset);
          offset++;
          delta--;
          if (ch == $LF) {
            line++;
            col = 0;
          } else {
            col++;
          }
        }
        return new ParseLocation(this.file, offset, line, col);
      }
      getContext(maxChars, maxLines) {
        const content = this.file.content;
        let startOffset = this.offset;
        if (startOffset != null) {
          if (startOffset > content.length - 1) {
            startOffset = content.length - 1;
          }
          let endOffset = startOffset;
          let ctxChars = 0;
          let ctxLines = 0;
          while (ctxChars < maxChars && startOffset > 0) {
            startOffset--;
            ctxChars++;
            if (content[startOffset] == "\n") {
              if (++ctxLines == maxLines) {
                break;
              }
            }
          }
          ctxChars = 0;
          ctxLines = 0;
          while (ctxChars < maxChars && endOffset < content.length - 1) {
            endOffset++;
            ctxChars++;
            if (content[endOffset] == "\n") {
              if (++ctxLines == maxLines) {
                break;
              }
            }
          }
          return {
            before: content.substring(startOffset, this.offset),
            after: content.substring(this.offset, endOffset + 1)
          };
        }
        return null;
      }
    };
    ParseSourceFile = class {
      constructor(content, url) {
        this.content = content;
        this.url = url;
      }
    };
    ParseSourceSpan = class {
      constructor(start, end, fullStart = start, details = null) {
        this.start = start;
        this.end = end;
        this.fullStart = fullStart;
        this.details = details;
      }
      toString() {
        return this.start.file.content.substring(this.start.offset, this.end.offset);
      }
    };
    (function(ParseErrorLevel2) {
      ParseErrorLevel2[ParseErrorLevel2["WARNING"] = 0] = "WARNING";
      ParseErrorLevel2[ParseErrorLevel2["ERROR"] = 1] = "ERROR";
    })(ParseErrorLevel || (ParseErrorLevel = {}));
    ParseError = class {
      constructor(span, msg, level = ParseErrorLevel.ERROR) {
        this.span = span;
        this.msg = msg;
        this.level = level;
      }
      contextualMessage() {
        const ctx = this.span.start.getContext(100, 3);
        return ctx ? `${this.msg} ("${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}")` : this.msg;
      }
      toString() {
        const details = this.span.details ? `, ${this.span.details}` : "";
        return `${this.contextualMessage()}: ${this.span.start}${details}`;
      }
    };
    _anonymousTypeIndex = 0;
    makeTemplateObjectPolyfill = '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,"raw",{value:t}):e.raw=t,e})';
    AbstractJsEmitterVisitor = class extends AbstractEmitterVisitor {
      constructor() {
        super(false);
      }
      visitWrappedNodeExpr(ast, ctx) {
        throw new Error("Cannot emit a WrappedNodeExpr in Javascript.");
      }
      visitDeclareVarStmt(stmt, ctx) {
        ctx.print(stmt, `var ${stmt.name}`);
        if (stmt.value) {
          ctx.print(stmt, " = ");
          stmt.value.visitExpression(this, ctx);
        }
        ctx.println(stmt, `;`);
        return null;
      }
      visitTaggedTemplateExpr(ast, ctx) {
        const elements = ast.template.elements;
        ast.tag.visitExpression(this, ctx);
        ctx.print(ast, `(${makeTemplateObjectPolyfill}(`);
        ctx.print(ast, `[${elements.map((part) => escapeIdentifier(part.text, false)).join(", ")}], `);
        ctx.print(ast, `[${elements.map((part) => escapeIdentifier(part.rawText, false)).join(", ")}])`);
        ast.template.expressions.forEach((expression) => {
          ctx.print(ast, ", ");
          expression.visitExpression(this, ctx);
        });
        ctx.print(ast, ")");
        return null;
      }
      visitFunctionExpr(ast, ctx) {
        ctx.print(ast, `function${ast.name ? " " + ast.name : ""}(`);
        this._visitParams(ast.params, ctx);
        ctx.println(ast, `) {`);
        ctx.incIndent();
        this.visitAllStatements(ast.statements, ctx);
        ctx.decIndent();
        ctx.print(ast, `}`);
        return null;
      }
      visitDeclareFunctionStmt(stmt, ctx) {
        ctx.print(stmt, `function ${stmt.name}(`);
        this._visitParams(stmt.params, ctx);
        ctx.println(stmt, `) {`);
        ctx.incIndent();
        this.visitAllStatements(stmt.statements, ctx);
        ctx.decIndent();
        ctx.println(stmt, `}`);
        return null;
      }
      visitLocalizedString(ast, ctx) {
        ctx.print(ast, `$localize(${makeTemplateObjectPolyfill}(`);
        const parts = [ast.serializeI18nHead()];
        for (let i = 1; i < ast.messageParts.length; i++) {
          parts.push(ast.serializeI18nTemplatePart(i));
        }
        ctx.print(ast, `[${parts.map((part) => escapeIdentifier(part.cooked, false)).join(", ")}], `);
        ctx.print(ast, `[${parts.map((part) => escapeIdentifier(part.raw, false)).join(", ")}])`);
        ast.expressions.forEach((expression) => {
          ctx.print(ast, ", ");
          expression.visitExpression(this, ctx);
        });
        ctx.print(ast, ")");
        return null;
      }
      _visitParams(params, ctx) {
        this.visitAllObjects((param) => ctx.print(null, param.name), params, ctx, ",");
      }
    };
    JitEvaluator = class {
      evaluateStatements(sourceUrl, statements, refResolver, createSourceMaps) {
        const converter = new JitEmitterVisitor(refResolver);
        const ctx = EmitterVisitorContext.createRoot();
        if (statements.length > 0 && !isUseStrictStatement(statements[0])) {
          statements = [literal("use strict").toStmt(), ...statements];
        }
        converter.visitAllStatements(statements, ctx);
        converter.createReturnStmt(ctx);
        return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);
      }
      evaluateCode(sourceUrl, ctx, vars, createSourceMap) {
        let fnBody = `"use strict";${ctx.toSource()}
//# sourceURL=${sourceUrl}`;
        const fnArgNames = [];
        const fnArgValues = [];
        for (const argName in vars) {
          fnArgValues.push(vars[argName]);
          fnArgNames.push(argName);
        }
        if (createSourceMap) {
          const emptyFn = newTrustedFunctionForJIT(...fnArgNames.concat("return null;")).toString();
          const headerLines = emptyFn.slice(0, emptyFn.indexOf("return null;")).split("\n").length - 1;
          fnBody += `
${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;
        }
        const fn2 = newTrustedFunctionForJIT(...fnArgNames.concat(fnBody));
        return this.executeFunction(fn2, fnArgValues);
      }
      executeFunction(fn2, args) {
        return fn2(...args);
      }
    };
    JitEmitterVisitor = class extends AbstractJsEmitterVisitor {
      constructor(refResolver) {
        super();
        this.refResolver = refResolver;
        this._evalArgNames = [];
        this._evalArgValues = [];
        this._evalExportedVars = [];
      }
      createReturnStmt(ctx) {
        const stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map((resultVar) => new LiteralMapEntry(resultVar, variable(resultVar), false))));
        stmt.visitStatement(this, ctx);
      }
      getArgs() {
        const result = {};
        for (let i = 0; i < this._evalArgNames.length; i++) {
          result[this._evalArgNames[i]] = this._evalArgValues[i];
        }
        return result;
      }
      visitExternalExpr(ast, ctx) {
        this._emitReferenceToExternal(ast, this.refResolver.resolveExternalReference(ast.value), ctx);
        return null;
      }
      visitWrappedNodeExpr(ast, ctx) {
        this._emitReferenceToExternal(ast, ast.node, ctx);
        return null;
      }
      visitDeclareVarStmt(stmt, ctx) {
        if (stmt.hasModifier(StmtModifier.Exported)) {
          this._evalExportedVars.push(stmt.name);
        }
        return super.visitDeclareVarStmt(stmt, ctx);
      }
      visitDeclareFunctionStmt(stmt, ctx) {
        if (stmt.hasModifier(StmtModifier.Exported)) {
          this._evalExportedVars.push(stmt.name);
        }
        return super.visitDeclareFunctionStmt(stmt, ctx);
      }
      _emitReferenceToExternal(ast, value, ctx) {
        let id = this._evalArgValues.indexOf(value);
        if (id === -1) {
          id = this._evalArgValues.length;
          this._evalArgValues.push(value);
          const name = identifierName({
            reference: value
          }) || "val";
          this._evalArgNames.push(`jit_${name}_${id}`);
        }
        ctx.print(ast, this._evalArgNames[id]);
      }
    };
    R3JitReflector = class {
      constructor(context2) {
        this.context = context2;
      }
      resolveExternalReference(ref) {
        if (ref.moduleName !== "@angular/core") {
          throw new Error(`Cannot resolve external reference to ${ref.moduleName}, only references to @angular/core are supported.`);
        }
        if (!this.context.hasOwnProperty(ref.name)) {
          throw new Error(`No value provided for @angular/core symbol '${ref.name}'.`);
        }
        return this.context[ref.name];
      }
    };
    (function(R3SelectorScopeMode2) {
      R3SelectorScopeMode2[R3SelectorScopeMode2["Inline"] = 0] = "Inline";
      R3SelectorScopeMode2[R3SelectorScopeMode2["SideEffect"] = 1] = "SideEffect";
      R3SelectorScopeMode2[R3SelectorScopeMode2["Omit"] = 2] = "Omit";
    })(R3SelectorScopeMode || (R3SelectorScopeMode = {}));
    (function(R3TemplateDependencyKind3) {
      R3TemplateDependencyKind3[R3TemplateDependencyKind3["Directive"] = 0] = "Directive";
      R3TemplateDependencyKind3[R3TemplateDependencyKind3["Pipe"] = 1] = "Pipe";
      R3TemplateDependencyKind3[R3TemplateDependencyKind3["NgModule"] = 2] = "NgModule";
    })(R3TemplateDependencyKind2 || (R3TemplateDependencyKind2 = {}));
    ParserError = class {
      constructor(message, input, errLocation, ctxLocation) {
        this.input = input;
        this.errLocation = errLocation;
        this.ctxLocation = ctxLocation;
        this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;
      }
    };
    ParseSpan = class {
      constructor(start, end) {
        this.start = start;
        this.end = end;
      }
      toAbsolute(absoluteOffset) {
        return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);
      }
    };
    AST = class {
      constructor(span, sourceSpan) {
        this.span = span;
        this.sourceSpan = sourceSpan;
      }
      toString() {
        return "AST";
      }
    };
    ASTWithName = class extends AST {
      constructor(span, sourceSpan, nameSpan) {
        super(span, sourceSpan);
        this.nameSpan = nameSpan;
      }
    };
    EmptyExpr = class extends AST {
      visit(visitor, context2 = null) {
      }
    };
    ImplicitReceiver = class extends AST {
      visit(visitor, context2 = null) {
        return visitor.visitImplicitReceiver(this, context2);
      }
    };
    ThisReceiver = class extends ImplicitReceiver {
      visit(visitor, context2 = null) {
        var _a;
        return (_a = visitor.visitThisReceiver) === null || _a === void 0 ? void 0 : _a.call(visitor, this, context2);
      }
    };
    Chain = class extends AST {
      constructor(span, sourceSpan, expressions) {
        super(span, sourceSpan);
        this.expressions = expressions;
      }
      visit(visitor, context2 = null) {
        return visitor.visitChain(this, context2);
      }
    };
    Conditional = class extends AST {
      constructor(span, sourceSpan, condition, trueExp, falseExp) {
        super(span, sourceSpan);
        this.condition = condition;
        this.trueExp = trueExp;
        this.falseExp = falseExp;
      }
      visit(visitor, context2 = null) {
        return visitor.visitConditional(this, context2);
      }
    };
    PropertyRead = class extends ASTWithName {
      constructor(span, sourceSpan, nameSpan, receiver, name) {
        super(span, sourceSpan, nameSpan);
        this.receiver = receiver;
        this.name = name;
      }
      visit(visitor, context2 = null) {
        return visitor.visitPropertyRead(this, context2);
      }
    };
    PropertyWrite = class extends ASTWithName {
      constructor(span, sourceSpan, nameSpan, receiver, name, value) {
        super(span, sourceSpan, nameSpan);
        this.receiver = receiver;
        this.name = name;
        this.value = value;
      }
      visit(visitor, context2 = null) {
        return visitor.visitPropertyWrite(this, context2);
      }
    };
    SafePropertyRead = class extends ASTWithName {
      constructor(span, sourceSpan, nameSpan, receiver, name) {
        super(span, sourceSpan, nameSpan);
        this.receiver = receiver;
        this.name = name;
      }
      visit(visitor, context2 = null) {
        return visitor.visitSafePropertyRead(this, context2);
      }
    };
    KeyedRead = class extends AST {
      constructor(span, sourceSpan, receiver, key) {
        super(span, sourceSpan);
        this.receiver = receiver;
        this.key = key;
      }
      visit(visitor, context2 = null) {
        return visitor.visitKeyedRead(this, context2);
      }
    };
    SafeKeyedRead = class extends AST {
      constructor(span, sourceSpan, receiver, key) {
        super(span, sourceSpan);
        this.receiver = receiver;
        this.key = key;
      }
      visit(visitor, context2 = null) {
        return visitor.visitSafeKeyedRead(this, context2);
      }
    };
    KeyedWrite = class extends AST {
      constructor(span, sourceSpan, receiver, key, value) {
        super(span, sourceSpan);
        this.receiver = receiver;
        this.key = key;
        this.value = value;
      }
      visit(visitor, context2 = null) {
        return visitor.visitKeyedWrite(this, context2);
      }
    };
    BindingPipe = class extends ASTWithName {
      constructor(span, sourceSpan, exp, name, args, nameSpan) {
        super(span, sourceSpan, nameSpan);
        this.exp = exp;
        this.name = name;
        this.args = args;
      }
      visit(visitor, context2 = null) {
        return visitor.visitPipe(this, context2);
      }
    };
    LiteralPrimitive = class extends AST {
      constructor(span, sourceSpan, value) {
        super(span, sourceSpan);
        this.value = value;
      }
      visit(visitor, context2 = null) {
        return visitor.visitLiteralPrimitive(this, context2);
      }
    };
    LiteralArray = class extends AST {
      constructor(span, sourceSpan, expressions) {
        super(span, sourceSpan);
        this.expressions = expressions;
      }
      visit(visitor, context2 = null) {
        return visitor.visitLiteralArray(this, context2);
      }
    };
    LiteralMap = class extends AST {
      constructor(span, sourceSpan, keys, values) {
        super(span, sourceSpan);
        this.keys = keys;
        this.values = values;
      }
      visit(visitor, context2 = null) {
        return visitor.visitLiteralMap(this, context2);
      }
    };
    Interpolation = class extends AST {
      constructor(span, sourceSpan, strings, expressions) {
        super(span, sourceSpan);
        this.strings = strings;
        this.expressions = expressions;
      }
      visit(visitor, context2 = null) {
        return visitor.visitInterpolation(this, context2);
      }
    };
    Binary = class extends AST {
      constructor(span, sourceSpan, operation, left, right) {
        super(span, sourceSpan);
        this.operation = operation;
        this.left = left;
        this.right = right;
      }
      visit(visitor, context2 = null) {
        return visitor.visitBinary(this, context2);
      }
    };
    Unary = class extends Binary {
      constructor(span, sourceSpan, operator, expr, binaryOp, binaryLeft, binaryRight) {
        super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);
        this.operator = operator;
        this.expr = expr;
        this.left = null;
        this.right = null;
        this.operation = null;
      }
      static createMinus(span, sourceSpan, expr) {
        return new Unary(span, sourceSpan, "-", expr, "-", new LiteralPrimitive(span, sourceSpan, 0), expr);
      }
      static createPlus(span, sourceSpan, expr) {
        return new Unary(span, sourceSpan, "+", expr, "-", expr, new LiteralPrimitive(span, sourceSpan, 0));
      }
      visit(visitor, context2 = null) {
        if (visitor.visitUnary !== void 0) {
          return visitor.visitUnary(this, context2);
        }
        return visitor.visitBinary(this, context2);
      }
    };
    PrefixNot = class extends AST {
      constructor(span, sourceSpan, expression) {
        super(span, sourceSpan);
        this.expression = expression;
      }
      visit(visitor, context2 = null) {
        return visitor.visitPrefixNot(this, context2);
      }
    };
    NonNullAssert = class extends AST {
      constructor(span, sourceSpan, expression) {
        super(span, sourceSpan);
        this.expression = expression;
      }
      visit(visitor, context2 = null) {
        return visitor.visitNonNullAssert(this, context2);
      }
    };
    Call = class extends AST {
      constructor(span, sourceSpan, receiver, args, argumentSpan) {
        super(span, sourceSpan);
        this.receiver = receiver;
        this.args = args;
        this.argumentSpan = argumentSpan;
      }
      visit(visitor, context2 = null) {
        return visitor.visitCall(this, context2);
      }
    };
    SafeCall = class extends AST {
      constructor(span, sourceSpan, receiver, args, argumentSpan) {
        super(span, sourceSpan);
        this.receiver = receiver;
        this.args = args;
        this.argumentSpan = argumentSpan;
      }
      visit(visitor, context2 = null) {
        return visitor.visitSafeCall(this, context2);
      }
    };
    AbsoluteSourceSpan = class {
      constructor(start, end) {
        this.start = start;
        this.end = end;
      }
    };
    ASTWithSource = class extends AST {
      constructor(ast, source, location2, absoluteOffset, errors) {
        super(new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));
        this.ast = ast;
        this.source = source;
        this.location = location2;
        this.errors = errors;
      }
      visit(visitor, context2 = null) {
        if (visitor.visitASTWithSource) {
          return visitor.visitASTWithSource(this, context2);
        }
        return this.ast.visit(visitor, context2);
      }
      toString() {
        return `${this.source} in ${this.location}`;
      }
    };
    VariableBinding = class {
      constructor(sourceSpan, key, value) {
        this.sourceSpan = sourceSpan;
        this.key = key;
        this.value = value;
      }
    };
    ExpressionBinding = class {
      constructor(sourceSpan, key, value) {
        this.sourceSpan = sourceSpan;
        this.key = key;
        this.value = value;
      }
    };
    RecursiveAstVisitor = class {
      visit(ast, context2) {
        ast.visit(this, context2);
      }
      visitUnary(ast, context2) {
        this.visit(ast.expr, context2);
      }
      visitBinary(ast, context2) {
        this.visit(ast.left, context2);
        this.visit(ast.right, context2);
      }
      visitChain(ast, context2) {
        this.visitAll(ast.expressions, context2);
      }
      visitConditional(ast, context2) {
        this.visit(ast.condition, context2);
        this.visit(ast.trueExp, context2);
        this.visit(ast.falseExp, context2);
      }
      visitPipe(ast, context2) {
        this.visit(ast.exp, context2);
        this.visitAll(ast.args, context2);
      }
      visitImplicitReceiver(ast, context2) {
      }
      visitThisReceiver(ast, context2) {
      }
      visitInterpolation(ast, context2) {
        this.visitAll(ast.expressions, context2);
      }
      visitKeyedRead(ast, context2) {
        this.visit(ast.receiver, context2);
        this.visit(ast.key, context2);
      }
      visitKeyedWrite(ast, context2) {
        this.visit(ast.receiver, context2);
        this.visit(ast.key, context2);
        this.visit(ast.value, context2);
      }
      visitLiteralArray(ast, context2) {
        this.visitAll(ast.expressions, context2);
      }
      visitLiteralMap(ast, context2) {
        this.visitAll(ast.values, context2);
      }
      visitLiteralPrimitive(ast, context2) {
      }
      visitPrefixNot(ast, context2) {
        this.visit(ast.expression, context2);
      }
      visitNonNullAssert(ast, context2) {
        this.visit(ast.expression, context2);
      }
      visitPropertyRead(ast, context2) {
        this.visit(ast.receiver, context2);
      }
      visitPropertyWrite(ast, context2) {
        this.visit(ast.receiver, context2);
        this.visit(ast.value, context2);
      }
      visitSafePropertyRead(ast, context2) {
        this.visit(ast.receiver, context2);
      }
      visitSafeKeyedRead(ast, context2) {
        this.visit(ast.receiver, context2);
        this.visit(ast.key, context2);
      }
      visitCall(ast, context2) {
        this.visit(ast.receiver, context2);
        this.visitAll(ast.args, context2);
      }
      visitSafeCall(ast, context2) {
        this.visit(ast.receiver, context2);
        this.visitAll(ast.args, context2);
      }
      visitAll(asts, context2) {
        for (const ast of asts) {
          this.visit(ast, context2);
        }
      }
    };
    AstTransformer = class {
      visitImplicitReceiver(ast, context2) {
        return ast;
      }
      visitThisReceiver(ast, context2) {
        return ast;
      }
      visitInterpolation(ast, context2) {
        return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));
      }
      visitLiteralPrimitive(ast, context2) {
        return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);
      }
      visitPropertyRead(ast, context2) {
        return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);
      }
      visitPropertyWrite(ast, context2) {
        return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, ast.value.visit(this));
      }
      visitSafePropertyRead(ast, context2) {
        return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);
      }
      visitLiteralArray(ast, context2) {
        return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));
      }
      visitLiteralMap(ast, context2) {
        return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));
      }
      visitUnary(ast, context2) {
        switch (ast.operator) {
          case "+":
            return Unary.createPlus(ast.span, ast.sourceSpan, ast.expr.visit(this));
          case "-":
            return Unary.createMinus(ast.span, ast.sourceSpan, ast.expr.visit(this));
          default:
            throw new Error(`Unknown unary operator ${ast.operator}`);
        }
      }
      visitBinary(ast, context2) {
        return new Binary(ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));
      }
      visitPrefixNot(ast, context2) {
        return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));
      }
      visitNonNullAssert(ast, context2) {
        return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));
      }
      visitConditional(ast, context2) {
        return new Conditional(ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
      }
      visitPipe(ast, context2) {
        return new BindingPipe(ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args), ast.nameSpan);
      }
      visitKeyedRead(ast, context2) {
        return new KeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));
      }
      visitKeyedWrite(ast, context2) {
        return new KeyedWrite(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this), ast.value.visit(this));
      }
      visitCall(ast, context2) {
        return new Call(ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args), ast.argumentSpan);
      }
      visitSafeCall(ast, context2) {
        return new SafeCall(ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args), ast.argumentSpan);
      }
      visitAll(asts) {
        const res = [];
        for (let i = 0; i < asts.length; ++i) {
          res[i] = asts[i].visit(this);
        }
        return res;
      }
      visitChain(ast, context2) {
        return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));
      }
      visitSafeKeyedRead(ast, context2) {
        return new SafeKeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));
      }
    };
    AstMemoryEfficientTransformer = class {
      visitImplicitReceiver(ast, context2) {
        return ast;
      }
      visitThisReceiver(ast, context2) {
        return ast;
      }
      visitInterpolation(ast, context2) {
        const expressions = this.visitAll(ast.expressions);
        if (expressions !== ast.expressions)
          return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);
        return ast;
      }
      visitLiteralPrimitive(ast, context2) {
        return ast;
      }
      visitPropertyRead(ast, context2) {
        const receiver = ast.receiver.visit(this);
        if (receiver !== ast.receiver) {
          return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);
        }
        return ast;
      }
      visitPropertyWrite(ast, context2) {
        const receiver = ast.receiver.visit(this);
        const value = ast.value.visit(this);
        if (receiver !== ast.receiver || value !== ast.value) {
          return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);
        }
        return ast;
      }
      visitSafePropertyRead(ast, context2) {
        const receiver = ast.receiver.visit(this);
        if (receiver !== ast.receiver) {
          return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);
        }
        return ast;
      }
      visitLiteralArray(ast, context2) {
        const expressions = this.visitAll(ast.expressions);
        if (expressions !== ast.expressions) {
          return new LiteralArray(ast.span, ast.sourceSpan, expressions);
        }
        return ast;
      }
      visitLiteralMap(ast, context2) {
        const values = this.visitAll(ast.values);
        if (values !== ast.values) {
          return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);
        }
        return ast;
      }
      visitUnary(ast, context2) {
        const expr = ast.expr.visit(this);
        if (expr !== ast.expr) {
          switch (ast.operator) {
            case "+":
              return Unary.createPlus(ast.span, ast.sourceSpan, expr);
            case "-":
              return Unary.createMinus(ast.span, ast.sourceSpan, expr);
            default:
              throw new Error(`Unknown unary operator ${ast.operator}`);
          }
        }
        return ast;
      }
      visitBinary(ast, context2) {
        const left = ast.left.visit(this);
        const right = ast.right.visit(this);
        if (left !== ast.left || right !== ast.right) {
          return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);
        }
        return ast;
      }
      visitPrefixNot(ast, context2) {
        const expression = ast.expression.visit(this);
        if (expression !== ast.expression) {
          return new PrefixNot(ast.span, ast.sourceSpan, expression);
        }
        return ast;
      }
      visitNonNullAssert(ast, context2) {
        const expression = ast.expression.visit(this);
        if (expression !== ast.expression) {
          return new NonNullAssert(ast.span, ast.sourceSpan, expression);
        }
        return ast;
      }
      visitConditional(ast, context2) {
        const condition = ast.condition.visit(this);
        const trueExp = ast.trueExp.visit(this);
        const falseExp = ast.falseExp.visit(this);
        if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {
          return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);
        }
        return ast;
      }
      visitPipe(ast, context2) {
        const exp = ast.exp.visit(this);
        const args = this.visitAll(ast.args);
        if (exp !== ast.exp || args !== ast.args) {
          return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);
        }
        return ast;
      }
      visitKeyedRead(ast, context2) {
        const obj = ast.receiver.visit(this);
        const key = ast.key.visit(this);
        if (obj !== ast.receiver || key !== ast.key) {
          return new KeyedRead(ast.span, ast.sourceSpan, obj, key);
        }
        return ast;
      }
      visitKeyedWrite(ast, context2) {
        const obj = ast.receiver.visit(this);
        const key = ast.key.visit(this);
        const value = ast.value.visit(this);
        if (obj !== ast.receiver || key !== ast.key || value !== ast.value) {
          return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);
        }
        return ast;
      }
      visitAll(asts) {
        const res = [];
        let modified = false;
        for (let i = 0; i < asts.length; ++i) {
          const original = asts[i];
          const value = original.visit(this);
          res[i] = value;
          modified = modified || value !== original;
        }
        return modified ? res : asts;
      }
      visitChain(ast, context2) {
        const expressions = this.visitAll(ast.expressions);
        if (expressions !== ast.expressions) {
          return new Chain(ast.span, ast.sourceSpan, expressions);
        }
        return ast;
      }
      visitCall(ast, context2) {
        const receiver = ast.receiver.visit(this);
        const args = this.visitAll(ast.args);
        if (receiver !== ast.receiver || args !== ast.args) {
          return new Call(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);
        }
        return ast;
      }
      visitSafeCall(ast, context2) {
        const receiver = ast.receiver.visit(this);
        const args = this.visitAll(ast.args);
        if (receiver !== ast.receiver || args !== ast.args) {
          return new SafeCall(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);
        }
        return ast;
      }
      visitSafeKeyedRead(ast, context2) {
        const obj = ast.receiver.visit(this);
        const key = ast.key.visit(this);
        if (obj !== ast.receiver || key !== ast.key) {
          return new SafeKeyedRead(ast.span, ast.sourceSpan, obj, key);
        }
        return ast;
      }
    };
    ParsedProperty = class {
      constructor(name, expression, type, sourceSpan, keySpan, valueSpan) {
        this.name = name;
        this.expression = expression;
        this.type = type;
        this.sourceSpan = sourceSpan;
        this.keySpan = keySpan;
        this.valueSpan = valueSpan;
        this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;
        this.isAnimation = this.type === ParsedPropertyType.ANIMATION;
      }
    };
    (function(ParsedPropertyType2) {
      ParsedPropertyType2[ParsedPropertyType2["DEFAULT"] = 0] = "DEFAULT";
      ParsedPropertyType2[ParsedPropertyType2["LITERAL_ATTR"] = 1] = "LITERAL_ATTR";
      ParsedPropertyType2[ParsedPropertyType2["ANIMATION"] = 2] = "ANIMATION";
    })(ParsedPropertyType || (ParsedPropertyType = {}));
    ParsedEvent = class {
      constructor(name, targetOrPhase, type, handler, sourceSpan, handlerSpan, keySpan) {
        this.name = name;
        this.targetOrPhase = targetOrPhase;
        this.type = type;
        this.handler = handler;
        this.sourceSpan = sourceSpan;
        this.handlerSpan = handlerSpan;
        this.keySpan = keySpan;
      }
    };
    ParsedVariable = class {
      constructor(name, value, sourceSpan, keySpan, valueSpan) {
        this.name = name;
        this.value = value;
        this.sourceSpan = sourceSpan;
        this.keySpan = keySpan;
        this.valueSpan = valueSpan;
      }
    };
    BoundElementProperty = class {
      constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan) {
        this.name = name;
        this.type = type;
        this.securityContext = securityContext;
        this.value = value;
        this.unit = unit;
        this.sourceSpan = sourceSpan;
        this.keySpan = keySpan;
        this.valueSpan = valueSpan;
      }
    };
    EventHandlerVars = class {
    };
    EventHandlerVars.event = variable("$event");
    ConvertPropertyBindingResult = class {
      constructor(stmts, currValExpr) {
        this.stmts = stmts;
        this.currValExpr = currValExpr;
      }
    };
    (function(_Mode2) {
      _Mode2[_Mode2["Statement"] = 0] = "Statement";
      _Mode2[_Mode2["Expression"] = 1] = "Expression";
    })(_Mode || (_Mode = {}));
    _BuiltinAstConverter = class extends AstTransformer {
      constructor(_converterFactory) {
        super();
        this._converterFactory = _converterFactory;
      }
      visitPipe(ast, context2) {
        const args = [ast.exp, ...ast.args].map((ast2) => ast2.visit(this, context2));
        return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createPipeConverter(ast.name, args.length));
      }
      visitLiteralArray(ast, context2) {
        const args = ast.expressions.map((ast2) => ast2.visit(this, context2));
        return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));
      }
      visitLiteralMap(ast, context2) {
        const args = ast.values.map((ast2) => ast2.visit(this, context2));
        return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));
      }
    };
    _AstToIrVisitor = class {
      constructor(_localResolver, _implicitReceiver, bindingId, supportsInterpolation, baseSourceSpan, implicitReceiverAccesses) {
        this._localResolver = _localResolver;
        this._implicitReceiver = _implicitReceiver;
        this.bindingId = bindingId;
        this.supportsInterpolation = supportsInterpolation;
        this.baseSourceSpan = baseSourceSpan;
        this.implicitReceiverAccesses = implicitReceiverAccesses;
        this._nodeMap = /* @__PURE__ */ new Map();
        this._resultMap = /* @__PURE__ */ new Map();
        this._currentTemporary = 0;
        this.temporaryCount = 0;
        this.usesImplicitReceiver = false;
      }
      visitUnary(ast, mode) {
        let op;
        switch (ast.operator) {
          case "+":
            op = UnaryOperator.Plus;
            break;
          case "-":
            op = UnaryOperator.Minus;
            break;
          default:
            throw new Error(`Unsupported operator ${ast.operator}`);
        }
        return convertToStatementIfNeeded(mode, new UnaryOperatorExpr(op, this._visit(ast.expr, _Mode.Expression), void 0, this.convertSourceSpan(ast.span)));
      }
      visitBinary(ast, mode) {
        let op;
        switch (ast.operation) {
          case "+":
            op = BinaryOperator.Plus;
            break;
          case "-":
            op = BinaryOperator.Minus;
            break;
          case "*":
            op = BinaryOperator.Multiply;
            break;
          case "/":
            op = BinaryOperator.Divide;
            break;
          case "%":
            op = BinaryOperator.Modulo;
            break;
          case "&&":
            op = BinaryOperator.And;
            break;
          case "||":
            op = BinaryOperator.Or;
            break;
          case "==":
            op = BinaryOperator.Equals;
            break;
          case "!=":
            op = BinaryOperator.NotEquals;
            break;
          case "===":
            op = BinaryOperator.Identical;
            break;
          case "!==":
            op = BinaryOperator.NotIdentical;
            break;
          case "<":
            op = BinaryOperator.Lower;
            break;
          case ">":
            op = BinaryOperator.Bigger;
            break;
          case "<=":
            op = BinaryOperator.LowerEquals;
            break;
          case ">=":
            op = BinaryOperator.BiggerEquals;
            break;
          case "??":
            return this.convertNullishCoalesce(ast, mode);
          default:
            throw new Error(`Unsupported operation ${ast.operation}`);
        }
        return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression), void 0, this.convertSourceSpan(ast.span)));
      }
      visitChain(ast, mode) {
        ensureStatementMode(mode, ast);
        return this.visitAll(ast.expressions, mode);
      }
      visitConditional(ast, mode) {
        const value = this._visit(ast.condition, _Mode.Expression);
        return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression), this.convertSourceSpan(ast.span)));
      }
      visitPipe(ast, mode) {
        throw new Error(`Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);
      }
      visitImplicitReceiver(ast, mode) {
        ensureExpressionMode(mode, ast);
        this.usesImplicitReceiver = true;
        return this._implicitReceiver;
      }
      visitThisReceiver(ast, mode) {
        return this.visitImplicitReceiver(ast, mode);
      }
      visitInterpolation(ast, mode) {
        if (!this.supportsInterpolation) {
          throw new Error("Unexpected interpolation");
        }
        ensureExpressionMode(mode, ast);
        let args = [];
        for (let i = 0; i < ast.strings.length - 1; i++) {
          args.push(literal(ast.strings[i]));
          args.push(this._visit(ast.expressions[i], _Mode.Expression));
        }
        args.push(literal(ast.strings[ast.strings.length - 1]));
        const strings = ast.strings;
        if (strings.length === 2 && strings[0] === "" && strings[1] === "") {
          args = [args[1]];
        } else if (ast.expressions.length >= 9) {
          args = [literalArr(args)];
        }
        return new InterpolationExpression(args);
      }
      visitKeyedRead(ast, mode) {
        const leftMostSafe = this.leftMostSafeNode(ast);
        if (leftMostSafe) {
          return this.convertSafeAccess(ast, leftMostSafe, mode);
        } else {
          return convertToStatementIfNeeded(mode, this._visit(ast.receiver, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));
        }
      }
      visitKeyedWrite(ast, mode) {
        const obj = this._visit(ast.receiver, _Mode.Expression);
        const key = this._visit(ast.key, _Mode.Expression);
        const value = this._visit(ast.value, _Mode.Expression);
        if (obj === this._implicitReceiver) {
          this._localResolver.maybeRestoreView();
        }
        return convertToStatementIfNeeded(mode, obj.key(key).set(value));
      }
      visitLiteralArray(ast, mode) {
        throw new Error(`Illegal State: literal arrays should have been converted into functions`);
      }
      visitLiteralMap(ast, mode) {
        throw new Error(`Illegal State: literal maps should have been converted into functions`);
      }
      visitLiteralPrimitive(ast, mode) {
        const type = ast.value === null || ast.value === void 0 || ast.value === true || ast.value === true ? INFERRED_TYPE : void 0;
        return convertToStatementIfNeeded(mode, literal(ast.value, type, this.convertSourceSpan(ast.span)));
      }
      _getLocal(name, receiver) {
        var _a;
        if (((_a = this._localResolver.globals) === null || _a === void 0 ? void 0 : _a.has(name)) && receiver instanceof ThisReceiver) {
          return null;
        }
        return this._localResolver.getLocal(name);
      }
      visitPrefixNot(ast, mode) {
        return convertToStatementIfNeeded(mode, not2(this._visit(ast.expression, _Mode.Expression)));
      }
      visitNonNullAssert(ast, mode) {
        return convertToStatementIfNeeded(mode, this._visit(ast.expression, _Mode.Expression));
      }
      visitPropertyRead(ast, mode) {
        const leftMostSafe = this.leftMostSafeNode(ast);
        if (leftMostSafe) {
          return this.convertSafeAccess(ast, leftMostSafe, mode);
        } else {
          let result = null;
          const prevUsesImplicitReceiver = this.usesImplicitReceiver;
          const receiver = this._visit(ast.receiver, _Mode.Expression);
          if (receiver === this._implicitReceiver) {
            result = this._getLocal(ast.name, ast.receiver);
            if (result) {
              this.usesImplicitReceiver = prevUsesImplicitReceiver;
              this.addImplicitReceiverAccess(ast.name);
            }
          }
          if (result == null) {
            result = receiver.prop(ast.name, this.convertSourceSpan(ast.span));
          }
          return convertToStatementIfNeeded(mode, result);
        }
      }
      visitPropertyWrite(ast, mode) {
        const receiver = this._visit(ast.receiver, _Mode.Expression);
        const prevUsesImplicitReceiver = this.usesImplicitReceiver;
        let varExpr = null;
        if (receiver === this._implicitReceiver) {
          const localExpr = this._getLocal(ast.name, ast.receiver);
          if (localExpr) {
            if (localExpr instanceof ReadPropExpr) {
              varExpr = localExpr;
              this.usesImplicitReceiver = prevUsesImplicitReceiver;
              this.addImplicitReceiverAccess(ast.name);
            } else {
              const receiver2 = ast.name;
              const value = ast.value instanceof PropertyRead ? ast.value.name : void 0;
              throw new Error(`Cannot assign value "${value}" to template variable "${receiver2}". Template variables are read-only.`);
            }
          }
        }
        if (varExpr === null) {
          varExpr = receiver.prop(ast.name, this.convertSourceSpan(ast.span));
        }
        return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));
      }
      visitSafePropertyRead(ast, mode) {
        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
      }
      visitSafeKeyedRead(ast, mode) {
        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
      }
      visitAll(asts, mode) {
        return asts.map((ast) => this._visit(ast, mode));
      }
      visitCall(ast, mode) {
        const leftMostSafe = this.leftMostSafeNode(ast);
        if (leftMostSafe) {
          return this.convertSafeAccess(ast, leftMostSafe, mode);
        }
        const convertedArgs = this.visitAll(ast.args, _Mode.Expression);
        if (ast instanceof BuiltinFunctionCall) {
          return convertToStatementIfNeeded(mode, ast.converter(convertedArgs));
        }
        const receiver = ast.receiver;
        if (receiver instanceof PropertyRead && receiver.receiver instanceof ImplicitReceiver && !(receiver.receiver instanceof ThisReceiver) && receiver.name === "$any") {
          if (convertedArgs.length !== 1) {
            throw new Error(`Invalid call to $any, expected 1 argument but received ${convertedArgs.length || "none"}`);
          }
          return convertToStatementIfNeeded(mode, convertedArgs[0]);
        }
        const call = this._visit(receiver, _Mode.Expression).callFn(convertedArgs, this.convertSourceSpan(ast.span));
        return convertToStatementIfNeeded(mode, call);
      }
      visitSafeCall(ast, mode) {
        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
      }
      _visit(ast, mode) {
        const result = this._resultMap.get(ast);
        if (result)
          return result;
        return (this._nodeMap.get(ast) || ast).visit(this, mode);
      }
      convertSafeAccess(ast, leftMostSafe, mode) {
        let guardedExpression2 = this._visit(leftMostSafe.receiver, _Mode.Expression);
        let temporary = void 0;
        if (this.needsTemporaryInSafeAccess(leftMostSafe.receiver)) {
          temporary = this.allocateTemporary();
          guardedExpression2 = temporary.set(guardedExpression2);
          this._resultMap.set(leftMostSafe.receiver, temporary);
        }
        const condition = guardedExpression2.isBlank();
        if (leftMostSafe instanceof SafeCall) {
          this._nodeMap.set(leftMostSafe, new Call(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.args, leftMostSafe.argumentSpan));
        } else if (leftMostSafe instanceof SafeKeyedRead) {
          this._nodeMap.set(leftMostSafe, new KeyedRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.key));
        } else {
          this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name));
        }
        const access = this._visit(ast, _Mode.Expression);
        this._nodeMap.delete(leftMostSafe);
        if (temporary) {
          this.releaseTemporary(temporary);
        }
        return convertToStatementIfNeeded(mode, condition.conditional(NULL_EXPR, access));
      }
      convertNullishCoalesce(ast, mode) {
        const left = this._visit(ast.left, _Mode.Expression);
        const right = this._visit(ast.right, _Mode.Expression);
        const temporary = this.allocateTemporary();
        this.releaseTemporary(temporary);
        return convertToStatementIfNeeded(mode, temporary.set(left).notIdentical(NULL_EXPR).and(temporary.notIdentical(literal(void 0))).conditional(temporary, right));
      }
      leftMostSafeNode(ast) {
        const visit = (visitor, ast2) => {
          return (this._nodeMap.get(ast2) || ast2).visit(visitor);
        };
        return ast.visit({
          visitUnary(ast2) {
            return null;
          },
          visitBinary(ast2) {
            return null;
          },
          visitChain(ast2) {
            return null;
          },
          visitConditional(ast2) {
            return null;
          },
          visitCall(ast2) {
            return visit(this, ast2.receiver);
          },
          visitSafeCall(ast2) {
            return visit(this, ast2.receiver) || ast2;
          },
          visitImplicitReceiver(ast2) {
            return null;
          },
          visitThisReceiver(ast2) {
            return null;
          },
          visitInterpolation(ast2) {
            return null;
          },
          visitKeyedRead(ast2) {
            return visit(this, ast2.receiver);
          },
          visitKeyedWrite(ast2) {
            return null;
          },
          visitLiteralArray(ast2) {
            return null;
          },
          visitLiteralMap(ast2) {
            return null;
          },
          visitLiteralPrimitive(ast2) {
            return null;
          },
          visitPipe(ast2) {
            return null;
          },
          visitPrefixNot(ast2) {
            return null;
          },
          visitNonNullAssert(ast2) {
            return null;
          },
          visitPropertyRead(ast2) {
            return visit(this, ast2.receiver);
          },
          visitPropertyWrite(ast2) {
            return null;
          },
          visitSafePropertyRead(ast2) {
            return visit(this, ast2.receiver) || ast2;
          },
          visitSafeKeyedRead(ast2) {
            return visit(this, ast2.receiver) || ast2;
          }
        });
      }
      needsTemporaryInSafeAccess(ast) {
        const visit = (visitor, ast2) => {
          return ast2 && (this._nodeMap.get(ast2) || ast2).visit(visitor);
        };
        const visitSome = (visitor, ast2) => {
          return ast2.some((ast3) => visit(visitor, ast3));
        };
        return ast.visit({
          visitUnary(ast2) {
            return visit(this, ast2.expr);
          },
          visitBinary(ast2) {
            return visit(this, ast2.left) || visit(this, ast2.right);
          },
          visitChain(ast2) {
            return false;
          },
          visitConditional(ast2) {
            return visit(this, ast2.condition) || visit(this, ast2.trueExp) || visit(this, ast2.falseExp);
          },
          visitCall(ast2) {
            return true;
          },
          visitSafeCall(ast2) {
            return true;
          },
          visitImplicitReceiver(ast2) {
            return false;
          },
          visitThisReceiver(ast2) {
            return false;
          },
          visitInterpolation(ast2) {
            return visitSome(this, ast2.expressions);
          },
          visitKeyedRead(ast2) {
            return false;
          },
          visitKeyedWrite(ast2) {
            return false;
          },
          visitLiteralArray(ast2) {
            return true;
          },
          visitLiteralMap(ast2) {
            return true;
          },
          visitLiteralPrimitive(ast2) {
            return false;
          },
          visitPipe(ast2) {
            return true;
          },
          visitPrefixNot(ast2) {
            return visit(this, ast2.expression);
          },
          visitNonNullAssert(ast2) {
            return visit(this, ast2.expression);
          },
          visitPropertyRead(ast2) {
            return false;
          },
          visitPropertyWrite(ast2) {
            return false;
          },
          visitSafePropertyRead(ast2) {
            return false;
          },
          visitSafeKeyedRead(ast2) {
            return false;
          }
        });
      }
      allocateTemporary() {
        const tempNumber = this._currentTemporary++;
        this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);
        return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));
      }
      releaseTemporary(temporary) {
        this._currentTemporary--;
        if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {
          throw new Error(`Temporary ${temporary.name} released out of order`);
        }
      }
      convertSourceSpan(span) {
        if (this.baseSourceSpan) {
          const start = this.baseSourceSpan.start.moveBy(span.start);
          const end = this.baseSourceSpan.start.moveBy(span.end);
          const fullStart = this.baseSourceSpan.fullStart.moveBy(span.start);
          return new ParseSourceSpan(start, end, fullStart);
        } else {
          return null;
        }
      }
      addImplicitReceiverAccess(name) {
        if (this.implicitReceiverAccesses) {
          this.implicitReceiverAccesses.add(name);
        }
      }
    };
    InterpolationExpression = class extends Expression {
      constructor(args) {
        super(null, null);
        this.args = args;
        this.isConstant = unsupported;
        this.isEquivalent = unsupported;
        this.visitExpression = unsupported;
      }
    };
    DefaultLocalResolver = class {
      constructor(globals) {
        this.globals = globals;
      }
      notifyImplicitReceiverUse() {
      }
      maybeRestoreView() {
      }
      getLocal(name) {
        if (name === EventHandlerVars.event.name) {
          return EventHandlerVars.event;
        }
        return null;
      }
    };
    BuiltinFunctionCall = class extends Call {
      constructor(span, sourceSpan, args, converter) {
        super(span, sourceSpan, new EmptyExpr(span, sourceSpan), args, null);
        this.converter = converter;
      }
    };
    ShadowCss = class {
      constructor() {
        this.strictStyling = true;
      }
      shimCssText(cssText, selector, hostSelector = "") {
        const commentsWithHash = extractCommentsWithHash(cssText);
        cssText = stripComments(cssText);
        cssText = this._insertDirectives(cssText);
        const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);
        return [scopedCssText, ...commentsWithHash].join("\n");
      }
      _insertDirectives(cssText) {
        cssText = this._insertPolyfillDirectivesInCssText(cssText);
        return this._insertPolyfillRulesInCssText(cssText);
      }
      _insertPolyfillDirectivesInCssText(cssText) {
        return cssText.replace(_cssContentNextSelectorRe, function(...m) {
          return m[2] + "{";
        });
      }
      _insertPolyfillRulesInCssText(cssText) {
        return cssText.replace(_cssContentRuleRe, (...m) => {
          const rule = m[0].replace(m[1], "").replace(m[2], "");
          return m[4] + rule;
        });
      }
      _scopeCssText(cssText, scopeSelector, hostSelector) {
        const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);
        cssText = this._insertPolyfillHostInCssText(cssText);
        cssText = this._convertColonHost(cssText);
        cssText = this._convertColonHostContext(cssText);
        cssText = this._convertShadowDOMSelectors(cssText);
        if (scopeSelector) {
          cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);
        }
        cssText = cssText + "\n" + unscopedRules;
        return cssText.trim();
      }
      _extractUnscopedRulesFromCssText(cssText) {
        let r = "";
        let m;
        _cssContentUnscopedRuleRe.lastIndex = 0;
        while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {
          const rule = m[0].replace(m[2], "").replace(m[1], m[4]);
          r += rule + "\n\n";
        }
        return r;
      }
      _convertColonHost(cssText) {
        return cssText.replace(_cssColonHostRe, (_, hostSelectors, otherSelectors) => {
          if (hostSelectors) {
            const convertedSelectors = [];
            const hostSelectorArray = hostSelectors.split(",").map((p) => p.trim());
            for (const hostSelector of hostSelectorArray) {
              if (!hostSelector)
                break;
              const convertedSelector = _polyfillHostNoCombinator + hostSelector.replace(_polyfillHost, "") + otherSelectors;
              convertedSelectors.push(convertedSelector);
            }
            return convertedSelectors.join(",");
          } else {
            return _polyfillHostNoCombinator + otherSelectors;
          }
        });
      }
      _convertColonHostContext(cssText) {
        return cssText.replace(_cssColonHostContextReGlobal, (selectorText) => {
          var _a;
          const contextSelectorGroups = [[]];
          let match;
          while (match = _cssColonHostContextRe.exec(selectorText)) {
            const newContextSelectors = ((_a = match[1]) !== null && _a !== void 0 ? _a : "").trim().split(",").map((m) => m.trim()).filter((m) => m !== "");
            const contextSelectorGroupsLength = contextSelectorGroups.length;
            repeatGroups(contextSelectorGroups, newContextSelectors.length);
            for (let i = 0; i < newContextSelectors.length; i++) {
              for (let j = 0; j < contextSelectorGroupsLength; j++) {
                contextSelectorGroups[j + i * contextSelectorGroupsLength].push(newContextSelectors[i]);
              }
            }
            selectorText = match[2];
          }
          return contextSelectorGroups.map((contextSelectors) => combineHostContextSelectors(contextSelectors, selectorText)).join(", ");
        });
      }
      _convertShadowDOMSelectors(cssText) {
        return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, " "), cssText);
      }
      _scopeSelectors(cssText, scopeSelector, hostSelector) {
        return processRules(cssText, (rule) => {
          let selector = rule.selector;
          let content = rule.content;
          if (rule.selector[0] !== "@") {
            selector = this._scopeSelector(rule.selector, scopeSelector, hostSelector, this.strictStyling);
          } else if (rule.selector.startsWith("@media") || rule.selector.startsWith("@supports") || rule.selector.startsWith("@document") || rule.selector.startsWith("@layer")) {
            content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);
          } else if (rule.selector.startsWith("@font-face") || rule.selector.startsWith("@page")) {
            content = this._stripScopingSelectors(rule.content);
          }
          return new CssRule(selector, content);
        });
      }
      _stripScopingSelectors(cssText) {
        return processRules(cssText, (rule) => {
          const selector = rule.selector.replace(_shadowDeepSelectors, " ").replace(_polyfillHostNoCombinatorRe, " ");
          return new CssRule(selector, rule.content);
        });
      }
      _scopeSelector(selector, scopeSelector, hostSelector, strict) {
        return selector.split(",").map((part) => part.trim().split(_shadowDeepSelectors)).map((deepParts) => {
          const [shallowPart, ...otherParts] = deepParts;
          const applyScope = (shallowPart2) => {
            if (this._selectorNeedsScoping(shallowPart2, scopeSelector)) {
              return strict ? this._applyStrictSelectorScope(shallowPart2, scopeSelector, hostSelector) : this._applySelectorScope(shallowPart2, scopeSelector, hostSelector);
            } else {
              return shallowPart2;
            }
          };
          return [applyScope(shallowPart), ...otherParts].join(" ");
        }).join(", ");
      }
      _selectorNeedsScoping(selector, scopeSelector) {
        const re = this._makeScopeMatcher(scopeSelector);
        return !re.test(selector);
      }
      _makeScopeMatcher(scopeSelector) {
        const lre = /\[/g;
        const rre = /\]/g;
        scopeSelector = scopeSelector.replace(lre, "\\[").replace(rre, "\\]");
        return new RegExp("^(" + scopeSelector + ")" + _selectorReSuffix, "m");
      }
      _applySelectorScope(selector, scopeSelector, hostSelector) {
        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
      }
      _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {
        _polyfillHostRe.lastIndex = 0;
        if (_polyfillHostRe.test(selector)) {
          const replaceBy = this.strictStyling ? `[${hostSelector}]` : scopeSelector;
          return selector.replace(_polyfillHostNoCombinatorRe, (hnc, selector2) => {
            return selector2.replace(/([^:]*)(:*)(.*)/, (_, before, colon, after) => {
              return before + replaceBy + colon + after;
            });
          }).replace(_polyfillHostRe, replaceBy + " ");
        }
        return scopeSelector + " " + selector;
      }
      _applyStrictSelectorScope(selector, scopeSelector, hostSelector) {
        const isRe = /\[is=([^\]]*)\]/g;
        scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);
        const attrName = "[" + scopeSelector + "]";
        const _scopeSelectorPart = (p) => {
          let scopedP = p.trim();
          if (!scopedP) {
            return "";
          }
          if (p.indexOf(_polyfillHostNoCombinator) > -1) {
            scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);
          } else {
            const t = p.replace(_polyfillHostRe, "");
            if (t.length > 0) {
              const matches = t.match(/([^:]*)(:*)(.*)/);
              if (matches) {
                scopedP = matches[1] + attrName + matches[2] + matches[3];
              }
            }
          }
          return scopedP;
        };
        const safeContent = new SafeSelector(selector);
        selector = safeContent.content();
        let scopedSelector = "";
        let startIndex = 0;
        let res;
        const sep = /( |>|\+|~(?!=))\s*/g;
        const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;
        let shouldScope = !hasHost;
        while ((res = sep.exec(selector)) !== null) {
          const separator = res[1];
          const part2 = selector.slice(startIndex, res.index).trim();
          shouldScope = shouldScope || part2.indexOf(_polyfillHostNoCombinator) > -1;
          const scopedPart = shouldScope ? _scopeSelectorPart(part2) : part2;
          scopedSelector += `${scopedPart} ${separator} `;
          startIndex = sep.lastIndex;
        }
        const part = selector.substring(startIndex);
        shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
        scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;
        return safeContent.restore(scopedSelector);
      }
      _insertPolyfillHostInCssText(selector) {
        return selector.replace(_colonHostContextRe, _polyfillHostContext).replace(_colonHostRe, _polyfillHost);
      }
    };
    SafeSelector = class {
      constructor(selector) {
        this.placeholders = [];
        this.index = 0;
        selector = this._escapeRegexMatches(selector, /(\[[^\]]*\])/g);
        selector = this._escapeRegexMatches(selector, /(\\.)/g);
        this._content = selector.replace(/(:nth-[-\w]+)(\([^)]+\))/g, (_, pseudo, exp) => {
          const replaceBy = `__ph-${this.index}__`;
          this.placeholders.push(exp);
          this.index++;
          return pseudo + replaceBy;
        });
      }
      restore(content) {
        return content.replace(/__ph-(\d+)__/g, (_ph, index) => this.placeholders[+index]);
      }
      content() {
        return this._content;
      }
      _escapeRegexMatches(content, pattern) {
        return content.replace(pattern, (_, keep) => {
          const replaceBy = `__ph-${this.index}__`;
          this.placeholders.push(keep);
          this.index++;
          return replaceBy;
        });
      }
    };
    _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?(['"])(.*?)\1[;\s]*}([^{]*?){/gim;
    _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
    _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
    _polyfillHost = "-shadowcsshost";
    _polyfillHostContext = "-shadowcsscontext";
    _parenSuffix = "(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))?([^,{]*)";
    _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix, "gim");
    _cssColonHostContextReGlobal = new RegExp(_polyfillHostContext + _parenSuffix, "gim");
    _cssColonHostContextRe = new RegExp(_polyfillHostContext + _parenSuffix, "im");
    _polyfillHostNoCombinator = _polyfillHost + "-no-combinator";
    _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
    _shadowDOMSelectorsRe = [
      /::shadow/g,
      /::content/g,
      /\/shadow-deep\//g,
      /\/shadow\//g
    ];
    _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)|(?:::ng-deep)/g;
    _selectorReSuffix = "([>\\s~+[.,{:][\\s\\S]*)?$";
    _polyfillHostRe = /-shadowcsshost/gim;
    _colonHostRe = /:host/gim;
    _colonHostContextRe = /:host-context/gim;
    _commentRe = /\/\*[\s\S]*?\*\//g;
    _commentWithHashRe = /\/\*\s*#\s*source(Mapping)?URL=[\s\S]+?\*\//g;
    BLOCK_PLACEHOLDER = "%BLOCK%";
    QUOTE_PLACEHOLDER = "%QUOTED%";
    _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
    _quotedRe = /%QUOTED%/g;
    CONTENT_PAIRS = /* @__PURE__ */ new Map([["{", "}"]]);
    QUOTE_PAIRS = /* @__PURE__ */ new Map([[`"`, `"`], [`'`, `'`]]);
    CssRule = class {
      constructor(selector, content) {
        this.selector = selector;
        this.content = content;
      }
    };
    StringWithEscapedBlocks = class {
      constructor(escapedString, blocks) {
        this.escapedString = escapedString;
        this.blocks = blocks;
      }
    };
    IMPORTANT_FLAG = "!important";
    MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;
    StylingBuilder = class {
      constructor(_directiveExpr) {
        this._directiveExpr = _directiveExpr;
        this._hasInitialValues = false;
        this.hasBindings = false;
        this.hasBindingsWithPipes = false;
        this._classMapInput = null;
        this._styleMapInput = null;
        this._singleStyleInputs = null;
        this._singleClassInputs = null;
        this._lastStylingInput = null;
        this._firstStylingInput = null;
        this._stylesIndex = /* @__PURE__ */ new Map();
        this._classesIndex = /* @__PURE__ */ new Map();
        this._initialStyleValues = [];
        this._initialClassValues = [];
      }
      registerBoundInput(input) {
        let binding = null;
        let name = input.name;
        switch (input.type) {
          case 0:
            binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);
            break;
          case 3:
            binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);
            break;
          case 2:
            binding = this.registerClassInput(name, false, input.value, input.sourceSpan);
            break;
        }
        return binding ? true : false;
      }
      registerInputBasedOnName(name, expression, sourceSpan) {
        let binding = null;
        const prefix = name.substring(0, 6);
        const isStyle = name === "style" || prefix === "style." || prefix === "style!";
        const isClass = !isStyle && (name === "class" || prefix === "class." || prefix === "class!");
        if (isStyle || isClass) {
          const isMapBased = name.charAt(5) !== ".";
          const property = name.slice(isMapBased ? 5 : 6);
          if (isStyle) {
            binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);
          } else {
            binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);
          }
        }
        return binding;
      }
      registerStyleInput(name, isMapBased, value, sourceSpan, suffix) {
        if (isEmptyExpression(value)) {
          return null;
        }
        if (!isCssCustomProperty(name)) {
          name = hyphenate(name);
        }
        const {
          property,
          hasOverrideFlag,
          suffix: bindingSuffix
        } = parseProperty(name);
        suffix = typeof suffix === "string" && suffix.length !== 0 ? suffix : bindingSuffix;
        const entry = {
          name: property,
          suffix,
          value,
          sourceSpan,
          hasOverrideFlag
        };
        if (isMapBased) {
          this._styleMapInput = entry;
        } else {
          (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);
          registerIntoMap(this._stylesIndex, property);
        }
        this._lastStylingInput = entry;
        this._firstStylingInput = this._firstStylingInput || entry;
        this._checkForPipes(value);
        this.hasBindings = true;
        return entry;
      }
      registerClassInput(name, isMapBased, value, sourceSpan) {
        if (isEmptyExpression(value)) {
          return null;
        }
        const {
          property,
          hasOverrideFlag
        } = parseProperty(name);
        const entry = {
          name: property,
          value,
          sourceSpan,
          hasOverrideFlag,
          suffix: null
        };
        if (isMapBased) {
          this._classMapInput = entry;
        } else {
          (this._singleClassInputs = this._singleClassInputs || []).push(entry);
          registerIntoMap(this._classesIndex, property);
        }
        this._lastStylingInput = entry;
        this._firstStylingInput = this._firstStylingInput || entry;
        this._checkForPipes(value);
        this.hasBindings = true;
        return entry;
      }
      _checkForPipes(value) {
        if (value instanceof ASTWithSource && value.ast instanceof BindingPipe) {
          this.hasBindingsWithPipes = true;
        }
      }
      registerStyleAttr(value) {
        this._initialStyleValues = parse(value);
        this._hasInitialValues = true;
      }
      registerClassAttr(value) {
        this._initialClassValues = value.trim().split(/\s+/g);
        this._hasInitialValues = true;
      }
      populateInitialStylingAttrs(attrs) {
        if (this._initialClassValues.length) {
          attrs.push(literal(
            1
          ));
          for (let i = 0; i < this._initialClassValues.length; i++) {
            attrs.push(literal(this._initialClassValues[i]));
          }
        }
        if (this._initialStyleValues.length) {
          attrs.push(literal(
            2
          ));
          for (let i = 0; i < this._initialStyleValues.length; i += 2) {
            attrs.push(literal(this._initialStyleValues[i]), literal(this._initialStyleValues[i + 1]));
          }
        }
      }
      assignHostAttrs(attrs, definitionMap) {
        if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {
          this.populateInitialStylingAttrs(attrs);
          definitionMap.set("hostAttrs", literalArr(attrs));
        }
      }
      buildClassMapInstruction(valueConverter) {
        if (this._classMapInput) {
          return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);
        }
        return null;
      }
      buildStyleMapInstruction(valueConverter) {
        if (this._styleMapInput) {
          return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);
        }
        return null;
      }
      _buildMapBasedInstruction(valueConverter, isClassBased, stylingInput) {
        let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;
        const mapValue = stylingInput.value.visit(valueConverter);
        let reference;
        if (mapValue instanceof Interpolation) {
          totalBindingSlotsRequired += mapValue.expressions.length;
          reference = isClassBased ? getClassMapInterpolationExpression(mapValue) : getStyleMapInterpolationExpression(mapValue);
        } else {
          reference = isClassBased ? Identifiers.classMap : Identifiers.styleMap;
        }
        return {
          reference,
          calls: [{
            supportsInterpolation: true,
            sourceSpan: stylingInput.sourceSpan,
            allocateBindingSlots: totalBindingSlotsRequired,
            params: (convertFn) => {
              const convertResult = convertFn(mapValue);
              const params = Array.isArray(convertResult) ? convertResult : [convertResult];
              return params;
            }
          }]
        };
      }
      _buildSingleInputs(reference, inputs, valueConverter, getInterpolationExpressionFn, isClassBased) {
        const instructions = [];
        inputs.forEach((input) => {
          const previousInstruction = instructions[instructions.length - 1];
          const value = input.value.visit(valueConverter);
          let referenceForCall = reference;
          let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;
          if (value instanceof Interpolation) {
            totalBindingSlotsRequired += value.expressions.length;
            if (getInterpolationExpressionFn) {
              referenceForCall = getInterpolationExpressionFn(value);
            }
          }
          const call = {
            sourceSpan: input.sourceSpan,
            allocateBindingSlots: totalBindingSlotsRequired,
            supportsInterpolation: !!getInterpolationExpressionFn,
            params: (convertFn) => {
              const params = [];
              params.push(literal(input.name));
              const convertResult = convertFn(value);
              if (Array.isArray(convertResult)) {
                params.push(...convertResult);
              } else {
                params.push(convertResult);
              }
              if (!isClassBased && input.suffix !== null) {
                params.push(literal(input.suffix));
              }
              return params;
            }
          };
          if (previousInstruction && previousInstruction.reference === referenceForCall) {
            previousInstruction.calls.push(call);
          } else {
            instructions.push({
              reference: referenceForCall,
              calls: [call]
            });
          }
        });
        return instructions;
      }
      _buildClassInputs(valueConverter) {
        if (this._singleClassInputs) {
          return this._buildSingleInputs(Identifiers.classProp, this._singleClassInputs, valueConverter, null, true);
        }
        return [];
      }
      _buildStyleInputs(valueConverter) {
        if (this._singleStyleInputs) {
          return this._buildSingleInputs(Identifiers.styleProp, this._singleStyleInputs, valueConverter, getStylePropInterpolationExpression, false);
        }
        return [];
      }
      buildUpdateLevelInstructions(valueConverter) {
        const instructions = [];
        if (this.hasBindings) {
          const styleMapInstruction = this.buildStyleMapInstruction(valueConverter);
          if (styleMapInstruction) {
            instructions.push(styleMapInstruction);
          }
          const classMapInstruction = this.buildClassMapInstruction(valueConverter);
          if (classMapInstruction) {
            instructions.push(classMapInstruction);
          }
          instructions.push(...this._buildStyleInputs(valueConverter));
          instructions.push(...this._buildClassInputs(valueConverter));
        }
        return instructions;
      }
    };
    (function(TokenType2) {
      TokenType2[TokenType2["Character"] = 0] = "Character";
      TokenType2[TokenType2["Identifier"] = 1] = "Identifier";
      TokenType2[TokenType2["PrivateIdentifier"] = 2] = "PrivateIdentifier";
      TokenType2[TokenType2["Keyword"] = 3] = "Keyword";
      TokenType2[TokenType2["String"] = 4] = "String";
      TokenType2[TokenType2["Operator"] = 5] = "Operator";
      TokenType2[TokenType2["Number"] = 6] = "Number";
      TokenType2[TokenType2["Error"] = 7] = "Error";
    })(TokenType || (TokenType = {}));
    KEYWORDS = ["var", "let", "as", "null", "undefined", "true", "false", "if", "else", "this"];
    Lexer = class {
      tokenize(text) {
        const scanner = new _Scanner(text);
        const tokens = [];
        let token = scanner.scanToken();
        while (token != null) {
          tokens.push(token);
          token = scanner.scanToken();
        }
        return tokens;
      }
    };
    Token = class {
      constructor(index, end, type, numValue, strValue) {
        this.index = index;
        this.end = end;
        this.type = type;
        this.numValue = numValue;
        this.strValue = strValue;
      }
      isCharacter(code) {
        return this.type == TokenType.Character && this.numValue == code;
      }
      isNumber() {
        return this.type == TokenType.Number;
      }
      isString() {
        return this.type == TokenType.String;
      }
      isOperator(operator) {
        return this.type == TokenType.Operator && this.strValue == operator;
      }
      isIdentifier() {
        return this.type == TokenType.Identifier;
      }
      isPrivateIdentifier() {
        return this.type == TokenType.PrivateIdentifier;
      }
      isKeyword() {
        return this.type == TokenType.Keyword;
      }
      isKeywordLet() {
        return this.type == TokenType.Keyword && this.strValue == "let";
      }
      isKeywordAs() {
        return this.type == TokenType.Keyword && this.strValue == "as";
      }
      isKeywordNull() {
        return this.type == TokenType.Keyword && this.strValue == "null";
      }
      isKeywordUndefined() {
        return this.type == TokenType.Keyword && this.strValue == "undefined";
      }
      isKeywordTrue() {
        return this.type == TokenType.Keyword && this.strValue == "true";
      }
      isKeywordFalse() {
        return this.type == TokenType.Keyword && this.strValue == "false";
      }
      isKeywordThis() {
        return this.type == TokenType.Keyword && this.strValue == "this";
      }
      isError() {
        return this.type == TokenType.Error;
      }
      toNumber() {
        return this.type == TokenType.Number ? this.numValue : -1;
      }
      toString() {
        switch (this.type) {
          case TokenType.Character:
          case TokenType.Identifier:
          case TokenType.Keyword:
          case TokenType.Operator:
          case TokenType.PrivateIdentifier:
          case TokenType.String:
          case TokenType.Error:
            return this.strValue;
          case TokenType.Number:
            return this.numValue.toString();
          default:
            return null;
        }
      }
    };
    EOF = new Token(-1, -1, TokenType.Character, 0, "");
    _Scanner = class {
      constructor(input) {
        this.input = input;
        this.peek = 0;
        this.index = -1;
        this.length = input.length;
        this.advance();
      }
      advance() {
        this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);
      }
      scanToken() {
        const input = this.input, length = this.length;
        let peek = this.peek, index = this.index;
        while (peek <= $SPACE) {
          if (++index >= length) {
            peek = $EOF;
            break;
          } else {
            peek = input.charCodeAt(index);
          }
        }
        this.peek = peek;
        this.index = index;
        if (index >= length) {
          return null;
        }
        if (isIdentifierStart(peek))
          return this.scanIdentifier();
        if (isDigit(peek))
          return this.scanNumber(index);
        const start = index;
        switch (peek) {
          case $PERIOD:
            this.advance();
            return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, this.index, $PERIOD);
          case $LPAREN:
          case $RPAREN:
          case $LBRACE:
          case $RBRACE:
          case $LBRACKET:
          case $RBRACKET:
          case $COMMA:
          case $COLON:
          case $SEMICOLON:
            return this.scanCharacter(start, peek);
          case $SQ:
          case $DQ:
            return this.scanString();
          case $HASH:
            return this.scanPrivateIdentifier();
          case $PLUS:
          case $MINUS:
          case $STAR:
          case $SLASH:
          case $PERCENT:
          case $CARET:
            return this.scanOperator(start, String.fromCharCode(peek));
          case $QUESTION:
            return this.scanQuestion(start);
          case $LT:
          case $GT:
            return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, "=");
          case $BANG:
          case $EQ:
            return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, "=", $EQ, "=");
          case $AMPERSAND:
            return this.scanComplexOperator(start, "&", $AMPERSAND, "&");
          case $BAR:
            return this.scanComplexOperator(start, "|", $BAR, "|");
          case $NBSP:
            while (isWhitespace(this.peek))
              this.advance();
            return this.scanToken();
        }
        this.advance();
        return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);
      }
      scanCharacter(start, code) {
        this.advance();
        return newCharacterToken(start, this.index, code);
      }
      scanOperator(start, str) {
        this.advance();
        return newOperatorToken(start, this.index, str);
      }
      scanComplexOperator(start, one, twoCode, two, threeCode, three) {
        this.advance();
        let str = one;
        if (this.peek == twoCode) {
          this.advance();
          str += two;
        }
        if (threeCode != null && this.peek == threeCode) {
          this.advance();
          str += three;
        }
        return newOperatorToken(start, this.index, str);
      }
      scanIdentifier() {
        const start = this.index;
        this.advance();
        while (isIdentifierPart(this.peek))
          this.advance();
        const str = this.input.substring(start, this.index);
        return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) : newIdentifierToken(start, this.index, str);
      }
      scanPrivateIdentifier() {
        const start = this.index;
        this.advance();
        if (!isIdentifierStart(this.peek)) {
          return this.error("Invalid character [#]", -1);
        }
        while (isIdentifierPart(this.peek))
          this.advance();
        const identifierName2 = this.input.substring(start, this.index);
        return newPrivateIdentifierToken(start, this.index, identifierName2);
      }
      scanNumber(start) {
        let simple = this.index === start;
        let hasSeparators = false;
        this.advance();
        while (true) {
          if (isDigit(this.peek)) {
          } else if (this.peek === $_) {
            if (!isDigit(this.input.charCodeAt(this.index - 1)) || !isDigit(this.input.charCodeAt(this.index + 1))) {
              return this.error("Invalid numeric separator", 0);
            }
            hasSeparators = true;
          } else if (this.peek === $PERIOD) {
            simple = false;
          } else if (isExponentStart(this.peek)) {
            this.advance();
            if (isExponentSign(this.peek))
              this.advance();
            if (!isDigit(this.peek))
              return this.error("Invalid exponent", -1);
            simple = false;
          } else {
            break;
          }
          this.advance();
        }
        let str = this.input.substring(start, this.index);
        if (hasSeparators) {
          str = str.replace(/_/g, "");
        }
        const value = simple ? parseIntAutoRadix2(str) : parseFloat(str);
        return newNumberToken(start, this.index, value);
      }
      scanString() {
        const start = this.index;
        const quote = this.peek;
        this.advance();
        let buffer2 = "";
        let marker = this.index;
        const input = this.input;
        while (this.peek != quote) {
          if (this.peek == $BACKSLASH) {
            buffer2 += input.substring(marker, this.index);
            this.advance();
            let unescapedCode;
            this.peek = this.peek;
            if (this.peek == $u) {
              const hex = input.substring(this.index + 1, this.index + 5);
              if (/^[0-9a-f]+$/i.test(hex)) {
                unescapedCode = parseInt(hex, 16);
              } else {
                return this.error(`Invalid unicode escape [\\u${hex}]`, 0);
              }
              for (let i = 0; i < 5; i++) {
                this.advance();
              }
            } else {
              unescapedCode = unescape(this.peek);
              this.advance();
            }
            buffer2 += String.fromCharCode(unescapedCode);
            marker = this.index;
          } else if (this.peek == $EOF) {
            return this.error("Unterminated quote", 0);
          } else {
            this.advance();
          }
        }
        const last3 = input.substring(marker, this.index);
        this.advance();
        return newStringToken(start, this.index, buffer2 + last3);
      }
      scanQuestion(start) {
        this.advance();
        let str = "?";
        if (this.peek === $QUESTION || this.peek === $PERIOD) {
          str += this.peek === $PERIOD ? "." : "?";
          this.advance();
        }
        return newOperatorToken(start, this.index, str);
      }
      error(message, offset) {
        const position = this.index + offset;
        return newErrorToken(position, this.index, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);
      }
    };
    SplitInterpolation = class {
      constructor(strings, expressions, offsets) {
        this.strings = strings;
        this.expressions = expressions;
        this.offsets = offsets;
      }
    };
    TemplateBindingParseResult = class {
      constructor(templateBindings, warnings, errors) {
        this.templateBindings = templateBindings;
        this.warnings = warnings;
        this.errors = errors;
      }
    };
    Parser$1 = class {
      constructor(_lexer) {
        this._lexer = _lexer;
        this.errors = [];
      }
      parseAction(input, isAssignmentEvent, location2, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
        this._checkNoInterpolation(input, location2, interpolationConfig);
        const sourceToLex = this._stripComments(input);
        const tokens = this._lexer.tokenize(sourceToLex);
        let flags = 1;
        if (isAssignmentEvent) {
          flags |= 2;
        }
        const ast = new _ParseAST(input, location2, absoluteOffset, tokens, flags, this.errors, 0).parseChain();
        return new ASTWithSource(ast, input, location2, absoluteOffset, this.errors);
      }
      parseBinding(input, location2, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
        const ast = this._parseBindingAst(input, location2, absoluteOffset, interpolationConfig);
        return new ASTWithSource(ast, input, location2, absoluteOffset, this.errors);
      }
      checkSimpleExpression(ast) {
        const checker = new SimpleExpressionChecker();
        ast.visit(checker);
        return checker.errors;
      }
      parseSimpleBinding(input, location2, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
        const ast = this._parseBindingAst(input, location2, absoluteOffset, interpolationConfig);
        const errors = this.checkSimpleExpression(ast);
        if (errors.length > 0) {
          this._reportError(`Host binding expression cannot contain ${errors.join(" ")}`, input, location2);
        }
        return new ASTWithSource(ast, input, location2, absoluteOffset, this.errors);
      }
      _reportError(message, input, errLocation, ctxLocation) {
        this.errors.push(new ParserError(message, input, errLocation, ctxLocation));
      }
      _parseBindingAst(input, location2, absoluteOffset, interpolationConfig) {
        this._checkNoInterpolation(input, location2, interpolationConfig);
        const sourceToLex = this._stripComments(input);
        const tokens = this._lexer.tokenize(sourceToLex);
        return new _ParseAST(
          input,
          location2,
          absoluteOffset,
          tokens,
          0,
          this.errors,
          0
        ).parseChain();
      }
      parseTemplateBindings(templateKey, templateValue, templateUrl, absoluteKeyOffset, absoluteValueOffset) {
        const tokens = this._lexer.tokenize(templateValue);
        const parser = new _ParseAST(
          templateValue,
          templateUrl,
          absoluteValueOffset,
          tokens,
          0,
          this.errors,
          0
        );
        return parser.parseTemplateBindings({
          source: templateKey,
          span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length)
        });
      }
      parseInterpolation(input, location2, absoluteOffset, interpolatedTokens, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
        const {
          strings,
          expressions,
          offsets
        } = this.splitInterpolation(input, location2, interpolatedTokens, interpolationConfig);
        if (expressions.length === 0)
          return null;
        const expressionNodes = [];
        for (let i = 0; i < expressions.length; ++i) {
          const expressionText = expressions[i].text;
          const sourceToLex = this._stripComments(expressionText);
          const tokens = this._lexer.tokenize(sourceToLex);
          const ast = new _ParseAST(
            input,
            location2,
            absoluteOffset,
            tokens,
            0,
            this.errors,
            offsets[i]
          ).parseChain();
          expressionNodes.push(ast);
        }
        return this.createInterpolationAst(strings.map((s) => s.text), expressionNodes, input, location2, absoluteOffset);
      }
      parseInterpolationExpression(expression, location2, absoluteOffset) {
        const sourceToLex = this._stripComments(expression);
        const tokens = this._lexer.tokenize(sourceToLex);
        const ast = new _ParseAST(
          expression,
          location2,
          absoluteOffset,
          tokens,
          0,
          this.errors,
          0
        ).parseChain();
        const strings = ["", ""];
        return this.createInterpolationAst(strings, [ast], expression, location2, absoluteOffset);
      }
      createInterpolationAst(strings, expressions, input, location2, absoluteOffset) {
        const span = new ParseSpan(0, input.length);
        const interpolation = new Interpolation(span, span.toAbsolute(absoluteOffset), strings, expressions);
        return new ASTWithSource(interpolation, input, location2, absoluteOffset, this.errors);
      }
      splitInterpolation(input, location2, interpolatedTokens, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
        var _a;
        const strings = [];
        const expressions = [];
        const offsets = [];
        const inputToTemplateIndexMap = interpolatedTokens ? getIndexMapForOriginalTemplate(interpolatedTokens) : null;
        let i = 0;
        let atInterpolation = false;
        let extendLastString = false;
        let {
          start: interpStart,
          end: interpEnd
        } = interpolationConfig;
        while (i < input.length) {
          if (!atInterpolation) {
            const start = i;
            i = input.indexOf(interpStart, i);
            if (i === -1) {
              i = input.length;
            }
            const text = input.substring(start, i);
            strings.push({
              text,
              start,
              end: i
            });
            atInterpolation = true;
          } else {
            const fullStart = i;
            const exprStart = fullStart + interpStart.length;
            const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);
            if (exprEnd === -1) {
              atInterpolation = false;
              extendLastString = true;
              break;
            }
            const fullEnd = exprEnd + interpEnd.length;
            const text = input.substring(exprStart, exprEnd);
            if (text.trim().length === 0) {
              this._reportError("Blank expressions are not allowed in interpolated strings", input, `at column ${i} in`, location2);
            }
            expressions.push({
              text,
              start: fullStart,
              end: fullEnd
            });
            const startInOriginalTemplate = (_a = inputToTemplateIndexMap === null || inputToTemplateIndexMap === void 0 ? void 0 : inputToTemplateIndexMap.get(fullStart)) !== null && _a !== void 0 ? _a : fullStart;
            const offset = startInOriginalTemplate + interpStart.length;
            offsets.push(offset);
            i = fullEnd;
            atInterpolation = false;
          }
        }
        if (!atInterpolation) {
          if (extendLastString) {
            const piece = strings[strings.length - 1];
            piece.text += input.substring(i);
            piece.end = input.length;
          } else {
            strings.push({
              text: input.substring(i),
              start: i,
              end: input.length
            });
          }
        }
        return new SplitInterpolation(strings, expressions, offsets);
      }
      wrapLiteralPrimitive(input, location2, absoluteOffset) {
        const span = new ParseSpan(0, input == null ? 0 : input.length);
        return new ASTWithSource(new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location2, absoluteOffset, this.errors);
      }
      _stripComments(input) {
        const i = this._commentStart(input);
        return i != null ? input.substring(0, i) : input;
      }
      _commentStart(input) {
        let outerQuote = null;
        for (let i = 0; i < input.length - 1; i++) {
          const char = input.charCodeAt(i);
          const nextChar = input.charCodeAt(i + 1);
          if (char === $SLASH && nextChar == $SLASH && outerQuote == null)
            return i;
          if (outerQuote === char) {
            outerQuote = null;
          } else if (outerQuote == null && isQuote(char)) {
            outerQuote = char;
          }
        }
        return null;
      }
      _checkNoInterpolation(input, location2, {
        start,
        end
      }) {
        let startIndex = -1;
        let endIndex = -1;
        for (const charIndex of this._forEachUnquotedChar(input, 0)) {
          if (startIndex === -1) {
            if (input.startsWith(start)) {
              startIndex = charIndex;
            }
          } else {
            endIndex = this._getInterpolationEndIndex(input, end, charIndex);
            if (endIndex > -1) {
              break;
            }
          }
        }
        if (startIndex > -1 && endIndex > -1) {
          this._reportError(`Got interpolation (${start}${end}) where expression was expected`, input, `at column ${startIndex} in`, location2);
        }
      }
      _getInterpolationEndIndex(input, expressionEnd, start) {
        for (const charIndex of this._forEachUnquotedChar(input, start)) {
          if (input.startsWith(expressionEnd, charIndex)) {
            return charIndex;
          }
          if (input.startsWith("//", charIndex)) {
            return input.indexOf(expressionEnd, charIndex);
          }
        }
        return -1;
      }
      *_forEachUnquotedChar(input, start) {
        let currentQuote = null;
        let escapeCount = 0;
        for (let i = start; i < input.length; i++) {
          const char = input[i];
          if (isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) && escapeCount % 2 === 0) {
            currentQuote = currentQuote === null ? char : null;
          } else if (currentQuote === null) {
            yield i;
          }
          escapeCount = char === "\\" ? escapeCount + 1 : 0;
        }
      }
    };
    (function(ParseContextFlags2) {
      ParseContextFlags2[ParseContextFlags2["None"] = 0] = "None";
      ParseContextFlags2[ParseContextFlags2["Writable"] = 1] = "Writable";
    })(ParseContextFlags || (ParseContextFlags = {}));
    _ParseAST = class {
      constructor(input, location2, absoluteOffset, tokens, parseFlags, errors, offset) {
        this.input = input;
        this.location = location2;
        this.absoluteOffset = absoluteOffset;
        this.tokens = tokens;
        this.parseFlags = parseFlags;
        this.errors = errors;
        this.offset = offset;
        this.rparensExpected = 0;
        this.rbracketsExpected = 0;
        this.rbracesExpected = 0;
        this.context = ParseContextFlags.None;
        this.sourceSpanCache = /* @__PURE__ */ new Map();
        this.index = 0;
      }
      peek(offset) {
        const i = this.index + offset;
        return i < this.tokens.length ? this.tokens[i] : EOF;
      }
      get next() {
        return this.peek(0);
      }
      get atEOF() {
        return this.index >= this.tokens.length;
      }
      get inputIndex() {
        return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;
      }
      get currentEndIndex() {
        if (this.index > 0) {
          const curToken = this.peek(-1);
          return curToken.end + this.offset;
        }
        if (this.tokens.length === 0) {
          return this.input.length + this.offset;
        }
        return this.next.index + this.offset;
      }
      get currentAbsoluteOffset() {
        return this.absoluteOffset + this.inputIndex;
      }
      span(start, artificialEndIndex) {
        let endIndex = this.currentEndIndex;
        if (artificialEndIndex !== void 0 && artificialEndIndex > this.currentEndIndex) {
          endIndex = artificialEndIndex;
        }
        if (start > endIndex) {
          const tmp = endIndex;
          endIndex = start;
          start = tmp;
        }
        return new ParseSpan(start, endIndex);
      }
      sourceSpan(start, artificialEndIndex) {
        const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;
        if (!this.sourceSpanCache.has(serial)) {
          this.sourceSpanCache.set(serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));
        }
        return this.sourceSpanCache.get(serial);
      }
      advance() {
        this.index++;
      }
      withContext(context2, cb) {
        this.context |= context2;
        const ret = cb();
        this.context ^= context2;
        return ret;
      }
      consumeOptionalCharacter(code) {
        if (this.next.isCharacter(code)) {
          this.advance();
          return true;
        } else {
          return false;
        }
      }
      peekKeywordLet() {
        return this.next.isKeywordLet();
      }
      peekKeywordAs() {
        return this.next.isKeywordAs();
      }
      expectCharacter(code) {
        if (this.consumeOptionalCharacter(code))
          return;
        this.error(`Missing expected ${String.fromCharCode(code)}`);
      }
      consumeOptionalOperator(op) {
        if (this.next.isOperator(op)) {
          this.advance();
          return true;
        } else {
          return false;
        }
      }
      expectOperator(operator) {
        if (this.consumeOptionalOperator(operator))
          return;
        this.error(`Missing expected operator ${operator}`);
      }
      prettyPrintToken(tok) {
        return tok === EOF ? "end of input" : `token ${tok}`;
      }
      expectIdentifierOrKeyword() {
        const n = this.next;
        if (!n.isIdentifier() && !n.isKeyword()) {
          if (n.isPrivateIdentifier()) {
            this._reportErrorForPrivateIdentifier(n, "expected identifier or keyword");
          } else {
            this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);
          }
          return null;
        }
        this.advance();
        return n.toString();
      }
      expectIdentifierOrKeywordOrString() {
        const n = this.next;
        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
          if (n.isPrivateIdentifier()) {
            this._reportErrorForPrivateIdentifier(n, "expected identifier, keyword or string");
          } else {
            this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier, keyword, or string`);
          }
          return "";
        }
        this.advance();
        return n.toString();
      }
      parseChain() {
        const exprs = [];
        const start = this.inputIndex;
        while (this.index < this.tokens.length) {
          const expr = this.parsePipe();
          exprs.push(expr);
          if (this.consumeOptionalCharacter($SEMICOLON)) {
            if (!(this.parseFlags & 1)) {
              this.error("Binding expression cannot contain chained expression");
            }
            while (this.consumeOptionalCharacter($SEMICOLON)) {
            }
          } else if (this.index < this.tokens.length) {
            this.error(`Unexpected token '${this.next}'`);
          }
        }
        if (exprs.length == 0) {
          const artificialStart = this.offset;
          const artificialEnd = this.offset + this.input.length;
          return new EmptyExpr(this.span(artificialStart, artificialEnd), this.sourceSpan(artificialStart, artificialEnd));
        }
        if (exprs.length == 1)
          return exprs[0];
        return new Chain(this.span(start), this.sourceSpan(start), exprs);
      }
      parsePipe() {
        const start = this.inputIndex;
        let result = this.parseExpression();
        if (this.consumeOptionalOperator("|")) {
          if (this.parseFlags & 1) {
            this.error("Cannot have a pipe in an action expression");
          }
          do {
            const nameStart = this.inputIndex;
            let nameId = this.expectIdentifierOrKeyword();
            let nameSpan;
            let fullSpanEnd = void 0;
            if (nameId !== null) {
              nameSpan = this.sourceSpan(nameStart);
            } else {
              nameId = "";
              fullSpanEnd = this.next.index !== -1 ? this.next.index : this.input.length + this.offset;
              nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);
            }
            const args = [];
            while (this.consumeOptionalCharacter($COLON)) {
              args.push(this.parseExpression());
            }
            result = new BindingPipe(this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);
          } while (this.consumeOptionalOperator("|"));
        }
        return result;
      }
      parseExpression() {
        return this.parseConditional();
      }
      parseConditional() {
        const start = this.inputIndex;
        const result = this.parseLogicalOr();
        if (this.consumeOptionalOperator("?")) {
          const yes = this.parsePipe();
          let no;
          if (!this.consumeOptionalCharacter($COLON)) {
            const end = this.inputIndex;
            const expression = this.input.substring(start, end);
            this.error(`Conditional expression ${expression} requires all 3 expressions`);
            no = new EmptyExpr(this.span(start), this.sourceSpan(start));
          } else {
            no = this.parsePipe();
          }
          return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);
        } else {
          return result;
        }
      }
      parseLogicalOr() {
        const start = this.inputIndex;
        let result = this.parseLogicalAnd();
        while (this.consumeOptionalOperator("||")) {
          const right = this.parseLogicalAnd();
          result = new Binary(this.span(start), this.sourceSpan(start), "||", result, right);
        }
        return result;
      }
      parseLogicalAnd() {
        const start = this.inputIndex;
        let result = this.parseNullishCoalescing();
        while (this.consumeOptionalOperator("&&")) {
          const right = this.parseNullishCoalescing();
          result = new Binary(this.span(start), this.sourceSpan(start), "&&", result, right);
        }
        return result;
      }
      parseNullishCoalescing() {
        const start = this.inputIndex;
        let result = this.parseEquality();
        while (this.consumeOptionalOperator("??")) {
          const right = this.parseEquality();
          result = new Binary(this.span(start), this.sourceSpan(start), "??", result, right);
        }
        return result;
      }
      parseEquality() {
        const start = this.inputIndex;
        let result = this.parseRelational();
        while (this.next.type == TokenType.Operator) {
          const operator = this.next.strValue;
          switch (operator) {
            case "==":
            case "===":
            case "!=":
            case "!==":
              this.advance();
              const right = this.parseRelational();
              result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
              continue;
          }
          break;
        }
        return result;
      }
      parseRelational() {
        const start = this.inputIndex;
        let result = this.parseAdditive();
        while (this.next.type == TokenType.Operator) {
          const operator = this.next.strValue;
          switch (operator) {
            case "<":
            case ">":
            case "<=":
            case ">=":
              this.advance();
              const right = this.parseAdditive();
              result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
              continue;
          }
          break;
        }
        return result;
      }
      parseAdditive() {
        const start = this.inputIndex;
        let result = this.parseMultiplicative();
        while (this.next.type == TokenType.Operator) {
          const operator = this.next.strValue;
          switch (operator) {
            case "+":
            case "-":
              this.advance();
              let right = this.parseMultiplicative();
              result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
              continue;
          }
          break;
        }
        return result;
      }
      parseMultiplicative() {
        const start = this.inputIndex;
        let result = this.parsePrefix();
        while (this.next.type == TokenType.Operator) {
          const operator = this.next.strValue;
          switch (operator) {
            case "*":
            case "%":
            case "/":
              this.advance();
              let right = this.parsePrefix();
              result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
              continue;
          }
          break;
        }
        return result;
      }
      parsePrefix() {
        if (this.next.type == TokenType.Operator) {
          const start = this.inputIndex;
          const operator = this.next.strValue;
          let result;
          switch (operator) {
            case "+":
              this.advance();
              result = this.parsePrefix();
              return Unary.createPlus(this.span(start), this.sourceSpan(start), result);
            case "-":
              this.advance();
              result = this.parsePrefix();
              return Unary.createMinus(this.span(start), this.sourceSpan(start), result);
            case "!":
              this.advance();
              result = this.parsePrefix();
              return new PrefixNot(this.span(start), this.sourceSpan(start), result);
          }
        }
        return this.parseCallChain();
      }
      parseCallChain() {
        const start = this.inputIndex;
        let result = this.parsePrimary();
        while (true) {
          if (this.consumeOptionalCharacter($PERIOD)) {
            result = this.parseAccessMember(result, start, false);
          } else if (this.consumeOptionalOperator("?.")) {
            if (this.consumeOptionalCharacter($LPAREN)) {
              result = this.parseCall(result, start, true);
            } else {
              result = this.consumeOptionalCharacter($LBRACKET) ? this.parseKeyedReadOrWrite(result, start, true) : this.parseAccessMember(result, start, true);
            }
          } else if (this.consumeOptionalCharacter($LBRACKET)) {
            result = this.parseKeyedReadOrWrite(result, start, false);
          } else if (this.consumeOptionalCharacter($LPAREN)) {
            result = this.parseCall(result, start, false);
          } else if (this.consumeOptionalOperator("!")) {
            result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);
          } else {
            return result;
          }
        }
      }
      parsePrimary() {
        const start = this.inputIndex;
        if (this.consumeOptionalCharacter($LPAREN)) {
          this.rparensExpected++;
          const result = this.parsePipe();
          this.rparensExpected--;
          this.expectCharacter($RPAREN);
          return result;
        } else if (this.next.isKeywordNull()) {
          this.advance();
          return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);
        } else if (this.next.isKeywordUndefined()) {
          this.advance();
          return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);
        } else if (this.next.isKeywordTrue()) {
          this.advance();
          return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);
        } else if (this.next.isKeywordFalse()) {
          this.advance();
          return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);
        } else if (this.next.isKeywordThis()) {
          this.advance();
          return new ThisReceiver(this.span(start), this.sourceSpan(start));
        } else if (this.consumeOptionalCharacter($LBRACKET)) {
          this.rbracketsExpected++;
          const elements = this.parseExpressionList($RBRACKET);
          this.rbracketsExpected--;
          this.expectCharacter($RBRACKET);
          return new LiteralArray(this.span(start), this.sourceSpan(start), elements);
        } else if (this.next.isCharacter($LBRACE)) {
          return this.parseLiteralMap();
        } else if (this.next.isIdentifier()) {
          return this.parseAccessMember(new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);
        } else if (this.next.isNumber()) {
          const value = this.next.toNumber();
          this.advance();
          return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);
        } else if (this.next.isString()) {
          const literalValue = this.next.toString();
          this.advance();
          return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);
        } else if (this.next.isPrivateIdentifier()) {
          this._reportErrorForPrivateIdentifier(this.next, null);
          return new EmptyExpr(this.span(start), this.sourceSpan(start));
        } else if (this.index >= this.tokens.length) {
          this.error(`Unexpected end of expression: ${this.input}`);
          return new EmptyExpr(this.span(start), this.sourceSpan(start));
        } else {
          this.error(`Unexpected token ${this.next}`);
          return new EmptyExpr(this.span(start), this.sourceSpan(start));
        }
      }
      parseExpressionList(terminator) {
        const result = [];
        do {
          if (!this.next.isCharacter(terminator)) {
            result.push(this.parsePipe());
          } else {
            break;
          }
        } while (this.consumeOptionalCharacter($COMMA));
        return result;
      }
      parseLiteralMap() {
        const keys = [];
        const values = [];
        const start = this.inputIndex;
        this.expectCharacter($LBRACE);
        if (!this.consumeOptionalCharacter($RBRACE)) {
          this.rbracesExpected++;
          do {
            const keyStart = this.inputIndex;
            const quoted = this.next.isString();
            const key = this.expectIdentifierOrKeywordOrString();
            keys.push({
              key,
              quoted
            });
            if (quoted) {
              this.expectCharacter($COLON);
              values.push(this.parsePipe());
            } else if (this.consumeOptionalCharacter($COLON)) {
              values.push(this.parsePipe());
            } else {
              const span = this.span(keyStart);
              const sourceSpan = this.sourceSpan(keyStart);
              values.push(new PropertyRead(span, sourceSpan, sourceSpan, new ImplicitReceiver(span, sourceSpan), key));
            }
          } while (this.consumeOptionalCharacter($COMMA));
          this.rbracesExpected--;
          this.expectCharacter($RBRACE);
        }
        return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);
      }
      parseAccessMember(readReceiver, start, isSafe) {
        const nameStart = this.inputIndex;
        const id = this.withContext(ParseContextFlags.Writable, () => {
          var _a;
          const id2 = (_a = this.expectIdentifierOrKeyword()) !== null && _a !== void 0 ? _a : "";
          if (id2.length === 0) {
            this.error(`Expected identifier for property access`, readReceiver.span.end);
          }
          return id2;
        });
        const nameSpan = this.sourceSpan(nameStart);
        let receiver;
        if (isSafe) {
          if (this.consumeOptionalAssignment()) {
            this.error("The '?.' operator cannot be used in the assignment");
            receiver = new EmptyExpr(this.span(start), this.sourceSpan(start));
          } else {
            receiver = new SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);
          }
        } else {
          if (this.consumeOptionalAssignment()) {
            if (!(this.parseFlags & 1)) {
              this.error("Bindings cannot contain assignments");
              return new EmptyExpr(this.span(start), this.sourceSpan(start));
            }
            const value = this.parseConditional();
            receiver = new PropertyWrite(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id, value);
          } else {
            receiver = new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);
          }
        }
        return receiver;
      }
      parseCall(receiver, start, isSafe) {
        const argumentStart = this.inputIndex;
        this.rparensExpected++;
        const args = this.parseCallArguments();
        const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);
        this.expectCharacter($RPAREN);
        this.rparensExpected--;
        const span = this.span(start);
        const sourceSpan = this.sourceSpan(start);
        return isSafe ? new SafeCall(span, sourceSpan, receiver, args, argumentSpan) : new Call(span, sourceSpan, receiver, args, argumentSpan);
      }
      consumeOptionalAssignment() {
        if (this.parseFlags & 2 && this.next.isOperator("!") && this.peek(1).isOperator("=")) {
          this.advance();
          this.advance();
          return true;
        }
        return this.consumeOptionalOperator("=");
      }
      parseCallArguments() {
        if (this.next.isCharacter($RPAREN))
          return [];
        const positionals = [];
        do {
          positionals.push(this.parsePipe());
        } while (this.consumeOptionalCharacter($COMMA));
        return positionals;
      }
      expectTemplateBindingKey() {
        let result = "";
        let operatorFound = false;
        const start = this.currentAbsoluteOffset;
        do {
          result += this.expectIdentifierOrKeywordOrString();
          operatorFound = this.consumeOptionalOperator("-");
          if (operatorFound) {
            result += "-";
          }
        } while (operatorFound);
        return {
          source: result,
          span: new AbsoluteSourceSpan(start, start + result.length)
        };
      }
      parseTemplateBindings(templateKey) {
        const bindings = [];
        bindings.push(...this.parseDirectiveKeywordBindings(templateKey));
        while (this.index < this.tokens.length) {
          const letBinding = this.parseLetBinding();
          if (letBinding) {
            bindings.push(letBinding);
          } else {
            const key = this.expectTemplateBindingKey();
            const binding = this.parseAsBinding(key);
            if (binding) {
              bindings.push(binding);
            } else {
              key.source = templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);
              bindings.push(...this.parseDirectiveKeywordBindings(key));
            }
          }
          this.consumeStatementTerminator();
        }
        return new TemplateBindingParseResult(
          bindings,
          [],
          this.errors
        );
      }
      parseKeyedReadOrWrite(receiver, start, isSafe) {
        return this.withContext(ParseContextFlags.Writable, () => {
          this.rbracketsExpected++;
          const key = this.parsePipe();
          if (key instanceof EmptyExpr) {
            this.error(`Key access cannot be empty`);
          }
          this.rbracketsExpected--;
          this.expectCharacter($RBRACKET);
          if (this.consumeOptionalOperator("=")) {
            if (isSafe) {
              this.error("The '?.' operator cannot be used in the assignment");
            } else {
              const value = this.parseConditional();
              return new KeyedWrite(this.span(start), this.sourceSpan(start), receiver, key, value);
            }
          } else {
            return isSafe ? new SafeKeyedRead(this.span(start), this.sourceSpan(start), receiver, key) : new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);
          }
          return new EmptyExpr(this.span(start), this.sourceSpan(start));
        });
      }
      parseDirectiveKeywordBindings(key) {
        const bindings = [];
        this.consumeOptionalCharacter($COLON);
        const value = this.getDirectiveBoundTarget();
        let spanEnd = this.currentAbsoluteOffset;
        const asBinding = this.parseAsBinding(key);
        if (!asBinding) {
          this.consumeStatementTerminator();
          spanEnd = this.currentAbsoluteOffset;
        }
        const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);
        bindings.push(new ExpressionBinding(sourceSpan, key, value));
        if (asBinding) {
          bindings.push(asBinding);
        }
        return bindings;
      }
      getDirectiveBoundTarget() {
        if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {
          return null;
        }
        const ast = this.parsePipe();
        const {
          start,
          end
        } = ast.span;
        const value = this.input.substring(start, end);
        return new ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);
      }
      parseAsBinding(value) {
        if (!this.peekKeywordAs()) {
          return null;
        }
        this.advance();
        const key = this.expectTemplateBindingKey();
        this.consumeStatementTerminator();
        const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);
        return new VariableBinding(sourceSpan, key, value);
      }
      parseLetBinding() {
        if (!this.peekKeywordLet()) {
          return null;
        }
        const spanStart = this.currentAbsoluteOffset;
        this.advance();
        const key = this.expectTemplateBindingKey();
        let value = null;
        if (this.consumeOptionalOperator("=")) {
          value = this.expectTemplateBindingKey();
        }
        this.consumeStatementTerminator();
        const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);
        return new VariableBinding(sourceSpan, key, value);
      }
      consumeStatementTerminator() {
        this.consumeOptionalCharacter($SEMICOLON) || this.consumeOptionalCharacter($COMMA);
      }
      error(message, index = null) {
        this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));
        this.skip();
      }
      locationText(index = null) {
        if (index == null)
          index = this.index;
        return index < this.tokens.length ? `at column ${this.tokens[index].index + 1} in` : `at the end of the expression`;
      }
      _reportErrorForPrivateIdentifier(token, extraMessage) {
        let errorMessage = `Private identifiers are not supported. Unexpected private identifier: ${token}`;
        if (extraMessage !== null) {
          errorMessage += `, ${extraMessage}`;
        }
        this.error(errorMessage);
      }
      skip() {
        let n = this.next;
        while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) && !n.isOperator("|") && (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) && (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) && (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET)) && (!(this.context & ParseContextFlags.Writable) || !n.isOperator("="))) {
          if (this.next.isError()) {
            this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));
          }
          this.advance();
          n = this.next;
        }
      }
    };
    SimpleExpressionChecker = class extends RecursiveAstVisitor {
      constructor() {
        super(...arguments);
        this.errors = [];
      }
      visitPipe() {
        this.errors.push("pipes");
      }
    };
    NodeWithI18n = class {
      constructor(sourceSpan, i18n) {
        this.sourceSpan = sourceSpan;
        this.i18n = i18n;
      }
    };
    Text2 = class extends NodeWithI18n {
      constructor(value, sourceSpan, tokens, i18n) {
        super(sourceSpan, i18n);
        this.value = value;
        this.tokens = tokens;
      }
      visit(visitor, context2) {
        return visitor.visitText(this, context2);
      }
    };
    Expansion = class extends NodeWithI18n {
      constructor(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {
        super(sourceSpan, i18n);
        this.switchValue = switchValue;
        this.type = type;
        this.cases = cases;
        this.switchValueSourceSpan = switchValueSourceSpan;
      }
      visit(visitor, context2) {
        return visitor.visitExpansion(this, context2);
      }
    };
    ExpansionCase = class {
      constructor(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {
        this.value = value;
        this.expression = expression;
        this.sourceSpan = sourceSpan;
        this.valueSourceSpan = valueSourceSpan;
        this.expSourceSpan = expSourceSpan;
      }
      visit(visitor, context2) {
        return visitor.visitExpansionCase(this, context2);
      }
    };
    Attribute2 = class extends NodeWithI18n {
      constructor(name, value, sourceSpan, keySpan, valueSpan, valueTokens, i18n) {
        super(sourceSpan, i18n);
        this.name = name;
        this.value = value;
        this.keySpan = keySpan;
        this.valueSpan = valueSpan;
        this.valueTokens = valueTokens;
      }
      visit(visitor, context2) {
        return visitor.visitAttribute(this, context2);
      }
    };
    Element2 = class extends NodeWithI18n {
      constructor(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan = null, i18n) {
        super(sourceSpan, i18n);
        this.name = name;
        this.attrs = attrs;
        this.children = children;
        this.startSourceSpan = startSourceSpan;
        this.endSourceSpan = endSourceSpan;
      }
      visit(visitor, context2) {
        return visitor.visitElement(this, context2);
      }
    };
    Comment = class {
      constructor(value, sourceSpan) {
        this.value = value;
        this.sourceSpan = sourceSpan;
      }
      visit(visitor, context2) {
        return visitor.visitComment(this, context2);
      }
    };
    NAMED_ENTITIES = {
      "AElig": "\xC6",
      "AMP": "&",
      "amp": "&",
      "Aacute": "\xC1",
      "Abreve": "\u0102",
      "Acirc": "\xC2",
      "Acy": "\u0410",
      "Afr": "\u{1D504}",
      "Agrave": "\xC0",
      "Alpha": "\u0391",
      "Amacr": "\u0100",
      "And": "\u2A53",
      "Aogon": "\u0104",
      "Aopf": "\u{1D538}",
      "ApplyFunction": "\u2061",
      "af": "\u2061",
      "Aring": "\xC5",
      "angst": "\xC5",
      "Ascr": "\u{1D49C}",
      "Assign": "\u2254",
      "colone": "\u2254",
      "coloneq": "\u2254",
      "Atilde": "\xC3",
      "Auml": "\xC4",
      "Backslash": "\u2216",
      "setminus": "\u2216",
      "setmn": "\u2216",
      "smallsetminus": "\u2216",
      "ssetmn": "\u2216",
      "Barv": "\u2AE7",
      "Barwed": "\u2306",
      "doublebarwedge": "\u2306",
      "Bcy": "\u0411",
      "Because": "\u2235",
      "becaus": "\u2235",
      "because": "\u2235",
      "Bernoullis": "\u212C",
      "Bscr": "\u212C",
      "bernou": "\u212C",
      "Beta": "\u0392",
      "Bfr": "\u{1D505}",
      "Bopf": "\u{1D539}",
      "Breve": "\u02D8",
      "breve": "\u02D8",
      "Bumpeq": "\u224E",
      "HumpDownHump": "\u224E",
      "bump": "\u224E",
      "CHcy": "\u0427",
      "COPY": "\xA9",
      "copy": "\xA9",
      "Cacute": "\u0106",
      "Cap": "\u22D2",
      "CapitalDifferentialD": "\u2145",
      "DD": "\u2145",
      "Cayleys": "\u212D",
      "Cfr": "\u212D",
      "Ccaron": "\u010C",
      "Ccedil": "\xC7",
      "Ccirc": "\u0108",
      "Cconint": "\u2230",
      "Cdot": "\u010A",
      "Cedilla": "\xB8",
      "cedil": "\xB8",
      "CenterDot": "\xB7",
      "centerdot": "\xB7",
      "middot": "\xB7",
      "Chi": "\u03A7",
      "CircleDot": "\u2299",
      "odot": "\u2299",
      "CircleMinus": "\u2296",
      "ominus": "\u2296",
      "CirclePlus": "\u2295",
      "oplus": "\u2295",
      "CircleTimes": "\u2297",
      "otimes": "\u2297",
      "ClockwiseContourIntegral": "\u2232",
      "cwconint": "\u2232",
      "CloseCurlyDoubleQuote": "\u201D",
      "rdquo": "\u201D",
      "rdquor": "\u201D",
      "CloseCurlyQuote": "\u2019",
      "rsquo": "\u2019",
      "rsquor": "\u2019",
      "Colon": "\u2237",
      "Proportion": "\u2237",
      "Colone": "\u2A74",
      "Congruent": "\u2261",
      "equiv": "\u2261",
      "Conint": "\u222F",
      "DoubleContourIntegral": "\u222F",
      "ContourIntegral": "\u222E",
      "conint": "\u222E",
      "oint": "\u222E",
      "Copf": "\u2102",
      "complexes": "\u2102",
      "Coproduct": "\u2210",
      "coprod": "\u2210",
      "CounterClockwiseContourIntegral": "\u2233",
      "awconint": "\u2233",
      "Cross": "\u2A2F",
      "Cscr": "\u{1D49E}",
      "Cup": "\u22D3",
      "CupCap": "\u224D",
      "asympeq": "\u224D",
      "DDotrahd": "\u2911",
      "DJcy": "\u0402",
      "DScy": "\u0405",
      "DZcy": "\u040F",
      "Dagger": "\u2021",
      "ddagger": "\u2021",
      "Darr": "\u21A1",
      "Dashv": "\u2AE4",
      "DoubleLeftTee": "\u2AE4",
      "Dcaron": "\u010E",
      "Dcy": "\u0414",
      "Del": "\u2207",
      "nabla": "\u2207",
      "Delta": "\u0394",
      "Dfr": "\u{1D507}",
      "DiacriticalAcute": "\xB4",
      "acute": "\xB4",
      "DiacriticalDot": "\u02D9",
      "dot": "\u02D9",
      "DiacriticalDoubleAcute": "\u02DD",
      "dblac": "\u02DD",
      "DiacriticalGrave": "`",
      "grave": "`",
      "DiacriticalTilde": "\u02DC",
      "tilde": "\u02DC",
      "Diamond": "\u22C4",
      "diam": "\u22C4",
      "diamond": "\u22C4",
      "DifferentialD": "\u2146",
      "dd": "\u2146",
      "Dopf": "\u{1D53B}",
      "Dot": "\xA8",
      "DoubleDot": "\xA8",
      "die": "\xA8",
      "uml": "\xA8",
      "DotDot": "\u20DC",
      "DotEqual": "\u2250",
      "doteq": "\u2250",
      "esdot": "\u2250",
      "DoubleDownArrow": "\u21D3",
      "Downarrow": "\u21D3",
      "dArr": "\u21D3",
      "DoubleLeftArrow": "\u21D0",
      "Leftarrow": "\u21D0",
      "lArr": "\u21D0",
      "DoubleLeftRightArrow": "\u21D4",
      "Leftrightarrow": "\u21D4",
      "hArr": "\u21D4",
      "iff": "\u21D4",
      "DoubleLongLeftArrow": "\u27F8",
      "Longleftarrow": "\u27F8",
      "xlArr": "\u27F8",
      "DoubleLongLeftRightArrow": "\u27FA",
      "Longleftrightarrow": "\u27FA",
      "xhArr": "\u27FA",
      "DoubleLongRightArrow": "\u27F9",
      "Longrightarrow": "\u27F9",
      "xrArr": "\u27F9",
      "DoubleRightArrow": "\u21D2",
      "Implies": "\u21D2",
      "Rightarrow": "\u21D2",
      "rArr": "\u21D2",
      "DoubleRightTee": "\u22A8",
      "vDash": "\u22A8",
      "DoubleUpArrow": "\u21D1",
      "Uparrow": "\u21D1",
      "uArr": "\u21D1",
      "DoubleUpDownArrow": "\u21D5",
      "Updownarrow": "\u21D5",
      "vArr": "\u21D5",
      "DoubleVerticalBar": "\u2225",
      "par": "\u2225",
      "parallel": "\u2225",
      "shortparallel": "\u2225",
      "spar": "\u2225",
      "DownArrow": "\u2193",
      "ShortDownArrow": "\u2193",
      "darr": "\u2193",
      "downarrow": "\u2193",
      "DownArrowBar": "\u2913",
      "DownArrowUpArrow": "\u21F5",
      "duarr": "\u21F5",
      "DownBreve": "\u0311",
      "DownLeftRightVector": "\u2950",
      "DownLeftTeeVector": "\u295E",
      "DownLeftVector": "\u21BD",
      "leftharpoondown": "\u21BD",
      "lhard": "\u21BD",
      "DownLeftVectorBar": "\u2956",
      "DownRightTeeVector": "\u295F",
      "DownRightVector": "\u21C1",
      "rhard": "\u21C1",
      "rightharpoondown": "\u21C1",
      "DownRightVectorBar": "\u2957",
      "DownTee": "\u22A4",
      "top": "\u22A4",
      "DownTeeArrow": "\u21A7",
      "mapstodown": "\u21A7",
      "Dscr": "\u{1D49F}",
      "Dstrok": "\u0110",
      "ENG": "\u014A",
      "ETH": "\xD0",
      "Eacute": "\xC9",
      "Ecaron": "\u011A",
      "Ecirc": "\xCA",
      "Ecy": "\u042D",
      "Edot": "\u0116",
      "Efr": "\u{1D508}",
      "Egrave": "\xC8",
      "Element": "\u2208",
      "in": "\u2208",
      "isin": "\u2208",
      "isinv": "\u2208",
      "Emacr": "\u0112",
      "EmptySmallSquare": "\u25FB",
      "EmptyVerySmallSquare": "\u25AB",
      "Eogon": "\u0118",
      "Eopf": "\u{1D53C}",
      "Epsilon": "\u0395",
      "Equal": "\u2A75",
      "EqualTilde": "\u2242",
      "eqsim": "\u2242",
      "esim": "\u2242",
      "Equilibrium": "\u21CC",
      "rightleftharpoons": "\u21CC",
      "rlhar": "\u21CC",
      "Escr": "\u2130",
      "expectation": "\u2130",
      "Esim": "\u2A73",
      "Eta": "\u0397",
      "Euml": "\xCB",
      "Exists": "\u2203",
      "exist": "\u2203",
      "ExponentialE": "\u2147",
      "ee": "\u2147",
      "exponentiale": "\u2147",
      "Fcy": "\u0424",
      "Ffr": "\u{1D509}",
      "FilledSmallSquare": "\u25FC",
      "FilledVerySmallSquare": "\u25AA",
      "blacksquare": "\u25AA",
      "squarf": "\u25AA",
      "squf": "\u25AA",
      "Fopf": "\u{1D53D}",
      "ForAll": "\u2200",
      "forall": "\u2200",
      "Fouriertrf": "\u2131",
      "Fscr": "\u2131",
      "GJcy": "\u0403",
      "GT": ">",
      "gt": ">",
      "Gamma": "\u0393",
      "Gammad": "\u03DC",
      "Gbreve": "\u011E",
      "Gcedil": "\u0122",
      "Gcirc": "\u011C",
      "Gcy": "\u0413",
      "Gdot": "\u0120",
      "Gfr": "\u{1D50A}",
      "Gg": "\u22D9",
      "ggg": "\u22D9",
      "Gopf": "\u{1D53E}",
      "GreaterEqual": "\u2265",
      "ge": "\u2265",
      "geq": "\u2265",
      "GreaterEqualLess": "\u22DB",
      "gel": "\u22DB",
      "gtreqless": "\u22DB",
      "GreaterFullEqual": "\u2267",
      "gE": "\u2267",
      "geqq": "\u2267",
      "GreaterGreater": "\u2AA2",
      "GreaterLess": "\u2277",
      "gl": "\u2277",
      "gtrless": "\u2277",
      "GreaterSlantEqual": "\u2A7E",
      "geqslant": "\u2A7E",
      "ges": "\u2A7E",
      "GreaterTilde": "\u2273",
      "gsim": "\u2273",
      "gtrsim": "\u2273",
      "Gscr": "\u{1D4A2}",
      "Gt": "\u226B",
      "NestedGreaterGreater": "\u226B",
      "gg": "\u226B",
      "HARDcy": "\u042A",
      "Hacek": "\u02C7",
      "caron": "\u02C7",
      "Hat": "^",
      "Hcirc": "\u0124",
      "Hfr": "\u210C",
      "Poincareplane": "\u210C",
      "HilbertSpace": "\u210B",
      "Hscr": "\u210B",
      "hamilt": "\u210B",
      "Hopf": "\u210D",
      "quaternions": "\u210D",
      "HorizontalLine": "\u2500",
      "boxh": "\u2500",
      "Hstrok": "\u0126",
      "HumpEqual": "\u224F",
      "bumpe": "\u224F",
      "bumpeq": "\u224F",
      "IEcy": "\u0415",
      "IJlig": "\u0132",
      "IOcy": "\u0401",
      "Iacute": "\xCD",
      "Icirc": "\xCE",
      "Icy": "\u0418",
      "Idot": "\u0130",
      "Ifr": "\u2111",
      "Im": "\u2111",
      "image": "\u2111",
      "imagpart": "\u2111",
      "Igrave": "\xCC",
      "Imacr": "\u012A",
      "ImaginaryI": "\u2148",
      "ii": "\u2148",
      "Int": "\u222C",
      "Integral": "\u222B",
      "int": "\u222B",
      "Intersection": "\u22C2",
      "bigcap": "\u22C2",
      "xcap": "\u22C2",
      "InvisibleComma": "\u2063",
      "ic": "\u2063",
      "InvisibleTimes": "\u2062",
      "it": "\u2062",
      "Iogon": "\u012E",
      "Iopf": "\u{1D540}",
      "Iota": "\u0399",
      "Iscr": "\u2110",
      "imagline": "\u2110",
      "Itilde": "\u0128",
      "Iukcy": "\u0406",
      "Iuml": "\xCF",
      "Jcirc": "\u0134",
      "Jcy": "\u0419",
      "Jfr": "\u{1D50D}",
      "Jopf": "\u{1D541}",
      "Jscr": "\u{1D4A5}",
      "Jsercy": "\u0408",
      "Jukcy": "\u0404",
      "KHcy": "\u0425",
      "KJcy": "\u040C",
      "Kappa": "\u039A",
      "Kcedil": "\u0136",
      "Kcy": "\u041A",
      "Kfr": "\u{1D50E}",
      "Kopf": "\u{1D542}",
      "Kscr": "\u{1D4A6}",
      "LJcy": "\u0409",
      "LT": "<",
      "lt": "<",
      "Lacute": "\u0139",
      "Lambda": "\u039B",
      "Lang": "\u27EA",
      "Laplacetrf": "\u2112",
      "Lscr": "\u2112",
      "lagran": "\u2112",
      "Larr": "\u219E",
      "twoheadleftarrow": "\u219E",
      "Lcaron": "\u013D",
      "Lcedil": "\u013B",
      "Lcy": "\u041B",
      "LeftAngleBracket": "\u27E8",
      "lang": "\u27E8",
      "langle": "\u27E8",
      "LeftArrow": "\u2190",
      "ShortLeftArrow": "\u2190",
      "larr": "\u2190",
      "leftarrow": "\u2190",
      "slarr": "\u2190",
      "LeftArrowBar": "\u21E4",
      "larrb": "\u21E4",
      "LeftArrowRightArrow": "\u21C6",
      "leftrightarrows": "\u21C6",
      "lrarr": "\u21C6",
      "LeftCeiling": "\u2308",
      "lceil": "\u2308",
      "LeftDoubleBracket": "\u27E6",
      "lobrk": "\u27E6",
      "LeftDownTeeVector": "\u2961",
      "LeftDownVector": "\u21C3",
      "dharl": "\u21C3",
      "downharpoonleft": "\u21C3",
      "LeftDownVectorBar": "\u2959",
      "LeftFloor": "\u230A",
      "lfloor": "\u230A",
      "LeftRightArrow": "\u2194",
      "harr": "\u2194",
      "leftrightarrow": "\u2194",
      "LeftRightVector": "\u294E",
      "LeftTee": "\u22A3",
      "dashv": "\u22A3",
      "LeftTeeArrow": "\u21A4",
      "mapstoleft": "\u21A4",
      "LeftTeeVector": "\u295A",
      "LeftTriangle": "\u22B2",
      "vartriangleleft": "\u22B2",
      "vltri": "\u22B2",
      "LeftTriangleBar": "\u29CF",
      "LeftTriangleEqual": "\u22B4",
      "ltrie": "\u22B4",
      "trianglelefteq": "\u22B4",
      "LeftUpDownVector": "\u2951",
      "LeftUpTeeVector": "\u2960",
      "LeftUpVector": "\u21BF",
      "uharl": "\u21BF",
      "upharpoonleft": "\u21BF",
      "LeftUpVectorBar": "\u2958",
      "LeftVector": "\u21BC",
      "leftharpoonup": "\u21BC",
      "lharu": "\u21BC",
      "LeftVectorBar": "\u2952",
      "LessEqualGreater": "\u22DA",
      "leg": "\u22DA",
      "lesseqgtr": "\u22DA",
      "LessFullEqual": "\u2266",
      "lE": "\u2266",
      "leqq": "\u2266",
      "LessGreater": "\u2276",
      "lessgtr": "\u2276",
      "lg": "\u2276",
      "LessLess": "\u2AA1",
      "LessSlantEqual": "\u2A7D",
      "leqslant": "\u2A7D",
      "les": "\u2A7D",
      "LessTilde": "\u2272",
      "lesssim": "\u2272",
      "lsim": "\u2272",
      "Lfr": "\u{1D50F}",
      "Ll": "\u22D8",
      "Lleftarrow": "\u21DA",
      "lAarr": "\u21DA",
      "Lmidot": "\u013F",
      "LongLeftArrow": "\u27F5",
      "longleftarrow": "\u27F5",
      "xlarr": "\u27F5",
      "LongLeftRightArrow": "\u27F7",
      "longleftrightarrow": "\u27F7",
      "xharr": "\u27F7",
      "LongRightArrow": "\u27F6",
      "longrightarrow": "\u27F6",
      "xrarr": "\u27F6",
      "Lopf": "\u{1D543}",
      "LowerLeftArrow": "\u2199",
      "swarr": "\u2199",
      "swarrow": "\u2199",
      "LowerRightArrow": "\u2198",
      "searr": "\u2198",
      "searrow": "\u2198",
      "Lsh": "\u21B0",
      "lsh": "\u21B0",
      "Lstrok": "\u0141",
      "Lt": "\u226A",
      "NestedLessLess": "\u226A",
      "ll": "\u226A",
      "Map": "\u2905",
      "Mcy": "\u041C",
      "MediumSpace": "\u205F",
      "Mellintrf": "\u2133",
      "Mscr": "\u2133",
      "phmmat": "\u2133",
      "Mfr": "\u{1D510}",
      "MinusPlus": "\u2213",
      "mnplus": "\u2213",
      "mp": "\u2213",
      "Mopf": "\u{1D544}",
      "Mu": "\u039C",
      "NJcy": "\u040A",
      "Nacute": "\u0143",
      "Ncaron": "\u0147",
      "Ncedil": "\u0145",
      "Ncy": "\u041D",
      "NegativeMediumSpace": "\u200B",
      "NegativeThickSpace": "\u200B",
      "NegativeThinSpace": "\u200B",
      "NegativeVeryThinSpace": "\u200B",
      "ZeroWidthSpace": "\u200B",
      "NewLine": "\n",
      "Nfr": "\u{1D511}",
      "NoBreak": "\u2060",
      "NonBreakingSpace": "\xA0",
      "nbsp": "\xA0",
      "Nopf": "\u2115",
      "naturals": "\u2115",
      "Not": "\u2AEC",
      "NotCongruent": "\u2262",
      "nequiv": "\u2262",
      "NotCupCap": "\u226D",
      "NotDoubleVerticalBar": "\u2226",
      "npar": "\u2226",
      "nparallel": "\u2226",
      "nshortparallel": "\u2226",
      "nspar": "\u2226",
      "NotElement": "\u2209",
      "notin": "\u2209",
      "notinva": "\u2209",
      "NotEqual": "\u2260",
      "ne": "\u2260",
      "NotEqualTilde": "\u2242\u0338",
      "nesim": "\u2242\u0338",
      "NotExists": "\u2204",
      "nexist": "\u2204",
      "nexists": "\u2204",
      "NotGreater": "\u226F",
      "ngt": "\u226F",
      "ngtr": "\u226F",
      "NotGreaterEqual": "\u2271",
      "nge": "\u2271",
      "ngeq": "\u2271",
      "NotGreaterFullEqual": "\u2267\u0338",
      "ngE": "\u2267\u0338",
      "ngeqq": "\u2267\u0338",
      "NotGreaterGreater": "\u226B\u0338",
      "nGtv": "\u226B\u0338",
      "NotGreaterLess": "\u2279",
      "ntgl": "\u2279",
      "NotGreaterSlantEqual": "\u2A7E\u0338",
      "ngeqslant": "\u2A7E\u0338",
      "nges": "\u2A7E\u0338",
      "NotGreaterTilde": "\u2275",
      "ngsim": "\u2275",
      "NotHumpDownHump": "\u224E\u0338",
      "nbump": "\u224E\u0338",
      "NotHumpEqual": "\u224F\u0338",
      "nbumpe": "\u224F\u0338",
      "NotLeftTriangle": "\u22EA",
      "nltri": "\u22EA",
      "ntriangleleft": "\u22EA",
      "NotLeftTriangleBar": "\u29CF\u0338",
      "NotLeftTriangleEqual": "\u22EC",
      "nltrie": "\u22EC",
      "ntrianglelefteq": "\u22EC",
      "NotLess": "\u226E",
      "nless": "\u226E",
      "nlt": "\u226E",
      "NotLessEqual": "\u2270",
      "nle": "\u2270",
      "nleq": "\u2270",
      "NotLessGreater": "\u2278",
      "ntlg": "\u2278",
      "NotLessLess": "\u226A\u0338",
      "nLtv": "\u226A\u0338",
      "NotLessSlantEqual": "\u2A7D\u0338",
      "nleqslant": "\u2A7D\u0338",
      "nles": "\u2A7D\u0338",
      "NotLessTilde": "\u2274",
      "nlsim": "\u2274",
      "NotNestedGreaterGreater": "\u2AA2\u0338",
      "NotNestedLessLess": "\u2AA1\u0338",
      "NotPrecedes": "\u2280",
      "npr": "\u2280",
      "nprec": "\u2280",
      "NotPrecedesEqual": "\u2AAF\u0338",
      "npre": "\u2AAF\u0338",
      "npreceq": "\u2AAF\u0338",
      "NotPrecedesSlantEqual": "\u22E0",
      "nprcue": "\u22E0",
      "NotReverseElement": "\u220C",
      "notni": "\u220C",
      "notniva": "\u220C",
      "NotRightTriangle": "\u22EB",
      "nrtri": "\u22EB",
      "ntriangleright": "\u22EB",
      "NotRightTriangleBar": "\u29D0\u0338",
      "NotRightTriangleEqual": "\u22ED",
      "nrtrie": "\u22ED",
      "ntrianglerighteq": "\u22ED",
      "NotSquareSubset": "\u228F\u0338",
      "NotSquareSubsetEqual": "\u22E2",
      "nsqsube": "\u22E2",
      "NotSquareSuperset": "\u2290\u0338",
      "NotSquareSupersetEqual": "\u22E3",
      "nsqsupe": "\u22E3",
      "NotSubset": "\u2282\u20D2",
      "nsubset": "\u2282\u20D2",
      "vnsub": "\u2282\u20D2",
      "NotSubsetEqual": "\u2288",
      "nsube": "\u2288",
      "nsubseteq": "\u2288",
      "NotSucceeds": "\u2281",
      "nsc": "\u2281",
      "nsucc": "\u2281",
      "NotSucceedsEqual": "\u2AB0\u0338",
      "nsce": "\u2AB0\u0338",
      "nsucceq": "\u2AB0\u0338",
      "NotSucceedsSlantEqual": "\u22E1",
      "nsccue": "\u22E1",
      "NotSucceedsTilde": "\u227F\u0338",
      "NotSuperset": "\u2283\u20D2",
      "nsupset": "\u2283\u20D2",
      "vnsup": "\u2283\u20D2",
      "NotSupersetEqual": "\u2289",
      "nsupe": "\u2289",
      "nsupseteq": "\u2289",
      "NotTilde": "\u2241",
      "nsim": "\u2241",
      "NotTildeEqual": "\u2244",
      "nsime": "\u2244",
      "nsimeq": "\u2244",
      "NotTildeFullEqual": "\u2247",
      "ncong": "\u2247",
      "NotTildeTilde": "\u2249",
      "nap": "\u2249",
      "napprox": "\u2249",
      "NotVerticalBar": "\u2224",
      "nmid": "\u2224",
      "nshortmid": "\u2224",
      "nsmid": "\u2224",
      "Nscr": "\u{1D4A9}",
      "Ntilde": "\xD1",
      "Nu": "\u039D",
      "OElig": "\u0152",
      "Oacute": "\xD3",
      "Ocirc": "\xD4",
      "Ocy": "\u041E",
      "Odblac": "\u0150",
      "Ofr": "\u{1D512}",
      "Ograve": "\xD2",
      "Omacr": "\u014C",
      "Omega": "\u03A9",
      "ohm": "\u03A9",
      "Omicron": "\u039F",
      "Oopf": "\u{1D546}",
      "OpenCurlyDoubleQuote": "\u201C",
      "ldquo": "\u201C",
      "OpenCurlyQuote": "\u2018",
      "lsquo": "\u2018",
      "Or": "\u2A54",
      "Oscr": "\u{1D4AA}",
      "Oslash": "\xD8",
      "Otilde": "\xD5",
      "Otimes": "\u2A37",
      "Ouml": "\xD6",
      "OverBar": "\u203E",
      "oline": "\u203E",
      "OverBrace": "\u23DE",
      "OverBracket": "\u23B4",
      "tbrk": "\u23B4",
      "OverParenthesis": "\u23DC",
      "PartialD": "\u2202",
      "part": "\u2202",
      "Pcy": "\u041F",
      "Pfr": "\u{1D513}",
      "Phi": "\u03A6",
      "Pi": "\u03A0",
      "PlusMinus": "\xB1",
      "plusmn": "\xB1",
      "pm": "\xB1",
      "Popf": "\u2119",
      "primes": "\u2119",
      "Pr": "\u2ABB",
      "Precedes": "\u227A",
      "pr": "\u227A",
      "prec": "\u227A",
      "PrecedesEqual": "\u2AAF",
      "pre": "\u2AAF",
      "preceq": "\u2AAF",
      "PrecedesSlantEqual": "\u227C",
      "prcue": "\u227C",
      "preccurlyeq": "\u227C",
      "PrecedesTilde": "\u227E",
      "precsim": "\u227E",
      "prsim": "\u227E",
      "Prime": "\u2033",
      "Product": "\u220F",
      "prod": "\u220F",
      "Proportional": "\u221D",
      "prop": "\u221D",
      "propto": "\u221D",
      "varpropto": "\u221D",
      "vprop": "\u221D",
      "Pscr": "\u{1D4AB}",
      "Psi": "\u03A8",
      "QUOT": '"',
      "quot": '"',
      "Qfr": "\u{1D514}",
      "Qopf": "\u211A",
      "rationals": "\u211A",
      "Qscr": "\u{1D4AC}",
      "RBarr": "\u2910",
      "drbkarow": "\u2910",
      "REG": "\xAE",
      "circledR": "\xAE",
      "reg": "\xAE",
      "Racute": "\u0154",
      "Rang": "\u27EB",
      "Rarr": "\u21A0",
      "twoheadrightarrow": "\u21A0",
      "Rarrtl": "\u2916",
      "Rcaron": "\u0158",
      "Rcedil": "\u0156",
      "Rcy": "\u0420",
      "Re": "\u211C",
      "Rfr": "\u211C",
      "real": "\u211C",
      "realpart": "\u211C",
      "ReverseElement": "\u220B",
      "SuchThat": "\u220B",
      "ni": "\u220B",
      "niv": "\u220B",
      "ReverseEquilibrium": "\u21CB",
      "leftrightharpoons": "\u21CB",
      "lrhar": "\u21CB",
      "ReverseUpEquilibrium": "\u296F",
      "duhar": "\u296F",
      "Rho": "\u03A1",
      "RightAngleBracket": "\u27E9",
      "rang": "\u27E9",
      "rangle": "\u27E9",
      "RightArrow": "\u2192",
      "ShortRightArrow": "\u2192",
      "rarr": "\u2192",
      "rightarrow": "\u2192",
      "srarr": "\u2192",
      "RightArrowBar": "\u21E5",
      "rarrb": "\u21E5",
      "RightArrowLeftArrow": "\u21C4",
      "rightleftarrows": "\u21C4",
      "rlarr": "\u21C4",
      "RightCeiling": "\u2309",
      "rceil": "\u2309",
      "RightDoubleBracket": "\u27E7",
      "robrk": "\u27E7",
      "RightDownTeeVector": "\u295D",
      "RightDownVector": "\u21C2",
      "dharr": "\u21C2",
      "downharpoonright": "\u21C2",
      "RightDownVectorBar": "\u2955",
      "RightFloor": "\u230B",
      "rfloor": "\u230B",
      "RightTee": "\u22A2",
      "vdash": "\u22A2",
      "RightTeeArrow": "\u21A6",
      "map": "\u21A6",
      "mapsto": "\u21A6",
      "RightTeeVector": "\u295B",
      "RightTriangle": "\u22B3",
      "vartriangleright": "\u22B3",
      "vrtri": "\u22B3",
      "RightTriangleBar": "\u29D0",
      "RightTriangleEqual": "\u22B5",
      "rtrie": "\u22B5",
      "trianglerighteq": "\u22B5",
      "RightUpDownVector": "\u294F",
      "RightUpTeeVector": "\u295C",
      "RightUpVector": "\u21BE",
      "uharr": "\u21BE",
      "upharpoonright": "\u21BE",
      "RightUpVectorBar": "\u2954",
      "RightVector": "\u21C0",
      "rharu": "\u21C0",
      "rightharpoonup": "\u21C0",
      "RightVectorBar": "\u2953",
      "Ropf": "\u211D",
      "reals": "\u211D",
      "RoundImplies": "\u2970",
      "Rrightarrow": "\u21DB",
      "rAarr": "\u21DB",
      "Rscr": "\u211B",
      "realine": "\u211B",
      "Rsh": "\u21B1",
      "rsh": "\u21B1",
      "RuleDelayed": "\u29F4",
      "SHCHcy": "\u0429",
      "SHcy": "\u0428",
      "SOFTcy": "\u042C",
      "Sacute": "\u015A",
      "Sc": "\u2ABC",
      "Scaron": "\u0160",
      "Scedil": "\u015E",
      "Scirc": "\u015C",
      "Scy": "\u0421",
      "Sfr": "\u{1D516}",
      "ShortUpArrow": "\u2191",
      "UpArrow": "\u2191",
      "uarr": "\u2191",
      "uparrow": "\u2191",
      "Sigma": "\u03A3",
      "SmallCircle": "\u2218",
      "compfn": "\u2218",
      "Sopf": "\u{1D54A}",
      "Sqrt": "\u221A",
      "radic": "\u221A",
      "Square": "\u25A1",
      "squ": "\u25A1",
      "square": "\u25A1",
      "SquareIntersection": "\u2293",
      "sqcap": "\u2293",
      "SquareSubset": "\u228F",
      "sqsub": "\u228F",
      "sqsubset": "\u228F",
      "SquareSubsetEqual": "\u2291",
      "sqsube": "\u2291",
      "sqsubseteq": "\u2291",
      "SquareSuperset": "\u2290",
      "sqsup": "\u2290",
      "sqsupset": "\u2290",
      "SquareSupersetEqual": "\u2292",
      "sqsupe": "\u2292",
      "sqsupseteq": "\u2292",
      "SquareUnion": "\u2294",
      "sqcup": "\u2294",
      "Sscr": "\u{1D4AE}",
      "Star": "\u22C6",
      "sstarf": "\u22C6",
      "Sub": "\u22D0",
      "Subset": "\u22D0",
      "SubsetEqual": "\u2286",
      "sube": "\u2286",
      "subseteq": "\u2286",
      "Succeeds": "\u227B",
      "sc": "\u227B",
      "succ": "\u227B",
      "SucceedsEqual": "\u2AB0",
      "sce": "\u2AB0",
      "succeq": "\u2AB0",
      "SucceedsSlantEqual": "\u227D",
      "sccue": "\u227D",
      "succcurlyeq": "\u227D",
      "SucceedsTilde": "\u227F",
      "scsim": "\u227F",
      "succsim": "\u227F",
      "Sum": "\u2211",
      "sum": "\u2211",
      "Sup": "\u22D1",
      "Supset": "\u22D1",
      "Superset": "\u2283",
      "sup": "\u2283",
      "supset": "\u2283",
      "SupersetEqual": "\u2287",
      "supe": "\u2287",
      "supseteq": "\u2287",
      "THORN": "\xDE",
      "TRADE": "\u2122",
      "trade": "\u2122",
      "TSHcy": "\u040B",
      "TScy": "\u0426",
      "Tab": "	",
      "Tau": "\u03A4",
      "Tcaron": "\u0164",
      "Tcedil": "\u0162",
      "Tcy": "\u0422",
      "Tfr": "\u{1D517}",
      "Therefore": "\u2234",
      "there4": "\u2234",
      "therefore": "\u2234",
      "Theta": "\u0398",
      "ThickSpace": "\u205F\u200A",
      "ThinSpace": "\u2009",
      "thinsp": "\u2009",
      "Tilde": "\u223C",
      "sim": "\u223C",
      "thicksim": "\u223C",
      "thksim": "\u223C",
      "TildeEqual": "\u2243",
      "sime": "\u2243",
      "simeq": "\u2243",
      "TildeFullEqual": "\u2245",
      "cong": "\u2245",
      "TildeTilde": "\u2248",
      "ap": "\u2248",
      "approx": "\u2248",
      "asymp": "\u2248",
      "thickapprox": "\u2248",
      "thkap": "\u2248",
      "Topf": "\u{1D54B}",
      "TripleDot": "\u20DB",
      "tdot": "\u20DB",
      "Tscr": "\u{1D4AF}",
      "Tstrok": "\u0166",
      "Uacute": "\xDA",
      "Uarr": "\u219F",
      "Uarrocir": "\u2949",
      "Ubrcy": "\u040E",
      "Ubreve": "\u016C",
      "Ucirc": "\xDB",
      "Ucy": "\u0423",
      "Udblac": "\u0170",
      "Ufr": "\u{1D518}",
      "Ugrave": "\xD9",
      "Umacr": "\u016A",
      "UnderBar": "_",
      "lowbar": "_",
      "UnderBrace": "\u23DF",
      "UnderBracket": "\u23B5",
      "bbrk": "\u23B5",
      "UnderParenthesis": "\u23DD",
      "Union": "\u22C3",
      "bigcup": "\u22C3",
      "xcup": "\u22C3",
      "UnionPlus": "\u228E",
      "uplus": "\u228E",
      "Uogon": "\u0172",
      "Uopf": "\u{1D54C}",
      "UpArrowBar": "\u2912",
      "UpArrowDownArrow": "\u21C5",
      "udarr": "\u21C5",
      "UpDownArrow": "\u2195",
      "updownarrow": "\u2195",
      "varr": "\u2195",
      "UpEquilibrium": "\u296E",
      "udhar": "\u296E",
      "UpTee": "\u22A5",
      "bot": "\u22A5",
      "bottom": "\u22A5",
      "perp": "\u22A5",
      "UpTeeArrow": "\u21A5",
      "mapstoup": "\u21A5",
      "UpperLeftArrow": "\u2196",
      "nwarr": "\u2196",
      "nwarrow": "\u2196",
      "UpperRightArrow": "\u2197",
      "nearr": "\u2197",
      "nearrow": "\u2197",
      "Upsi": "\u03D2",
      "upsih": "\u03D2",
      "Upsilon": "\u03A5",
      "Uring": "\u016E",
      "Uscr": "\u{1D4B0}",
      "Utilde": "\u0168",
      "Uuml": "\xDC",
      "VDash": "\u22AB",
      "Vbar": "\u2AEB",
      "Vcy": "\u0412",
      "Vdash": "\u22A9",
      "Vdashl": "\u2AE6",
      "Vee": "\u22C1",
      "bigvee": "\u22C1",
      "xvee": "\u22C1",
      "Verbar": "\u2016",
      "Vert": "\u2016",
      "VerticalBar": "\u2223",
      "mid": "\u2223",
      "shortmid": "\u2223",
      "smid": "\u2223",
      "VerticalLine": "|",
      "verbar": "|",
      "vert": "|",
      "VerticalSeparator": "\u2758",
      "VerticalTilde": "\u2240",
      "wr": "\u2240",
      "wreath": "\u2240",
      "VeryThinSpace": "\u200A",
      "hairsp": "\u200A",
      "Vfr": "\u{1D519}",
      "Vopf": "\u{1D54D}",
      "Vscr": "\u{1D4B1}",
      "Vvdash": "\u22AA",
      "Wcirc": "\u0174",
      "Wedge": "\u22C0",
      "bigwedge": "\u22C0",
      "xwedge": "\u22C0",
      "Wfr": "\u{1D51A}",
      "Wopf": "\u{1D54E}",
      "Wscr": "\u{1D4B2}",
      "Xfr": "\u{1D51B}",
      "Xi": "\u039E",
      "Xopf": "\u{1D54F}",
      "Xscr": "\u{1D4B3}",
      "YAcy": "\u042F",
      "YIcy": "\u0407",
      "YUcy": "\u042E",
      "Yacute": "\xDD",
      "Ycirc": "\u0176",
      "Ycy": "\u042B",
      "Yfr": "\u{1D51C}",
      "Yopf": "\u{1D550}",
      "Yscr": "\u{1D4B4}",
      "Yuml": "\u0178",
      "ZHcy": "\u0416",
      "Zacute": "\u0179",
      "Zcaron": "\u017D",
      "Zcy": "\u0417",
      "Zdot": "\u017B",
      "Zeta": "\u0396",
      "Zfr": "\u2128",
      "zeetrf": "\u2128",
      "Zopf": "\u2124",
      "integers": "\u2124",
      "Zscr": "\u{1D4B5}",
      "aacute": "\xE1",
      "abreve": "\u0103",
      "ac": "\u223E",
      "mstpos": "\u223E",
      "acE": "\u223E\u0333",
      "acd": "\u223F",
      "acirc": "\xE2",
      "acy": "\u0430",
      "aelig": "\xE6",
      "afr": "\u{1D51E}",
      "agrave": "\xE0",
      "alefsym": "\u2135",
      "aleph": "\u2135",
      "alpha": "\u03B1",
      "amacr": "\u0101",
      "amalg": "\u2A3F",
      "and": "\u2227",
      "wedge": "\u2227",
      "andand": "\u2A55",
      "andd": "\u2A5C",
      "andslope": "\u2A58",
      "andv": "\u2A5A",
      "ang": "\u2220",
      "angle": "\u2220",
      "ange": "\u29A4",
      "angmsd": "\u2221",
      "measuredangle": "\u2221",
      "angmsdaa": "\u29A8",
      "angmsdab": "\u29A9",
      "angmsdac": "\u29AA",
      "angmsdad": "\u29AB",
      "angmsdae": "\u29AC",
      "angmsdaf": "\u29AD",
      "angmsdag": "\u29AE",
      "angmsdah": "\u29AF",
      "angrt": "\u221F",
      "angrtvb": "\u22BE",
      "angrtvbd": "\u299D",
      "angsph": "\u2222",
      "angzarr": "\u237C",
      "aogon": "\u0105",
      "aopf": "\u{1D552}",
      "apE": "\u2A70",
      "apacir": "\u2A6F",
      "ape": "\u224A",
      "approxeq": "\u224A",
      "apid": "\u224B",
      "apos": "'",
      "aring": "\xE5",
      "ascr": "\u{1D4B6}",
      "ast": "*",
      "midast": "*",
      "atilde": "\xE3",
      "auml": "\xE4",
      "awint": "\u2A11",
      "bNot": "\u2AED",
      "backcong": "\u224C",
      "bcong": "\u224C",
      "backepsilon": "\u03F6",
      "bepsi": "\u03F6",
      "backprime": "\u2035",
      "bprime": "\u2035",
      "backsim": "\u223D",
      "bsim": "\u223D",
      "backsimeq": "\u22CD",
      "bsime": "\u22CD",
      "barvee": "\u22BD",
      "barwed": "\u2305",
      "barwedge": "\u2305",
      "bbrktbrk": "\u23B6",
      "bcy": "\u0431",
      "bdquo": "\u201E",
      "ldquor": "\u201E",
      "bemptyv": "\u29B0",
      "beta": "\u03B2",
      "beth": "\u2136",
      "between": "\u226C",
      "twixt": "\u226C",
      "bfr": "\u{1D51F}",
      "bigcirc": "\u25EF",
      "xcirc": "\u25EF",
      "bigodot": "\u2A00",
      "xodot": "\u2A00",
      "bigoplus": "\u2A01",
      "xoplus": "\u2A01",
      "bigotimes": "\u2A02",
      "xotime": "\u2A02",
      "bigsqcup": "\u2A06",
      "xsqcup": "\u2A06",
      "bigstar": "\u2605",
      "starf": "\u2605",
      "bigtriangledown": "\u25BD",
      "xdtri": "\u25BD",
      "bigtriangleup": "\u25B3",
      "xutri": "\u25B3",
      "biguplus": "\u2A04",
      "xuplus": "\u2A04",
      "bkarow": "\u290D",
      "rbarr": "\u290D",
      "blacklozenge": "\u29EB",
      "lozf": "\u29EB",
      "blacktriangle": "\u25B4",
      "utrif": "\u25B4",
      "blacktriangledown": "\u25BE",
      "dtrif": "\u25BE",
      "blacktriangleleft": "\u25C2",
      "ltrif": "\u25C2",
      "blacktriangleright": "\u25B8",
      "rtrif": "\u25B8",
      "blank": "\u2423",
      "blk12": "\u2592",
      "blk14": "\u2591",
      "blk34": "\u2593",
      "block": "\u2588",
      "bne": "=\u20E5",
      "bnequiv": "\u2261\u20E5",
      "bnot": "\u2310",
      "bopf": "\u{1D553}",
      "bowtie": "\u22C8",
      "boxDL": "\u2557",
      "boxDR": "\u2554",
      "boxDl": "\u2556",
      "boxDr": "\u2553",
      "boxH": "\u2550",
      "boxHD": "\u2566",
      "boxHU": "\u2569",
      "boxHd": "\u2564",
      "boxHu": "\u2567",
      "boxUL": "\u255D",
      "boxUR": "\u255A",
      "boxUl": "\u255C",
      "boxUr": "\u2559",
      "boxV": "\u2551",
      "boxVH": "\u256C",
      "boxVL": "\u2563",
      "boxVR": "\u2560",
      "boxVh": "\u256B",
      "boxVl": "\u2562",
      "boxVr": "\u255F",
      "boxbox": "\u29C9",
      "boxdL": "\u2555",
      "boxdR": "\u2552",
      "boxdl": "\u2510",
      "boxdr": "\u250C",
      "boxhD": "\u2565",
      "boxhU": "\u2568",
      "boxhd": "\u252C",
      "boxhu": "\u2534",
      "boxminus": "\u229F",
      "minusb": "\u229F",
      "boxplus": "\u229E",
      "plusb": "\u229E",
      "boxtimes": "\u22A0",
      "timesb": "\u22A0",
      "boxuL": "\u255B",
      "boxuR": "\u2558",
      "boxul": "\u2518",
      "boxur": "\u2514",
      "boxv": "\u2502",
      "boxvH": "\u256A",
      "boxvL": "\u2561",
      "boxvR": "\u255E",
      "boxvh": "\u253C",
      "boxvl": "\u2524",
      "boxvr": "\u251C",
      "brvbar": "\xA6",
      "bscr": "\u{1D4B7}",
      "bsemi": "\u204F",
      "bsol": "\\",
      "bsolb": "\u29C5",
      "bsolhsub": "\u27C8",
      "bull": "\u2022",
      "bullet": "\u2022",
      "bumpE": "\u2AAE",
      "cacute": "\u0107",
      "cap": "\u2229",
      "capand": "\u2A44",
      "capbrcup": "\u2A49",
      "capcap": "\u2A4B",
      "capcup": "\u2A47",
      "capdot": "\u2A40",
      "caps": "\u2229\uFE00",
      "caret": "\u2041",
      "ccaps": "\u2A4D",
      "ccaron": "\u010D",
      "ccedil": "\xE7",
      "ccirc": "\u0109",
      "ccups": "\u2A4C",
      "ccupssm": "\u2A50",
      "cdot": "\u010B",
      "cemptyv": "\u29B2",
      "cent": "\xA2",
      "cfr": "\u{1D520}",
      "chcy": "\u0447",
      "check": "\u2713",
      "checkmark": "\u2713",
      "chi": "\u03C7",
      "cir": "\u25CB",
      "cirE": "\u29C3",
      "circ": "\u02C6",
      "circeq": "\u2257",
      "cire": "\u2257",
      "circlearrowleft": "\u21BA",
      "olarr": "\u21BA",
      "circlearrowright": "\u21BB",
      "orarr": "\u21BB",
      "circledS": "\u24C8",
      "oS": "\u24C8",
      "circledast": "\u229B",
      "oast": "\u229B",
      "circledcirc": "\u229A",
      "ocir": "\u229A",
      "circleddash": "\u229D",
      "odash": "\u229D",
      "cirfnint": "\u2A10",
      "cirmid": "\u2AEF",
      "cirscir": "\u29C2",
      "clubs": "\u2663",
      "clubsuit": "\u2663",
      "colon": ":",
      "comma": ",",
      "commat": "@",
      "comp": "\u2201",
      "complement": "\u2201",
      "congdot": "\u2A6D",
      "copf": "\u{1D554}",
      "copysr": "\u2117",
      "crarr": "\u21B5",
      "cross": "\u2717",
      "cscr": "\u{1D4B8}",
      "csub": "\u2ACF",
      "csube": "\u2AD1",
      "csup": "\u2AD0",
      "csupe": "\u2AD2",
      "ctdot": "\u22EF",
      "cudarrl": "\u2938",
      "cudarrr": "\u2935",
      "cuepr": "\u22DE",
      "curlyeqprec": "\u22DE",
      "cuesc": "\u22DF",
      "curlyeqsucc": "\u22DF",
      "cularr": "\u21B6",
      "curvearrowleft": "\u21B6",
      "cularrp": "\u293D",
      "cup": "\u222A",
      "cupbrcap": "\u2A48",
      "cupcap": "\u2A46",
      "cupcup": "\u2A4A",
      "cupdot": "\u228D",
      "cupor": "\u2A45",
      "cups": "\u222A\uFE00",
      "curarr": "\u21B7",
      "curvearrowright": "\u21B7",
      "curarrm": "\u293C",
      "curlyvee": "\u22CE",
      "cuvee": "\u22CE",
      "curlywedge": "\u22CF",
      "cuwed": "\u22CF",
      "curren": "\xA4",
      "cwint": "\u2231",
      "cylcty": "\u232D",
      "dHar": "\u2965",
      "dagger": "\u2020",
      "daleth": "\u2138",
      "dash": "\u2010",
      "hyphen": "\u2010",
      "dbkarow": "\u290F",
      "rBarr": "\u290F",
      "dcaron": "\u010F",
      "dcy": "\u0434",
      "ddarr": "\u21CA",
      "downdownarrows": "\u21CA",
      "ddotseq": "\u2A77",
      "eDDot": "\u2A77",
      "deg": "\xB0",
      "delta": "\u03B4",
      "demptyv": "\u29B1",
      "dfisht": "\u297F",
      "dfr": "\u{1D521}",
      "diamondsuit": "\u2666",
      "diams": "\u2666",
      "digamma": "\u03DD",
      "gammad": "\u03DD",
      "disin": "\u22F2",
      "div": "\xF7",
      "divide": "\xF7",
      "divideontimes": "\u22C7",
      "divonx": "\u22C7",
      "djcy": "\u0452",
      "dlcorn": "\u231E",
      "llcorner": "\u231E",
      "dlcrop": "\u230D",
      "dollar": "$",
      "dopf": "\u{1D555}",
      "doteqdot": "\u2251",
      "eDot": "\u2251",
      "dotminus": "\u2238",
      "minusd": "\u2238",
      "dotplus": "\u2214",
      "plusdo": "\u2214",
      "dotsquare": "\u22A1",
      "sdotb": "\u22A1",
      "drcorn": "\u231F",
      "lrcorner": "\u231F",
      "drcrop": "\u230C",
      "dscr": "\u{1D4B9}",
      "dscy": "\u0455",
      "dsol": "\u29F6",
      "dstrok": "\u0111",
      "dtdot": "\u22F1",
      "dtri": "\u25BF",
      "triangledown": "\u25BF",
      "dwangle": "\u29A6",
      "dzcy": "\u045F",
      "dzigrarr": "\u27FF",
      "eacute": "\xE9",
      "easter": "\u2A6E",
      "ecaron": "\u011B",
      "ecir": "\u2256",
      "eqcirc": "\u2256",
      "ecirc": "\xEA",
      "ecolon": "\u2255",
      "eqcolon": "\u2255",
      "ecy": "\u044D",
      "edot": "\u0117",
      "efDot": "\u2252",
      "fallingdotseq": "\u2252",
      "efr": "\u{1D522}",
      "eg": "\u2A9A",
      "egrave": "\xE8",
      "egs": "\u2A96",
      "eqslantgtr": "\u2A96",
      "egsdot": "\u2A98",
      "el": "\u2A99",
      "elinters": "\u23E7",
      "ell": "\u2113",
      "els": "\u2A95",
      "eqslantless": "\u2A95",
      "elsdot": "\u2A97",
      "emacr": "\u0113",
      "empty": "\u2205",
      "emptyset": "\u2205",
      "emptyv": "\u2205",
      "varnothing": "\u2205",
      "emsp13": "\u2004",
      "emsp14": "\u2005",
      "emsp": "\u2003",
      "eng": "\u014B",
      "ensp": "\u2002",
      "eogon": "\u0119",
      "eopf": "\u{1D556}",
      "epar": "\u22D5",
      "eparsl": "\u29E3",
      "eplus": "\u2A71",
      "epsi": "\u03B5",
      "epsilon": "\u03B5",
      "epsiv": "\u03F5",
      "straightepsilon": "\u03F5",
      "varepsilon": "\u03F5",
      "equals": "=",
      "equest": "\u225F",
      "questeq": "\u225F",
      "equivDD": "\u2A78",
      "eqvparsl": "\u29E5",
      "erDot": "\u2253",
      "risingdotseq": "\u2253",
      "erarr": "\u2971",
      "escr": "\u212F",
      "eta": "\u03B7",
      "eth": "\xF0",
      "euml": "\xEB",
      "euro": "\u20AC",
      "excl": "!",
      "fcy": "\u0444",
      "female": "\u2640",
      "ffilig": "\uFB03",
      "fflig": "\uFB00",
      "ffllig": "\uFB04",
      "ffr": "\u{1D523}",
      "filig": "\uFB01",
      "fjlig": "fj",
      "flat": "\u266D",
      "fllig": "\uFB02",
      "fltns": "\u25B1",
      "fnof": "\u0192",
      "fopf": "\u{1D557}",
      "fork": "\u22D4",
      "pitchfork": "\u22D4",
      "forkv": "\u2AD9",
      "fpartint": "\u2A0D",
      "frac12": "\xBD",
      "half": "\xBD",
      "frac13": "\u2153",
      "frac14": "\xBC",
      "frac15": "\u2155",
      "frac16": "\u2159",
      "frac18": "\u215B",
      "frac23": "\u2154",
      "frac25": "\u2156",
      "frac34": "\xBE",
      "frac35": "\u2157",
      "frac38": "\u215C",
      "frac45": "\u2158",
      "frac56": "\u215A",
      "frac58": "\u215D",
      "frac78": "\u215E",
      "frasl": "\u2044",
      "frown": "\u2322",
      "sfrown": "\u2322",
      "fscr": "\u{1D4BB}",
      "gEl": "\u2A8C",
      "gtreqqless": "\u2A8C",
      "gacute": "\u01F5",
      "gamma": "\u03B3",
      "gap": "\u2A86",
      "gtrapprox": "\u2A86",
      "gbreve": "\u011F",
      "gcirc": "\u011D",
      "gcy": "\u0433",
      "gdot": "\u0121",
      "gescc": "\u2AA9",
      "gesdot": "\u2A80",
      "gesdoto": "\u2A82",
      "gesdotol": "\u2A84",
      "gesl": "\u22DB\uFE00",
      "gesles": "\u2A94",
      "gfr": "\u{1D524}",
      "gimel": "\u2137",
      "gjcy": "\u0453",
      "glE": "\u2A92",
      "gla": "\u2AA5",
      "glj": "\u2AA4",
      "gnE": "\u2269",
      "gneqq": "\u2269",
      "gnap": "\u2A8A",
      "gnapprox": "\u2A8A",
      "gne": "\u2A88",
      "gneq": "\u2A88",
      "gnsim": "\u22E7",
      "gopf": "\u{1D558}",
      "gscr": "\u210A",
      "gsime": "\u2A8E",
      "gsiml": "\u2A90",
      "gtcc": "\u2AA7",
      "gtcir": "\u2A7A",
      "gtdot": "\u22D7",
      "gtrdot": "\u22D7",
      "gtlPar": "\u2995",
      "gtquest": "\u2A7C",
      "gtrarr": "\u2978",
      "gvertneqq": "\u2269\uFE00",
      "gvnE": "\u2269\uFE00",
      "hardcy": "\u044A",
      "harrcir": "\u2948",
      "harrw": "\u21AD",
      "leftrightsquigarrow": "\u21AD",
      "hbar": "\u210F",
      "hslash": "\u210F",
      "planck": "\u210F",
      "plankv": "\u210F",
      "hcirc": "\u0125",
      "hearts": "\u2665",
      "heartsuit": "\u2665",
      "hellip": "\u2026",
      "mldr": "\u2026",
      "hercon": "\u22B9",
      "hfr": "\u{1D525}",
      "hksearow": "\u2925",
      "searhk": "\u2925",
      "hkswarow": "\u2926",
      "swarhk": "\u2926",
      "hoarr": "\u21FF",
      "homtht": "\u223B",
      "hookleftarrow": "\u21A9",
      "larrhk": "\u21A9",
      "hookrightarrow": "\u21AA",
      "rarrhk": "\u21AA",
      "hopf": "\u{1D559}",
      "horbar": "\u2015",
      "hscr": "\u{1D4BD}",
      "hstrok": "\u0127",
      "hybull": "\u2043",
      "iacute": "\xED",
      "icirc": "\xEE",
      "icy": "\u0438",
      "iecy": "\u0435",
      "iexcl": "\xA1",
      "ifr": "\u{1D526}",
      "igrave": "\xEC",
      "iiiint": "\u2A0C",
      "qint": "\u2A0C",
      "iiint": "\u222D",
      "tint": "\u222D",
      "iinfin": "\u29DC",
      "iiota": "\u2129",
      "ijlig": "\u0133",
      "imacr": "\u012B",
      "imath": "\u0131",
      "inodot": "\u0131",
      "imof": "\u22B7",
      "imped": "\u01B5",
      "incare": "\u2105",
      "infin": "\u221E",
      "infintie": "\u29DD",
      "intcal": "\u22BA",
      "intercal": "\u22BA",
      "intlarhk": "\u2A17",
      "intprod": "\u2A3C",
      "iprod": "\u2A3C",
      "iocy": "\u0451",
      "iogon": "\u012F",
      "iopf": "\u{1D55A}",
      "iota": "\u03B9",
      "iquest": "\xBF",
      "iscr": "\u{1D4BE}",
      "isinE": "\u22F9",
      "isindot": "\u22F5",
      "isins": "\u22F4",
      "isinsv": "\u22F3",
      "itilde": "\u0129",
      "iukcy": "\u0456",
      "iuml": "\xEF",
      "jcirc": "\u0135",
      "jcy": "\u0439",
      "jfr": "\u{1D527}",
      "jmath": "\u0237",
      "jopf": "\u{1D55B}",
      "jscr": "\u{1D4BF}",
      "jsercy": "\u0458",
      "jukcy": "\u0454",
      "kappa": "\u03BA",
      "kappav": "\u03F0",
      "varkappa": "\u03F0",
      "kcedil": "\u0137",
      "kcy": "\u043A",
      "kfr": "\u{1D528}",
      "kgreen": "\u0138",
      "khcy": "\u0445",
      "kjcy": "\u045C",
      "kopf": "\u{1D55C}",
      "kscr": "\u{1D4C0}",
      "lAtail": "\u291B",
      "lBarr": "\u290E",
      "lEg": "\u2A8B",
      "lesseqqgtr": "\u2A8B",
      "lHar": "\u2962",
      "lacute": "\u013A",
      "laemptyv": "\u29B4",
      "lambda": "\u03BB",
      "langd": "\u2991",
      "lap": "\u2A85",
      "lessapprox": "\u2A85",
      "laquo": "\xAB",
      "larrbfs": "\u291F",
      "larrfs": "\u291D",
      "larrlp": "\u21AB",
      "looparrowleft": "\u21AB",
      "larrpl": "\u2939",
      "larrsim": "\u2973",
      "larrtl": "\u21A2",
      "leftarrowtail": "\u21A2",
      "lat": "\u2AAB",
      "latail": "\u2919",
      "late": "\u2AAD",
      "lates": "\u2AAD\uFE00",
      "lbarr": "\u290C",
      "lbbrk": "\u2772",
      "lbrace": "{",
      "lcub": "{",
      "lbrack": "[",
      "lsqb": "[",
      "lbrke": "\u298B",
      "lbrksld": "\u298F",
      "lbrkslu": "\u298D",
      "lcaron": "\u013E",
      "lcedil": "\u013C",
      "lcy": "\u043B",
      "ldca": "\u2936",
      "ldrdhar": "\u2967",
      "ldrushar": "\u294B",
      "ldsh": "\u21B2",
      "le": "\u2264",
      "leq": "\u2264",
      "leftleftarrows": "\u21C7",
      "llarr": "\u21C7",
      "leftthreetimes": "\u22CB",
      "lthree": "\u22CB",
      "lescc": "\u2AA8",
      "lesdot": "\u2A7F",
      "lesdoto": "\u2A81",
      "lesdotor": "\u2A83",
      "lesg": "\u22DA\uFE00",
      "lesges": "\u2A93",
      "lessdot": "\u22D6",
      "ltdot": "\u22D6",
      "lfisht": "\u297C",
      "lfr": "\u{1D529}",
      "lgE": "\u2A91",
      "lharul": "\u296A",
      "lhblk": "\u2584",
      "ljcy": "\u0459",
      "llhard": "\u296B",
      "lltri": "\u25FA",
      "lmidot": "\u0140",
      "lmoust": "\u23B0",
      "lmoustache": "\u23B0",
      "lnE": "\u2268",
      "lneqq": "\u2268",
      "lnap": "\u2A89",
      "lnapprox": "\u2A89",
      "lne": "\u2A87",
      "lneq": "\u2A87",
      "lnsim": "\u22E6",
      "loang": "\u27EC",
      "loarr": "\u21FD",
      "longmapsto": "\u27FC",
      "xmap": "\u27FC",
      "looparrowright": "\u21AC",
      "rarrlp": "\u21AC",
      "lopar": "\u2985",
      "lopf": "\u{1D55D}",
      "loplus": "\u2A2D",
      "lotimes": "\u2A34",
      "lowast": "\u2217",
      "loz": "\u25CA",
      "lozenge": "\u25CA",
      "lpar": "(",
      "lparlt": "\u2993",
      "lrhard": "\u296D",
      "lrm": "\u200E",
      "lrtri": "\u22BF",
      "lsaquo": "\u2039",
      "lscr": "\u{1D4C1}",
      "lsime": "\u2A8D",
      "lsimg": "\u2A8F",
      "lsquor": "\u201A",
      "sbquo": "\u201A",
      "lstrok": "\u0142",
      "ltcc": "\u2AA6",
      "ltcir": "\u2A79",
      "ltimes": "\u22C9",
      "ltlarr": "\u2976",
      "ltquest": "\u2A7B",
      "ltrPar": "\u2996",
      "ltri": "\u25C3",
      "triangleleft": "\u25C3",
      "lurdshar": "\u294A",
      "luruhar": "\u2966",
      "lvertneqq": "\u2268\uFE00",
      "lvnE": "\u2268\uFE00",
      "mDDot": "\u223A",
      "macr": "\xAF",
      "strns": "\xAF",
      "male": "\u2642",
      "malt": "\u2720",
      "maltese": "\u2720",
      "marker": "\u25AE",
      "mcomma": "\u2A29",
      "mcy": "\u043C",
      "mdash": "\u2014",
      "mfr": "\u{1D52A}",
      "mho": "\u2127",
      "micro": "\xB5",
      "midcir": "\u2AF0",
      "minus": "\u2212",
      "minusdu": "\u2A2A",
      "mlcp": "\u2ADB",
      "models": "\u22A7",
      "mopf": "\u{1D55E}",
      "mscr": "\u{1D4C2}",
      "mu": "\u03BC",
      "multimap": "\u22B8",
      "mumap": "\u22B8",
      "nGg": "\u22D9\u0338",
      "nGt": "\u226B\u20D2",
      "nLeftarrow": "\u21CD",
      "nlArr": "\u21CD",
      "nLeftrightarrow": "\u21CE",
      "nhArr": "\u21CE",
      "nLl": "\u22D8\u0338",
      "nLt": "\u226A\u20D2",
      "nRightarrow": "\u21CF",
      "nrArr": "\u21CF",
      "nVDash": "\u22AF",
      "nVdash": "\u22AE",
      "nacute": "\u0144",
      "nang": "\u2220\u20D2",
      "napE": "\u2A70\u0338",
      "napid": "\u224B\u0338",
      "napos": "\u0149",
      "natur": "\u266E",
      "natural": "\u266E",
      "ncap": "\u2A43",
      "ncaron": "\u0148",
      "ncedil": "\u0146",
      "ncongdot": "\u2A6D\u0338",
      "ncup": "\u2A42",
      "ncy": "\u043D",
      "ndash": "\u2013",
      "neArr": "\u21D7",
      "nearhk": "\u2924",
      "nedot": "\u2250\u0338",
      "nesear": "\u2928",
      "toea": "\u2928",
      "nfr": "\u{1D52B}",
      "nharr": "\u21AE",
      "nleftrightarrow": "\u21AE",
      "nhpar": "\u2AF2",
      "nis": "\u22FC",
      "nisd": "\u22FA",
      "njcy": "\u045A",
      "nlE": "\u2266\u0338",
      "nleqq": "\u2266\u0338",
      "nlarr": "\u219A",
      "nleftarrow": "\u219A",
      "nldr": "\u2025",
      "nopf": "\u{1D55F}",
      "not": "\xAC",
      "notinE": "\u22F9\u0338",
      "notindot": "\u22F5\u0338",
      "notinvb": "\u22F7",
      "notinvc": "\u22F6",
      "notnivb": "\u22FE",
      "notnivc": "\u22FD",
      "nparsl": "\u2AFD\u20E5",
      "npart": "\u2202\u0338",
      "npolint": "\u2A14",
      "nrarr": "\u219B",
      "nrightarrow": "\u219B",
      "nrarrc": "\u2933\u0338",
      "nrarrw": "\u219D\u0338",
      "nscr": "\u{1D4C3}",
      "nsub": "\u2284",
      "nsubE": "\u2AC5\u0338",
      "nsubseteqq": "\u2AC5\u0338",
      "nsup": "\u2285",
      "nsupE": "\u2AC6\u0338",
      "nsupseteqq": "\u2AC6\u0338",
      "ntilde": "\xF1",
      "nu": "\u03BD",
      "num": "#",
      "numero": "\u2116",
      "numsp": "\u2007",
      "nvDash": "\u22AD",
      "nvHarr": "\u2904",
      "nvap": "\u224D\u20D2",
      "nvdash": "\u22AC",
      "nvge": "\u2265\u20D2",
      "nvgt": ">\u20D2",
      "nvinfin": "\u29DE",
      "nvlArr": "\u2902",
      "nvle": "\u2264\u20D2",
      "nvlt": "<\u20D2",
      "nvltrie": "\u22B4\u20D2",
      "nvrArr": "\u2903",
      "nvrtrie": "\u22B5\u20D2",
      "nvsim": "\u223C\u20D2",
      "nwArr": "\u21D6",
      "nwarhk": "\u2923",
      "nwnear": "\u2927",
      "oacute": "\xF3",
      "ocirc": "\xF4",
      "ocy": "\u043E",
      "odblac": "\u0151",
      "odiv": "\u2A38",
      "odsold": "\u29BC",
      "oelig": "\u0153",
      "ofcir": "\u29BF",
      "ofr": "\u{1D52C}",
      "ogon": "\u02DB",
      "ograve": "\xF2",
      "ogt": "\u29C1",
      "ohbar": "\u29B5",
      "olcir": "\u29BE",
      "olcross": "\u29BB",
      "olt": "\u29C0",
      "omacr": "\u014D",
      "omega": "\u03C9",
      "omicron": "\u03BF",
      "omid": "\u29B6",
      "oopf": "\u{1D560}",
      "opar": "\u29B7",
      "operp": "\u29B9",
      "or": "\u2228",
      "vee": "\u2228",
      "ord": "\u2A5D",
      "order": "\u2134",
      "orderof": "\u2134",
      "oscr": "\u2134",
      "ordf": "\xAA",
      "ordm": "\xBA",
      "origof": "\u22B6",
      "oror": "\u2A56",
      "orslope": "\u2A57",
      "orv": "\u2A5B",
      "oslash": "\xF8",
      "osol": "\u2298",
      "otilde": "\xF5",
      "otimesas": "\u2A36",
      "ouml": "\xF6",
      "ovbar": "\u233D",
      "para": "\xB6",
      "parsim": "\u2AF3",
      "parsl": "\u2AFD",
      "pcy": "\u043F",
      "percnt": "%",
      "period": ".",
      "permil": "\u2030",
      "pertenk": "\u2031",
      "pfr": "\u{1D52D}",
      "phi": "\u03C6",
      "phiv": "\u03D5",
      "straightphi": "\u03D5",
      "varphi": "\u03D5",
      "phone": "\u260E",
      "pi": "\u03C0",
      "piv": "\u03D6",
      "varpi": "\u03D6",
      "planckh": "\u210E",
      "plus": "+",
      "plusacir": "\u2A23",
      "pluscir": "\u2A22",
      "plusdu": "\u2A25",
      "pluse": "\u2A72",
      "plussim": "\u2A26",
      "plustwo": "\u2A27",
      "pointint": "\u2A15",
      "popf": "\u{1D561}",
      "pound": "\xA3",
      "prE": "\u2AB3",
      "prap": "\u2AB7",
      "precapprox": "\u2AB7",
      "precnapprox": "\u2AB9",
      "prnap": "\u2AB9",
      "precneqq": "\u2AB5",
      "prnE": "\u2AB5",
      "precnsim": "\u22E8",
      "prnsim": "\u22E8",
      "prime": "\u2032",
      "profalar": "\u232E",
      "profline": "\u2312",
      "profsurf": "\u2313",
      "prurel": "\u22B0",
      "pscr": "\u{1D4C5}",
      "psi": "\u03C8",
      "puncsp": "\u2008",
      "qfr": "\u{1D52E}",
      "qopf": "\u{1D562}",
      "qprime": "\u2057",
      "qscr": "\u{1D4C6}",
      "quatint": "\u2A16",
      "quest": "?",
      "rAtail": "\u291C",
      "rHar": "\u2964",
      "race": "\u223D\u0331",
      "racute": "\u0155",
      "raemptyv": "\u29B3",
      "rangd": "\u2992",
      "range": "\u29A5",
      "raquo": "\xBB",
      "rarrap": "\u2975",
      "rarrbfs": "\u2920",
      "rarrc": "\u2933",
      "rarrfs": "\u291E",
      "rarrpl": "\u2945",
      "rarrsim": "\u2974",
      "rarrtl": "\u21A3",
      "rightarrowtail": "\u21A3",
      "rarrw": "\u219D",
      "rightsquigarrow": "\u219D",
      "ratail": "\u291A",
      "ratio": "\u2236",
      "rbbrk": "\u2773",
      "rbrace": "}",
      "rcub": "}",
      "rbrack": "]",
      "rsqb": "]",
      "rbrke": "\u298C",
      "rbrksld": "\u298E",
      "rbrkslu": "\u2990",
      "rcaron": "\u0159",
      "rcedil": "\u0157",
      "rcy": "\u0440",
      "rdca": "\u2937",
      "rdldhar": "\u2969",
      "rdsh": "\u21B3",
      "rect": "\u25AD",
      "rfisht": "\u297D",
      "rfr": "\u{1D52F}",
      "rharul": "\u296C",
      "rho": "\u03C1",
      "rhov": "\u03F1",
      "varrho": "\u03F1",
      "rightrightarrows": "\u21C9",
      "rrarr": "\u21C9",
      "rightthreetimes": "\u22CC",
      "rthree": "\u22CC",
      "ring": "\u02DA",
      "rlm": "\u200F",
      "rmoust": "\u23B1",
      "rmoustache": "\u23B1",
      "rnmid": "\u2AEE",
      "roang": "\u27ED",
      "roarr": "\u21FE",
      "ropar": "\u2986",
      "ropf": "\u{1D563}",
      "roplus": "\u2A2E",
      "rotimes": "\u2A35",
      "rpar": ")",
      "rpargt": "\u2994",
      "rppolint": "\u2A12",
      "rsaquo": "\u203A",
      "rscr": "\u{1D4C7}",
      "rtimes": "\u22CA",
      "rtri": "\u25B9",
      "triangleright": "\u25B9",
      "rtriltri": "\u29CE",
      "ruluhar": "\u2968",
      "rx": "\u211E",
      "sacute": "\u015B",
      "scE": "\u2AB4",
      "scap": "\u2AB8",
      "succapprox": "\u2AB8",
      "scaron": "\u0161",
      "scedil": "\u015F",
      "scirc": "\u015D",
      "scnE": "\u2AB6",
      "succneqq": "\u2AB6",
      "scnap": "\u2ABA",
      "succnapprox": "\u2ABA",
      "scnsim": "\u22E9",
      "succnsim": "\u22E9",
      "scpolint": "\u2A13",
      "scy": "\u0441",
      "sdot": "\u22C5",
      "sdote": "\u2A66",
      "seArr": "\u21D8",
      "sect": "\xA7",
      "semi": ";",
      "seswar": "\u2929",
      "tosa": "\u2929",
      "sext": "\u2736",
      "sfr": "\u{1D530}",
      "sharp": "\u266F",
      "shchcy": "\u0449",
      "shcy": "\u0448",
      "shy": "\xAD",
      "sigma": "\u03C3",
      "sigmaf": "\u03C2",
      "sigmav": "\u03C2",
      "varsigma": "\u03C2",
      "simdot": "\u2A6A",
      "simg": "\u2A9E",
      "simgE": "\u2AA0",
      "siml": "\u2A9D",
      "simlE": "\u2A9F",
      "simne": "\u2246",
      "simplus": "\u2A24",
      "simrarr": "\u2972",
      "smashp": "\u2A33",
      "smeparsl": "\u29E4",
      "smile": "\u2323",
      "ssmile": "\u2323",
      "smt": "\u2AAA",
      "smte": "\u2AAC",
      "smtes": "\u2AAC\uFE00",
      "softcy": "\u044C",
      "sol": "/",
      "solb": "\u29C4",
      "solbar": "\u233F",
      "sopf": "\u{1D564}",
      "spades": "\u2660",
      "spadesuit": "\u2660",
      "sqcaps": "\u2293\uFE00",
      "sqcups": "\u2294\uFE00",
      "sscr": "\u{1D4C8}",
      "star": "\u2606",
      "sub": "\u2282",
      "subset": "\u2282",
      "subE": "\u2AC5",
      "subseteqq": "\u2AC5",
      "subdot": "\u2ABD",
      "subedot": "\u2AC3",
      "submult": "\u2AC1",
      "subnE": "\u2ACB",
      "subsetneqq": "\u2ACB",
      "subne": "\u228A",
      "subsetneq": "\u228A",
      "subplus": "\u2ABF",
      "subrarr": "\u2979",
      "subsim": "\u2AC7",
      "subsub": "\u2AD5",
      "subsup": "\u2AD3",
      "sung": "\u266A",
      "sup1": "\xB9",
      "sup2": "\xB2",
      "sup3": "\xB3",
      "supE": "\u2AC6",
      "supseteqq": "\u2AC6",
      "supdot": "\u2ABE",
      "supdsub": "\u2AD8",
      "supedot": "\u2AC4",
      "suphsol": "\u27C9",
      "suphsub": "\u2AD7",
      "suplarr": "\u297B",
      "supmult": "\u2AC2",
      "supnE": "\u2ACC",
      "supsetneqq": "\u2ACC",
      "supne": "\u228B",
      "supsetneq": "\u228B",
      "supplus": "\u2AC0",
      "supsim": "\u2AC8",
      "supsub": "\u2AD4",
      "supsup": "\u2AD6",
      "swArr": "\u21D9",
      "swnwar": "\u292A",
      "szlig": "\xDF",
      "target": "\u2316",
      "tau": "\u03C4",
      "tcaron": "\u0165",
      "tcedil": "\u0163",
      "tcy": "\u0442",
      "telrec": "\u2315",
      "tfr": "\u{1D531}",
      "theta": "\u03B8",
      "thetasym": "\u03D1",
      "thetav": "\u03D1",
      "vartheta": "\u03D1",
      "thorn": "\xFE",
      "times": "\xD7",
      "timesbar": "\u2A31",
      "timesd": "\u2A30",
      "topbot": "\u2336",
      "topcir": "\u2AF1",
      "topf": "\u{1D565}",
      "topfork": "\u2ADA",
      "tprime": "\u2034",
      "triangle": "\u25B5",
      "utri": "\u25B5",
      "triangleq": "\u225C",
      "trie": "\u225C",
      "tridot": "\u25EC",
      "triminus": "\u2A3A",
      "triplus": "\u2A39",
      "trisb": "\u29CD",
      "tritime": "\u2A3B",
      "trpezium": "\u23E2",
      "tscr": "\u{1D4C9}",
      "tscy": "\u0446",
      "tshcy": "\u045B",
      "tstrok": "\u0167",
      "uHar": "\u2963",
      "uacute": "\xFA",
      "ubrcy": "\u045E",
      "ubreve": "\u016D",
      "ucirc": "\xFB",
      "ucy": "\u0443",
      "udblac": "\u0171",
      "ufisht": "\u297E",
      "ufr": "\u{1D532}",
      "ugrave": "\xF9",
      "uhblk": "\u2580",
      "ulcorn": "\u231C",
      "ulcorner": "\u231C",
      "ulcrop": "\u230F",
      "ultri": "\u25F8",
      "umacr": "\u016B",
      "uogon": "\u0173",
      "uopf": "\u{1D566}",
      "upsi": "\u03C5",
      "upsilon": "\u03C5",
      "upuparrows": "\u21C8",
      "uuarr": "\u21C8",
      "urcorn": "\u231D",
      "urcorner": "\u231D",
      "urcrop": "\u230E",
      "uring": "\u016F",
      "urtri": "\u25F9",
      "uscr": "\u{1D4CA}",
      "utdot": "\u22F0",
      "utilde": "\u0169",
      "uuml": "\xFC",
      "uwangle": "\u29A7",
      "vBar": "\u2AE8",
      "vBarv": "\u2AE9",
      "vangrt": "\u299C",
      "varsubsetneq": "\u228A\uFE00",
      "vsubne": "\u228A\uFE00",
      "varsubsetneqq": "\u2ACB\uFE00",
      "vsubnE": "\u2ACB\uFE00",
      "varsupsetneq": "\u228B\uFE00",
      "vsupne": "\u228B\uFE00",
      "varsupsetneqq": "\u2ACC\uFE00",
      "vsupnE": "\u2ACC\uFE00",
      "vcy": "\u0432",
      "veebar": "\u22BB",
      "veeeq": "\u225A",
      "vellip": "\u22EE",
      "vfr": "\u{1D533}",
      "vopf": "\u{1D567}",
      "vscr": "\u{1D4CB}",
      "vzigzag": "\u299A",
      "wcirc": "\u0175",
      "wedbar": "\u2A5F",
      "wedgeq": "\u2259",
      "weierp": "\u2118",
      "wp": "\u2118",
      "wfr": "\u{1D534}",
      "wopf": "\u{1D568}",
      "wscr": "\u{1D4CC}",
      "xfr": "\u{1D535}",
      "xi": "\u03BE",
      "xnis": "\u22FB",
      "xopf": "\u{1D569}",
      "xscr": "\u{1D4CD}",
      "yacute": "\xFD",
      "yacy": "\u044F",
      "ycirc": "\u0177",
      "ycy": "\u044B",
      "yen": "\xA5",
      "yfr": "\u{1D536}",
      "yicy": "\u0457",
      "yopf": "\u{1D56A}",
      "yscr": "\u{1D4CE}",
      "yucy": "\u044E",
      "yuml": "\xFF",
      "zacute": "\u017A",
      "zcaron": "\u017E",
      "zcy": "\u0437",
      "zdot": "\u017C",
      "zeta": "\u03B6",
      "zfr": "\u{1D537}",
      "zhcy": "\u0436",
      "zigrarr": "\u21DD",
      "zopf": "\u{1D56B}",
      "zscr": "\u{1D4CF}",
      "zwj": "\u200D",
      "zwnj": "\u200C"
    };
    NGSP_UNICODE = "\uE500";
    NAMED_ENTITIES["ngsp"] = NGSP_UNICODE;
    TokenError = class extends ParseError {
      constructor(errorMsg, tokenType, span) {
        super(span, errorMsg);
        this.tokenType = tokenType;
      }
    };
    TokenizeResult = class {
      constructor(tokens, errors, nonNormalizedIcuExpressions) {
        this.tokens = tokens;
        this.errors = errors;
        this.nonNormalizedIcuExpressions = nonNormalizedIcuExpressions;
      }
    };
    _CR_OR_CRLF_REGEXP = /\r\n?/g;
    (function(CharacterReferenceType2) {
      CharacterReferenceType2["HEX"] = "hexadecimal";
      CharacterReferenceType2["DEC"] = "decimal";
    })(CharacterReferenceType || (CharacterReferenceType = {}));
    _ControlFlowError = class {
      constructor(error2) {
        this.error = error2;
      }
    };
    _Tokenizer = class {
      constructor(_file, _getTagDefinition, options) {
        this._getTagDefinition = _getTagDefinition;
        this._currentTokenStart = null;
        this._currentTokenType = null;
        this._expansionCaseStack = [];
        this._inInterpolation = false;
        this.tokens = [];
        this.errors = [];
        this.nonNormalizedIcuExpressions = [];
        this._tokenizeIcu = options.tokenizeExpansionForms || false;
        this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;
        this._leadingTriviaCodePoints = options.leadingTriviaChars && options.leadingTriviaChars.map((c) => c.codePointAt(0) || 0);
        const range2 = options.range || {
          endPos: _file.content.length,
          startPos: 0,
          startLine: 0,
          startCol: 0
        };
        this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range2) : new PlainCharacterCursor(_file, range2);
        this._preserveLineEndings = options.preserveLineEndings || false;
        this._escapedString = options.escapedString || false;
        this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;
        try {
          this._cursor.init();
        } catch (e) {
          this.handleError(e);
        }
      }
      _processCarriageReturns(content) {
        if (this._preserveLineEndings) {
          return content;
        }
        return content.replace(_CR_OR_CRLF_REGEXP, "\n");
      }
      tokenize() {
        while (this._cursor.peek() !== $EOF) {
          const start = this._cursor.clone();
          try {
            if (this._attemptCharCode($LT)) {
              if (this._attemptCharCode($BANG)) {
                if (this._attemptCharCode($LBRACKET)) {
                  this._consumeCdata(start);
                } else if (this._attemptCharCode($MINUS)) {
                  this._consumeComment(start);
                } else {
                  this._consumeDocType(start);
                }
              } else if (this._attemptCharCode($SLASH)) {
                this._consumeTagClose(start);
              } else {
                this._consumeTagOpen(start);
              }
            } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {
              this._consumeWithInterpolation(
                5,
                8,
                () => this._isTextEnd(),
                () => this._isTagStart()
              );
            }
          } catch (e) {
            this.handleError(e);
          }
        }
        this._beginToken(
          24
        );
        this._endToken([]);
      }
      _tokenizeExpansionForm() {
        if (this.isExpansionFormStart()) {
          this._consumeExpansionFormStart();
          return true;
        }
        if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {
          this._consumeExpansionCaseStart();
          return true;
        }
        if (this._cursor.peek() === $RBRACE) {
          if (this._isInExpansionCase()) {
            this._consumeExpansionCaseEnd();
            return true;
          }
          if (this._isInExpansionForm()) {
            this._consumeExpansionFormEnd();
            return true;
          }
        }
        return false;
      }
      _beginToken(type, start = this._cursor.clone()) {
        this._currentTokenStart = start;
        this._currentTokenType = type;
      }
      _endToken(parts, end) {
        if (this._currentTokenStart === null) {
          throw new TokenError("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(end));
        }
        if (this._currentTokenType === null) {
          throw new TokenError("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
        }
        const token = {
          type: this._currentTokenType,
          parts,
          sourceSpan: (end !== null && end !== void 0 ? end : this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints)
        };
        this.tokens.push(token);
        this._currentTokenStart = null;
        this._currentTokenType = null;
        return token;
      }
      _createError(msg, span) {
        if (this._isInExpansionForm()) {
          msg += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`;
        }
        const error2 = new TokenError(msg, this._currentTokenType, span);
        this._currentTokenStart = null;
        this._currentTokenType = null;
        return new _ControlFlowError(error2);
      }
      handleError(e) {
        if (e instanceof CursorError) {
          e = this._createError(e.msg, this._cursor.getSpan(e.cursor));
        }
        if (e instanceof _ControlFlowError) {
          this.errors.push(e.error);
        } else {
          throw e;
        }
      }
      _attemptCharCode(charCode) {
        if (this._cursor.peek() === charCode) {
          this._cursor.advance();
          return true;
        }
        return false;
      }
      _attemptCharCodeCaseInsensitive(charCode) {
        if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {
          this._cursor.advance();
          return true;
        }
        return false;
      }
      _requireCharCode(charCode) {
        const location2 = this._cursor.clone();
        if (!this._attemptCharCode(charCode)) {
          throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location2));
        }
      }
      _attemptStr(chars) {
        const len = chars.length;
        if (this._cursor.charsLeft() < len) {
          return false;
        }
        const initialPosition = this._cursor.clone();
        for (let i = 0; i < len; i++) {
          if (!this._attemptCharCode(chars.charCodeAt(i))) {
            this._cursor = initialPosition;
            return false;
          }
        }
        return true;
      }
      _attemptStrCaseInsensitive(chars) {
        for (let i = 0; i < chars.length; i++) {
          if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {
            return false;
          }
        }
        return true;
      }
      _requireStr(chars) {
        const location2 = this._cursor.clone();
        if (!this._attemptStr(chars)) {
          throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location2));
        }
      }
      _attemptCharCodeUntilFn(predicate) {
        while (!predicate(this._cursor.peek())) {
          this._cursor.advance();
        }
      }
      _requireCharCodeUntilFn(predicate, len) {
        const start = this._cursor.clone();
        this._attemptCharCodeUntilFn(predicate);
        if (this._cursor.diff(start) < len) {
          throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
        }
      }
      _attemptUntilChar(char) {
        while (this._cursor.peek() !== char) {
          this._cursor.advance();
        }
      }
      _readChar() {
        const char = String.fromCodePoint(this._cursor.peek());
        this._cursor.advance();
        return char;
      }
      _consumeEntity(textTokenType) {
        this._beginToken(
          9
        );
        const start = this._cursor.clone();
        this._cursor.advance();
        if (this._attemptCharCode($HASH)) {
          const isHex = this._attemptCharCode($x) || this._attemptCharCode($X);
          const codeStart = this._cursor.clone();
          this._attemptCharCodeUntilFn(isDigitEntityEnd);
          if (this._cursor.peek() != $SEMICOLON) {
            this._cursor.advance();
            const entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;
            throw this._createError(_unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)), this._cursor.getSpan());
          }
          const strNum = this._cursor.getChars(codeStart);
          this._cursor.advance();
          try {
            const charCode = parseInt(strNum, isHex ? 16 : 10);
            this._endToken([String.fromCharCode(charCode), this._cursor.getChars(start)]);
          } catch (_a) {
            throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());
          }
        } else {
          const nameStart = this._cursor.clone();
          this._attemptCharCodeUntilFn(isNamedEntityEnd);
          if (this._cursor.peek() != $SEMICOLON) {
            this._beginToken(textTokenType, start);
            this._cursor = nameStart;
            this._endToken(["&"]);
          } else {
            const name = this._cursor.getChars(nameStart);
            this._cursor.advance();
            const char = NAMED_ENTITIES[name];
            if (!char) {
              throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));
            }
            this._endToken([char, `&${name};`]);
          }
        }
      }
      _consumeRawText(consumeEntities, endMarkerPredicate) {
        this._beginToken(
          consumeEntities ? 6 : 7
        );
        const parts = [];
        while (true) {
          const tagCloseStart = this._cursor.clone();
          const foundEndMarker = endMarkerPredicate();
          this._cursor = tagCloseStart;
          if (foundEndMarker) {
            break;
          }
          if (consumeEntities && this._cursor.peek() === $AMPERSAND) {
            this._endToken([this._processCarriageReturns(parts.join(""))]);
            parts.length = 0;
            this._consumeEntity(
              6
            );
            this._beginToken(
              6
            );
          } else {
            parts.push(this._readChar());
          }
        }
        this._endToken([this._processCarriageReturns(parts.join(""))]);
      }
      _consumeComment(start) {
        this._beginToken(
          10,
          start
        );
        this._requireCharCode($MINUS);
        this._endToken([]);
        this._consumeRawText(false, () => this._attemptStr("-->"));
        this._beginToken(
          11
        );
        this._requireStr("-->");
        this._endToken([]);
      }
      _consumeCdata(start) {
        this._beginToken(
          12,
          start
        );
        this._requireStr("CDATA[");
        this._endToken([]);
        this._consumeRawText(false, () => this._attemptStr("]]>"));
        this._beginToken(
          13
        );
        this._requireStr("]]>");
        this._endToken([]);
      }
      _consumeDocType(start) {
        this._beginToken(
          18,
          start
        );
        const contentStart = this._cursor.clone();
        this._attemptUntilChar($GT);
        const content = this._cursor.getChars(contentStart);
        this._cursor.advance();
        this._endToken([content]);
      }
      _consumePrefixAndName() {
        const nameOrPrefixStart = this._cursor.clone();
        let prefix = "";
        while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {
          this._cursor.advance();
        }
        let nameStart;
        if (this._cursor.peek() === $COLON) {
          prefix = this._cursor.getChars(nameOrPrefixStart);
          this._cursor.advance();
          nameStart = this._cursor.clone();
        } else {
          nameStart = nameOrPrefixStart;
        }
        this._requireCharCodeUntilFn(isNameEnd, prefix === "" ? 0 : 1);
        const name = this._cursor.getChars(nameStart);
        return [prefix, name];
      }
      _consumeTagOpen(start) {
        let tagName;
        let prefix;
        let openTagToken;
        try {
          if (!isAsciiLetter(this._cursor.peek())) {
            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
          }
          openTagToken = this._consumeTagOpenStart(start);
          prefix = openTagToken.parts[0];
          tagName = openTagToken.parts[1];
          this._attemptCharCodeUntilFn(isNotWhitespace);
          while (this._cursor.peek() !== $SLASH && this._cursor.peek() !== $GT && this._cursor.peek() !== $LT && this._cursor.peek() !== $EOF) {
            this._consumeAttributeName();
            this._attemptCharCodeUntilFn(isNotWhitespace);
            if (this._attemptCharCode($EQ)) {
              this._attemptCharCodeUntilFn(isNotWhitespace);
              this._consumeAttributeValue();
            }
            this._attemptCharCodeUntilFn(isNotWhitespace);
          }
          this._consumeTagOpenEnd();
        } catch (e) {
          if (e instanceof _ControlFlowError) {
            if (openTagToken) {
              openTagToken.type = 4;
            } else {
              this._beginToken(
                5,
                start
              );
              this._endToken(["<"]);
            }
            return;
          }
          throw e;
        }
        const contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);
        if (contentTokenType === TagContentType.RAW_TEXT) {
          this._consumeRawTextWithTagClose(prefix, tagName, false);
        } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {
          this._consumeRawTextWithTagClose(prefix, tagName, true);
        }
      }
      _consumeRawTextWithTagClose(prefix, tagName, consumeEntities) {
        this._consumeRawText(consumeEntities, () => {
          if (!this._attemptCharCode($LT))
            return false;
          if (!this._attemptCharCode($SLASH))
            return false;
          this._attemptCharCodeUntilFn(isNotWhitespace);
          if (!this._attemptStrCaseInsensitive(tagName))
            return false;
          this._attemptCharCodeUntilFn(isNotWhitespace);
          return this._attemptCharCode($GT);
        });
        this._beginToken(
          3
        );
        this._requireCharCodeUntilFn((code) => code === $GT, 3);
        this._cursor.advance();
        this._endToken([prefix, tagName]);
      }
      _consumeTagOpenStart(start) {
        this._beginToken(
          0,
          start
        );
        const parts = this._consumePrefixAndName();
        return this._endToken(parts);
      }
      _consumeAttributeName() {
        const attrNameStart = this._cursor.peek();
        if (attrNameStart === $SQ || attrNameStart === $DQ) {
          throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());
        }
        this._beginToken(
          14
        );
        const prefixAndName = this._consumePrefixAndName();
        this._endToken(prefixAndName);
      }
      _consumeAttributeValue() {
        let value;
        if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {
          const quoteChar = this._cursor.peek();
          this._consumeQuote(quoteChar);
          const endPredicate = () => this._cursor.peek() === quoteChar;
          this._consumeWithInterpolation(
            16,
            17,
            endPredicate,
            endPredicate
          );
          this._consumeQuote(quoteChar);
        } else {
          const endPredicate = () => isNameEnd(this._cursor.peek());
          this._consumeWithInterpolation(
            16,
            17,
            endPredicate,
            endPredicate
          );
        }
      }
      _consumeQuote(quoteChar) {
        this._beginToken(
          15
        );
        this._requireCharCode(quoteChar);
        this._endToken([String.fromCodePoint(quoteChar)]);
      }
      _consumeTagOpenEnd() {
        const tokenType = this._attemptCharCode($SLASH) ? 2 : 1;
        this._beginToken(tokenType);
        this._requireCharCode($GT);
        this._endToken([]);
      }
      _consumeTagClose(start) {
        this._beginToken(
          3,
          start
        );
        this._attemptCharCodeUntilFn(isNotWhitespace);
        const prefixAndName = this._consumePrefixAndName();
        this._attemptCharCodeUntilFn(isNotWhitespace);
        this._requireCharCode($GT);
        this._endToken(prefixAndName);
      }
      _consumeExpansionFormStart() {
        this._beginToken(
          19
        );
        this._requireCharCode($LBRACE);
        this._endToken([]);
        this._expansionCaseStack.push(
          19
        );
        this._beginToken(
          7
        );
        const condition = this._readUntil($COMMA);
        const normalizedCondition = this._processCarriageReturns(condition);
        if (this._i18nNormalizeLineEndingsInICUs) {
          this._endToken([normalizedCondition]);
        } else {
          const conditionToken = this._endToken([condition]);
          if (normalizedCondition !== condition) {
            this.nonNormalizedIcuExpressions.push(conditionToken);
          }
        }
        this._requireCharCode($COMMA);
        this._attemptCharCodeUntilFn(isNotWhitespace);
        this._beginToken(
          7
        );
        const type = this._readUntil($COMMA);
        this._endToken([type]);
        this._requireCharCode($COMMA);
        this._attemptCharCodeUntilFn(isNotWhitespace);
      }
      _consumeExpansionCaseStart() {
        this._beginToken(
          20
        );
        const value = this._readUntil($LBRACE).trim();
        this._endToken([value]);
        this._attemptCharCodeUntilFn(isNotWhitespace);
        this._beginToken(
          21
        );
        this._requireCharCode($LBRACE);
        this._endToken([]);
        this._attemptCharCodeUntilFn(isNotWhitespace);
        this._expansionCaseStack.push(
          21
        );
      }
      _consumeExpansionCaseEnd() {
        this._beginToken(
          22
        );
        this._requireCharCode($RBRACE);
        this._endToken([]);
        this._attemptCharCodeUntilFn(isNotWhitespace);
        this._expansionCaseStack.pop();
      }
      _consumeExpansionFormEnd() {
        this._beginToken(
          23
        );
        this._requireCharCode($RBRACE);
        this._endToken([]);
        this._expansionCaseStack.pop();
      }
      _consumeWithInterpolation(textTokenType, interpolationTokenType, endPredicate, endInterpolation) {
        this._beginToken(textTokenType);
        const parts = [];
        while (!endPredicate()) {
          const current = this._cursor.clone();
          if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {
            this._endToken([this._processCarriageReturns(parts.join(""))], current);
            parts.length = 0;
            this._consumeInterpolation(interpolationTokenType, current, endInterpolation);
            this._beginToken(textTokenType);
          } else if (this._cursor.peek() === $AMPERSAND) {
            this._endToken([this._processCarriageReturns(parts.join(""))]);
            parts.length = 0;
            this._consumeEntity(textTokenType);
            this._beginToken(textTokenType);
          } else {
            parts.push(this._readChar());
          }
        }
        this._inInterpolation = false;
        this._endToken([this._processCarriageReturns(parts.join(""))]);
      }
      _consumeInterpolation(interpolationTokenType, interpolationStart, prematureEndPredicate) {
        const parts = [];
        this._beginToken(interpolationTokenType, interpolationStart);
        parts.push(this._interpolationConfig.start);
        const expressionStart = this._cursor.clone();
        let inQuote = null;
        let inComment = false;
        while (this._cursor.peek() !== $EOF && (prematureEndPredicate === null || !prematureEndPredicate())) {
          const current = this._cursor.clone();
          if (this._isTagStart()) {
            this._cursor = current;
            parts.push(this._getProcessedChars(expressionStart, current));
            this._endToken(parts);
            return;
          }
          if (inQuote === null) {
            if (this._attemptStr(this._interpolationConfig.end)) {
              parts.push(this._getProcessedChars(expressionStart, current));
              parts.push(this._interpolationConfig.end);
              this._endToken(parts);
              return;
            } else if (this._attemptStr("//")) {
              inComment = true;
            }
          }
          const char = this._cursor.peek();
          this._cursor.advance();
          if (char === $BACKSLASH) {
            this._cursor.advance();
          } else if (char === inQuote) {
            inQuote = null;
          } else if (!inComment && inQuote === null && isQuote(char)) {
            inQuote = char;
          }
        }
        parts.push(this._getProcessedChars(expressionStart, this._cursor));
        this._endToken(parts);
      }
      _getProcessedChars(start, end) {
        return this._processCarriageReturns(end.getChars(start));
      }
      _isTextEnd() {
        if (this._isTagStart() || this._cursor.peek() === $EOF) {
          return true;
        }
        if (this._tokenizeIcu && !this._inInterpolation) {
          if (this.isExpansionFormStart()) {
            return true;
          }
          if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {
            return true;
          }
        }
        return false;
      }
      _isTagStart() {
        if (this._cursor.peek() === $LT) {
          const tmp = this._cursor.clone();
          tmp.advance();
          const code = tmp.peek();
          if ($a <= code && code <= $z || $A <= code && code <= $Z || code === $SLASH || code === $BANG) {
            return true;
          }
        }
        return false;
      }
      _readUntil(char) {
        const start = this._cursor.clone();
        this._attemptUntilChar(char);
        return this._cursor.getChars(start);
      }
      _isInExpansionCase() {
        return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 21;
      }
      _isInExpansionForm() {
        return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 19;
      }
      isExpansionFormStart() {
        if (this._cursor.peek() !== $LBRACE) {
          return false;
        }
        if (this._interpolationConfig) {
          const start = this._cursor.clone();
          const isInterpolation = this._attemptStr(this._interpolationConfig.start);
          this._cursor = start;
          return !isInterpolation;
        }
        return true;
      }
    };
    PlainCharacterCursor = class {
      constructor(fileOrCursor, range2) {
        if (fileOrCursor instanceof PlainCharacterCursor) {
          this.file = fileOrCursor.file;
          this.input = fileOrCursor.input;
          this.end = fileOrCursor.end;
          const state = fileOrCursor.state;
          this.state = {
            peek: state.peek,
            offset: state.offset,
            line: state.line,
            column: state.column
          };
        } else {
          if (!range2) {
            throw new Error("Programming error: the range argument must be provided with a file argument.");
          }
          this.file = fileOrCursor;
          this.input = fileOrCursor.content;
          this.end = range2.endPos;
          this.state = {
            peek: -1,
            offset: range2.startPos,
            line: range2.startLine,
            column: range2.startCol
          };
        }
      }
      clone() {
        return new PlainCharacterCursor(this);
      }
      peek() {
        return this.state.peek;
      }
      charsLeft() {
        return this.end - this.state.offset;
      }
      diff(other) {
        return this.state.offset - other.state.offset;
      }
      advance() {
        this.advanceState(this.state);
      }
      init() {
        this.updatePeek(this.state);
      }
      getSpan(start, leadingTriviaCodePoints) {
        start = start || this;
        let fullStart = start;
        if (leadingTriviaCodePoints) {
          while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {
            if (fullStart === start) {
              start = start.clone();
            }
            start.advance();
          }
        }
        const startLocation = this.locationFromCursor(start);
        const endLocation = this.locationFromCursor(this);
        const fullStartLocation = fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;
        return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);
      }
      getChars(start) {
        return this.input.substring(start.state.offset, this.state.offset);
      }
      charAt(pos) {
        return this.input.charCodeAt(pos);
      }
      advanceState(state) {
        if (state.offset >= this.end) {
          this.state = state;
          throw new CursorError('Unexpected character "EOF"', this);
        }
        const currentChar = this.charAt(state.offset);
        if (currentChar === $LF) {
          state.line++;
          state.column = 0;
        } else if (!isNewLine(currentChar)) {
          state.column++;
        }
        state.offset++;
        this.updatePeek(state);
      }
      updatePeek(state) {
        state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);
      }
      locationFromCursor(cursor) {
        return new ParseLocation(cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);
      }
    };
    EscapedCharacterCursor = class extends PlainCharacterCursor {
      constructor(fileOrCursor, range2) {
        if (fileOrCursor instanceof EscapedCharacterCursor) {
          super(fileOrCursor);
          this.internalState = Object.assign({}, fileOrCursor.internalState);
        } else {
          super(fileOrCursor, range2);
          this.internalState = this.state;
        }
      }
      advance() {
        this.state = this.internalState;
        super.advance();
        this.processEscapeSequence();
      }
      init() {
        super.init();
        this.processEscapeSequence();
      }
      clone() {
        return new EscapedCharacterCursor(this);
      }
      getChars(start) {
        const cursor = start.clone();
        let chars = "";
        while (cursor.internalState.offset < this.internalState.offset) {
          chars += String.fromCodePoint(cursor.peek());
          cursor.advance();
        }
        return chars;
      }
      processEscapeSequence() {
        const peek = () => this.internalState.peek;
        if (peek() === $BACKSLASH) {
          this.internalState = Object.assign({}, this.state);
          this.advanceState(this.internalState);
          if (peek() === $n) {
            this.state.peek = $LF;
          } else if (peek() === $r) {
            this.state.peek = $CR;
          } else if (peek() === $v) {
            this.state.peek = $VTAB;
          } else if (peek() === $t) {
            this.state.peek = $TAB;
          } else if (peek() === $b) {
            this.state.peek = $BSPACE;
          } else if (peek() === $f) {
            this.state.peek = $FF;
          } else if (peek() === $u) {
            this.advanceState(this.internalState);
            if (peek() === $LBRACE) {
              this.advanceState(this.internalState);
              const digitStart = this.clone();
              let length = 0;
              while (peek() !== $RBRACE) {
                this.advanceState(this.internalState);
                length++;
              }
              this.state.peek = this.decodeHexDigits(digitStart, length);
            } else {
              const digitStart = this.clone();
              this.advanceState(this.internalState);
              this.advanceState(this.internalState);
              this.advanceState(this.internalState);
              this.state.peek = this.decodeHexDigits(digitStart, 4);
            }
          } else if (peek() === $x) {
            this.advanceState(this.internalState);
            const digitStart = this.clone();
            this.advanceState(this.internalState);
            this.state.peek = this.decodeHexDigits(digitStart, 2);
          } else if (isOctalDigit(peek())) {
            let octal = "";
            let length = 0;
            let previous = this.clone();
            while (isOctalDigit(peek()) && length < 3) {
              previous = this.clone();
              octal += String.fromCodePoint(peek());
              this.advanceState(this.internalState);
              length++;
            }
            this.state.peek = parseInt(octal, 8);
            this.internalState = previous.internalState;
          } else if (isNewLine(this.internalState.peek)) {
            this.advanceState(this.internalState);
            this.state = this.internalState;
          } else {
            this.state.peek = this.internalState.peek;
          }
        }
      }
      decodeHexDigits(start, length) {
        const hex = this.input.slice(start.internalState.offset, start.internalState.offset + length);
        const charCode = parseInt(hex, 16);
        if (!isNaN(charCode)) {
          return charCode;
        } else {
          start.state = start.internalState;
          throw new CursorError("Invalid hexadecimal escape sequence", start);
        }
      }
    };
    CursorError = class {
      constructor(msg, cursor) {
        this.msg = msg;
        this.cursor = cursor;
      }
    };
    TreeError = class extends ParseError {
      constructor(elementName, span, msg) {
        super(span, msg);
        this.elementName = elementName;
      }
      static create(elementName, span, msg) {
        return new TreeError(elementName, span, msg);
      }
    };
    ParseTreeResult = class {
      constructor(rootNodes, errors) {
        this.rootNodes = rootNodes;
        this.errors = errors;
      }
    };
    Parser = class {
      constructor(getTagDefinition) {
        this.getTagDefinition = getTagDefinition;
      }
      parse(source, url, options) {
        const tokenizeResult = tokenize(source, url, this.getTagDefinition, options);
        const parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);
        parser.build();
        return new ParseTreeResult(parser.rootNodes, tokenizeResult.errors.concat(parser.errors));
      }
    };
    _TreeBuilder = class {
      constructor(tokens, getTagDefinition) {
        this.tokens = tokens;
        this.getTagDefinition = getTagDefinition;
        this._index = -1;
        this._elementStack = [];
        this.rootNodes = [];
        this.errors = [];
        this._advance();
      }
      build() {
        while (this._peek.type !== 24) {
          if (this._peek.type === 0 || this._peek.type === 4) {
            this._consumeStartTag(this._advance());
          } else if (this._peek.type === 3) {
            this._consumeEndTag(this._advance());
          } else if (this._peek.type === 12) {
            this._closeVoidElement();
            this._consumeCdata(this._advance());
          } else if (this._peek.type === 10) {
            this._closeVoidElement();
            this._consumeComment(this._advance());
          } else if (this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6) {
            this._closeVoidElement();
            this._consumeText(this._advance());
          } else if (this._peek.type === 19) {
            this._consumeExpansion(this._advance());
          } else {
            this._advance();
          }
        }
      }
      _advance() {
        const prev = this._peek;
        if (this._index < this.tokens.length - 1) {
          this._index++;
        }
        this._peek = this.tokens[this._index];
        return prev;
      }
      _advanceIf(type) {
        if (this._peek.type === type) {
          return this._advance();
        }
        return null;
      }
      _consumeCdata(_startToken) {
        this._consumeText(this._advance());
        this._advanceIf(
          13
        );
      }
      _consumeComment(token) {
        const text = this._advanceIf(
          7
        );
        this._advanceIf(
          11
        );
        const value = text != null ? text.parts[0].trim() : null;
        this._addToParent(new Comment(value, token.sourceSpan));
      }
      _consumeExpansion(token) {
        const switchValue = this._advance();
        const type = this._advance();
        const cases = [];
        while (this._peek.type === 20) {
          const expCase = this._parseExpansionCase();
          if (!expCase)
            return;
          cases.push(expCase);
        }
        if (this._peek.type !== 23) {
          this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));
          return;
        }
        const sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end, token.sourceSpan.fullStart);
        this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));
        this._advance();
      }
      _parseExpansionCase() {
        const value = this._advance();
        if (this._peek.type !== 21) {
          this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));
          return null;
        }
        const start = this._advance();
        const exp = this._collectExpansionExpTokens(start);
        if (!exp)
          return null;
        const end = this._advance();
        exp.push({
          type: 24,
          parts: [],
          sourceSpan: end.sourceSpan
        });
        const expansionCaseParser = new _TreeBuilder(exp, this.getTagDefinition);
        expansionCaseParser.build();
        if (expansionCaseParser.errors.length > 0) {
          this.errors = this.errors.concat(expansionCaseParser.errors);
          return null;
        }
        const sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end, value.sourceSpan.fullStart);
        const expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end, start.sourceSpan.fullStart);
        return new ExpansionCase(value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
      }
      _collectExpansionExpTokens(start) {
        const exp = [];
        const expansionFormStack = [
          21
        ];
        while (true) {
          if (this._peek.type === 19 || this._peek.type === 21) {
            expansionFormStack.push(this._peek.type);
          }
          if (this._peek.type === 22) {
            if (lastOnStack(
              expansionFormStack,
              21
            )) {
              expansionFormStack.pop();
              if (expansionFormStack.length === 0)
                return exp;
            } else {
              this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
              return null;
            }
          }
          if (this._peek.type === 23) {
            if (lastOnStack(
              expansionFormStack,
              19
            )) {
              expansionFormStack.pop();
            } else {
              this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
              return null;
            }
          }
          if (this._peek.type === 24) {
            this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
            return null;
          }
          exp.push(this._advance());
        }
      }
      _consumeText(token) {
        const tokens = [token];
        const startSpan = token.sourceSpan;
        let text = token.parts[0];
        if (text.length > 0 && text[0] === "\n") {
          const parent = this._getParentElement();
          if (parent != null && parent.children.length === 0 && this.getTagDefinition(parent.name).ignoreFirstLf) {
            text = text.substring(1);
            tokens[0] = {
              type: token.type,
              sourceSpan: token.sourceSpan,
              parts: [text]
            };
          }
        }
        while (this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9) {
          token = this._advance();
          tokens.push(token);
          if (token.type === 8) {
            text += token.parts.join("").replace(/&([^;]+);/g, decodeEntity);
          } else if (token.type === 9) {
            text += token.parts[0];
          } else {
            text += token.parts.join("");
          }
        }
        if (text.length > 0) {
          const endSpan = token.sourceSpan;
          this._addToParent(new Text2(text, new ParseSourceSpan(startSpan.start, endSpan.end, startSpan.fullStart, startSpan.details), tokens));
        }
      }
      _closeVoidElement() {
        const el = this._getParentElement();
        if (el && this.getTagDefinition(el.name).isVoid) {
          this._elementStack.pop();
        }
      }
      _consumeStartTag(startTagToken) {
        const [prefix, name] = startTagToken.parts;
        const attrs = [];
        while (this._peek.type === 14) {
          attrs.push(this._consumeAttr(this._advance()));
        }
        const fullName = this._getElementFullName(prefix, name, this._getParentElement());
        let selfClosing = false;
        if (this._peek.type === 2) {
          this._advance();
          selfClosing = true;
          const tagDef = this.getTagDefinition(fullName);
          if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {
            this.errors.push(TreeError.create(fullName, startTagToken.sourceSpan, `Only void and foreign elements can be self closed "${startTagToken.parts[1]}"`));
          }
        } else if (this._peek.type === 1) {
          this._advance();
          selfClosing = false;
        }
        const end = this._peek.sourceSpan.fullStart;
        const span = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);
        const startSpan = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);
        const el = new Element2(fullName, attrs, [], span, startSpan, void 0);
        this._pushElement(el);
        if (selfClosing) {
          this._popElement(fullName, span);
        } else if (startTagToken.type === 4) {
          this._popElement(fullName, null);
          this.errors.push(TreeError.create(fullName, span, `Opening tag "${fullName}" not terminated.`));
        }
      }
      _pushElement(el) {
        const parentEl = this._getParentElement();
        if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {
          this._elementStack.pop();
        }
        this._addToParent(el);
        this._elementStack.push(el);
      }
      _consumeEndTag(endTagToken) {
        const fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());
        if (this.getTagDefinition(fullName).isVoid) {
          this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, `Void elements do not have end tags "${endTagToken.parts[1]}"`));
        } else if (!this._popElement(fullName, endTagToken.sourceSpan)) {
          const errMsg = `Unexpected closing tag "${fullName}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
          this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));
        }
      }
      _popElement(fullName, endSourceSpan) {
        let unexpectedCloseTagDetected = false;
        for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {
          const el = this._elementStack[stackIndex];
          if (el.name === fullName) {
            el.endSourceSpan = endSourceSpan;
            el.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : el.sourceSpan.end;
            this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);
            return !unexpectedCloseTagDetected;
          }
          if (!this.getTagDefinition(el.name).closedByParent) {
            unexpectedCloseTagDetected = true;
          }
        }
        return false;
      }
      _consumeAttr(attrName) {
        const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);
        let attrEnd = attrName.sourceSpan.end;
        if (this._peek.type === 15) {
          this._advance();
        }
        let value = "";
        const valueTokens = [];
        let valueStartSpan = void 0;
        let valueEnd = void 0;
        const nextTokenType = this._peek.type;
        if (nextTokenType === 16) {
          valueStartSpan = this._peek.sourceSpan;
          valueEnd = this._peek.sourceSpan.end;
          while (this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9) {
            const valueToken = this._advance();
            valueTokens.push(valueToken);
            if (valueToken.type === 17) {
              value += valueToken.parts.join("").replace(/&([^;]+);/g, decodeEntity);
            } else if (valueToken.type === 9) {
              value += valueToken.parts[0];
            } else {
              value += valueToken.parts.join("");
            }
            valueEnd = attrEnd = valueToken.sourceSpan.end;
          }
        }
        if (this._peek.type === 15) {
          const quoteToken = this._advance();
          attrEnd = quoteToken.sourceSpan.end;
        }
        const valueSpan = valueStartSpan && valueEnd && new ParseSourceSpan(valueStartSpan.start, valueEnd, valueStartSpan.fullStart);
        return new Attribute2(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, attrEnd, attrName.sourceSpan.fullStart), attrName.sourceSpan, valueSpan, valueTokens.length > 0 ? valueTokens : void 0, void 0);
      }
      _getParentElement() {
        return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
      }
      _addToParent(node) {
        const parent = this._getParentElement();
        if (parent != null) {
          parent.children.push(node);
        } else {
          this.rootNodes.push(node);
        }
      }
      _getElementFullName(prefix, localName, parentElement) {
        if (prefix === "") {
          prefix = this.getTagDefinition(localName).implicitNamespacePrefix || "";
          if (prefix === "" && parentElement != null) {
            const parentTagName = splitNsName(parentElement.name)[1];
            const parentTagDefinition = this.getTagDefinition(parentTagName);
            if (!parentTagDefinition.preventNamespaceInheritance) {
              prefix = getNsPrefix(parentElement.name);
            }
          }
        }
        return mergeNsAndName(prefix, localName);
      }
    };
    HtmlParser = class extends Parser {
      constructor() {
        super(getHtmlTagDefinition);
      }
      parse(source, url, options) {
        return super.parse(source, url, options);
      }
    };
    PRESERVE_WS_ATTR_NAME = "ngPreserveWhitespaces";
    SKIP_WS_TRIM_TAGS = /* @__PURE__ */ new Set(["pre", "template", "textarea", "script", "style"]);
    WS_CHARS = " \f\n\r	\v\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF";
    NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);
    WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, "g");
    WhitespaceVisitor = class {
      visitElement(element, context2) {
        if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {
          return new Element2(element.name, visitAll(this, element.attrs), element.children, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
        }
        return new Element2(element.name, element.attrs, visitAllWithSiblings(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
      }
      visitAttribute(attribute, context2) {
        return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;
      }
      visitText(text, context2) {
        const isNotBlank = text.value.match(NO_WS_REGEXP);
        const hasExpansionSibling = context2 && (context2.prev instanceof Expansion || context2.next instanceof Expansion);
        if (isNotBlank || hasExpansionSibling) {
          const tokens = text.tokens.map((token) => token.type === 5 ? createWhitespaceProcessedTextToken(token) : token);
          const value = processWhitespace(text.value);
          return new Text2(value, text.sourceSpan, tokens, text.i18n);
        }
        return null;
      }
      visitComment(comment, context2) {
        return comment;
      }
      visitExpansion(expansion, context2) {
        return expansion;
      }
      visitExpansionCase(expansionCase, context2) {
        return expansionCase;
      }
    };
    ElementSchemaRegistry = class {
    };
    BOOLEAN = "boolean";
    NUMBER = "number";
    STRING = "string";
    OBJECT = "object";
    SCHEMA = ["[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored", "[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate", "abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate", "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume", ":svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex", ":svg:graphics^:svg:|", ":svg:animation^:svg:|*begin,*end,*repeat", ":svg:geometry^:svg:|", ":svg:componentTransferFunction^:svg:|", ":svg:gradient^:svg:|", ":svg:textContent^:svg:graphics|", ":svg:textPositioning^:svg:textContent|", "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username", "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username", "audio^media|", "br^[HTMLElement]|clear", "base^[HTMLElement]|href,target", "body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink", "button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value", "canvas^[HTMLElement]|#height,#width", "content^[HTMLElement]|select", "dl^[HTMLElement]|!compact", "datalist^[HTMLElement]|", "details^[HTMLElement]|!open", "dialog^[HTMLElement]|!open,returnValue", "dir^[HTMLElement]|!compact", "div^[HTMLElement]|align", "embed^[HTMLElement]|align,height,name,src,type,width", "fieldset^[HTMLElement]|!disabled,name", "font^[HTMLElement]|color,face,size", "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target", "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src", "frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows", "hr^[HTMLElement]|align,color,!noShade,size,width", "head^[HTMLElement]|", "h1,h2,h3,h4,h5,h6^[HTMLElement]|align", "html^[HTMLElement]|version", "iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width", "img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width", "input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width", "li^[HTMLElement]|type,#value", "label^[HTMLElement]|htmlFor", "legend^[HTMLElement]|align", "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type", "map^[HTMLElement]|name", "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width", "menu^[HTMLElement]|!compact", "meta^[HTMLElement]|content,httpEquiv,name,scheme", "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value", "ins,del^[HTMLElement]|cite,dateTime", "ol^[HTMLElement]|!compact,!reversed,#start,type", "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width", "optgroup^[HTMLElement]|!disabled,label", "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value", "output^[HTMLElement]|defaultValue,%htmlFor,name,value", "p^[HTMLElement]|align", "param^[HTMLElement]|name,type,value,valueType", "picture^[HTMLElement]|", "pre^[HTMLElement]|#width", "progress^[HTMLElement]|#max,#value", "q,blockquote,cite^[HTMLElement]|", "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type", "select^[HTMLElement]|autocomplete,!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value", "shadow^[HTMLElement]|", "slot^[HTMLElement]|name", "source^[HTMLElement]|media,sizes,src,srcset,type", "span^[HTMLElement]|", "style^[HTMLElement]|!disabled,media,type", "caption^[HTMLElement]|align", "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width", "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width", "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width", "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign", "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign", "template^[HTMLElement]|", "textarea^[HTMLElement]|autocapitalize,autocomplete,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap", "title^[HTMLElement]|text", "track^[HTMLElement]|!default,kind,label,src,srclang", "ul^[HTMLElement]|!compact,type", "unknown^[HTMLElement]|", "video^media|#height,poster,#width", ":svg:a^:svg:graphics|", ":svg:animate^:svg:animation|", ":svg:animateMotion^:svg:animation|", ":svg:animateTransform^:svg:animation|", ":svg:circle^:svg:geometry|", ":svg:clipPath^:svg:graphics|", ":svg:defs^:svg:graphics|", ":svg:desc^:svg:|", ":svg:discard^:svg:|", ":svg:ellipse^:svg:geometry|", ":svg:feBlend^:svg:|", ":svg:feColorMatrix^:svg:|", ":svg:feComponentTransfer^:svg:|", ":svg:feComposite^:svg:|", ":svg:feConvolveMatrix^:svg:|", ":svg:feDiffuseLighting^:svg:|", ":svg:feDisplacementMap^:svg:|", ":svg:feDistantLight^:svg:|", ":svg:feDropShadow^:svg:|", ":svg:feFlood^:svg:|", ":svg:feFuncA^:svg:componentTransferFunction|", ":svg:feFuncB^:svg:componentTransferFunction|", ":svg:feFuncG^:svg:componentTransferFunction|", ":svg:feFuncR^:svg:componentTransferFunction|", ":svg:feGaussianBlur^:svg:|", ":svg:feImage^:svg:|", ":svg:feMerge^:svg:|", ":svg:feMergeNode^:svg:|", ":svg:feMorphology^:svg:|", ":svg:feOffset^:svg:|", ":svg:fePointLight^:svg:|", ":svg:feSpecularLighting^:svg:|", ":svg:feSpotLight^:svg:|", ":svg:feTile^:svg:|", ":svg:feTurbulence^:svg:|", ":svg:filter^:svg:|", ":svg:foreignObject^:svg:graphics|", ":svg:g^:svg:graphics|", ":svg:image^:svg:graphics|", ":svg:line^:svg:geometry|", ":svg:linearGradient^:svg:gradient|", ":svg:mpath^:svg:|", ":svg:marker^:svg:|", ":svg:mask^:svg:|", ":svg:metadata^:svg:|", ":svg:path^:svg:geometry|", ":svg:pattern^:svg:|", ":svg:polygon^:svg:geometry|", ":svg:polyline^:svg:geometry|", ":svg:radialGradient^:svg:gradient|", ":svg:rect^:svg:geometry|", ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan", ":svg:script^:svg:|type", ":svg:set^:svg:animation|", ":svg:stop^:svg:|", ":svg:style^:svg:|!disabled,media,title,type", ":svg:switch^:svg:graphics|", ":svg:symbol^:svg:|", ":svg:tspan^:svg:textPositioning|", ":svg:text^:svg:textPositioning|", ":svg:textPath^:svg:textContent|", ":svg:title^:svg:|", ":svg:use^:svg:graphics|", ":svg:view^:svg:|#zoomAndPan", "data^[HTMLElement]|value", "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name", "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default", "summary^[HTMLElement]|", "time^[HTMLElement]|dateTime", ":svg:cursor^:svg:|"];
    _ATTR_TO_PROP = {
      "class": "className",
      "for": "htmlFor",
      "formaction": "formAction",
      "innerHtml": "innerHTML",
      "readonly": "readOnly",
      "tabindex": "tabIndex"
    };
    _PROP_TO_ATTR = Object.keys(_ATTR_TO_PROP).reduce((inverted, attr) => {
      inverted[_ATTR_TO_PROP[attr]] = attr;
      return inverted;
    }, {});
    DomElementSchemaRegistry = class extends ElementSchemaRegistry {
      constructor() {
        super();
        this._schema = {};
        this._eventSchema = {};
        SCHEMA.forEach((encodedType) => {
          const type = {};
          const events = /* @__PURE__ */ new Set();
          const [strType, strProperties] = encodedType.split("|");
          const properties = strProperties.split(",");
          const [typeNames, superName] = strType.split("^");
          typeNames.split(",").forEach((tag) => {
            this._schema[tag.toLowerCase()] = type;
            this._eventSchema[tag.toLowerCase()] = events;
          });
          const superType = superName && this._schema[superName.toLowerCase()];
          if (superType) {
            Object.keys(superType).forEach((prop) => {
              type[prop] = superType[prop];
            });
            for (const superEvent of this._eventSchema[superName.toLowerCase()]) {
              events.add(superEvent);
            }
          }
          properties.forEach((property) => {
            if (property.length > 0) {
              switch (property[0]) {
                case "*":
                  events.add(property.substring(1));
                  break;
                case "!":
                  type[property.substring(1)] = BOOLEAN;
                  break;
                case "#":
                  type[property.substring(1)] = NUMBER;
                  break;
                case "%":
                  type[property.substring(1)] = OBJECT;
                  break;
                default:
                  type[property] = STRING;
              }
            }
          });
        });
      }
      hasProperty(tagName, propName, schemaMetas) {
        if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA2.name)) {
          return true;
        }
        if (tagName.indexOf("-") > -1) {
          if (isNgContainer(tagName) || isNgContent(tagName)) {
            return false;
          }
          if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA2.name)) {
            return true;
          }
        }
        const elementProperties = this._schema[tagName.toLowerCase()] || this._schema["unknown"];
        return !!elementProperties[propName];
      }
      hasElement(tagName, schemaMetas) {
        if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA2.name)) {
          return true;
        }
        if (tagName.indexOf("-") > -1) {
          if (isNgContainer(tagName) || isNgContent(tagName)) {
            return true;
          }
          if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA2.name)) {
            return true;
          }
        }
        return !!this._schema[tagName.toLowerCase()];
      }
      securityContext(tagName, propName, isAttribute) {
        if (isAttribute) {
          propName = this.getMappedPropName(propName);
        }
        tagName = tagName.toLowerCase();
        propName = propName.toLowerCase();
        let ctx = SECURITY_SCHEMA()[tagName + "|" + propName];
        if (ctx) {
          return ctx;
        }
        ctx = SECURITY_SCHEMA()["*|" + propName];
        return ctx ? ctx : SecurityContext2.NONE;
      }
      getMappedPropName(propName) {
        return _ATTR_TO_PROP[propName] || propName;
      }
      getDefaultComponentElementName() {
        return "ng-component";
      }
      validateProperty(name) {
        if (name.toLowerCase().startsWith("on")) {
          const msg = `Binding to event property '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...
If '${name}' is a directive input, make sure the directive is imported by the current module.`;
          return {
            error: true,
            msg
          };
        } else {
          return {
            error: false
          };
        }
      }
      validateAttribute(name) {
        if (name.toLowerCase().startsWith("on")) {
          const msg = `Binding to event attribute '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...`;
          return {
            error: true,
            msg
          };
        } else {
          return {
            error: false
          };
        }
      }
      allKnownElementNames() {
        return Object.keys(this._schema);
      }
      allKnownAttributesOfElement(tagName) {
        const elementProperties = this._schema[tagName.toLowerCase()] || this._schema["unknown"];
        return Object.keys(elementProperties).map((prop) => {
          var _a;
          return (_a = _PROP_TO_ATTR[prop]) !== null && _a !== void 0 ? _a : prop;
        });
      }
      allKnownEventsOfElement(tagName) {
        var _a;
        return Array.from((_a = this._eventSchema[tagName.toLowerCase()]) !== null && _a !== void 0 ? _a : []);
      }
      normalizeAnimationStyleProperty(propName) {
        return dashCaseToCamelCase(propName);
      }
      normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {
        let unit = "";
        const strVal = val.toString().trim();
        let errorMsg = null;
        if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== "0") {
          if (typeof val === "number") {
            unit = "px";
          } else {
            const valAndSuffixMatch = val.match(/^[+-]?[\d\.]+([a-z]*)$/);
            if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
              errorMsg = `Please provide a CSS unit value for ${userProvidedProp}:${val}`;
            }
          }
        }
        return {
          error: errorMsg,
          value: strVal + unit
        };
      }
    };
    TRUSTED_TYPES_SINKS = /* @__PURE__ */ new Set([
      "iframe|srcdoc",
      "*|innerhtml",
      "*|outerhtml",
      "embed|src",
      "object|codebase",
      "object|data"
    ]);
    PROPERTY_PARTS_SEPARATOR = ".";
    ATTRIBUTE_PREFIX = "attr";
    CLASS_PREFIX = "class";
    STYLE_PREFIX = "style";
    TEMPLATE_ATTR_PREFIX$1 = "*";
    ANIMATE_PROP_PREFIX = "animate-";
    BindingParser = class {
      constructor(_exprParser, _interpolationConfig, _schemaRegistry, errors) {
        this._exprParser = _exprParser;
        this._interpolationConfig = _interpolationConfig;
        this._schemaRegistry = _schemaRegistry;
        this.errors = errors;
      }
      get interpolationConfig() {
        return this._interpolationConfig;
      }
      createBoundHostProperties(properties, sourceSpan) {
        const boundProps = [];
        for (const propName of Object.keys(properties)) {
          const expression = properties[propName];
          if (typeof expression === "string") {
            this.parsePropertyBinding(
              propName,
              expression,
              true,
              sourceSpan,
              sourceSpan.start.offset,
              void 0,
              [],
              boundProps,
              sourceSpan
            );
          } else {
            this._reportError(`Value of the host property binding "${propName}" needs to be a string representing an expression but got "${expression}" (${typeof expression})`, sourceSpan);
          }
        }
        return boundProps;
      }
      createDirectiveHostEventAsts(hostListeners, sourceSpan) {
        const targetEvents = [];
        for (const propName of Object.keys(hostListeners)) {
          const expression = hostListeners[propName];
          if (typeof expression === "string") {
            this.parseEvent(
              propName,
              expression,
              false,
              sourceSpan,
              sourceSpan,
              [],
              targetEvents,
              sourceSpan
            );
          } else {
            this._reportError(`Value of the host listener "${propName}" needs to be a string representing an expression but got "${expression}" (${typeof expression})`, sourceSpan);
          }
        }
        return targetEvents;
      }
      parseInterpolation(value, sourceSpan, interpolatedTokens) {
        const sourceInfo = sourceSpan.start.toString();
        const absoluteOffset = sourceSpan.fullStart.offset;
        try {
          const ast = this._exprParser.parseInterpolation(value, sourceInfo, absoluteOffset, interpolatedTokens, this._interpolationConfig);
          if (ast)
            this._reportExpressionParserErrors(ast.errors, sourceSpan);
          return ast;
        } catch (e) {
          this._reportError(`${e}`, sourceSpan);
          return this._exprParser.wrapLiteralPrimitive("ERROR", sourceInfo, absoluteOffset);
        }
      }
      parseInterpolationExpression(expression, sourceSpan) {
        const sourceInfo = sourceSpan.start.toString();
        const absoluteOffset = sourceSpan.start.offset;
        try {
          const ast = this._exprParser.parseInterpolationExpression(expression, sourceInfo, absoluteOffset);
          if (ast)
            this._reportExpressionParserErrors(ast.errors, sourceSpan);
          return ast;
        } catch (e) {
          this._reportError(`${e}`, sourceSpan);
          return this._exprParser.wrapLiteralPrimitive("ERROR", sourceInfo, absoluteOffset);
        }
      }
      parseInlineTemplateBinding(tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars, isIvyAst) {
        const absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX$1.length;
        const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);
        for (const binding of bindings) {
          const bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);
          const key = binding.key.source;
          const keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);
          if (binding instanceof VariableBinding) {
            const value = binding.value ? binding.value.source : "$implicit";
            const valueSpan = binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : void 0;
            targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));
          } else if (binding.value) {
            const srcSpan = isIvyAst ? bindingSpan : sourceSpan;
            const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);
            this._parsePropertyAst(key, binding.value, srcSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);
          } else {
            targetMatchableAttrs.push([
              key,
              ""
            ]);
            this.parseLiteralAttr(
              key,
              null,
              keySpan,
              absoluteValueOffset,
              void 0,
              targetMatchableAttrs,
              targetProps,
              keySpan
            );
          }
        }
      }
      _parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset) {
        const sourceInfo = sourceSpan.start.toString();
        try {
          const bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);
          this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);
          bindingsResult.warnings.forEach((warning) => {
            this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);
          });
          return bindingsResult.templateBindings;
        } catch (e) {
          this._reportError(`${e}`, sourceSpan);
          return [];
        }
      }
      parseLiteralAttr(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {
        if (isAnimationLabel(name)) {
          name = name.substring(1);
          if (keySpan !== void 0) {
            keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));
          }
          if (value) {
            this._reportError(`Assigning animation triggers via @prop="exp" attributes with an expression is invalid. Use property bindings (e.g. [@prop]="exp") or use an attribute without a value (e.g. @prop) instead.`, sourceSpan, ParseErrorLevel.ERROR);
          }
          this._parseAnimation(name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);
        } else {
          targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, "", absoluteOffset), ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));
        }
      }
      parsePropertyBinding(name, expression, isHost, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {
        if (name.length === 0) {
          this._reportError(`Property name is missing in binding`, sourceSpan);
        }
        let isAnimationProp2 = false;
        if (name.startsWith(ANIMATE_PROP_PREFIX)) {
          isAnimationProp2 = true;
          name = name.substring(ANIMATE_PROP_PREFIX.length);
          if (keySpan !== void 0) {
            keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + ANIMATE_PROP_PREFIX.length, keySpan.end.offset));
          }
        } else if (isAnimationLabel(name)) {
          isAnimationProp2 = true;
          name = name.substring(1);
          if (keySpan !== void 0) {
            keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));
          }
        }
        if (isAnimationProp2) {
          this._parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);
        } else {
          this._parsePropertyAst(name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);
        }
      }
      parsePropertyInterpolation(name, value, sourceSpan, valueSpan, targetMatchableAttrs, targetProps, keySpan, interpolatedTokens) {
        const expr = this.parseInterpolation(value, valueSpan || sourceSpan, interpolatedTokens);
        if (expr) {
          this._parsePropertyAst(name, expr, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);
          return true;
        }
        return false;
      }
      _parsePropertyAst(name, ast, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps) {
        targetMatchableAttrs.push([name, ast.source]);
        targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));
      }
      _parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps) {
        if (name.length === 0) {
          this._reportError("Animation trigger is missing", sourceSpan);
        }
        const ast = this._parseBinding(expression || "undefined", false, valueSpan || sourceSpan, absoluteOffset);
        targetMatchableAttrs.push([name, ast.source]);
        targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));
      }
      _parseBinding(value, isHostBinding2, sourceSpan, absoluteOffset) {
        const sourceInfo = (sourceSpan && sourceSpan.start || "(unknown)").toString();
        try {
          const ast = isHostBinding2 ? this._exprParser.parseSimpleBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig) : this._exprParser.parseBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig);
          if (ast)
            this._reportExpressionParserErrors(ast.errors, sourceSpan);
          return ast;
        } catch (e) {
          this._reportError(`${e}`, sourceSpan);
          return this._exprParser.wrapLiteralPrimitive("ERROR", sourceInfo, absoluteOffset);
        }
      }
      createBoundElementProperty(elementSelector, boundProp, skipValidation = false, mapPropertyName = true) {
        if (boundProp.isAnimation) {
          return new BoundElementProperty(
            boundProp.name,
            4,
            SecurityContext2.NONE,
            boundProp.expression,
            null,
            boundProp.sourceSpan,
            boundProp.keySpan,
            boundProp.valueSpan
          );
        }
        let unit = null;
        let bindingType = void 0;
        let boundPropertyName = null;
        const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);
        let securityContexts = void 0;
        if (parts.length > 1) {
          if (parts[0] == ATTRIBUTE_PREFIX) {
            boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);
            if (!skipValidation) {
              this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);
            }
            securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);
            const nsSeparatorIdx = boundPropertyName.indexOf(":");
            if (nsSeparatorIdx > -1) {
              const ns = boundPropertyName.substring(0, nsSeparatorIdx);
              const name = boundPropertyName.substring(nsSeparatorIdx + 1);
              boundPropertyName = mergeNsAndName(ns, name);
            }
            bindingType = 1;
          } else if (parts[0] == CLASS_PREFIX) {
            boundPropertyName = parts[1];
            bindingType = 2;
            securityContexts = [SecurityContext2.NONE];
          } else if (parts[0] == STYLE_PREFIX) {
            unit = parts.length > 2 ? parts[2] : null;
            boundPropertyName = parts[1];
            bindingType = 3;
            securityContexts = [SecurityContext2.STYLE];
          }
        }
        if (boundPropertyName === null) {
          const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);
          boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;
          securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);
          bindingType = 0;
          if (!skipValidation) {
            this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);
          }
        }
        return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);
      }
      parseEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {
        if (name.length === 0) {
          this._reportError(`Event name is missing in binding`, sourceSpan);
        }
        if (isAnimationLabel(name)) {
          name = name.slice(1);
          if (keySpan !== void 0) {
            keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));
          }
          this._parseAnimationEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetEvents, keySpan);
        } else {
          this._parseRegularEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan);
        }
      }
      calcPossibleSecurityContexts(selector, propName, isAttribute) {
        const prop = this._schemaRegistry.getMappedPropName(propName);
        return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);
      }
      _parseAnimationEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetEvents, keySpan) {
        const matches = splitAtPeriod(name, [name, ""]);
        const eventName = matches[0];
        const phase = matches[1].toLowerCase();
        const ast = this._parseAction(expression, isAssignmentEvent, handlerSpan);
        targetEvents.push(new ParsedEvent(
          eventName,
          phase,
          1,
          ast,
          sourceSpan,
          handlerSpan,
          keySpan
        ));
        if (eventName.length === 0) {
          this._reportError(`Animation event name is missing in binding`, sourceSpan);
        }
        if (phase) {
          if (phase !== "start" && phase !== "done") {
            this._reportError(`The provided animation output phase value "${phase}" for "@${eventName}" is not supported (use start or done)`, sourceSpan);
          }
        } else {
          this._reportError(`The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`, sourceSpan);
        }
      }
      _parseRegularEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {
        const [target, eventName] = splitAtColon(name, [null, name]);
        const ast = this._parseAction(expression, isAssignmentEvent, handlerSpan);
        targetMatchableAttrs.push([name, ast.source]);
        targetEvents.push(new ParsedEvent(
          eventName,
          target,
          0,
          ast,
          sourceSpan,
          handlerSpan,
          keySpan
        ));
      }
      _parseAction(value, isAssignmentEvent, sourceSpan) {
        const sourceInfo = (sourceSpan && sourceSpan.start || "(unknown").toString();
        const absoluteOffset = sourceSpan && sourceSpan.start ? sourceSpan.start.offset : 0;
        try {
          const ast = this._exprParser.parseAction(value, isAssignmentEvent, sourceInfo, absoluteOffset, this._interpolationConfig);
          if (ast) {
            this._reportExpressionParserErrors(ast.errors, sourceSpan);
          }
          if (!ast || ast.ast instanceof EmptyExpr) {
            this._reportError(`Empty expressions are not allowed`, sourceSpan);
            return this._exprParser.wrapLiteralPrimitive("ERROR", sourceInfo, absoluteOffset);
          }
          return ast;
        } catch (e) {
          this._reportError(`${e}`, sourceSpan);
          return this._exprParser.wrapLiteralPrimitive("ERROR", sourceInfo, absoluteOffset);
        }
      }
      _reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {
        this.errors.push(new ParseError(sourceSpan, message, level));
      }
      _reportExpressionParserErrors(errors, sourceSpan) {
        for (const error2 of errors) {
          this._reportError(error2.message, sourceSpan);
        }
      }
      _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {
        const report = isAttr ? this._schemaRegistry.validateAttribute(propName) : this._schemaRegistry.validateProperty(propName);
        if (report.error) {
          this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);
        }
      }
    };
    URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;
    NG_CONTENT_SELECT_ATTR$1 = "select";
    LINK_ELEMENT = "link";
    LINK_STYLE_REL_ATTR = "rel";
    LINK_STYLE_HREF_ATTR = "href";
    LINK_STYLE_REL_VALUE = "stylesheet";
    STYLE_ELEMENT = "style";
    SCRIPT_ELEMENT = "script";
    NG_NON_BINDABLE_ATTR = "ngNonBindable";
    NG_PROJECT_AS = "ngProjectAs";
    (function(PreparsedElementType2) {
      PreparsedElementType2[PreparsedElementType2["NG_CONTENT"] = 0] = "NG_CONTENT";
      PreparsedElementType2[PreparsedElementType2["STYLE"] = 1] = "STYLE";
      PreparsedElementType2[PreparsedElementType2["STYLESHEET"] = 2] = "STYLESHEET";
      PreparsedElementType2[PreparsedElementType2["SCRIPT"] = 3] = "SCRIPT";
      PreparsedElementType2[PreparsedElementType2["OTHER"] = 4] = "OTHER";
    })(PreparsedElementType || (PreparsedElementType = {}));
    PreparsedElement = class {
      constructor(type, selectAttr, hrefAttr, nonBindable, projectAs) {
        this.type = type;
        this.selectAttr = selectAttr;
        this.hrefAttr = hrefAttr;
        this.nonBindable = nonBindable;
        this.projectAs = projectAs;
      }
    };
    BIND_NAME_REGEXP = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/;
    KW_BIND_IDX = 1;
    KW_LET_IDX = 2;
    KW_REF_IDX = 3;
    KW_ON_IDX = 4;
    KW_BINDON_IDX = 5;
    KW_AT_IDX = 6;
    IDENT_KW_IDX = 7;
    BINDING_DELIMS = {
      BANANA_BOX: {
        start: "[(",
        end: ")]"
      },
      PROPERTY: {
        start: "[",
        end: "]"
      },
      EVENT: {
        start: "(",
        end: ")"
      }
    };
    TEMPLATE_ATTR_PREFIX = "*";
    HtmlAstToIvyAst = class {
      constructor(bindingParser, options) {
        this.bindingParser = bindingParser;
        this.options = options;
        this.errors = [];
        this.styles = [];
        this.styleUrls = [];
        this.ngContentSelectors = [];
        this.commentNodes = [];
        this.inI18nBlock = false;
      }
      visitElement(element) {
        const isI18nRootElement = isI18nRootNode(element.i18n);
        if (isI18nRootElement) {
          if (this.inI18nBlock) {
            this.reportError("Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.", element.sourceSpan);
          }
          this.inI18nBlock = true;
        }
        const preparsedElement = preparseElement(element);
        if (preparsedElement.type === PreparsedElementType.SCRIPT) {
          return null;
        } else if (preparsedElement.type === PreparsedElementType.STYLE) {
          const contents = textContents(element);
          if (contents !== null) {
            this.styles.push(contents);
          }
          return null;
        } else if (preparsedElement.type === PreparsedElementType.STYLESHEET && isStyleUrlResolvable(preparsedElement.hrefAttr)) {
          this.styleUrls.push(preparsedElement.hrefAttr);
          return null;
        }
        const isTemplateElement2 = isNgTemplate(element.name);
        const parsedProperties = [];
        const boundEvents = [];
        const variables = [];
        const references = [];
        const attributes = [];
        const i18nAttrsMeta = {};
        const templateParsedProperties = [];
        const templateVariables = [];
        let elementHasInlineTemplate = false;
        for (const attribute of element.attrs) {
          let hasBinding = false;
          const normalizedName = normalizeAttributeName(attribute.name);
          let isTemplateBinding = false;
          if (attribute.i18n) {
            i18nAttrsMeta[attribute.name] = attribute.i18n;
          }
          if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {
            if (elementHasInlineTemplate) {
              this.reportError(`Can't have multiple template bindings on one element. Use only one attribute prefixed with *`, attribute.sourceSpan);
            }
            isTemplateBinding = true;
            elementHasInlineTemplate = true;
            const templateValue = attribute.value;
            const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);
            const parsedVariables = [];
            const absoluteValueOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : attribute.sourceSpan.start.offset + attribute.name.length;
            this.bindingParser.parseInlineTemplateBinding(
              templateKey,
              templateValue,
              attribute.sourceSpan,
              absoluteValueOffset,
              [],
              templateParsedProperties,
              parsedVariables,
              true
            );
            templateVariables.push(...parsedVariables.map((v) => new Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan)));
          } else {
            hasBinding = this.parseAttribute(isTemplateElement2, attribute, [], parsedProperties, boundEvents, variables, references);
          }
          if (!hasBinding && !isTemplateBinding) {
            attributes.push(this.visitAttribute(attribute));
          }
        }
        const children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children);
        let parsedElement;
        if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
          if (element.children && !element.children.every((node) => isEmptyTextNode(node) || isCommentNode(node))) {
            this.reportError(`<ng-content> element cannot have content.`, element.sourceSpan);
          }
          const selector = preparsedElement.selectAttr;
          const attrs = element.attrs.map((attr) => this.visitAttribute(attr));
          parsedElement = new Content(selector, attrs, element.sourceSpan, element.i18n);
          this.ngContentSelectors.push(selector);
        } else if (isTemplateElement2) {
          const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);
          parsedElement = new Template(element.name, attributes, attrs.bound, boundEvents, [], children, references, variables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
        } else {
          const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);
          parsedElement = new Element$1(element.name, attributes, attrs.bound, boundEvents, children, references, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
        }
        if (elementHasInlineTemplate) {
          const attrs = this.extractAttributes("ng-template", templateParsedProperties, i18nAttrsMeta);
          const templateAttrs = [];
          attrs.literal.forEach((attr) => templateAttrs.push(attr));
          attrs.bound.forEach((attr) => templateAttrs.push(attr));
          const hoistedAttrs = parsedElement instanceof Element$1 ? {
            attributes: parsedElement.attributes,
            inputs: parsedElement.inputs,
            outputs: parsedElement.outputs
          } : {
            attributes: [],
            inputs: [],
            outputs: []
          };
          const i18n = isTemplateElement2 && isI18nRootElement ? void 0 : element.i18n;
          const name = parsedElement instanceof Template ? null : parsedElement.name;
          parsedElement = new Template(name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs, [parsedElement], [], templateVariables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, i18n);
        }
        if (isI18nRootElement) {
          this.inI18nBlock = false;
        }
        return parsedElement;
      }
      visitAttribute(attribute) {
        return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);
      }
      visitText(text) {
        return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.tokens, text.i18n);
      }
      visitExpansion(expansion) {
        if (!expansion.i18n) {
          return null;
        }
        if (!isI18nRootNode(expansion.i18n)) {
          throw new Error(`Invalid type "${expansion.i18n.constructor}" for "i18n" property of ${expansion.sourceSpan.toString()}. Expected a "Message"`);
        }
        const message = expansion.i18n;
        const vars = {};
        const placeholders = {};
        Object.keys(message.placeholders).forEach((key) => {
          const value = message.placeholders[key];
          if (key.startsWith(I18N_ICU_VAR_PREFIX)) {
            const formattedKey = key.trim();
            const ast = this.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);
            vars[formattedKey] = new BoundText(ast, value.sourceSpan);
          } else {
            placeholders[key] = this._visitTextWithInterpolation(value.text, value.sourceSpan, null);
          }
        });
        return new Icu$1(vars, placeholders, expansion.sourceSpan, message);
      }
      visitExpansionCase(expansionCase) {
        return null;
      }
      visitComment(comment) {
        if (this.options.collectCommentNodes) {
          this.commentNodes.push(new Comment$1(comment.value || "", comment.sourceSpan));
        }
        return null;
      }
      extractAttributes(elementName, properties, i18nPropsMeta) {
        const bound = [];
        const literal2 = [];
        properties.forEach((prop) => {
          const i18n = i18nPropsMeta[prop.name];
          if (prop.isLiteral) {
            literal2.push(new TextAttribute(prop.name, prop.expression.source || "", prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n));
          } else {
            const bep = this.bindingParser.createBoundElementProperty(
              elementName,
              prop,
              true,
              false
            );
            bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));
          }
        });
        return {
          bound,
          literal: literal2
        };
      }
      parseAttribute(isTemplateElement2, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {
        var _a;
        const name = normalizeAttributeName(attribute.name);
        const value = attribute.value;
        const srcSpan = attribute.sourceSpan;
        const absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;
        function createKeySpan(srcSpan2, prefix, identifier) {
          const normalizationAdjustment = attribute.name.length - name.length;
          const keySpanStart = srcSpan2.start.moveBy(prefix.length + normalizationAdjustment);
          const keySpanEnd = keySpanStart.moveBy(identifier.length);
          return new ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);
        }
        const bindParts = name.match(BIND_NAME_REGEXP);
        if (bindParts) {
          if (bindParts[KW_BIND_IDX] != null) {
            const identifier = bindParts[IDENT_KW_IDX];
            const keySpan2 = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);
            this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan2);
          } else if (bindParts[KW_LET_IDX]) {
            if (isTemplateElement2) {
              const identifier = bindParts[IDENT_KW_IDX];
              const keySpan2 = createKeySpan(srcSpan, bindParts[KW_LET_IDX], identifier);
              this.parseVariable(identifier, value, srcSpan, keySpan2, attribute.valueSpan, variables);
            } else {
              this.reportError(`"let-" is only supported on ng-template elements.`, srcSpan);
            }
          } else if (bindParts[KW_REF_IDX]) {
            const identifier = bindParts[IDENT_KW_IDX];
            const keySpan2 = createKeySpan(srcSpan, bindParts[KW_REF_IDX], identifier);
            this.parseReference(identifier, value, srcSpan, keySpan2, attribute.valueSpan, references);
          } else if (bindParts[KW_ON_IDX]) {
            const events = [];
            const identifier = bindParts[IDENT_KW_IDX];
            const keySpan2 = createKeySpan(srcSpan, bindParts[KW_ON_IDX], identifier);
            this.bindingParser.parseEvent(
              identifier,
              value,
              false,
              srcSpan,
              attribute.valueSpan || srcSpan,
              matchableAttributes,
              events,
              keySpan2
            );
            addEvents(events, boundEvents);
          } else if (bindParts[KW_BINDON_IDX]) {
            const identifier = bindParts[IDENT_KW_IDX];
            const keySpan2 = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX], identifier);
            this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan2);
            this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan2);
          } else if (bindParts[KW_AT_IDX]) {
            const keySpan2 = createKeySpan(srcSpan, "", name);
            this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan2);
          }
          return true;
        }
        let delims = null;
        if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {
          delims = BINDING_DELIMS.BANANA_BOX;
        } else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {
          delims = BINDING_DELIMS.PROPERTY;
        } else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {
          delims = BINDING_DELIMS.EVENT;
        }
        if (delims !== null && name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {
          const identifier = name.substring(delims.start.length, name.length - delims.end.length);
          const keySpan2 = createKeySpan(srcSpan, delims.start, identifier);
          if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {
            this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan2);
            this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan2);
          } else if (delims.start === BINDING_DELIMS.PROPERTY.start) {
            this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan2);
          } else {
            const events = [];
            this.bindingParser.parseEvent(
              identifier,
              value,
              false,
              srcSpan,
              attribute.valueSpan || srcSpan,
              matchableAttributes,
              events,
              keySpan2
            );
            addEvents(events, boundEvents);
          }
          return true;
        }
        const keySpan = createKeySpan(
          srcSpan,
          "",
          name
        );
        const hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan, (_a = attribute.valueTokens) !== null && _a !== void 0 ? _a : null);
        return hasBinding;
      }
      _visitTextWithInterpolation(value, sourceSpan, interpolatedTokens, i18n) {
        const valueNoNgsp = replaceNgsp2(value);
        const expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan, interpolatedTokens);
        return expr ? new BoundText(expr, sourceSpan, i18n) : new Text$3(valueNoNgsp, sourceSpan);
      }
      parseVariable(identifier, value, sourceSpan, keySpan, valueSpan, variables) {
        if (identifier.indexOf("-") > -1) {
          this.reportError(`"-" is not allowed in variable names`, sourceSpan);
        } else if (identifier.length === 0) {
          this.reportError(`Variable does not have a name`, sourceSpan);
        }
        variables.push(new Variable(identifier, value, sourceSpan, keySpan, valueSpan));
      }
      parseReference(identifier, value, sourceSpan, keySpan, valueSpan, references) {
        if (identifier.indexOf("-") > -1) {
          this.reportError(`"-" is not allowed in reference names`, sourceSpan);
        } else if (identifier.length === 0) {
          this.reportError(`Reference does not have a name`, sourceSpan);
        } else if (references.some((reference) => reference.name === identifier)) {
          this.reportError(`Reference "#${identifier}" is defined more than once`, sourceSpan);
        }
        references.push(new Reference(identifier, value, sourceSpan, keySpan, valueSpan));
      }
      parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents, keySpan) {
        const events = [];
        this.bindingParser.parseEvent(
          `${name}Change`,
          `${expression} =$event`,
          true,
          sourceSpan,
          valueSpan || sourceSpan,
          targetMatchableAttrs,
          events,
          keySpan
        );
        addEvents(events, boundEvents);
      }
      reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {
        this.errors.push(new ParseError(sourceSpan, message, level));
      }
    };
    NonBindableVisitor = class {
      visitElement(ast) {
        const preparsedElement = preparseElement(ast);
        if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE || preparsedElement.type === PreparsedElementType.STYLESHEET) {
          return null;
        }
        const children = visitAll(this, ast.children, null);
        return new Element$1(
          ast.name,
          visitAll(this, ast.attrs),
          [],
          [],
          children,
          [],
          ast.sourceSpan,
          ast.startSourceSpan,
          ast.endSourceSpan
        );
      }
      visitComment(comment) {
        return null;
      }
      visitAttribute(attribute) {
        return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);
      }
      visitText(text) {
        return new Text$3(text.value, text.sourceSpan);
      }
      visitExpansion(expansion) {
        return null;
      }
      visitExpansionCase(expansionCase) {
        return null;
      }
    };
    NON_BINDABLE_VISITOR = new NonBindableVisitor();
    (function(TagType2) {
      TagType2[TagType2["ELEMENT"] = 0] = "ELEMENT";
      TagType2[TagType2["TEMPLATE"] = 1] = "TEMPLATE";
    })(TagType || (TagType = {}));
    I18nContext = class {
      constructor(index, ref, level = 0, templateIndex = null, meta, registry) {
        this.index = index;
        this.ref = ref;
        this.level = level;
        this.templateIndex = templateIndex;
        this.meta = meta;
        this.registry = registry;
        this.bindings = /* @__PURE__ */ new Set();
        this.placeholders = /* @__PURE__ */ new Map();
        this.isEmitted = false;
        this._unresolvedCtxCount = 0;
        this._registry = registry || setupRegistry();
        this.id = this._registry.getUniqueId();
      }
      appendTag(type, node, index, closed) {
        if (node.isVoid && closed) {
          return;
        }
        const ph = node.isVoid || !closed ? node.startName : node.closeName;
        const content = {
          type,
          index,
          ctx: this.id,
          isVoid: node.isVoid,
          closed
        };
        updatePlaceholderMap(this.placeholders, ph, content);
      }
      get icus() {
        return this._registry.icus;
      }
      get isRoot() {
        return this.level === 0;
      }
      get isResolved() {
        return this._unresolvedCtxCount === 0;
      }
      getSerializedPlaceholders() {
        const result = /* @__PURE__ */ new Map();
        this.placeholders.forEach((values, key) => result.set(key, values.map(serializePlaceholderValue)));
        return result;
      }
      appendBinding(binding) {
        this.bindings.add(binding);
      }
      appendIcu(name, ref) {
        updatePlaceholderMap(this._registry.icus, name, ref);
      }
      appendBoundText(node) {
        const phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);
        phs.forEach((values, key) => updatePlaceholderMap(this.placeholders, key, ...values));
      }
      appendTemplate(node, index) {
        this.appendTag(TagType.TEMPLATE, node, index, false);
        this.appendTag(TagType.TEMPLATE, node, index, true);
        this._unresolvedCtxCount++;
      }
      appendElement(node, index, closed) {
        this.appendTag(TagType.ELEMENT, node, index, closed);
      }
      appendProjection(node, index) {
        this.appendTag(TagType.ELEMENT, node, index, false);
        this.appendTag(TagType.ELEMENT, node, index, true);
      }
      forkChildContext(index, templateIndex, meta) {
        return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);
      }
      reconcileChildContext(context2) {
        ["start", "close"].forEach((op) => {
          const key = context2.meta[`${op}Name`];
          const phs = this.placeholders.get(key) || [];
          const tag = phs.find(findTemplateFn(this.id, context2.templateIndex));
          if (tag) {
            tag.ctx = context2.id;
          }
        });
        const childPhs = context2.placeholders;
        childPhs.forEach((values, key) => {
          const phs = this.placeholders.get(key);
          if (!phs) {
            this.placeholders.set(key, values);
            return;
          }
          const tmplIdx = phs.findIndex(findTemplateFn(context2.id, context2.templateIndex));
          if (tmplIdx >= 0) {
            const isCloseTag = key.startsWith("CLOSE");
            const isTemplateTag = key.endsWith("NG-TEMPLATE");
            if (isTemplateTag) {
              phs.splice(tmplIdx + (isCloseTag ? 0 : 1), 0, ...values);
            } else {
              const idx = isCloseTag ? values.length - 1 : 0;
              values[idx].tmpl = phs[tmplIdx];
              phs.splice(tmplIdx, 1, ...values);
            }
          } else {
            phs.push(...values);
          }
          this.placeholders.set(key, phs);
        });
        this._unresolvedCtxCount--;
      }
    };
    IcuSerializerVisitor = class {
      visitText(text) {
        return text.value;
      }
      visitContainer(container) {
        return container.children.map((child) => child.visit(this)).join("");
      }
      visitIcu(icu) {
        const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
        const result = `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(" ")}}`;
        return result;
      }
      visitTagPlaceholder(ph) {
        return ph.isVoid ? this.formatPh(ph.startName) : `${this.formatPh(ph.startName)}${ph.children.map((child) => child.visit(this)).join("")}${this.formatPh(ph.closeName)}`;
      }
      visitPlaceholder(ph) {
        return this.formatPh(ph.name);
      }
      visitIcuPlaceholder(ph, context2) {
        return this.formatPh(ph.name);
      }
      formatPh(value) {
        return `{${formatI18nPlaceholderName(
          value,
          false
        )}}`;
      }
    };
    serializer = new IcuSerializerVisitor();
    TAG_TO_PLACEHOLDER_NAMES = {
      "A": "LINK",
      "B": "BOLD_TEXT",
      "BR": "LINE_BREAK",
      "EM": "EMPHASISED_TEXT",
      "H1": "HEADING_LEVEL1",
      "H2": "HEADING_LEVEL2",
      "H3": "HEADING_LEVEL3",
      "H4": "HEADING_LEVEL4",
      "H5": "HEADING_LEVEL5",
      "H6": "HEADING_LEVEL6",
      "HR": "HORIZONTAL_RULE",
      "I": "ITALIC_TEXT",
      "LI": "LIST_ITEM",
      "LINK": "MEDIA_LINK",
      "OL": "ORDERED_LIST",
      "P": "PARAGRAPH",
      "Q": "QUOTATION",
      "S": "STRIKETHROUGH_TEXT",
      "SMALL": "SMALL_TEXT",
      "SUB": "SUBSTRIPT",
      "SUP": "SUPERSCRIPT",
      "TBODY": "TABLE_BODY",
      "TD": "TABLE_CELL",
      "TFOOT": "TABLE_FOOTER",
      "TH": "TABLE_HEADER_CELL",
      "THEAD": "TABLE_HEADER",
      "TR": "TABLE_ROW",
      "TT": "MONOSPACED_TEXT",
      "U": "UNDERLINED_TEXT",
      "UL": "UNORDERED_LIST"
    };
    PlaceholderRegistry = class {
      constructor() {
        this._placeHolderNameCounts = {};
        this._signatureToName = {};
      }
      getStartTagPlaceholderName(tag, attrs, isVoid) {
        const signature = this._hashTag(tag, attrs, isVoid);
        if (this._signatureToName[signature]) {
          return this._signatureToName[signature];
        }
        const upperTag = tag.toUpperCase();
        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;
        const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);
        this._signatureToName[signature] = name;
        return name;
      }
      getCloseTagPlaceholderName(tag) {
        const signature = this._hashClosingTag(tag);
        if (this._signatureToName[signature]) {
          return this._signatureToName[signature];
        }
        const upperTag = tag.toUpperCase();
        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;
        const name = this._generateUniqueName(`CLOSE_${baseName}`);
        this._signatureToName[signature] = name;
        return name;
      }
      getPlaceholderName(name, content) {
        const upperName = name.toUpperCase();
        const signature = `PH: ${upperName}=${content}`;
        if (this._signatureToName[signature]) {
          return this._signatureToName[signature];
        }
        const uniqueName = this._generateUniqueName(upperName);
        this._signatureToName[signature] = uniqueName;
        return uniqueName;
      }
      getUniquePlaceholder(name) {
        return this._generateUniqueName(name.toUpperCase());
      }
      _hashTag(tag, attrs, isVoid) {
        const start = `<${tag}`;
        const strAttrs = Object.keys(attrs).sort().map((name) => ` ${name}=${attrs[name]}`).join("");
        const end = isVoid ? "/>" : `></${tag}>`;
        return start + strAttrs + end;
      }
      _hashClosingTag(tag) {
        return this._hashTag(`/${tag}`, {}, false);
      }
      _generateUniqueName(base) {
        const seen = this._placeHolderNameCounts.hasOwnProperty(base);
        if (!seen) {
          this._placeHolderNameCounts[base] = 1;
          return base;
        }
        const id = this._placeHolderNameCounts[base];
        this._placeHolderNameCounts[base] = id + 1;
        return `${base}_${id}`;
      }
    };
    _expParser = new Parser$1(new Lexer());
    _I18nVisitor = class {
      constructor(_expressionParser, _interpolationConfig) {
        this._expressionParser = _expressionParser;
        this._interpolationConfig = _interpolationConfig;
      }
      toI18nMessage(nodes, meaning = "", description = "", customId = "", visitNodeFn) {
        const context2 = {
          isIcu: nodes.length == 1 && nodes[0] instanceof Expansion,
          icuDepth: 0,
          placeholderRegistry: new PlaceholderRegistry(),
          placeholderToContent: {},
          placeholderToMessage: {},
          visitNodeFn: visitNodeFn || noopVisitNodeFn
        };
        const i18nodes = visitAll(this, nodes, context2);
        return new Message(i18nodes, context2.placeholderToContent, context2.placeholderToMessage, meaning, description, customId);
      }
      visitElement(el, context2) {
        var _a;
        const children = visitAll(this, el.children, context2);
        const attrs = {};
        el.attrs.forEach((attr) => {
          attrs[attr.name] = attr.value;
        });
        const isVoid = getHtmlTagDefinition(el.name).isVoid;
        const startPhName = context2.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);
        context2.placeholderToContent[startPhName] = {
          text: el.startSourceSpan.toString(),
          sourceSpan: el.startSourceSpan
        };
        let closePhName = "";
        if (!isVoid) {
          closePhName = context2.placeholderRegistry.getCloseTagPlaceholderName(el.name);
          context2.placeholderToContent[closePhName] = {
            text: `</${el.name}>`,
            sourceSpan: (_a = el.endSourceSpan) !== null && _a !== void 0 ? _a : el.sourceSpan
          };
        }
        const node = new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
        return context2.visitNodeFn(el, node);
      }
      visitAttribute(attribute, context2) {
        const node = attribute.valueTokens === void 0 || attribute.valueTokens.length === 1 ? new Text$2(attribute.value, attribute.valueSpan || attribute.sourceSpan) : this._visitTextWithInterpolation(attribute.valueTokens, attribute.valueSpan || attribute.sourceSpan, context2, attribute.i18n);
        return context2.visitNodeFn(attribute, node);
      }
      visitText(text, context2) {
        const node = text.tokens.length === 1 ? new Text$2(text.value, text.sourceSpan) : this._visitTextWithInterpolation(text.tokens, text.sourceSpan, context2, text.i18n);
        return context2.visitNodeFn(text, node);
      }
      visitComment(comment, context2) {
        return null;
      }
      visitExpansion(icu, context2) {
        context2.icuDepth++;
        const i18nIcuCases = {};
        const i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);
        icu.cases.forEach((caze) => {
          i18nIcuCases[caze.value] = new Container(caze.expression.map((node2) => node2.visit(this, context2)), caze.expSourceSpan);
        });
        context2.icuDepth--;
        if (context2.isIcu || context2.icuDepth > 0) {
          const expPh = context2.placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);
          i18nIcu.expressionPlaceholder = expPh;
          context2.placeholderToContent[expPh] = {
            text: icu.switchValue,
            sourceSpan: icu.switchValueSourceSpan
          };
          return context2.visitNodeFn(icu, i18nIcu);
        }
        const phName = context2.placeholderRegistry.getPlaceholderName("ICU", icu.sourceSpan.toString());
        context2.placeholderToMessage[phName] = this.toI18nMessage([icu], "", "", "", void 0);
        const node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);
        return context2.visitNodeFn(icu, node);
      }
      visitExpansionCase(_icuCase, _context) {
        throw new Error("Unreachable code");
      }
      _visitTextWithInterpolation(tokens, sourceSpan, context2, previousI18n) {
        const nodes = [];
        let hasInterpolation = false;
        for (const token of tokens) {
          switch (token.type) {
            case 8:
            case 17:
              hasInterpolation = true;
              const expression = token.parts[1];
              const baseName = extractPlaceholderName(expression) || "INTERPOLATION";
              const phName = context2.placeholderRegistry.getPlaceholderName(baseName, expression);
              context2.placeholderToContent[phName] = {
                text: token.parts.join(""),
                sourceSpan: token.sourceSpan
              };
              nodes.push(new Placeholder(expression, phName, token.sourceSpan));
              break;
            default:
              if (token.parts[0].length > 0) {
                const previous = nodes[nodes.length - 1];
                if (previous instanceof Text$2) {
                  previous.value += token.parts[0];
                  previous.sourceSpan = new ParseSourceSpan(previous.sourceSpan.start, token.sourceSpan.end, previous.sourceSpan.fullStart, previous.sourceSpan.details);
                } else {
                  nodes.push(new Text$2(token.parts[0], token.sourceSpan));
                }
              }
              break;
          }
        }
        if (hasInterpolation) {
          reusePreviousSourceSpans(nodes, previousI18n);
          return new Container(nodes, sourceSpan);
        } else {
          return nodes[0];
        }
      }
    };
    _CUSTOM_PH_EXP = /\/\/[\s\S]*i18n[\s\S]*\([\s\S]*ph[\s\S]*=[\s\S]*("|')([\s\S]*?)\1[\s\S]*\)/g;
    I18nError = class extends ParseError {
      constructor(span, msg) {
        super(span, msg);
      }
    };
    setI18nRefs = (htmlNode, i18nNode) => {
      if (htmlNode instanceof NodeWithI18n) {
        if (i18nNode instanceof IcuPlaceholder && htmlNode.i18n instanceof Message) {
          i18nNode.previousMessage = htmlNode.i18n;
        }
        htmlNode.i18n = i18nNode;
      }
      return i18nNode;
    };
    I18nMetaVisitor = class {
      constructor(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG, keepI18nAttrs = false, enableI18nLegacyMessageIdFormat = false) {
        this.interpolationConfig = interpolationConfig;
        this.keepI18nAttrs = keepI18nAttrs;
        this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;
        this.hasI18nMeta = false;
        this._errors = [];
        this._createI18nMessage = createI18nMessageFactory(this.interpolationConfig);
      }
      _generateI18nMessage(nodes, meta = "", visitNodeFn) {
        const {
          meaning,
          description,
          customId
        } = this._parseMetadata(meta);
        const message = this._createI18nMessage(nodes, meaning, description, customId, visitNodeFn);
        this._setMessageId(message, meta);
        this._setLegacyIds(message, meta);
        return message;
      }
      visitAllWithErrors(nodes) {
        const result = nodes.map((node) => node.visit(this, null));
        return new ParseTreeResult(result, this._errors);
      }
      visitElement(element) {
        let message = void 0;
        if (hasI18nAttrs(element)) {
          this.hasI18nMeta = true;
          const attrs = [];
          const attrsMeta = {};
          for (const attr of element.attrs) {
            if (attr.name === I18N_ATTR) {
              const i18n = element.i18n || attr.value;
              message = this._generateI18nMessage(element.children, i18n, setI18nRefs);
              if (message.nodes.length === 0) {
                message = void 0;
              }
              element.i18n = message;
            } else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {
              const name = attr.name.slice(I18N_ATTR_PREFIX.length);
              if (isTrustedTypesSink(element.name, name)) {
                this._reportError(attr, `Translating attribute '${name}' is disallowed for security reasons.`);
              } else {
                attrsMeta[name] = attr.value;
              }
            } else {
              attrs.push(attr);
            }
          }
          if (Object.keys(attrsMeta).length) {
            for (const attr of attrs) {
              const meta = attrsMeta[attr.name];
              if (meta !== void 0 && attr.value) {
                attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);
              }
            }
          }
          if (!this.keepI18nAttrs) {
            element.attrs = attrs;
          }
        }
        visitAll(this, element.children, message);
        return element;
      }
      visitExpansion(expansion, currentMessage) {
        let message;
        const meta = expansion.i18n;
        this.hasI18nMeta = true;
        if (meta instanceof IcuPlaceholder) {
          const name = meta.name;
          message = this._generateI18nMessage([expansion], meta);
          const icu = icuFromI18nMessage(message);
          icu.name = name;
          if (currentMessage !== null) {
            currentMessage.placeholderToMessage[name] = message;
          }
        } else {
          message = this._generateI18nMessage([expansion], currentMessage || meta);
        }
        expansion.i18n = message;
        return expansion;
      }
      visitText(text) {
        return text;
      }
      visitAttribute(attribute) {
        return attribute;
      }
      visitComment(comment) {
        return comment;
      }
      visitExpansionCase(expansionCase) {
        return expansionCase;
      }
      _parseMetadata(meta) {
        return typeof meta === "string" ? parseI18nMeta(meta) : meta instanceof Message ? meta : {};
      }
      _setMessageId(message, meta) {
        if (!message.id) {
          message.id = meta instanceof Message && meta.id || decimalDigest(message);
        }
      }
      _setLegacyIds(message, meta) {
        if (this.enableI18nLegacyMessageIdFormat) {
          message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];
        } else if (typeof meta !== "string") {
          const previousMessage = meta instanceof Message ? meta : meta instanceof IcuPlaceholder ? meta.previousMessage : void 0;
          message.legacyIds = previousMessage ? previousMessage.legacyIds : [];
        }
      }
      _reportError(node, msg) {
        this._errors.push(new I18nError(node.sourceSpan, msg));
      }
    };
    I18N_MEANING_SEPARATOR = "|";
    I18N_ID_SEPARATOR = "@@";
    GOOG_GET_MSG = "goog.getMsg";
    GetMsgSerializerVisitor = class {
      formatPh(value) {
        return `{$${formatI18nPlaceholderName(value)}}`;
      }
      visitText(text) {
        return text.value;
      }
      visitContainer(container) {
        return container.children.map((child) => child.visit(this)).join("");
      }
      visitIcu(icu) {
        return serializeIcuNode(icu);
      }
      visitTagPlaceholder(ph) {
        return ph.isVoid ? this.formatPh(ph.startName) : `${this.formatPh(ph.startName)}${ph.children.map((child) => child.visit(this)).join("")}${this.formatPh(ph.closeName)}`;
      }
      visitPlaceholder(ph) {
        return this.formatPh(ph.name);
      }
      visitIcuPlaceholder(ph, context2) {
        return this.formatPh(ph.name);
      }
    };
    serializerVisitor = new GetMsgSerializerVisitor();
    LocalizeSerializerVisitor = class {
      constructor(placeholderToMessage, pieces) {
        this.placeholderToMessage = placeholderToMessage;
        this.pieces = pieces;
      }
      visitText(text) {
        if (this.pieces[this.pieces.length - 1] instanceof LiteralPiece) {
          this.pieces[this.pieces.length - 1].text += text.value;
        } else {
          const sourceSpan = new ParseSourceSpan(text.sourceSpan.fullStart, text.sourceSpan.end, text.sourceSpan.fullStart, text.sourceSpan.details);
          this.pieces.push(new LiteralPiece(text.value, sourceSpan));
        }
      }
      visitContainer(container) {
        container.children.forEach((child) => child.visit(this));
      }
      visitIcu(icu) {
        this.pieces.push(new LiteralPiece(serializeIcuNode(icu), icu.sourceSpan));
      }
      visitTagPlaceholder(ph) {
        var _a, _b;
        this.pieces.push(this.createPlaceholderPiece(ph.startName, (_a = ph.startSourceSpan) !== null && _a !== void 0 ? _a : ph.sourceSpan));
        if (!ph.isVoid) {
          ph.children.forEach((child) => child.visit(this));
          this.pieces.push(this.createPlaceholderPiece(ph.closeName, (_b = ph.endSourceSpan) !== null && _b !== void 0 ? _b : ph.sourceSpan));
        }
      }
      visitPlaceholder(ph) {
        this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));
      }
      visitIcuPlaceholder(ph) {
        this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan, this.placeholderToMessage[ph.name]));
      }
      createPlaceholderPiece(name, sourceSpan, associatedMessage) {
        return new PlaceholderPiece(formatI18nPlaceholderName(
          name,
          false
        ), sourceSpan, associatedMessage);
      }
    };
    NG_CONTENT_SELECT_ATTR = "select";
    NG_PROJECT_AS_ATTR_NAME = "ngProjectAs";
    EVENT_BINDING_SCOPE_GLOBALS = /* @__PURE__ */ new Set(["$event"]);
    GLOBAL_TARGET_RESOLVERS = /* @__PURE__ */ new Map([["window", Identifiers.resolveWindow], ["document", Identifiers.resolveDocument], ["body", Identifiers.resolveBody]]);
    LEADING_TRIVIA_CHARS = [" ", "\n", "\r", "	"];
    TemplateDefinitionBuilder = class {
      constructor(constantPool, parentBindingScope, level = 0, contextName, i18nContext, templateIndex, templateName, _namespace, relativeContextFilePath, i18nUseExternalIds, _constants = createComponentDefConsts()) {
        this.constantPool = constantPool;
        this.level = level;
        this.contextName = contextName;
        this.i18nContext = i18nContext;
        this.templateIndex = templateIndex;
        this.templateName = templateName;
        this._namespace = _namespace;
        this.i18nUseExternalIds = i18nUseExternalIds;
        this._constants = _constants;
        this._dataIndex = 0;
        this._bindingContext = 0;
        this._prefixCode = [];
        this._creationCodeFns = [];
        this._updateCodeFns = [];
        this._currentIndex = 0;
        this._tempVariables = [];
        this._nestedTemplateFns = [];
        this.i18n = null;
        this._pureFunctionSlots = 0;
        this._bindingSlots = 0;
        this._ngContentReservedSlots = [];
        this._ngContentSelectorsOffset = 0;
        this._implicitReceiverExpr = null;
        this.visitReference = invalid;
        this.visitVariable = invalid;
        this.visitTextAttribute = invalid;
        this.visitBoundAttribute = invalid;
        this.visitBoundEvent = invalid;
        this._bindingScope = parentBindingScope.nestedScope(level);
        this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, "_") + "_";
        this._valueConverter = new ValueConverter(constantPool, () => this.allocateDataSlot(), (numSlots) => this.allocatePureFunctionSlots(numSlots), (name, localName, slot, value) => {
          this._bindingScope.set(this.level, localName, value);
          this.creationInstruction(null, Identifiers.pipe, [literal(slot), literal(name)]);
        });
      }
      buildTemplateFunction(nodes, variables, ngContentSelectorsOffset = 0, i18n) {
        this._ngContentSelectorsOffset = ngContentSelectorsOffset;
        if (this._namespace !== Identifiers.namespaceHTML) {
          this.creationInstruction(null, this._namespace);
        }
        variables.forEach((v) => this.registerContextVariables(v));
        const initI18nContext = this.i18nContext || isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) && !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n);
        const selfClosingI18nInstruction = hasTextChildrenOnly(nodes);
        if (initI18nContext) {
          this.i18nStart(null, i18n, selfClosingI18nInstruction);
        }
        visitAll$1(this, nodes);
        this._pureFunctionSlots += this._bindingSlots;
        this._valueConverter.updatePipeSlotOffsets(this._bindingSlots);
        this._nestedTemplateFns.forEach((buildTemplateFn) => buildTemplateFn());
        if (this.level === 0 && this._ngContentReservedSlots.length) {
          const parameters = [];
          if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== "*") {
            const r3ReservedSlots = this._ngContentReservedSlots.map((s) => s !== "*" ? parseSelectorToR3Selector(s) : s);
            parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));
          }
          this.creationInstruction(
            null,
            Identifiers.projectionDef,
            parameters,
            true
          );
        }
        if (initI18nContext) {
          this.i18nEnd(null, selfClosingI18nInstruction);
        }
        const creationStatements = getInstructionStatements(this._creationCodeFns);
        const updateStatements = getInstructionStatements(this._updateCodeFns);
        const creationVariables = this._bindingScope.viewSnapshotStatements();
        const updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);
        const creationBlock = creationStatements.length > 0 ? [renderFlagCheckIfStmt(
          1,
          creationVariables.concat(creationStatements)
        )] : [];
        const updateBlock = updateStatements.length > 0 ? [renderFlagCheckIfStmt(
          2,
          updateVariables.concat(updateStatements)
        )] : [];
        return fn(
          [new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)],
          [
            ...this._prefixCode,
            ...creationBlock,
            ...updateBlock
          ],
          INFERRED_TYPE,
          null,
          this.templateName
        );
      }
      getLocal(name) {
        return this._bindingScope.get(name);
      }
      notifyImplicitReceiverUse() {
        this._bindingScope.notifyImplicitReceiverUse();
      }
      maybeRestoreView() {
        this._bindingScope.maybeRestoreView();
      }
      i18nTranslate(message, params = {}, ref, transformFn) {
        const _ref = ref || this.i18nGenerateMainBlockVar();
        const closureVar = this.i18nGenerateClosureVar(message.id);
        const statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);
        this._constants.prepareStatements.push(...statements);
        return _ref;
      }
      registerContextVariables(variable$1) {
        const scopedName = this._bindingScope.freshReferenceName();
        const retrievalLevel = this.level;
        const lhs = variable(variable$1.name + scopedName);
        this._bindingScope.set(
          retrievalLevel,
          variable$1.name,
          lhs,
          1,
          (scope, relativeLevel) => {
            let rhs;
            if (scope.bindingLevel === retrievalLevel) {
              if (scope.isListenerScope() && scope.hasRestoreViewVariable()) {
                rhs = variable(RESTORED_VIEW_CONTEXT_NAME);
                scope.notifyRestoredViewContextUse();
              } else {
                rhs = variable(CONTEXT_NAME);
              }
            } else {
              const sharedCtxVar = scope.getSharedContextName(retrievalLevel);
              rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);
            }
            return [lhs.set(rhs.prop(variable$1.value || IMPLICIT_REFERENCE)).toConstDecl()];
          }
        );
      }
      i18nAppendBindings(expressions) {
        if (expressions.length > 0) {
          expressions.forEach((expression) => this.i18n.appendBinding(expression));
        }
      }
      i18nBindProps(props) {
        const bound = {};
        Object.keys(props).forEach((key) => {
          const prop = props[key];
          if (prop instanceof Text$3) {
            bound[key] = literal(prop.value);
          } else {
            const value = prop.value.visit(this._valueConverter);
            this.allocateBindingSlots(value);
            if (value instanceof Interpolation) {
              const {
                strings,
                expressions
              } = value;
              const {
                id,
                bindings
              } = this.i18n;
              const label = assembleI18nBoundString(strings, bindings.size, id);
              this.i18nAppendBindings(expressions);
              bound[key] = literal(label);
            }
          }
        });
        return bound;
      }
      i18nGenerateMainBlockVar() {
        return variable(this.constantPool.uniqueName(TRANSLATION_VAR_PREFIX));
      }
      i18nGenerateClosureVar(messageId) {
        let name;
        const suffix = this.fileBasedI18nSuffix.toUpperCase();
        if (this.i18nUseExternalIds) {
          const prefix = getTranslationConstPrefix(`EXTERNAL_`);
          const uniqueSuffix = this.constantPool.uniqueName(suffix);
          name = `${prefix}${sanitizeIdentifier(messageId)}$$${uniqueSuffix}`;
        } else {
          const prefix = getTranslationConstPrefix(suffix);
          name = this.constantPool.uniqueName(prefix);
        }
        return variable(name);
      }
      i18nUpdateRef(context2) {
        const {
          icus,
          meta,
          isRoot,
          isResolved,
          isEmitted
        } = context2;
        if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {
          context2.isEmitted = true;
          const placeholders = context2.getSerializedPlaceholders();
          let icuMapping = {};
          let params = placeholders.size ? placeholdersToParams(placeholders) : {};
          if (icus.size) {
            icus.forEach((refs, key) => {
              if (refs.length === 1) {
                params[key] = refs[0];
              } else {
                const placeholder = wrapI18nPlaceholder(`${I18N_ICU_MAPPING_PREFIX}${key}`);
                params[key] = literal(placeholder);
                icuMapping[key] = literalArr(refs);
              }
            });
          }
          const needsPostprocessing = Array.from(placeholders.values()).some((value) => value.length > 1) || Object.keys(icuMapping).length;
          let transformFn;
          if (needsPostprocessing) {
            transformFn = (raw) => {
              const args = [raw];
              if (Object.keys(icuMapping).length) {
                args.push(mapLiteral(icuMapping, true));
              }
              return invokeInstruction(null, Identifiers.i18nPostprocess, args);
            };
          }
          this.i18nTranslate(meta, params, context2.ref, transformFn);
        }
      }
      i18nStart(span = null, meta, selfClosing) {
        const index = this.allocateDataSlot();
        this.i18n = this.i18nContext ? this.i18nContext.forkChildContext(index, this.templateIndex, meta) : new I18nContext(index, this.i18nGenerateMainBlockVar(), 0, this.templateIndex, meta);
        const {
          id,
          ref
        } = this.i18n;
        const params = [literal(index), this.addToConsts(ref)];
        if (id > 0) {
          params.push(literal(id));
        }
        this.creationInstruction(span, selfClosing ? Identifiers.i18n : Identifiers.i18nStart, params);
      }
      i18nEnd(span = null, selfClosing) {
        if (!this.i18n) {
          throw new Error("i18nEnd is executed with no i18n context present");
        }
        if (this.i18nContext) {
          this.i18nContext.reconcileChildContext(this.i18n);
          this.i18nUpdateRef(this.i18nContext);
        } else {
          this.i18nUpdateRef(this.i18n);
        }
        const {
          index,
          bindings
        } = this.i18n;
        if (bindings.size) {
          for (const binding of bindings) {
            this.updateInstructionWithAdvance(this.getConstCount() - 1, span, Identifiers.i18nExp, () => this.convertPropertyBinding(binding));
          }
          this.updateInstruction(span, Identifiers.i18nApply, [literal(index)]);
        }
        if (!selfClosing) {
          this.creationInstruction(span, Identifiers.i18nEnd);
        }
        this.i18n = null;
      }
      i18nAttributesInstruction(nodeIndex, attrs, sourceSpan) {
        let hasBindings = false;
        const i18nAttrArgs = [];
        attrs.forEach((attr) => {
          const message = attr.i18n;
          const converted = attr.value.visit(this._valueConverter);
          this.allocateBindingSlots(converted);
          if (converted instanceof Interpolation) {
            const placeholders = assembleBoundTextPlaceholders(message);
            const params = placeholdersToParams(placeholders);
            i18nAttrArgs.push(literal(attr.name), this.i18nTranslate(message, params));
            converted.expressions.forEach((expression) => {
              hasBindings = true;
              this.updateInstructionWithAdvance(nodeIndex, sourceSpan, Identifiers.i18nExp, () => this.convertPropertyBinding(expression));
            });
          }
        });
        if (i18nAttrArgs.length > 0) {
          const index = literal(this.allocateDataSlot());
          const constIndex = this.addToConsts(literalArr(i18nAttrArgs));
          this.creationInstruction(sourceSpan, Identifiers.i18nAttributes, [index, constIndex]);
          if (hasBindings) {
            this.updateInstruction(sourceSpan, Identifiers.i18nApply, [index]);
          }
        }
      }
      getNamespaceInstruction(namespaceKey) {
        switch (namespaceKey) {
          case "math":
            return Identifiers.namespaceMathML;
          case "svg":
            return Identifiers.namespaceSVG;
          default:
            return Identifiers.namespaceHTML;
        }
      }
      addNamespaceInstruction(nsInstruction, element) {
        this._namespace = nsInstruction;
        this.creationInstruction(element.startSourceSpan, nsInstruction);
      }
      interpolatedUpdateInstruction(instruction, elementIndex, attrName, input, value, params) {
        this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, instruction, () => [literal(attrName), ...this.getUpdateInstructionArguments(value), ...params]);
      }
      visitContent(ngContent) {
        const slot = this.allocateDataSlot();
        const projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;
        const parameters = [literal(slot)];
        this._ngContentReservedSlots.push(ngContent.selector);
        const nonContentSelectAttributes = ngContent.attributes.filter((attr) => attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR);
        const attributes = this.getAttributeExpressions(ngContent.name, nonContentSelectAttributes, [], []);
        if (attributes.length > 0) {
          parameters.push(literal(projectionSlotIdx), literalArr(attributes));
        } else if (projectionSlotIdx !== 0) {
          parameters.push(literal(projectionSlotIdx));
        }
        this.creationInstruction(ngContent.sourceSpan, Identifiers.projection, parameters);
        if (this.i18n) {
          this.i18n.appendProjection(ngContent.i18n, slot);
        }
      }
      visitElement(element) {
        var _a, _b;
        const elementIndex = this.allocateDataSlot();
        const stylingBuilder = new StylingBuilder(null);
        let isNonBindableMode = false;
        const isI18nRootElement = isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);
        const outputAttrs = [];
        const [namespaceKey, elementName] = splitNsName(element.name);
        const isNgContainer$1 = isNgContainer(element.name);
        for (const attr of element.attributes) {
          const {
            name,
            value
          } = attr;
          if (name === NON_BINDABLE_ATTR) {
            isNonBindableMode = true;
          } else if (name === "style") {
            stylingBuilder.registerStyleAttr(value);
          } else if (name === "class") {
            stylingBuilder.registerClassAttr(value);
          } else {
            outputAttrs.push(attr);
          }
        }
        const parameters = [literal(elementIndex)];
        if (!isNgContainer$1) {
          parameters.push(literal(elementName));
        }
        const allOtherInputs = [];
        const boundI18nAttrs = [];
        element.inputs.forEach((input) => {
          const stylingInputWasSet = stylingBuilder.registerBoundInput(input);
          if (!stylingInputWasSet) {
            if (input.type === 0 && input.i18n) {
              boundI18nAttrs.push(input);
            } else {
              allOtherInputs.push(input);
            }
          }
        });
        const attributes = this.getAttributeExpressions(element.name, outputAttrs, allOtherInputs, element.outputs, stylingBuilder, [], boundI18nAttrs);
        parameters.push(this.addAttrsToConsts(attributes));
        const refs = this.prepareRefsArray(element.references);
        parameters.push(this.addToConsts(refs));
        const wasInNamespace = this._namespace;
        const currentNamespace = this.getNamespaceInstruction(namespaceKey);
        if (currentNamespace !== wasInNamespace) {
          this.addNamespaceInstruction(currentNamespace, element);
        }
        if (this.i18n) {
          this.i18n.appendElement(element.i18n, elementIndex);
        }
        const hasChildren = !isI18nRootElement && this.i18n ? !hasTextChildrenOnly(element.children) : element.children.length > 0;
        const createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes && element.outputs.length === 0 && boundI18nAttrs.length === 0 && !hasChildren;
        const createSelfClosingI18nInstruction = !createSelfClosingInstruction && hasTextChildrenOnly(element.children);
        if (createSelfClosingInstruction) {
          this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers.elementContainer : Identifiers.element, trimTrailingNulls(parameters));
        } else {
          this.creationInstruction(element.startSourceSpan, isNgContainer$1 ? Identifiers.elementContainerStart : Identifiers.elementStart, trimTrailingNulls(parameters));
          if (isNonBindableMode) {
            this.creationInstruction(element.startSourceSpan, Identifiers.disableBindings);
          }
          if (boundI18nAttrs.length > 0) {
            this.i18nAttributesInstruction(elementIndex, boundI18nAttrs, (_a = element.startSourceSpan) !== null && _a !== void 0 ? _a : element.sourceSpan);
          }
          if (element.outputs.length > 0) {
            for (const outputAst of element.outputs) {
              this.creationInstruction(outputAst.sourceSpan, Identifiers.listener, this.prepareListenerParameter(element.name, outputAst, elementIndex));
            }
          }
          if (isI18nRootElement) {
            this.i18nStart(element.startSourceSpan, element.i18n, createSelfClosingI18nInstruction);
          }
        }
        const stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);
        const limit = stylingInstructions.length - 1;
        for (let i = 0; i <= limit; i++) {
          const instruction = stylingInstructions[i];
          this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, instruction);
        }
        const emptyValueBindInstruction = literal(void 0);
        const propertyBindings = [];
        const attributeBindings = [];
        allOtherInputs.forEach((input) => {
          const inputType = input.type;
          if (inputType === 4) {
            const value = input.value.visit(this._valueConverter);
            const hasValue = value instanceof LiteralPrimitive ? !!value.value : true;
            this.allocateBindingSlots(value);
            propertyBindings.push({
              span: input.sourceSpan,
              paramsOrFn: getBindingFunctionParams(() => hasValue ? this.convertPropertyBinding(value) : emptyValueBindInstruction, prepareSyntheticPropertyName(input.name))
            });
          } else {
            if (input.i18n)
              return;
            const value = input.value.visit(this._valueConverter);
            if (value !== void 0) {
              const params = [];
              const [attrNamespace, attrName] = splitNsName(input.name);
              const isAttributeBinding = inputType === 1;
              const sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);
              if (sanitizationRef)
                params.push(sanitizationRef);
              if (attrNamespace) {
                const namespaceLiteral = literal(attrNamespace);
                if (sanitizationRef) {
                  params.push(namespaceLiteral);
                } else {
                  params.push(literal(null), namespaceLiteral);
                }
              }
              this.allocateBindingSlots(value);
              if (inputType === 0) {
                if (value instanceof Interpolation) {
                  this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), elementIndex, attrName, input, value, params);
                } else {
                  propertyBindings.push({
                    span: input.sourceSpan,
                    paramsOrFn: getBindingFunctionParams(() => this.convertPropertyBinding(value), attrName, params)
                  });
                }
              } else if (inputType === 1) {
                if (value instanceof Interpolation && getInterpolationArgsLength(value) > 1) {
                  this.interpolatedUpdateInstruction(getAttributeInterpolationExpression(value), elementIndex, attrName, input, value, params);
                } else {
                  const boundValue = value instanceof Interpolation ? value.expressions[0] : value;
                  attributeBindings.push({
                    span: input.sourceSpan,
                    paramsOrFn: getBindingFunctionParams(() => this.convertPropertyBinding(boundValue), attrName, params)
                  });
                }
              } else {
                this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, Identifiers.classProp, () => {
                  return [literal(elementIndex), literal(attrName), this.convertPropertyBinding(value), ...params];
                });
              }
            }
          }
        });
        for (const propertyBinding of propertyBindings) {
          this.updateInstructionWithAdvance(elementIndex, propertyBinding.span, Identifiers.property, propertyBinding.paramsOrFn);
        }
        for (const attributeBinding of attributeBindings) {
          this.updateInstructionWithAdvance(elementIndex, attributeBinding.span, Identifiers.attribute, attributeBinding.paramsOrFn);
        }
        visitAll$1(this, element.children);
        if (!isI18nRootElement && this.i18n) {
          this.i18n.appendElement(element.i18n, elementIndex, true);
        }
        if (!createSelfClosingInstruction) {
          const span = (_b = element.endSourceSpan) !== null && _b !== void 0 ? _b : element.sourceSpan;
          if (isI18nRootElement) {
            this.i18nEnd(span, createSelfClosingI18nInstruction);
          }
          if (isNonBindableMode) {
            this.creationInstruction(span, Identifiers.enableBindings);
          }
          this.creationInstruction(span, isNgContainer$1 ? Identifiers.elementContainerEnd : Identifiers.elementEnd);
        }
      }
      visitTemplate(template) {
        var _a;
        const NG_TEMPLATE_TAG_NAME = "ng-template";
        const templateIndex = this.allocateDataSlot();
        if (this.i18n) {
          this.i18n.appendTemplate(template.i18n, templateIndex);
        }
        const tagNameWithoutNamespace = template.tagName ? splitNsName(template.tagName)[1] : template.tagName;
        const contextName = `${this.contextName}${template.tagName ? "_" + sanitizeIdentifier(template.tagName) : ""}_${templateIndex}`;
        const templateName = `${contextName}_Template`;
        const parameters = [
          literal(templateIndex),
          variable(templateName),
          literal(tagNameWithoutNamespace)
        ];
        const attrsExprs = this.getAttributeExpressions(
          NG_TEMPLATE_TAG_NAME,
          template.attributes,
          template.inputs,
          template.outputs,
          void 0,
          template.templateAttrs
        );
        parameters.push(this.addAttrsToConsts(attrsExprs));
        if (template.references && template.references.length) {
          const refs = this.prepareRefsArray(template.references);
          parameters.push(this.addToConsts(refs));
          parameters.push(importExpr(Identifiers.templateRefExtractor));
        }
        const templateVisitor = new TemplateDefinitionBuilder(this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n, templateIndex, templateName, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds, this._constants);
        this._nestedTemplateFns.push(() => {
          const templateFunctionExpr = templateVisitor.buildTemplateFunction(template.children, template.variables, this._ngContentReservedSlots.length + this._ngContentSelectorsOffset, template.i18n);
          this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName));
          if (templateVisitor._ngContentReservedSlots.length) {
            this._ngContentReservedSlots.push(...templateVisitor._ngContentReservedSlots);
          }
        });
        this.creationInstruction(template.sourceSpan, Identifiers.templateCreate, () => {
          parameters.splice(2, 0, literal(templateVisitor.getConstCount()), literal(templateVisitor.getVarCount()));
          return trimTrailingNulls(parameters);
        });
        this.templatePropertyBindings(templateIndex, template.templateAttrs);
        if (tagNameWithoutNamespace === NG_TEMPLATE_TAG_NAME) {
          const [i18nInputs, inputs] = partitionArray(template.inputs, hasI18nMeta);
          if (i18nInputs.length > 0) {
            this.i18nAttributesInstruction(templateIndex, i18nInputs, (_a = template.startSourceSpan) !== null && _a !== void 0 ? _a : template.sourceSpan);
          }
          if (inputs.length > 0) {
            this.templatePropertyBindings(templateIndex, inputs);
          }
          for (const outputAst of template.outputs) {
            this.creationInstruction(outputAst.sourceSpan, Identifiers.listener, this.prepareListenerParameter("ng_template", outputAst, templateIndex));
          }
        }
      }
      visitBoundText(text) {
        if (this.i18n) {
          const value2 = text.value.visit(this._valueConverter);
          this.allocateBindingSlots(value2);
          if (value2 instanceof Interpolation) {
            this.i18n.appendBoundText(text.i18n);
            this.i18nAppendBindings(value2.expressions);
          }
          return;
        }
        const nodeIndex = this.allocateDataSlot();
        this.creationInstruction(text.sourceSpan, Identifiers.text, [literal(nodeIndex)]);
        const value = text.value.visit(this._valueConverter);
        this.allocateBindingSlots(value);
        if (value instanceof Interpolation) {
          this.updateInstructionWithAdvance(nodeIndex, text.sourceSpan, getTextInterpolationExpression(value), () => this.getUpdateInstructionArguments(value));
        } else {
          error("Text nodes should be interpolated and never bound directly.");
        }
      }
      visitText(text) {
        if (!this.i18n) {
          this.creationInstruction(text.sourceSpan, Identifiers.text, [literal(this.allocateDataSlot()), literal(text.value)]);
        }
      }
      visitIcu(icu) {
        let initWasInvoked = false;
        if (!this.i18n) {
          initWasInvoked = true;
          this.i18nStart(null, icu.i18n, true);
        }
        const i18n = this.i18n;
        const vars = this.i18nBindProps(icu.vars);
        const placeholders = this.i18nBindProps(icu.placeholders);
        const message = icu.i18n;
        const transformFn = (raw) => {
          const params = Object.assign(Object.assign({}, vars), placeholders);
          const formatted = formatI18nPlaceholderNamesInMap(
            params,
            false
          );
          return invokeInstruction(null, Identifiers.i18nPostprocess, [raw, mapLiteral(formatted, true)]);
        };
        if (isSingleI18nIcu(i18n.meta)) {
          this.i18nTranslate(
            message,
            {},
            i18n.ref,
            transformFn
          );
        } else {
          const ref = this.i18nTranslate(
            message,
            {},
            void 0,
            transformFn
          );
          i18n.appendIcu(icuFromI18nMessage(message).name, ref);
        }
        if (initWasInvoked) {
          this.i18nEnd(null, true);
        }
        return null;
      }
      allocateDataSlot() {
        return this._dataIndex++;
      }
      getConstCount() {
        return this._dataIndex;
      }
      getVarCount() {
        return this._pureFunctionSlots;
      }
      getConsts() {
        return this._constants;
      }
      getNgContentSelectors() {
        return this._ngContentReservedSlots.length ? this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) : null;
      }
      bindingContext() {
        return `${this._bindingContext++}`;
      }
      templatePropertyBindings(templateIndex, attrs) {
        const propertyBindings = [];
        for (const input of attrs) {
          if (!(input instanceof BoundAttribute)) {
            continue;
          }
          const value = input.value.visit(this._valueConverter);
          if (value === void 0) {
            continue;
          }
          this.allocateBindingSlots(value);
          if (value instanceof Interpolation) {
            const params = [];
            this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), templateIndex, input.name, input, value, params);
          } else {
            propertyBindings.push({
              span: input.sourceSpan,
              paramsOrFn: getBindingFunctionParams(() => this.convertPropertyBinding(value), input.name)
            });
          }
        }
        for (const propertyBinding of propertyBindings) {
          this.updateInstructionWithAdvance(templateIndex, propertyBinding.span, Identifiers.property, propertyBinding.paramsOrFn);
        }
      }
      instructionFn(fns, span, reference, paramsOrFn, prepend = false) {
        fns[prepend ? "unshift" : "push"]({
          span,
          reference,
          paramsOrFn
        });
      }
      processStylingUpdateInstruction(elementIndex, instruction) {
        let allocateBindingSlots = 0;
        if (instruction) {
          for (const call of instruction.calls) {
            allocateBindingSlots += call.allocateBindingSlots;
            this.updateInstructionWithAdvance(elementIndex, call.sourceSpan, instruction.reference, () => call.params((value) => call.supportsInterpolation && value instanceof Interpolation ? this.getUpdateInstructionArguments(value) : this.convertPropertyBinding(value)));
          }
        }
        return allocateBindingSlots;
      }
      creationInstruction(span, reference, paramsOrFn, prepend) {
        this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);
      }
      updateInstructionWithAdvance(nodeIndex, span, reference, paramsOrFn) {
        this.addAdvanceInstructionIfNecessary(nodeIndex, span);
        this.updateInstruction(span, reference, paramsOrFn);
      }
      updateInstruction(span, reference, paramsOrFn) {
        this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);
      }
      addAdvanceInstructionIfNecessary(nodeIndex, span) {
        if (nodeIndex !== this._currentIndex) {
          const delta = nodeIndex - this._currentIndex;
          if (delta < 1) {
            throw new Error("advance instruction can only go forwards");
          }
          this.instructionFn(this._updateCodeFns, span, Identifiers.advance, [literal(delta)]);
          this._currentIndex = nodeIndex;
        }
      }
      allocatePureFunctionSlots(numSlots) {
        const originalSlots = this._pureFunctionSlots;
        this._pureFunctionSlots += numSlots;
        return originalSlots;
      }
      allocateBindingSlots(value) {
        this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;
      }
      getImplicitReceiverExpr() {
        if (this._implicitReceiverExpr) {
          return this._implicitReceiverExpr;
        }
        return this._implicitReceiverExpr = this.level === 0 ? variable(CONTEXT_NAME) : this._bindingScope.getOrCreateSharedContextVar(0);
      }
      convertPropertyBinding(value) {
        const convertedPropertyBinding = convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext());
        const valExpr = convertedPropertyBinding.currValExpr;
        this._tempVariables.push(...convertedPropertyBinding.stmts);
        return valExpr;
      }
      getUpdateInstructionArguments(value) {
        const {
          args,
          stmts
        } = convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext());
        this._tempVariables.push(...stmts);
        return args;
      }
      getAttributeExpressions(elementName, renderAttributes, inputs, outputs, styles, templateAttrs = [], boundI18nAttrs = []) {
        const alreadySeen = /* @__PURE__ */ new Set();
        const attrExprs = [];
        let ngProjectAsAttr;
        for (const attr of renderAttributes) {
          if (attr.name === NG_PROJECT_AS_ATTR_NAME) {
            ngProjectAsAttr = attr;
          }
          if (attr.i18n) {
            const {
              i18nVarRefsCache
            } = this._constants;
            let i18nVarRef;
            if (i18nVarRefsCache.has(attr.i18n)) {
              i18nVarRef = i18nVarRefsCache.get(attr.i18n);
            } else {
              i18nVarRef = this.i18nTranslate(attr.i18n);
              i18nVarRefsCache.set(attr.i18n, i18nVarRef);
            }
            attrExprs.push(literal(attr.name), i18nVarRef);
          } else {
            attrExprs.push(...getAttributeNameLiterals(attr.name), trustedConstAttribute(elementName, attr));
          }
        }
        if (ngProjectAsAttr) {
          attrExprs.push(...getNgProjectAsLiteral(ngProjectAsAttr));
        }
        function addAttrExpr(key, value) {
          if (typeof key === "string") {
            if (!alreadySeen.has(key)) {
              attrExprs.push(...getAttributeNameLiterals(key));
              value !== void 0 && attrExprs.push(value);
              alreadySeen.add(key);
            }
          } else {
            attrExprs.push(literal(key));
          }
        }
        if (styles) {
          styles.populateInitialStylingAttrs(attrExprs);
        }
        if (inputs.length || outputs.length) {
          const attrsLengthBeforeInputs = attrExprs.length;
          for (let i = 0; i < inputs.length; i++) {
            const input = inputs[i];
            if (input.type !== 4 && input.type !== 1) {
              addAttrExpr(input.name);
            }
          }
          for (let i = 0; i < outputs.length; i++) {
            const output = outputs[i];
            if (output.type !== 1) {
              addAttrExpr(output.name);
            }
          }
          if (attrExprs.length !== attrsLengthBeforeInputs) {
            attrExprs.splice(attrsLengthBeforeInputs, 0, literal(
              3
            ));
          }
        }
        if (templateAttrs.length) {
          attrExprs.push(literal(
            4
          ));
          templateAttrs.forEach((attr) => addAttrExpr(attr.name));
        }
        if (boundI18nAttrs.length) {
          attrExprs.push(literal(
            6
          ));
          boundI18nAttrs.forEach((attr) => addAttrExpr(attr.name));
        }
        return attrExprs;
      }
      addToConsts(expression) {
        if (isNull(expression)) {
          return TYPED_NULL_EXPR;
        }
        const consts = this._constants.constExpressions;
        for (let i = 0; i < consts.length; i++) {
          if (consts[i].isEquivalent(expression)) {
            return literal(i);
          }
        }
        return literal(consts.push(expression) - 1);
      }
      addAttrsToConsts(attrs) {
        return attrs.length > 0 ? this.addToConsts(literalArr(attrs)) : TYPED_NULL_EXPR;
      }
      prepareRefsArray(references) {
        if (!references || references.length === 0) {
          return TYPED_NULL_EXPR;
        }
        const refsParam = flatten2(references.map((reference) => {
          const slot = this.allocateDataSlot();
          const variableName = this._bindingScope.freshReferenceName();
          const retrievalLevel = this.level;
          const lhs = variable(variableName);
          this._bindingScope.set(
            retrievalLevel,
            reference.name,
            lhs,
            0,
            (scope, relativeLevel) => {
              const nextContextStmt = relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : [];
              const refExpr = lhs.set(importExpr(Identifiers.reference).callFn([literal(slot)]));
              return nextContextStmt.concat(refExpr.toConstDecl());
            },
            true
          );
          return [reference.name, reference.value];
        }));
        return asLiteral(refsParam);
      }
      prepareListenerParameter(tagName, outputAst, index) {
        return () => {
          const eventName = outputAst.name;
          const bindingFnName = outputAst.type === 1 ? prepareSyntheticListenerFunctionName(eventName, outputAst.phase) : sanitizeIdentifier(eventName);
          const handlerName = `${this.templateName}_${tagName}_${bindingFnName}_${index}_listener`;
          const scope = this._bindingScope.nestedScope(this._bindingScope.bindingLevel, EVENT_BINDING_SCOPE_GLOBALS);
          return prepareEventListenerParameters(outputAst, handlerName, scope);
        };
      }
    };
    ValueConverter = class extends AstMemoryEfficientTransformer {
      constructor(constantPool, allocateSlot, allocatePureFunctionSlots, definePipe) {
        super();
        this.constantPool = constantPool;
        this.allocateSlot = allocateSlot;
        this.allocatePureFunctionSlots = allocatePureFunctionSlots;
        this.definePipe = definePipe;
        this._pipeBindExprs = [];
      }
      visitPipe(pipe2, context2) {
        const slot = this.allocateSlot();
        const slotPseudoLocal = `PIPE:${slot}`;
        const pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe2.args.length);
        const target = new PropertyRead(pipe2.span, pipe2.sourceSpan, pipe2.nameSpan, new ImplicitReceiver(pipe2.span, pipe2.sourceSpan), slotPseudoLocal);
        const {
          identifier,
          isVarLength
        } = pipeBindingCallInfo(pipe2.args);
        this.definePipe(pipe2.name, slotPseudoLocal, slot, importExpr(identifier));
        const args = [pipe2.exp, ...pipe2.args];
        const convertedArgs = isVarLength ? this.visitAll([new LiteralArray(pipe2.span, pipe2.sourceSpan, args)]) : this.visitAll(args);
        const pipeBindExpr = new Call(pipe2.span, pipe2.sourceSpan, target, [new LiteralPrimitive(pipe2.span, pipe2.sourceSpan, slot), new LiteralPrimitive(pipe2.span, pipe2.sourceSpan, pureFunctionSlot), ...convertedArgs], null);
        this._pipeBindExprs.push(pipeBindExpr);
        return pipeBindExpr;
      }
      updatePipeSlotOffsets(bindingSlots) {
        this._pipeBindExprs.forEach((pipe2) => {
          const slotOffset = pipe2.args[1];
          slotOffset.value += bindingSlots;
        });
      }
      visitLiteralArray(array, context2) {
        return new BuiltinFunctionCall(array.span, array.sourceSpan, this.visitAll(array.expressions), (values) => {
          const literal2 = literalArr(values);
          return getLiteralFactory(this.constantPool, literal2, this.allocatePureFunctionSlots);
        });
      }
      visitLiteralMap(map2, context2) {
        return new BuiltinFunctionCall(map2.span, map2.sourceSpan, this.visitAll(map2.values), (values) => {
          const literal2 = literalMap(values.map((value, index) => ({
            key: map2.keys[index].key,
            value,
            quoted: map2.keys[index].quoted
          })));
          return getLiteralFactory(this.constantPool, literal2, this.allocatePureFunctionSlots);
        });
      }
    };
    pipeBindingIdentifiers = [Identifiers.pipeBind1, Identifiers.pipeBind2, Identifiers.pipeBind3, Identifiers.pipeBind4];
    pureFunctionIdentifiers = [Identifiers.pureFunction0, Identifiers.pureFunction1, Identifiers.pureFunction2, Identifiers.pureFunction3, Identifiers.pureFunction4, Identifiers.pureFunction5, Identifiers.pureFunction6, Identifiers.pureFunction7, Identifiers.pureFunction8];
    SHARED_CONTEXT_KEY = "$$shared_ctx$$";
    BindingScope = class {
      constructor(bindingLevel = 0, parent = null, globals) {
        this.bindingLevel = bindingLevel;
        this.parent = parent;
        this.globals = globals;
        this.map = /* @__PURE__ */ new Map();
        this.referenceNameIndex = 0;
        this.restoreViewVariable = null;
        this.usesRestoredViewContext = false;
        if (globals !== void 0) {
          for (const name of globals) {
            this.set(0, name, variable(name));
          }
        }
      }
      static createRootScope() {
        return new BindingScope();
      }
      get(name) {
        let current = this;
        while (current) {
          let value = current.map.get(name);
          if (value != null) {
            if (current !== this) {
              value = {
                retrievalLevel: value.retrievalLevel,
                lhs: value.lhs,
                declareLocalCallback: value.declareLocalCallback,
                declare: false,
                priority: value.priority
              };
              this.map.set(name, value);
              this.maybeGenerateSharedContextVar(value);
              this.maybeRestoreView();
            }
            if (value.declareLocalCallback && !value.declare) {
              value.declare = true;
            }
            return value.lhs;
          }
          current = current.parent;
        }
        return this.bindingLevel === 0 ? null : this.getComponentProperty(name);
      }
      set(retrievalLevel, name, lhs, priority = 0, declareLocalCallback, localRef) {
        if (this.map.has(name)) {
          if (localRef) {
            return this;
          }
          error(`The name ${name} is already defined in scope to be ${this.map.get(name)}`);
        }
        this.map.set(name, {
          retrievalLevel,
          lhs,
          declare: false,
          declareLocalCallback,
          priority
        });
        return this;
      }
      getLocal(name) {
        return this.get(name);
      }
      notifyImplicitReceiverUse() {
        if (this.bindingLevel !== 0) {
          this.map.get(SHARED_CONTEXT_KEY + 0).declare = true;
        }
      }
      nestedScope(level, globals) {
        const newScope = new BindingScope(level, this, globals);
        if (level > 0)
          newScope.generateSharedContextVar(0);
        return newScope;
      }
      getOrCreateSharedContextVar(retrievalLevel) {
        const bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;
        if (!this.map.has(bindingKey)) {
          this.generateSharedContextVar(retrievalLevel);
        }
        return this.map.get(bindingKey).lhs;
      }
      getSharedContextName(retrievalLevel) {
        const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel);
        return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs : null;
      }
      maybeGenerateSharedContextVar(value) {
        if (value.priority === 1 && value.retrievalLevel < this.bindingLevel) {
          const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);
          if (sharedCtxObj) {
            sharedCtxObj.declare = true;
          } else {
            this.generateSharedContextVar(value.retrievalLevel);
          }
        }
      }
      generateSharedContextVar(retrievalLevel) {
        const lhs = variable(CONTEXT_NAME + this.freshReferenceName());
        this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {
          retrievalLevel,
          lhs,
          declareLocalCallback: (scope, relativeLevel) => {
            return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];
          },
          declare: false,
          priority: 2
        });
      }
      getComponentProperty(name) {
        const componentValue = this.map.get(SHARED_CONTEXT_KEY + 0);
        componentValue.declare = true;
        this.maybeRestoreView();
        return componentValue.lhs.prop(name);
      }
      maybeRestoreView() {
        if (this.isListenerScope()) {
          if (!this.parent.restoreViewVariable) {
            this.parent.restoreViewVariable = variable(this.parent.freshReferenceName());
          }
          this.restoreViewVariable = this.parent.restoreViewVariable;
        }
      }
      restoreViewStatement() {
        if (this.restoreViewVariable) {
          const restoreCall = invokeInstruction(null, Identifiers.restoreView, [this.restoreViewVariable]);
          return this.usesRestoredViewContext ? variable(RESTORED_VIEW_CONTEXT_NAME).set(restoreCall).toConstDecl() : restoreCall.toStmt();
        }
        return null;
      }
      viewSnapshotStatements() {
        return this.restoreViewVariable ? [this.restoreViewVariable.set(invokeInstruction(null, Identifiers.getCurrentView, [])).toConstDecl()] : [];
      }
      isListenerScope() {
        return this.parent && this.parent.bindingLevel === this.bindingLevel;
      }
      variableDeclarations() {
        let currentContextLevel = 0;
        return Array.from(this.map.values()).filter((value) => value.declare).sort((a, b) => b.retrievalLevel - a.retrievalLevel || b.priority - a.priority).reduce((stmts, value) => {
          const levelDiff = this.bindingLevel - value.retrievalLevel;
          const currStmts = value.declareLocalCallback(this, levelDiff - currentContextLevel);
          currentContextLevel = levelDiff;
          return stmts.concat(currStmts);
        }, []);
      }
      freshReferenceName() {
        let current = this;
        while (current.parent)
          current = current.parent;
        const ref = `${REFERENCE_PREFIX}${current.referenceNameIndex++}`;
        return ref;
      }
      hasRestoreViewVariable() {
        return !!this.restoreViewVariable;
      }
      notifyRestoredViewContextUse() {
        this.usesRestoredViewContext = true;
      }
    };
    elementRegistry = new DomElementSchemaRegistry();
    NG_I18N_CLOSURE_MODE = "ngI18nClosureMode";
    ATTR_REGEX = /attr\.([^\]]+)/;
    COMPONENT_VARIABLE = "%COMP%";
    HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
    CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
    HOST_REG_EXP = /^(?:\[([^\]]+)\])|(?:\(([^\)]+)\))$/;
    ResourceLoader = class {
    };
    CompilerFacadeImpl = class {
      constructor(jitEvaluator = new JitEvaluator()) {
        this.jitEvaluator = jitEvaluator;
        this.FactoryTarget = FactoryTarget$1;
        this.ResourceLoader = ResourceLoader;
        this.elementSchemaRegistry = new DomElementSchemaRegistry();
      }
      compilePipe(angularCoreEnv2, sourceMapUrl, facade) {
        const metadata = {
          name: facade.name,
          type: wrapReference(facade.type),
          internalType: new WrappedNodeExpr(facade.type),
          typeArgumentCount: 0,
          deps: null,
          pipeName: facade.pipeName,
          pure: facade.pure,
          isStandalone: facade.isStandalone
        };
        const res = compilePipeFromMetadata(metadata);
        return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, []);
      }
      compilePipeDeclaration(angularCoreEnv2, sourceMapUrl, declaration) {
        const meta = convertDeclarePipeFacadeToMetadata(declaration);
        const res = compilePipeFromMetadata(meta);
        return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, []);
      }
      compileInjectable(angularCoreEnv2, sourceMapUrl, facade) {
        var _a;
        const {
          expression,
          statements
        } = compileInjectable2(
          {
            name: facade.name,
            type: wrapReference(facade.type),
            internalType: new WrappedNodeExpr(facade.type),
            typeArgumentCount: facade.typeArgumentCount,
            providedIn: computeProvidedIn(facade.providedIn),
            useClass: convertToProviderExpression(facade, "useClass"),
            useFactory: wrapExpression(facade, "useFactory"),
            useValue: convertToProviderExpression(facade, "useValue"),
            useExisting: convertToProviderExpression(facade, "useExisting"),
            deps: (_a = facade.deps) === null || _a === void 0 ? void 0 : _a.map(convertR3DependencyMetadata)
          },
          true
        );
        return this.jitExpression(expression, angularCoreEnv2, sourceMapUrl, statements);
      }
      compileInjectableDeclaration(angularCoreEnv2, sourceMapUrl, facade) {
        var _a;
        const {
          expression,
          statements
        } = compileInjectable2(
          {
            name: facade.type.name,
            type: wrapReference(facade.type),
            internalType: new WrappedNodeExpr(facade.type),
            typeArgumentCount: 0,
            providedIn: computeProvidedIn(facade.providedIn),
            useClass: convertToProviderExpression(facade, "useClass"),
            useFactory: wrapExpression(facade, "useFactory"),
            useValue: convertToProviderExpression(facade, "useValue"),
            useExisting: convertToProviderExpression(facade, "useExisting"),
            deps: (_a = facade.deps) === null || _a === void 0 ? void 0 : _a.map(convertR3DeclareDependencyMetadata)
          },
          true
        );
        return this.jitExpression(expression, angularCoreEnv2, sourceMapUrl, statements);
      }
      compileInjector(angularCoreEnv2, sourceMapUrl, facade) {
        const meta = {
          name: facade.name,
          type: wrapReference(facade.type),
          internalType: new WrappedNodeExpr(facade.type),
          providers: facade.providers && facade.providers.length > 0 ? new WrappedNodeExpr(facade.providers) : null,
          imports: facade.imports.map((i) => new WrappedNodeExpr(i))
        };
        const res = compileInjector(meta);
        return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, []);
      }
      compileInjectorDeclaration(angularCoreEnv2, sourceMapUrl, declaration) {
        const meta = convertDeclareInjectorFacadeToMetadata(declaration);
        const res = compileInjector(meta);
        return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, []);
      }
      compileNgModule(angularCoreEnv2, sourceMapUrl, facade) {
        const meta = {
          type: wrapReference(facade.type),
          internalType: new WrappedNodeExpr(facade.type),
          adjacentType: new WrappedNodeExpr(facade.type),
          bootstrap: facade.bootstrap.map(wrapReference),
          declarations: facade.declarations.map(wrapReference),
          publicDeclarationTypes: null,
          imports: facade.imports.map(wrapReference),
          includeImportTypes: true,
          exports: facade.exports.map(wrapReference),
          selectorScopeMode: R3SelectorScopeMode.Inline,
          containsForwardDecls: false,
          schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,
          id: facade.id ? new WrappedNodeExpr(facade.id) : null
        };
        const res = compileNgModule2(meta);
        return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, []);
      }
      compileNgModuleDeclaration(angularCoreEnv2, sourceMapUrl, declaration) {
        const expression = compileNgModuleDeclarationExpression(declaration);
        return this.jitExpression(expression, angularCoreEnv2, sourceMapUrl, []);
      }
      compileDirective(angularCoreEnv2, sourceMapUrl, facade) {
        const meta = convertDirectiveFacadeToMetadata(facade);
        return this.compileDirectiveFromMeta(angularCoreEnv2, sourceMapUrl, meta);
      }
      compileDirectiveDeclaration(angularCoreEnv2, sourceMapUrl, declaration) {
        const typeSourceSpan = this.createParseSourceSpan("Directive", declaration.type.name, sourceMapUrl);
        const meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);
        return this.compileDirectiveFromMeta(angularCoreEnv2, sourceMapUrl, meta);
      }
      compileDirectiveFromMeta(angularCoreEnv2, sourceMapUrl, meta) {
        const constantPool = new ConstantPool();
        const bindingParser = makeBindingParser();
        const res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);
        return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, constantPool.statements);
      }
      compileComponent(angularCoreEnv2, sourceMapUrl, facade) {
        const {
          template,
          interpolation
        } = parseJitTemplate(facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces, facade.interpolation);
        const meta = Object.assign(Object.assign(Object.assign({}, facade), convertDirectiveFacadeToMetadata(facade)), {
          selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(),
          template,
          declarations: facade.declarations.map(convertDeclarationFacadeToMetadata),
          declarationListEmitMode: 0,
          styles: [...facade.styles, ...template.styles],
          encapsulation: facade.encapsulation,
          interpolation,
          changeDetection: facade.changeDetection,
          animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null,
          viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) : null,
          relativeContextFilePath: "",
          i18nUseExternalIds: true
        });
        const jitExpressionSourceMap = `ng:///${facade.name}.js`;
        return this.compileComponentFromMeta(angularCoreEnv2, jitExpressionSourceMap, meta);
      }
      compileComponentDeclaration(angularCoreEnv2, sourceMapUrl, declaration) {
        const typeSourceSpan = this.createParseSourceSpan("Component", declaration.type.name, sourceMapUrl);
        const meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);
        return this.compileComponentFromMeta(angularCoreEnv2, sourceMapUrl, meta);
      }
      compileComponentFromMeta(angularCoreEnv2, sourceMapUrl, meta) {
        const constantPool = new ConstantPool();
        const bindingParser = makeBindingParser(meta.interpolation);
        const res = compileComponentFromMetadata(meta, constantPool, bindingParser);
        return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, constantPool.statements);
      }
      compileFactory(angularCoreEnv2, sourceMapUrl, meta) {
        const factoryRes = compileFactoryFunction({
          name: meta.name,
          type: wrapReference(meta.type),
          internalType: new WrappedNodeExpr(meta.type),
          typeArgumentCount: meta.typeArgumentCount,
          deps: convertR3DependencyMetadataArray(meta.deps),
          target: meta.target
        });
        return this.jitExpression(factoryRes.expression, angularCoreEnv2, sourceMapUrl, factoryRes.statements);
      }
      compileFactoryDeclaration(angularCoreEnv2, sourceMapUrl, meta) {
        const factoryRes = compileFactoryFunction({
          name: meta.type.name,
          type: wrapReference(meta.type),
          internalType: new WrappedNodeExpr(meta.type),
          typeArgumentCount: 0,
          deps: Array.isArray(meta.deps) ? meta.deps.map(convertR3DeclareDependencyMetadata) : meta.deps,
          target: meta.target
        });
        return this.jitExpression(factoryRes.expression, angularCoreEnv2, sourceMapUrl, factoryRes.statements);
      }
      createParseSourceSpan(kind, typeName, sourceUrl) {
        return r3JitTypeSourceSpan(kind, typeName, sourceUrl);
      }
      jitExpression(def, context2, sourceUrl, preStatements) {
        const statements = [...preStatements, new DeclareVarStmt("$def", def, void 0, StmtModifier.Exported)];
        const res = this.jitEvaluator.evaluateStatements(
          sourceUrl,
          statements,
          new R3JitReflector(context2),
          true
        );
        return res["$def"];
      }
    };
    VERSION4 = new Version2("14.1.1");
    CompilerConfig = class {
      constructor({
        defaultEncapsulation = ViewEncapsulation2.Emulated,
        useJit = true,
        jitDevMode = false,
        missingTranslation = null,
        preserveWhitespaces,
        strictInjectionParameters
      } = {}) {
        this.defaultEncapsulation = defaultEncapsulation;
        this.useJit = !!useJit;
        this.jitDevMode = !!jitDevMode;
        this.missingTranslation = missingTranslation;
        this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));
        this.strictInjectionParameters = strictInjectionParameters === true;
      }
    };
    (function(_VisitorMode2) {
      _VisitorMode2[_VisitorMode2["Extract"] = 0] = "Extract";
      _VisitorMode2[_VisitorMode2["Merge"] = 1] = "Merge";
    })(_VisitorMode || (_VisitorMode = {}));
    XmlTagDefinition = class {
      constructor() {
        this.closedByParent = false;
        this.isVoid = false;
        this.ignoreFirstLf = false;
        this.canSelfClose = true;
        this.preventNamespaceInheritance = false;
      }
      requireExtraParent(currentParent) {
        return false;
      }
      isClosedByChild(name) {
        return false;
      }
      getContentType() {
        return TagContentType.PARSABLE_DATA;
      }
    };
    _TAG_DEFINITION = new XmlTagDefinition();
    (function(FactoryTarget3) {
      FactoryTarget3[FactoryTarget3["Directive"] = 0] = "Directive";
      FactoryTarget3[FactoryTarget3["Component"] = 1] = "Component";
      FactoryTarget3[FactoryTarget3["Injectable"] = 2] = "Injectable";
      FactoryTarget3[FactoryTarget3["Pipe"] = 3] = "Pipe";
      FactoryTarget3[FactoryTarget3["NgModule"] = 4] = "NgModule";
    })(FactoryTarget2 || (FactoryTarget2 = {}));
    publishFacade(_global2);
  }
});

// node_modules/@angular/platform-browser/fesm2015/platform-browser.mjs
var platform_browser_exports = {};
__export(platform_browser_exports, {
  BrowserModule: () => BrowserModule,
  BrowserTransferStateModule: () => BrowserTransferStateModule,
  By: () => By,
  DomSanitizer: () => DomSanitizer,
  EVENT_MANAGER_PLUGINS: () => EVENT_MANAGER_PLUGINS,
  EventManager: () => EventManager,
  HAMMER_GESTURE_CONFIG: () => HAMMER_GESTURE_CONFIG,
  HAMMER_LOADER: () => HAMMER_LOADER,
  HammerGestureConfig: () => HammerGestureConfig,
  HammerModule: () => HammerModule,
  Meta: () => Meta,
  Title: () => Title,
  TransferState: () => TransferState,
  VERSION: () => VERSION5,
  bootstrapApplication: () => bootstrapApplication,
  disableDebugTools: () => disableDebugTools,
  enableDebugTools: () => enableDebugTools,
  makeStateKey: () => makeStateKey,
  platformBrowser: () => platformBrowser,
  provideProtractorTestingSupport: () => provideProtractorTestingSupport,
  \u0275BrowserDomAdapter: () => BrowserDomAdapter,
  \u0275BrowserGetTestability: () => BrowserGetTestability,
  \u0275DomEventsPlugin: () => DomEventsPlugin,
  \u0275DomRendererFactory2: () => DomRendererFactory2,
  \u0275DomSanitizerImpl: () => DomSanitizerImpl,
  \u0275DomSharedStylesHost: () => DomSharedStylesHost,
  \u0275HammerGesturesPlugin: () => HammerGesturesPlugin,
  \u0275INTERNAL_BROWSER_PLATFORM_PROVIDERS: () => INTERNAL_BROWSER_PLATFORM_PROVIDERS,
  \u0275KeyEventsPlugin: () => KeyEventsPlugin,
  \u0275NAMESPACE_URIS: () => NAMESPACE_URIS,
  \u0275SharedStylesHost: () => SharedStylesHost,
  \u0275TRANSITION_ID: () => TRANSITION_ID,
  \u0275escapeHtml: () => escapeHtml,
  \u0275flattenStyles: () => flattenStyles,
  \u0275getDOM: () => getDOM,
  \u0275initDomAdapter: () => initDomAdapter,
  \u0275shimContentAttribute: () => shimContentAttribute,
  \u0275shimHostAttribute: () => shimHostAttribute
});
function getBaseElementHref() {
  baseElement = baseElement || document.querySelector("base");
  return baseElement ? baseElement.getAttribute("href") : null;
}
function relativePath(url) {
  urlParsingNode = urlParsingNode || document.createElement("a");
  urlParsingNode.setAttribute("href", url);
  const pathName = urlParsingNode.pathname;
  return pathName.charAt(0) === "/" ? pathName : `/${pathName}`;
}
function appInitializerFactory(transitionId, document2, injector) {
  return () => {
    injector.get(ApplicationInitStatus).donePromise.then(() => {
      const dom = getDOM();
      const styles = document2.querySelectorAll(`style[ng-transition="${transitionId}"]`);
      for (let i = 0; i < styles.length; i++) {
        dom.remove(styles[i]);
      }
    });
  };
}
function removeStyle(styleNode) {
  getDOM().remove(styleNode);
}
function shimContentAttribute(componentShortId) {
  return CONTENT_ATTR2.replace(COMPONENT_REGEX, componentShortId);
}
function shimHostAttribute(componentShortId) {
  return HOST_ATTR2.replace(COMPONENT_REGEX, componentShortId);
}
function flattenStyles(compId, styles, target) {
  for (let i = 0; i < styles.length; i++) {
    let style = styles[i];
    if (Array.isArray(style)) {
      flattenStyles(compId, style, target);
    } else {
      style = style.replace(COMPONENT_REGEX, compId);
      target.push(style);
    }
  }
  return target;
}
function decoratePreventDefault(eventHandler) {
  return (event) => {
    if (event === "__ngUnwrap__") {
      return eventHandler;
    }
    const allowDefaultBehavior = eventHandler(event);
    if (allowDefaultBehavior === false) {
      event.preventDefault();
      event.returnValue = false;
    }
    return void 0;
  };
}
function checkNoSyntheticProp(name, nameKind) {
  if (name.charCodeAt(0) === AT_CHARCODE) {
    throw new Error(`Unexpected synthetic ${nameKind} ${name} found. Please make sure that:
  - Either \`BrowserAnimationsModule\` or \`NoopAnimationsModule\` are imported in your application.
  - There is corresponding configuration for the animation named \`${name}\` defined in the \`animations\` field of the \`@Component\` decorator (see https://angular.io/api/core/Component#animations).`);
  }
}
function isTemplateNode(node) {
  return node.tagName === "TEMPLATE" && node.content !== void 0;
}
function getEventKey(event) {
  let key = event.key;
  if (key == null) {
    key = event.keyIdentifier;
    if (key == null) {
      return "Unidentified";
    }
    if (key.startsWith("U+")) {
      key = String.fromCharCode(parseInt(key.substring(2), 16));
      if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
        key = _chromeNumKeyPadMap[key];
      }
    }
  }
  return _keyMap[key] || key;
}
function bootstrapApplication(rootComponent, options) {
  var _a;
  return internalBootstrapApplication({
    rootComponent,
    appProviders: [...BROWSER_MODULE_PROVIDERS, ...(_a = options === null || options === void 0 ? void 0 : options.providers) !== null && _a !== void 0 ? _a : []],
    platformProviders: INTERNAL_BROWSER_PLATFORM_PROVIDERS
  });
}
function provideProtractorTestingSupport() {
  return [...TESTABILITY_PROVIDERS];
}
function initDomAdapter() {
  BrowserDomAdapter.makeCurrent();
}
function errorHandler() {
  return new ErrorHandler();
}
function _document() {
  setDocument(document);
  return document;
}
function createMeta() {
  return new Meta(\u0275\u0275inject(DOCUMENT2));
}
function createTitle() {
  return new Title(\u0275\u0275inject(DOCUMENT2));
}
function exportNgVar(name, value) {
  if (typeof COMPILED === "undefined" || !COMPILED) {
    const ng = _global["ng"] = _global["ng"] || {};
    ng[name] = value;
  }
}
function performanceNow() {
  return win.performance && win.performance.now ? win.performance.now() : new Date().getTime();
}
function enableDebugTools(ref) {
  exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));
  return ref;
}
function disableDebugTools() {
  exportNgVar(PROFILER_GLOBAL_NAME, null);
}
function escapeHtml(text) {
  const escapedText = {
    "&": "&a;",
    '"': "&q;",
    "'": "&s;",
    "<": "&l;",
    ">": "&g;"
  };
  return text.replace(/[&"'<>]/g, (s) => escapedText[s]);
}
function unescapeHtml(text) {
  const unescapedText = {
    "&a;": "&",
    "&q;": '"',
    "&s;": "'",
    "&l;": "<",
    "&g;": ">"
  };
  return text.replace(/&[^;]+;/g, (s) => unescapedText[s]);
}
function makeStateKey(key) {
  return key;
}
function retrieveTransferredState(doc, appId) {
  const script = doc.getElementById(appId + "-state");
  let initialState = {};
  if (script && script.textContent) {
    try {
      initialState = JSON.parse(unescapeHtml(script.textContent));
    } catch (e) {
      console.warn("Exception while restoring TransferState for app " + appId, e);
    }
  }
  return initialState;
}
function elementMatches(n, selector) {
  if (getDOM().isElementNode(n)) {
    return n.matches && n.matches(selector) || n.msMatchesSelector && n.msMatchesSelector(selector) || n.webkitMatchesSelector && n.webkitMatchesSelector(selector);
  }
  return false;
}
function domSanitizerImplFactory(injector) {
  return new DomSanitizerImpl(injector.get(DOCUMENT2));
}
var GenericBrowserDomAdapter, BrowserDomAdapter, baseElement, urlParsingNode, TRANSITION_ID, SERVER_TRANSITION_PROVIDERS, BrowserGetTestability, BrowserXhr, EVENT_MANAGER_PLUGINS, EventManager, EventManagerPlugin, SharedStylesHost, DomSharedStylesHost, NAMESPACE_URIS, COMPONENT_REGEX, NG_DEV_MODE$12, COMPONENT_VARIABLE2, HOST_ATTR2, CONTENT_ATTR2, hasLoggedNativeEncapsulationWarning, DomRendererFactory2, DefaultDomRenderer2, AT_CHARCODE, EmulatedEncapsulationDomRenderer2, ShadowDomRenderer, DomEventsPlugin, MODIFIER_KEYS, DOM_KEY_LOCATION_NUMPAD, _keyMap, _chromeNumKeyPadMap, MODIFIER_KEY_GETTERS, KeyEventsPlugin, NG_DEV_MODE4, INTERNAL_BROWSER_PLATFORM_PROVIDERS, platformBrowser, BROWSER_MODULE_PROVIDERS_MARKER, TESTABILITY_PROVIDERS, BROWSER_MODULE_PROVIDERS, BrowserModule, Meta, META_KEYS_MAP, Title, win, ChangeDetectionPerfRecord, AngularProfiler, PROFILER_GLOBAL_NAME, TransferState, BrowserTransferStateModule, By, EVENT_NAMES, HAMMER_GESTURE_CONFIG, HAMMER_LOADER, HammerGestureConfig, HammerGesturesPlugin, HammerModule, DomSanitizer, DomSanitizerImpl, VERSION5;
var init_platform_browser = __esm({
  "node_modules/@angular/platform-browser/fesm2015/platform-browser.mjs"() {
    init_define_ngDevMode();
    init_common();
    init_common();
    init_core();
    init_core();
    GenericBrowserDomAdapter = class extends DomAdapter {
      constructor() {
        super(...arguments);
        this.supportsDOMEvents = true;
      }
    };
    BrowserDomAdapter = class extends GenericBrowserDomAdapter {
      static makeCurrent() {
        setRootDomAdapter(new BrowserDomAdapter());
      }
      onAndCancel(el, evt, listener) {
        el.addEventListener(evt, listener, false);
        return () => {
          el.removeEventListener(evt, listener, false);
        };
      }
      dispatchEvent(el, evt) {
        el.dispatchEvent(evt);
      }
      remove(node) {
        if (node.parentNode) {
          node.parentNode.removeChild(node);
        }
      }
      createElement(tagName, doc) {
        doc = doc || this.getDefaultDocument();
        return doc.createElement(tagName);
      }
      createHtmlDocument() {
        return document.implementation.createHTMLDocument("fakeTitle");
      }
      getDefaultDocument() {
        return document;
      }
      isElementNode(node) {
        return node.nodeType === Node.ELEMENT_NODE;
      }
      isShadowRoot(node) {
        return node instanceof DocumentFragment;
      }
      getGlobalEventTarget(doc, target) {
        if (target === "window") {
          return window;
        }
        if (target === "document") {
          return doc;
        }
        if (target === "body") {
          return doc.body;
        }
        return null;
      }
      getBaseHref(doc) {
        const href = getBaseElementHref();
        return href == null ? null : relativePath(href);
      }
      resetBaseElement() {
        baseElement = null;
      }
      getUserAgent() {
        return window.navigator.userAgent;
      }
      getCookie(name) {
        return parseCookieValue(document.cookie, name);
      }
    };
    baseElement = null;
    TRANSITION_ID = new InjectionToken("TRANSITION_ID");
    SERVER_TRANSITION_PROVIDERS = [{
      provide: APP_INITIALIZER,
      useFactory: appInitializerFactory,
      deps: [TRANSITION_ID, DOCUMENT2, Injector],
      multi: true
    }];
    BrowserGetTestability = class {
      addToWindow(registry) {
        _global["getAngularTestability"] = (elem, findInAncestors = true) => {
          const testability = registry.findTestabilityInTree(elem, findInAncestors);
          if (testability == null) {
            throw new Error("Could not find testability for element.");
          }
          return testability;
        };
        _global["getAllAngularTestabilities"] = () => registry.getAllTestabilities();
        _global["getAllAngularRootElements"] = () => registry.getAllRootElements();
        const whenAllStable = (callback) => {
          const testabilities = _global["getAllAngularTestabilities"]();
          let count2 = testabilities.length;
          let didWork = false;
          const decrement = function(didWork_) {
            didWork = didWork || didWork_;
            count2--;
            if (count2 == 0) {
              callback(didWork);
            }
          };
          testabilities.forEach(function(testability) {
            testability.whenStable(decrement);
          });
        };
        if (!_global["frameworkStabilizers"]) {
          _global["frameworkStabilizers"] = [];
        }
        _global["frameworkStabilizers"].push(whenAllStable);
      }
      findTestabilityInTree(registry, elem, findInAncestors) {
        if (elem == null) {
          return null;
        }
        const t = registry.getTestability(elem);
        if (t != null) {
          return t;
        } else if (!findInAncestors) {
          return null;
        }
        if (getDOM().isShadowRoot(elem)) {
          return this.findTestabilityInTree(registry, elem.host, true);
        }
        return this.findTestabilityInTree(registry, elem.parentElement, true);
      }
    };
    BrowserXhr = class {
      build() {
        return new XMLHttpRequest();
      }
    };
    BrowserXhr.\u0275fac = function BrowserXhr_Factory(t) {
      return new (t || BrowserXhr)();
    };
    BrowserXhr.\u0275prov = \u0275\u0275defineInjectable({
      token: BrowserXhr,
      factory: BrowserXhr.\u0275fac
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(BrowserXhr, [{
        type: Injectable
      }], null, null);
    })();
    EVENT_MANAGER_PLUGINS = new InjectionToken("EventManagerPlugins");
    EventManager = class {
      constructor(plugins, _zone) {
        this._zone = _zone;
        this._eventNameToPlugin = /* @__PURE__ */ new Map();
        plugins.forEach((p) => p.manager = this);
        this._plugins = plugins.slice().reverse();
      }
      addEventListener(element, eventName, handler) {
        const plugin = this._findPluginFor(eventName);
        return plugin.addEventListener(element, eventName, handler);
      }
      addGlobalEventListener(target, eventName, handler) {
        const plugin = this._findPluginFor(eventName);
        return plugin.addGlobalEventListener(target, eventName, handler);
      }
      getZone() {
        return this._zone;
      }
      _findPluginFor(eventName) {
        const plugin = this._eventNameToPlugin.get(eventName);
        if (plugin) {
          return plugin;
        }
        const plugins = this._plugins;
        for (let i = 0; i < plugins.length; i++) {
          const plugin2 = plugins[i];
          if (plugin2.supports(eventName)) {
            this._eventNameToPlugin.set(eventName, plugin2);
            return plugin2;
          }
        }
        throw new Error(`No event manager plugin found for event ${eventName}`);
      }
    };
    EventManager.\u0275fac = function EventManager_Factory(t) {
      return new (t || EventManager)(\u0275\u0275inject(EVENT_MANAGER_PLUGINS), \u0275\u0275inject(NgZone));
    };
    EventManager.\u0275prov = \u0275\u0275defineInjectable({
      token: EventManager,
      factory: EventManager.\u0275fac
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(EventManager, [{
        type: Injectable
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Inject,
            args: [EVENT_MANAGER_PLUGINS]
          }]
        }, {
          type: NgZone
        }];
      }, null);
    })();
    EventManagerPlugin = class {
      constructor(_doc) {
        this._doc = _doc;
      }
      addGlobalEventListener(element, eventName, handler) {
        const target = getDOM().getGlobalEventTarget(this._doc, element);
        if (!target) {
          throw new Error(`Unsupported event target ${target} for event ${eventName}`);
        }
        return this.addEventListener(target, eventName, handler);
      }
    };
    SharedStylesHost = class {
      constructor() {
        this._stylesSet = /* @__PURE__ */ new Set();
      }
      addStyles(styles) {
        const additions = /* @__PURE__ */ new Set();
        styles.forEach((style) => {
          if (!this._stylesSet.has(style)) {
            this._stylesSet.add(style);
            additions.add(style);
          }
        });
        this.onStylesAdded(additions);
      }
      onStylesAdded(additions) {
      }
      getAllStyles() {
        return Array.from(this._stylesSet);
      }
    };
    SharedStylesHost.\u0275fac = function SharedStylesHost_Factory(t) {
      return new (t || SharedStylesHost)();
    };
    SharedStylesHost.\u0275prov = \u0275\u0275defineInjectable({
      token: SharedStylesHost,
      factory: SharedStylesHost.\u0275fac
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(SharedStylesHost, [{
        type: Injectable
      }], null, null);
    })();
    DomSharedStylesHost = class extends SharedStylesHost {
      constructor(_doc) {
        super();
        this._doc = _doc;
        this._hostNodes = /* @__PURE__ */ new Map();
        this._hostNodes.set(_doc.head, []);
      }
      _addStylesToHost(styles, host, styleNodes) {
        styles.forEach((style) => {
          const styleEl = this._doc.createElement("style");
          styleEl.textContent = style;
          styleNodes.push(host.appendChild(styleEl));
        });
      }
      addHost(hostNode) {
        const styleNodes = [];
        this._addStylesToHost(this._stylesSet, hostNode, styleNodes);
        this._hostNodes.set(hostNode, styleNodes);
      }
      removeHost(hostNode) {
        const styleNodes = this._hostNodes.get(hostNode);
        if (styleNodes) {
          styleNodes.forEach(removeStyle);
        }
        this._hostNodes.delete(hostNode);
      }
      onStylesAdded(additions) {
        this._hostNodes.forEach((styleNodes, hostNode) => {
          this._addStylesToHost(additions, hostNode, styleNodes);
        });
      }
      ngOnDestroy() {
        this._hostNodes.forEach((styleNodes) => styleNodes.forEach(removeStyle));
      }
    };
    DomSharedStylesHost.\u0275fac = function DomSharedStylesHost_Factory(t) {
      return new (t || DomSharedStylesHost)(\u0275\u0275inject(DOCUMENT2));
    };
    DomSharedStylesHost.\u0275prov = \u0275\u0275defineInjectable({
      token: DomSharedStylesHost,
      factory: DomSharedStylesHost.\u0275fac
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(DomSharedStylesHost, [{
        type: Injectable
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Inject,
            args: [DOCUMENT2]
          }]
        }];
      }, null);
    })();
    NAMESPACE_URIS = {
      "svg": "http://www.w3.org/2000/svg",
      "xhtml": "http://www.w3.org/1999/xhtml",
      "xlink": "http://www.w3.org/1999/xlink",
      "xml": "http://www.w3.org/XML/1998/namespace",
      "xmlns": "http://www.w3.org/2000/xmlns/",
      "math": "http://www.w3.org/1998/MathML/"
    };
    COMPONENT_REGEX = /%COMP%/g;
    NG_DEV_MODE$12 = typeof define_ngDevMode_default === "undefined" || !!define_ngDevMode_default;
    COMPONENT_VARIABLE2 = "%COMP%";
    HOST_ATTR2 = `_nghost-${COMPONENT_VARIABLE2}`;
    CONTENT_ATTR2 = `_ngcontent-${COMPONENT_VARIABLE2}`;
    hasLoggedNativeEncapsulationWarning = false;
    DomRendererFactory2 = class {
      constructor(eventManager, sharedStylesHost, appId) {
        this.eventManager = eventManager;
        this.sharedStylesHost = sharedStylesHost;
        this.appId = appId;
        this.rendererByCompId = /* @__PURE__ */ new Map();
        this.defaultRenderer = new DefaultDomRenderer2(eventManager);
      }
      createRenderer(element, type) {
        if (!element || !type) {
          return this.defaultRenderer;
        }
        switch (type.encapsulation) {
          case ViewEncapsulation$1.Emulated: {
            let renderer = this.rendererByCompId.get(type.id);
            if (!renderer) {
              renderer = new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type, this.appId);
              this.rendererByCompId.set(type.id, renderer);
            }
            renderer.applyToHost(element);
            return renderer;
          }
          case 1:
          case ViewEncapsulation$1.ShadowDom:
            if ((typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && !hasLoggedNativeEncapsulationWarning && type.encapsulation === 1) {
              hasLoggedNativeEncapsulationWarning = true;
              console.warn("ViewEncapsulation.Native is no longer supported. Falling back to ViewEncapsulation.ShadowDom. The fallback will be removed in v12.");
            }
            return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);
          default: {
            if (!this.rendererByCompId.has(type.id)) {
              const styles = flattenStyles(type.id, type.styles, []);
              this.sharedStylesHost.addStyles(styles);
              this.rendererByCompId.set(type.id, this.defaultRenderer);
            }
            return this.defaultRenderer;
          }
        }
      }
      begin() {
      }
      end() {
      }
    };
    DomRendererFactory2.\u0275fac = function DomRendererFactory2_Factory(t) {
      return new (t || DomRendererFactory2)(\u0275\u0275inject(EventManager), \u0275\u0275inject(DomSharedStylesHost), \u0275\u0275inject(APP_ID));
    };
    DomRendererFactory2.\u0275prov = \u0275\u0275defineInjectable({
      token: DomRendererFactory2,
      factory: DomRendererFactory2.\u0275fac
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(DomRendererFactory2, [{
        type: Injectable
      }], function() {
        return [{
          type: EventManager
        }, {
          type: DomSharedStylesHost
        }, {
          type: void 0,
          decorators: [{
            type: Inject,
            args: [APP_ID]
          }]
        }];
      }, null);
    })();
    DefaultDomRenderer2 = class {
      constructor(eventManager) {
        this.eventManager = eventManager;
        this.data = /* @__PURE__ */ Object.create(null);
        this.destroyNode = null;
      }
      destroy() {
      }
      createElement(name, namespace) {
        if (namespace) {
          return document.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);
        }
        return document.createElement(name);
      }
      createComment(value) {
        return document.createComment(value);
      }
      createText(value) {
        return document.createTextNode(value);
      }
      appendChild(parent, newChild) {
        const targetParent = isTemplateNode(parent) ? parent.content : parent;
        targetParent.appendChild(newChild);
      }
      insertBefore(parent, newChild, refChild) {
        if (parent) {
          const targetParent = isTemplateNode(parent) ? parent.content : parent;
          targetParent.insertBefore(newChild, refChild);
        }
      }
      removeChild(parent, oldChild) {
        if (parent) {
          parent.removeChild(oldChild);
        }
      }
      selectRootElement(selectorOrNode, preserveContent) {
        let el = typeof selectorOrNode === "string" ? document.querySelector(selectorOrNode) : selectorOrNode;
        if (!el) {
          throw new Error(`The selector "${selectorOrNode}" did not match any elements`);
        }
        if (!preserveContent) {
          el.textContent = "";
        }
        return el;
      }
      parentNode(node) {
        return node.parentNode;
      }
      nextSibling(node) {
        return node.nextSibling;
      }
      setAttribute(el, name, value, namespace) {
        if (namespace) {
          name = namespace + ":" + name;
          const namespaceUri = NAMESPACE_URIS[namespace];
          if (namespaceUri) {
            el.setAttributeNS(namespaceUri, name, value);
          } else {
            el.setAttribute(name, value);
          }
        } else {
          el.setAttribute(name, value);
        }
      }
      removeAttribute(el, name, namespace) {
        if (namespace) {
          const namespaceUri = NAMESPACE_URIS[namespace];
          if (namespaceUri) {
            el.removeAttributeNS(namespaceUri, name);
          } else {
            el.removeAttribute(`${namespace}:${name}`);
          }
        } else {
          el.removeAttribute(name);
        }
      }
      addClass(el, name) {
        el.classList.add(name);
      }
      removeClass(el, name) {
        el.classList.remove(name);
      }
      setStyle(el, style, value, flags) {
        if (flags & (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {
          el.style.setProperty(style, value, flags & RendererStyleFlags2.Important ? "important" : "");
        } else {
          el.style[style] = value;
        }
      }
      removeStyle(el, style, flags) {
        if (flags & RendererStyleFlags2.DashCase) {
          el.style.removeProperty(style);
        } else {
          el.style[style] = "";
        }
      }
      setProperty(el, name, value) {
        NG_DEV_MODE$12 && checkNoSyntheticProp(name, "property");
        el[name] = value;
      }
      setValue(node, value) {
        node.nodeValue = value;
      }
      listen(target, event, callback) {
        NG_DEV_MODE$12 && checkNoSyntheticProp(event, "listener");
        if (typeof target === "string") {
          return this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback));
        }
        return this.eventManager.addEventListener(target, event, decoratePreventDefault(callback));
      }
    };
    AT_CHARCODE = (() => "@".charCodeAt(0))();
    EmulatedEncapsulationDomRenderer2 = class extends DefaultDomRenderer2 {
      constructor(eventManager, sharedStylesHost, component, appId) {
        super(eventManager);
        this.component = component;
        const styles = flattenStyles(appId + "-" + component.id, component.styles, []);
        sharedStylesHost.addStyles(styles);
        this.contentAttr = shimContentAttribute(appId + "-" + component.id);
        this.hostAttr = shimHostAttribute(appId + "-" + component.id);
      }
      applyToHost(element) {
        super.setAttribute(element, this.hostAttr, "");
      }
      createElement(parent, name) {
        const el = super.createElement(parent, name);
        super.setAttribute(el, this.contentAttr, "");
        return el;
      }
    };
    ShadowDomRenderer = class extends DefaultDomRenderer2 {
      constructor(eventManager, sharedStylesHost, hostEl, component) {
        super(eventManager);
        this.sharedStylesHost = sharedStylesHost;
        this.hostEl = hostEl;
        this.shadowRoot = hostEl.attachShadow({
          mode: "open"
        });
        this.sharedStylesHost.addHost(this.shadowRoot);
        const styles = flattenStyles(component.id, component.styles, []);
        for (let i = 0; i < styles.length; i++) {
          const styleEl = document.createElement("style");
          styleEl.textContent = styles[i];
          this.shadowRoot.appendChild(styleEl);
        }
      }
      nodeOrShadowRoot(node) {
        return node === this.hostEl ? this.shadowRoot : node;
      }
      destroy() {
        this.sharedStylesHost.removeHost(this.shadowRoot);
      }
      appendChild(parent, newChild) {
        return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
      }
      insertBefore(parent, newChild, refChild) {
        return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);
      }
      removeChild(parent, oldChild) {
        return super.removeChild(this.nodeOrShadowRoot(parent), oldChild);
      }
      parentNode(node) {
        return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
      }
    };
    DomEventsPlugin = class extends EventManagerPlugin {
      constructor(doc) {
        super(doc);
      }
      supports(eventName) {
        return true;
      }
      addEventListener(element, eventName, handler) {
        element.addEventListener(eventName, handler, false);
        return () => this.removeEventListener(element, eventName, handler);
      }
      removeEventListener(target, eventName, callback) {
        return target.removeEventListener(eventName, callback);
      }
    };
    DomEventsPlugin.\u0275fac = function DomEventsPlugin_Factory(t) {
      return new (t || DomEventsPlugin)(\u0275\u0275inject(DOCUMENT2));
    };
    DomEventsPlugin.\u0275prov = \u0275\u0275defineInjectable({
      token: DomEventsPlugin,
      factory: DomEventsPlugin.\u0275fac
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(DomEventsPlugin, [{
        type: Injectable
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Inject,
            args: [DOCUMENT2]
          }]
        }];
      }, null);
    })();
    MODIFIER_KEYS = ["alt", "control", "meta", "shift"];
    DOM_KEY_LOCATION_NUMPAD = 3;
    _keyMap = {
      "\b": "Backspace",
      "	": "Tab",
      "\x7F": "Delete",
      "\x1B": "Escape",
      "Del": "Delete",
      "Esc": "Escape",
      "Left": "ArrowLeft",
      "Right": "ArrowRight",
      "Up": "ArrowUp",
      "Down": "ArrowDown",
      "Menu": "ContextMenu",
      "Scroll": "ScrollLock",
      "Win": "OS"
    };
    _chromeNumKeyPadMap = {
      "A": "1",
      "B": "2",
      "C": "3",
      "D": "4",
      "E": "5",
      "F": "6",
      "G": "7",
      "H": "8",
      "I": "9",
      "J": "*",
      "K": "+",
      "M": "-",
      "N": ".",
      "O": "/",
      "`": "0",
      "\x90": "NumLock"
    };
    MODIFIER_KEY_GETTERS = {
      "alt": (event) => event.altKey,
      "control": (event) => event.ctrlKey,
      "meta": (event) => event.metaKey,
      "shift": (event) => event.shiftKey
    };
    KeyEventsPlugin = class extends EventManagerPlugin {
      constructor(doc) {
        super(doc);
      }
      supports(eventName) {
        return KeyEventsPlugin.parseEventName(eventName) != null;
      }
      addEventListener(element, eventName, handler) {
        const parsedEvent = KeyEventsPlugin.parseEventName(eventName);
        const outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent["fullKey"], handler, this.manager.getZone());
        return this.manager.getZone().runOutsideAngular(() => {
          return getDOM().onAndCancel(element, parsedEvent["domEventName"], outsideHandler);
        });
      }
      static parseEventName(eventName) {
        const parts = eventName.toLowerCase().split(".");
        const domEventName = parts.shift();
        if (parts.length === 0 || !(domEventName === "keydown" || domEventName === "keyup")) {
          return null;
        }
        const key = KeyEventsPlugin._normalizeKey(parts.pop());
        let fullKey = "";
        MODIFIER_KEYS.forEach((modifierName) => {
          const index = parts.indexOf(modifierName);
          if (index > -1) {
            parts.splice(index, 1);
            fullKey += modifierName + ".";
          }
        });
        fullKey += key;
        if (parts.length != 0 || key.length === 0) {
          return null;
        }
        const result = {};
        result["domEventName"] = domEventName;
        result["fullKey"] = fullKey;
        return result;
      }
      static getEventFullKey(event) {
        let fullKey = "";
        let key = getEventKey(event);
        key = key.toLowerCase();
        if (key === " ") {
          key = "space";
        } else if (key === ".") {
          key = "dot";
        }
        MODIFIER_KEYS.forEach((modifierName) => {
          if (modifierName != key) {
            const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
            if (modifierGetter(event)) {
              fullKey += modifierName + ".";
            }
          }
        });
        fullKey += key;
        return fullKey;
      }
      static eventCallback(fullKey, handler, zone) {
        return (event) => {
          if (KeyEventsPlugin.getEventFullKey(event) === fullKey) {
            zone.runGuarded(() => handler(event));
          }
        };
      }
      static _normalizeKey(keyName) {
        switch (keyName) {
          case "esc":
            return "escape";
          default:
            return keyName;
        }
      }
    };
    KeyEventsPlugin.\u0275fac = function KeyEventsPlugin_Factory(t) {
      return new (t || KeyEventsPlugin)(\u0275\u0275inject(DOCUMENT2));
    };
    KeyEventsPlugin.\u0275prov = \u0275\u0275defineInjectable({
      token: KeyEventsPlugin,
      factory: KeyEventsPlugin.\u0275fac
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(KeyEventsPlugin, [{
        type: Injectable
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Inject,
            args: [DOCUMENT2]
          }]
        }];
      }, null);
    })();
    NG_DEV_MODE4 = typeof define_ngDevMode_default === "undefined" || !!define_ngDevMode_default;
    INTERNAL_BROWSER_PLATFORM_PROVIDERS = [{
      provide: PLATFORM_ID,
      useValue: PLATFORM_BROWSER_ID
    }, {
      provide: PLATFORM_INITIALIZER,
      useValue: initDomAdapter,
      multi: true
    }, {
      provide: DOCUMENT2,
      useFactory: _document,
      deps: []
    }];
    platformBrowser = createPlatformFactory(platformCore, "browser", INTERNAL_BROWSER_PLATFORM_PROVIDERS);
    BROWSER_MODULE_PROVIDERS_MARKER = new InjectionToken(NG_DEV_MODE4 ? "BrowserModule Providers Marker" : "");
    TESTABILITY_PROVIDERS = [{
      provide: TESTABILITY_GETTER,
      useClass: BrowserGetTestability,
      deps: []
    }, {
      provide: TESTABILITY,
      useClass: Testability,
      deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER]
    }, {
      provide: Testability,
      useClass: Testability,
      deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER]
    }];
    BROWSER_MODULE_PROVIDERS = [{
      provide: INJECTOR_SCOPE,
      useValue: "root"
    }, {
      provide: ErrorHandler,
      useFactory: errorHandler,
      deps: []
    }, {
      provide: EVENT_MANAGER_PLUGINS,
      useClass: DomEventsPlugin,
      multi: true,
      deps: [DOCUMENT2, NgZone, PLATFORM_ID]
    }, {
      provide: EVENT_MANAGER_PLUGINS,
      useClass: KeyEventsPlugin,
      multi: true,
      deps: [DOCUMENT2]
    }, {
      provide: DomRendererFactory2,
      useClass: DomRendererFactory2,
      deps: [EventManager, DomSharedStylesHost, APP_ID]
    }, {
      provide: RendererFactory2,
      useExisting: DomRendererFactory2
    }, {
      provide: SharedStylesHost,
      useExisting: DomSharedStylesHost
    }, {
      provide: DomSharedStylesHost,
      useClass: DomSharedStylesHost,
      deps: [DOCUMENT2]
    }, {
      provide: EventManager,
      useClass: EventManager,
      deps: [EVENT_MANAGER_PLUGINS, NgZone]
    }, {
      provide: XhrFactory,
      useClass: BrowserXhr,
      deps: []
    }, NG_DEV_MODE4 ? {
      provide: BROWSER_MODULE_PROVIDERS_MARKER,
      useValue: true
    } : []];
    BrowserModule = class {
      constructor(providersAlreadyPresent) {
        if (NG_DEV_MODE4 && providersAlreadyPresent) {
          throw new Error(`Providers from the \`BrowserModule\` have already been loaded. If you need access to common directives such as NgIf and NgFor, import the \`CommonModule\` instead.`);
        }
      }
      static withServerTransition(params) {
        return {
          ngModule: BrowserModule,
          providers: [{
            provide: APP_ID,
            useValue: params.appId
          }, {
            provide: TRANSITION_ID,
            useExisting: APP_ID
          }, SERVER_TRANSITION_PROVIDERS]
        };
      }
    };
    BrowserModule.\u0275fac = function BrowserModule_Factory(t) {
      return new (t || BrowserModule)(\u0275\u0275inject(BROWSER_MODULE_PROVIDERS_MARKER, 12));
    };
    BrowserModule.\u0275mod = \u0275\u0275defineNgModule({
      type: BrowserModule
    });
    BrowserModule.\u0275inj = \u0275\u0275defineInjector({
      providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
      imports: [CommonModule, ApplicationModule]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(BrowserModule, [{
        type: NgModule,
        args: [{
          providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
          exports: [CommonModule, ApplicationModule]
        }]
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: SkipSelf
          }, {
            type: Inject,
            args: [BROWSER_MODULE_PROVIDERS_MARKER]
          }]
        }];
      }, null);
    })();
    Meta = class {
      constructor(_doc) {
        this._doc = _doc;
        this._dom = getDOM();
      }
      addTag(tag, forceCreation = false) {
        if (!tag)
          return null;
        return this._getOrCreateElement(tag, forceCreation);
      }
      addTags(tags, forceCreation = false) {
        if (!tags)
          return [];
        return tags.reduce((result, tag) => {
          if (tag) {
            result.push(this._getOrCreateElement(tag, forceCreation));
          }
          return result;
        }, []);
      }
      getTag(attrSelector) {
        if (!attrSelector)
          return null;
        return this._doc.querySelector(`meta[${attrSelector}]`) || null;
      }
      getTags(attrSelector) {
        if (!attrSelector)
          return [];
        const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);
        return list ? [].slice.call(list) : [];
      }
      updateTag(tag, selector) {
        if (!tag)
          return null;
        selector = selector || this._parseSelector(tag);
        const meta = this.getTag(selector);
        if (meta) {
          return this._setMetaElementAttributes(tag, meta);
        }
        return this._getOrCreateElement(tag, true);
      }
      removeTag(attrSelector) {
        this.removeTagElement(this.getTag(attrSelector));
      }
      removeTagElement(meta) {
        if (meta) {
          this._dom.remove(meta);
        }
      }
      _getOrCreateElement(meta, forceCreation = false) {
        if (!forceCreation) {
          const selector = this._parseSelector(meta);
          const elem = this.getTags(selector).filter((elem2) => this._containsAttributes(meta, elem2))[0];
          if (elem !== void 0)
            return elem;
        }
        const element = this._dom.createElement("meta");
        this._setMetaElementAttributes(meta, element);
        const head = this._doc.getElementsByTagName("head")[0];
        head.appendChild(element);
        return element;
      }
      _setMetaElementAttributes(tag, el) {
        Object.keys(tag).forEach((prop) => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));
        return el;
      }
      _parseSelector(tag) {
        const attr = tag.name ? "name" : "property";
        return `${attr}="${tag[attr]}"`;
      }
      _containsAttributes(tag, elem) {
        return Object.keys(tag).every((key) => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);
      }
      _getMetaKeyMap(prop) {
        return META_KEYS_MAP[prop] || prop;
      }
    };
    Meta.\u0275fac = function Meta_Factory(t) {
      return new (t || Meta)(\u0275\u0275inject(DOCUMENT2));
    };
    Meta.\u0275prov = \u0275\u0275defineInjectable({
      token: Meta,
      factory: function Meta_Factory2(t) {
        let r = null;
        if (t) {
          r = new t();
        } else {
          r = createMeta();
        }
        return r;
      },
      providedIn: "root"
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(Meta, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: createMeta,
          deps: []
        }]
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Inject,
            args: [DOCUMENT2]
          }]
        }];
      }, null);
    })();
    META_KEYS_MAP = {
      httpEquiv: "http-equiv"
    };
    Title = class {
      constructor(_doc) {
        this._doc = _doc;
      }
      getTitle() {
        return this._doc.title;
      }
      setTitle(newTitle) {
        this._doc.title = newTitle || "";
      }
    };
    Title.\u0275fac = function Title_Factory(t) {
      return new (t || Title)(\u0275\u0275inject(DOCUMENT2));
    };
    Title.\u0275prov = \u0275\u0275defineInjectable({
      token: Title,
      factory: function Title_Factory2(t) {
        let r = null;
        if (t) {
          r = new t();
        } else {
          r = createTitle();
        }
        return r;
      },
      providedIn: "root"
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(Title, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: createTitle,
          deps: []
        }]
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Inject,
            args: [DOCUMENT2]
          }]
        }];
      }, null);
    })();
    win = typeof window !== "undefined" && window || {};
    ChangeDetectionPerfRecord = class {
      constructor(msPerTick, numTicks) {
        this.msPerTick = msPerTick;
        this.numTicks = numTicks;
      }
    };
    AngularProfiler = class {
      constructor(ref) {
        this.appRef = ref.injector.get(ApplicationRef);
      }
      timeChangeDetection(config2) {
        const record = config2 && config2["record"];
        const profileName = "Change Detection";
        const isProfilerAvailable = win.console.profile != null;
        if (record && isProfilerAvailable) {
          win.console.profile(profileName);
        }
        const start = performanceNow();
        let numTicks = 0;
        while (numTicks < 5 || performanceNow() - start < 500) {
          this.appRef.tick();
          numTicks++;
        }
        const end = performanceNow();
        if (record && isProfilerAvailable) {
          win.console.profileEnd(profileName);
        }
        const msPerTick = (end - start) / numTicks;
        win.console.log(`ran ${numTicks} change detection cycles`);
        win.console.log(`${msPerTick.toFixed(2)} ms per check`);
        return new ChangeDetectionPerfRecord(msPerTick, numTicks);
      }
    };
    PROFILER_GLOBAL_NAME = "profiler";
    TransferState = class {
      constructor() {
        this.store = {};
        this.onSerializeCallbacks = {};
      }
      get(key, defaultValue) {
        return this.store[key] !== void 0 ? this.store[key] : defaultValue;
      }
      set(key, value) {
        this.store[key] = value;
      }
      remove(key) {
        delete this.store[key];
      }
      hasKey(key) {
        return this.store.hasOwnProperty(key);
      }
      onSerialize(key, callback) {
        this.onSerializeCallbacks[key] = callback;
      }
      toJson() {
        for (const key in this.onSerializeCallbacks) {
          if (this.onSerializeCallbacks.hasOwnProperty(key)) {
            try {
              this.store[key] = this.onSerializeCallbacks[key]();
            } catch (e) {
              console.warn("Exception in onSerialize callback: ", e);
            }
          }
        }
        return JSON.stringify(this.store);
      }
    };
    TransferState.\u0275fac = function TransferState_Factory(t) {
      return new (t || TransferState)();
    };
    TransferState.\u0275prov = \u0275\u0275defineInjectable({
      token: TransferState,
      factory: function() {
        return (() => {
          const doc = inject(DOCUMENT2);
          const appId = inject(APP_ID);
          const state = new TransferState();
          state.store = retrieveTransferredState(doc, appId);
          return state;
        })();
      },
      providedIn: "root"
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(TransferState, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: () => {
            const doc = inject(DOCUMENT2);
            const appId = inject(APP_ID);
            const state = new TransferState();
            state.store = retrieveTransferredState(doc, appId);
            return state;
          }
        }]
      }], null, null);
    })();
    BrowserTransferStateModule = class {
    };
    BrowserTransferStateModule.\u0275fac = function BrowserTransferStateModule_Factory(t) {
      return new (t || BrowserTransferStateModule)();
    };
    BrowserTransferStateModule.\u0275mod = \u0275\u0275defineNgModule({
      type: BrowserTransferStateModule
    });
    BrowserTransferStateModule.\u0275inj = \u0275\u0275defineInjector({});
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(BrowserTransferStateModule, [{
        type: NgModule,
        args: [{}]
      }], null, null);
    })();
    By = class {
      static all() {
        return () => true;
      }
      static css(selector) {
        return (debugElement) => {
          return debugElement.nativeElement != null ? elementMatches(debugElement.nativeElement, selector) : false;
        };
      }
      static directive(type) {
        return (debugNode) => debugNode.providerTokens.indexOf(type) !== -1;
      }
    };
    EVENT_NAMES = {
      "pan": true,
      "panstart": true,
      "panmove": true,
      "panend": true,
      "pancancel": true,
      "panleft": true,
      "panright": true,
      "panup": true,
      "pandown": true,
      "pinch": true,
      "pinchstart": true,
      "pinchmove": true,
      "pinchend": true,
      "pinchcancel": true,
      "pinchin": true,
      "pinchout": true,
      "press": true,
      "pressup": true,
      "rotate": true,
      "rotatestart": true,
      "rotatemove": true,
      "rotateend": true,
      "rotatecancel": true,
      "swipe": true,
      "swipeleft": true,
      "swiperight": true,
      "swipeup": true,
      "swipedown": true,
      "tap": true,
      "doubletap": true
    };
    HAMMER_GESTURE_CONFIG = new InjectionToken("HammerGestureConfig");
    HAMMER_LOADER = new InjectionToken("HammerLoader");
    HammerGestureConfig = class {
      constructor() {
        this.events = [];
        this.overrides = {};
      }
      buildHammer(element) {
        const mc = new Hammer(element, this.options);
        mc.get("pinch").set({
          enable: true
        });
        mc.get("rotate").set({
          enable: true
        });
        for (const eventName in this.overrides) {
          mc.get(eventName).set(this.overrides[eventName]);
        }
        return mc;
      }
    };
    HammerGestureConfig.\u0275fac = function HammerGestureConfig_Factory(t) {
      return new (t || HammerGestureConfig)();
    };
    HammerGestureConfig.\u0275prov = \u0275\u0275defineInjectable({
      token: HammerGestureConfig,
      factory: HammerGestureConfig.\u0275fac
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(HammerGestureConfig, [{
        type: Injectable
      }], null, null);
    })();
    HammerGesturesPlugin = class extends EventManagerPlugin {
      constructor(doc, _config, console2, loader) {
        super(doc);
        this._config = _config;
        this.console = console2;
        this.loader = loader;
        this._loaderPromise = null;
      }
      supports(eventName) {
        if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
          return false;
        }
        if (!window.Hammer && !this.loader) {
          if (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) {
            this.console.warn(`The "${eventName}" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.`);
          }
          return false;
        }
        return true;
      }
      addEventListener(element, eventName, handler) {
        const zone = this.manager.getZone();
        eventName = eventName.toLowerCase();
        if (!window.Hammer && this.loader) {
          this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader());
          let cancelRegistration = false;
          let deregister = () => {
            cancelRegistration = true;
          };
          zone.runOutsideAngular(() => this._loaderPromise.then(() => {
            if (!window.Hammer) {
              if (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) {
                this.console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);
              }
              deregister = () => {
              };
              return;
            }
            if (!cancelRegistration) {
              deregister = this.addEventListener(element, eventName, handler);
            }
          }).catch(() => {
            if (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) {
              this.console.warn(`The "${eventName}" event cannot be bound because the custom Hammer.JS loader failed.`);
            }
            deregister = () => {
            };
          }));
          return () => {
            deregister();
          };
        }
        return zone.runOutsideAngular(() => {
          const mc = this._config.buildHammer(element);
          const callback = function(eventObj) {
            zone.runGuarded(function() {
              handler(eventObj);
            });
          };
          mc.on(eventName, callback);
          return () => {
            mc.off(eventName, callback);
            if (typeof mc.destroy === "function") {
              mc.destroy();
            }
          };
        });
      }
      isCustomEvent(eventName) {
        return this._config.events.indexOf(eventName) > -1;
      }
    };
    HammerGesturesPlugin.\u0275fac = function HammerGesturesPlugin_Factory(t) {
      return new (t || HammerGesturesPlugin)(\u0275\u0275inject(DOCUMENT2), \u0275\u0275inject(HAMMER_GESTURE_CONFIG), \u0275\u0275inject(Console), \u0275\u0275inject(HAMMER_LOADER, 8));
    };
    HammerGesturesPlugin.\u0275prov = \u0275\u0275defineInjectable({
      token: HammerGesturesPlugin,
      factory: HammerGesturesPlugin.\u0275fac
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(HammerGesturesPlugin, [{
        type: Injectable
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Inject,
            args: [DOCUMENT2]
          }]
        }, {
          type: HammerGestureConfig,
          decorators: [{
            type: Inject,
            args: [HAMMER_GESTURE_CONFIG]
          }]
        }, {
          type: Console
        }, {
          type: void 0,
          decorators: [{
            type: Optional
          }, {
            type: Inject,
            args: [HAMMER_LOADER]
          }]
        }];
      }, null);
    })();
    HammerModule = class {
    };
    HammerModule.\u0275fac = function HammerModule_Factory(t) {
      return new (t || HammerModule)();
    };
    HammerModule.\u0275mod = \u0275\u0275defineNgModule({
      type: HammerModule
    });
    HammerModule.\u0275inj = \u0275\u0275defineInjector({
      providers: [{
        provide: EVENT_MANAGER_PLUGINS,
        useClass: HammerGesturesPlugin,
        multi: true,
        deps: [DOCUMENT2, HAMMER_GESTURE_CONFIG, Console, [new Optional(), HAMMER_LOADER]]
      }, {
        provide: HAMMER_GESTURE_CONFIG,
        useClass: HammerGestureConfig,
        deps: []
      }]
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(HammerModule, [{
        type: NgModule,
        args: [{
          providers: [{
            provide: EVENT_MANAGER_PLUGINS,
            useClass: HammerGesturesPlugin,
            multi: true,
            deps: [DOCUMENT2, HAMMER_GESTURE_CONFIG, Console, [new Optional(), HAMMER_LOADER]]
          }, {
            provide: HAMMER_GESTURE_CONFIG,
            useClass: HammerGestureConfig,
            deps: []
          }]
        }]
      }], null, null);
    })();
    DomSanitizer = class {
    };
    DomSanitizer.\u0275fac = function DomSanitizer_Factory(t) {
      return new (t || DomSanitizer)();
    };
    DomSanitizer.\u0275prov = \u0275\u0275defineInjectable({
      token: DomSanitizer,
      factory: function DomSanitizer_Factory2(t) {
        let r = null;
        if (t) {
          r = new (t || DomSanitizer)();
        } else {
          r = \u0275\u0275inject(DomSanitizerImpl);
        }
        return r;
      },
      providedIn: "root"
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(DomSanitizer, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useExisting: forwardRef(() => DomSanitizerImpl)
        }]
      }], null, null);
    })();
    DomSanitizerImpl = class extends DomSanitizer {
      constructor(_doc) {
        super();
        this._doc = _doc;
      }
      sanitize(ctx, value) {
        if (value == null)
          return null;
        switch (ctx) {
          case SecurityContext.NONE:
            return value;
          case SecurityContext.HTML:
            if (allowSanitizationBypassAndThrow(
              value,
              "HTML"
            )) {
              return unwrapSafeValue(value);
            }
            return _sanitizeHtml(this._doc, String(value)).toString();
          case SecurityContext.STYLE:
            if (allowSanitizationBypassAndThrow(
              value,
              "Style"
            )) {
              return unwrapSafeValue(value);
            }
            return value;
          case SecurityContext.SCRIPT:
            if (allowSanitizationBypassAndThrow(
              value,
              "Script"
            )) {
              return unwrapSafeValue(value);
            }
            throw new Error("unsafe value used in a script context");
          case SecurityContext.URL:
            if (allowSanitizationBypassAndThrow(
              value,
              "URL"
            )) {
              return unwrapSafeValue(value);
            }
            return _sanitizeUrl(String(value));
          case SecurityContext.RESOURCE_URL:
            if (allowSanitizationBypassAndThrow(
              value,
              "ResourceURL"
            )) {
              return unwrapSafeValue(value);
            }
            throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)");
          default:
            throw new Error(`Unexpected SecurityContext ${ctx} (see https://g.co/ng/security#xss)`);
        }
      }
      bypassSecurityTrustHtml(value) {
        return bypassSanitizationTrustHtml(value);
      }
      bypassSecurityTrustStyle(value) {
        return bypassSanitizationTrustStyle(value);
      }
      bypassSecurityTrustScript(value) {
        return bypassSanitizationTrustScript(value);
      }
      bypassSecurityTrustUrl(value) {
        return bypassSanitizationTrustUrl(value);
      }
      bypassSecurityTrustResourceUrl(value) {
        return bypassSanitizationTrustResourceUrl(value);
      }
    };
    DomSanitizerImpl.\u0275fac = function DomSanitizerImpl_Factory(t) {
      return new (t || DomSanitizerImpl)(\u0275\u0275inject(DOCUMENT2));
    };
    DomSanitizerImpl.\u0275prov = \u0275\u0275defineInjectable({
      token: DomSanitizerImpl,
      factory: function DomSanitizerImpl_Factory2(t) {
        let r = null;
        if (t) {
          r = new t();
        } else {
          r = domSanitizerImplFactory(\u0275\u0275inject(Injector));
        }
        return r;
      },
      providedIn: "root"
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(DomSanitizerImpl, [{
        type: Injectable,
        args: [{
          providedIn: "root",
          useFactory: domSanitizerImplFactory,
          deps: [Injector]
        }]
      }], function() {
        return [{
          type: void 0,
          decorators: [{
            type: Inject,
            args: [DOCUMENT2]
          }]
        }];
      }, null);
    })();
    VERSION5 = new Version("14.1.1");
  }
});

// node_modules/@angular/platform-browser-dynamic/fesm2015/platform-browser-dynamic.mjs
var platform_browser_dynamic_exports = {};
__export(platform_browser_dynamic_exports, {
  JitCompilerFactory: () => JitCompilerFactory,
  RESOURCE_CACHE_PROVIDER: () => RESOURCE_CACHE_PROVIDER,
  VERSION: () => VERSION6,
  platformBrowserDynamic: () => platformBrowserDynamic,
  \u0275INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS: () => INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS,
  \u0275platformCoreDynamic: () => platformCoreDynamic
});
function _mergeOptions(optionsArr) {
  return {
    useJit: _lastDefined2(optionsArr.map((options) => options.useJit)),
    defaultEncapsulation: _lastDefined2(optionsArr.map((options) => options.defaultEncapsulation)),
    providers: _mergeArrays2(optionsArr.map((options) => options.providers)),
    missingTranslation: _lastDefined2(optionsArr.map((options) => options.missingTranslation)),
    preserveWhitespaces: _lastDefined2(optionsArr.map((options) => options.preserveWhitespaces))
  };
}
function _lastDefined2(args) {
  for (let i = args.length - 1; i >= 0; i--) {
    if (args[i] !== void 0) {
      return args[i];
    }
  }
  return void 0;
}
function _mergeArrays2(parts) {
  const result = [];
  parts.forEach((part) => part && result.push(...part));
  return result;
}
var ERROR_COLLECTOR_TOKEN, COMPILER_PROVIDERS, JitCompilerFactory, platformCoreDynamic, ResourceLoaderImpl, INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS, CachedResourceLoader, VERSION6, RESOURCE_CACHE_PROVIDER, platformBrowserDynamic;
var init_platform_browser_dynamic = __esm({
  "node_modules/@angular/platform-browser-dynamic/fesm2015/platform-browser-dynamic.mjs"() {
    init_define_ngDevMode();
    init_compiler();
    init_core();
    init_core();
    init_common();
    init_platform_browser();
    ERROR_COLLECTOR_TOKEN = new InjectionToken("ErrorCollector");
    COMPILER_PROVIDERS = [{
      provide: Compiler,
      useFactory: () => new Compiler()
    }];
    JitCompilerFactory = class {
      constructor(defaultOptions) {
        const compilerOptions = {
          useJit: true,
          defaultEncapsulation: ViewEncapsulation$1.Emulated,
          missingTranslation: MissingTranslationStrategy.Warning
        };
        this._defaultOptions = [compilerOptions, ...defaultOptions];
      }
      createCompiler(options = []) {
        const opts = _mergeOptions(this._defaultOptions.concat(options));
        const injector = Injector.create([COMPILER_PROVIDERS, {
          provide: CompilerConfig,
          useFactory: () => {
            return new CompilerConfig({
              useJit: opts.useJit,
              jitDevMode: isDevMode(),
              defaultEncapsulation: opts.defaultEncapsulation,
              missingTranslation: opts.missingTranslation,
              preserveWhitespaces: opts.preserveWhitespaces
            });
          },
          deps: []
        }, opts.providers]);
        return injector.get(Compiler);
      }
    };
    platformCoreDynamic = createPlatformFactory(platformCore, "coreDynamic", [{
      provide: COMPILER_OPTIONS,
      useValue: {},
      multi: true
    }, {
      provide: CompilerFactory,
      useClass: JitCompilerFactory,
      deps: [COMPILER_OPTIONS]
    }]);
    ResourceLoaderImpl = class extends ResourceLoader {
      get(url) {
        let resolve;
        let reject;
        const promise2 = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        const xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.responseType = "text";
        xhr.onload = function() {
          const response = xhr.response || xhr.responseText;
          let status = xhr.status === 1223 ? 204 : xhr.status;
          if (status === 0) {
            status = response ? 200 : 0;
          }
          if (200 <= status && status <= 300) {
            resolve(response);
          } else {
            reject(`Failed to load ${url}`);
          }
        };
        xhr.onerror = function() {
          reject(`Failed to load ${url}`);
        };
        xhr.send();
        return promise2;
      }
    };
    ResourceLoaderImpl.\u0275fac = function() {
      let \u0275ResourceLoaderImpl_BaseFactory;
      return function ResourceLoaderImpl_Factory(t) {
        return (\u0275ResourceLoaderImpl_BaseFactory || (\u0275ResourceLoaderImpl_BaseFactory = \u0275\u0275getInheritedFactory(ResourceLoaderImpl)))(t || ResourceLoaderImpl);
      };
    }();
    ResourceLoaderImpl.\u0275prov = \u0275\u0275defineInjectable({
      token: ResourceLoaderImpl,
      factory: ResourceLoaderImpl.\u0275fac
    });
    (function() {
      (typeof define_ngDevMode_default === "undefined" || define_ngDevMode_default) && setClassMetadata(ResourceLoaderImpl, [{
        type: Injectable
      }], null, null);
    })();
    INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS = [INTERNAL_BROWSER_PLATFORM_PROVIDERS, {
      provide: COMPILER_OPTIONS,
      useValue: {
        providers: [{
          provide: ResourceLoader,
          useClass: ResourceLoaderImpl,
          deps: []
        }]
      },
      multi: true
    }, {
      provide: PLATFORM_ID,
      useValue: PLATFORM_BROWSER_ID
    }];
    CachedResourceLoader = class extends ResourceLoader {
      constructor() {
        super();
        this._cache = _global.$templateCache;
        if (this._cache == null) {
          throw new Error("CachedResourceLoader: Template cache was not found in $templateCache.");
        }
      }
      get(url) {
        if (this._cache.hasOwnProperty(url)) {
          return Promise.resolve(this._cache[url]);
        } else {
          return Promise.reject("CachedResourceLoader: Did not find cached template for " + url);
        }
      }
    };
    VERSION6 = new Version("14.1.1");
    RESOURCE_CACHE_PROVIDER = [{
      provide: ResourceLoader,
      useClass: CachedResourceLoader,
      deps: []
    }];
    platformBrowserDynamic = createPlatformFactory(platformCoreDynamic, "browserDynamic", INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS);
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isFunction.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isFunction = void 0;
    function isFunction2(value) {
      return typeof value === "function";
    }
    exports.isFunction = isFunction2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js
var require_createErrorClass = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createErrorClass = void 0;
    function createErrorClass2(createImpl) {
      var _super = function(instance) {
        Error.call(instance);
        instance.stack = new Error().stack;
      };
      var ctorFunc = createImpl(_super);
      ctorFunc.prototype = Object.create(Error.prototype);
      ctorFunc.prototype.constructor = ctorFunc;
      return ctorFunc;
    }
    exports.createErrorClass = createErrorClass2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js
var require_UnsubscriptionError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UnsubscriptionError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
      return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
          return i + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/arrRemove.js
var require_arrRemove = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/arrRemove.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.arrRemove = void 0;
    function arrRemove2(arr, item) {
      if (arr) {
        var index = arr.indexOf(item);
        0 <= index && arr.splice(index, 1);
      }
    }
    exports.arrRemove = arrRemove2;
  }
});

// node_modules/rxjs/dist/cjs/internal/Subscription.js
var require_Subscription = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Subscription.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __values2 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return {
              value: o && o[i++],
              done: !o
            };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isSubscription = exports.EMPTY_SUBSCRIPTION = exports.Subscription = void 0;
    var isFunction_1 = require_isFunction();
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    var arrRemove_1 = require_arrRemove();
    var Subscription2 = function() {
      function Subscription3(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
      }
      Subscription3.prototype.unsubscribe = function() {
        var e_1, _a, e_2, _b;
        var errors;
        if (!this.closed) {
          this.closed = true;
          var _parentage = this._parentage;
          if (_parentage) {
            this._parentage = null;
            if (Array.isArray(_parentage)) {
              try {
                for (var _parentage_1 = __values2(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                  var parent_1 = _parentage_1_1.value;
                  parent_1.remove(this);
                }
              } catch (e_1_1) {
                e_1 = {
                  error: e_1_1
                };
              } finally {
                try {
                  if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                    _a.call(_parentage_1);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
            } else {
              _parentage.remove(this);
            }
          }
          var initialFinalizer = this.initialTeardown;
          if (isFunction_1.isFunction(initialFinalizer)) {
            try {
              initialFinalizer();
            } catch (e) {
              errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
            }
          }
          var _finalizers = this._finalizers;
          if (_finalizers) {
            this._finalizers = null;
            try {
              for (var _finalizers_1 = __values2(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                var finalizer = _finalizers_1_1.value;
                try {
                  execFinalizer2(finalizer);
                } catch (err) {
                  errors = errors !== null && errors !== void 0 ? errors : [];
                  if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                    errors = __spreadArray2(__spreadArray2([], __read2(errors)), __read2(err.errors));
                  } else {
                    errors.push(err);
                  }
                }
              }
            } catch (e_2_1) {
              e_2 = {
                error: e_2_1
              };
            } finally {
              try {
                if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                  _b.call(_finalizers_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
          if (errors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
          }
        }
      };
      Subscription3.prototype.add = function(teardown) {
        var _a;
        if (teardown && teardown !== this) {
          if (this.closed) {
            execFinalizer2(teardown);
          } else {
            if (teardown instanceof Subscription3) {
              if (teardown.closed || teardown._hasParent(this)) {
                return;
              }
              teardown._addParent(this);
            }
            (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
          }
        }
      };
      Subscription3.prototype._hasParent = function(parent) {
        var _parentage = this._parentage;
        return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
      };
      Subscription3.prototype._addParent = function(parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
      };
      Subscription3.prototype._removeParent = function(parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) {
          this._parentage = null;
        } else if (Array.isArray(_parentage)) {
          arrRemove_1.arrRemove(_parentage, parent);
        }
      };
      Subscription3.prototype.remove = function(teardown) {
        var _finalizers = this._finalizers;
        _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
        if (teardown instanceof Subscription3) {
          teardown._removeParent(this);
        }
      };
      Subscription3.EMPTY = function() {
        var empty2 = new Subscription3();
        empty2.closed = true;
        return empty2;
      }();
      return Subscription3;
    }();
    exports.Subscription = Subscription2;
    exports.EMPTY_SUBSCRIPTION = Subscription2.EMPTY;
    function isSubscription2(value) {
      return value instanceof Subscription2 || value && "closed" in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe);
    }
    exports.isSubscription = isSubscription2;
    function execFinalizer2(finalizer) {
      if (isFunction_1.isFunction(finalizer)) {
        finalizer();
      } else {
        finalizer.unsubscribe();
      }
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/config.js
var require_config = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/config.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.config = void 0;
    exports.config = {
      onUnhandledError: null,
      onStoppedNotification: null,
      Promise: void 0,
      useDeprecatedSynchronousErrorHandling: false,
      useDeprecatedNextContext: false
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js
var require_timeoutProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.timeoutProvider = void 0;
    exports.timeoutProvider = {
      setTimeout: function(handler, timeout2) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = exports.timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
          return delegate.setTimeout.apply(delegate, __spreadArray2([handler, timeout2], __read2(args)));
        }
        return setTimeout.apply(void 0, __spreadArray2([handler, timeout2], __read2(args)));
      },
      clearTimeout: function(handle) {
        var delegate = exports.timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js
var require_reportUnhandledError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.reportUnhandledError = void 0;
    var config_1 = require_config();
    var timeoutProvider_1 = require_timeoutProvider();
    function reportUnhandledError2(err) {
      timeoutProvider_1.timeoutProvider.setTimeout(function() {
        var onUnhandledError = config_1.config.onUnhandledError;
        if (onUnhandledError) {
          onUnhandledError(err);
        } else {
          throw err;
        }
      });
    }
    exports.reportUnhandledError = reportUnhandledError2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/noop.js
var require_noop = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/noop.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.noop = void 0;
    function noop3() {
    }
    exports.noop = noop3;
  }
});

// node_modules/rxjs/dist/cjs/internal/NotificationFactories.js
var require_NotificationFactories = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/NotificationFactories.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createNotification = exports.nextNotification = exports.errorNotification = exports.COMPLETE_NOTIFICATION = void 0;
    exports.COMPLETE_NOTIFICATION = function() {
      return createNotification2("C", void 0, void 0);
    }();
    function errorNotification2(error2) {
      return createNotification2("E", void 0, error2);
    }
    exports.errorNotification = errorNotification2;
    function nextNotification2(value) {
      return createNotification2("N", value, void 0);
    }
    exports.nextNotification = nextNotification2;
    function createNotification2(kind, value, error2) {
      return {
        kind,
        value,
        error: error2
      };
    }
    exports.createNotification = createNotification2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/errorContext.js
var require_errorContext = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/errorContext.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.captureError = exports.errorContext = void 0;
    var config_1 = require_config();
    var context2 = null;
    function errorContext2(cb) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        var isRoot = !context2;
        if (isRoot) {
          context2 = {
            errorThrown: false,
            error: null
          };
        }
        cb();
        if (isRoot) {
          var _a = context2, errorThrown = _a.errorThrown, error2 = _a.error;
          context2 = null;
          if (errorThrown) {
            throw error2;
          }
        }
      } else {
        cb();
      }
    }
    exports.errorContext = errorContext2;
    function captureError2(err) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling && context2) {
        context2.errorThrown = true;
        context2.error = err;
      }
    }
    exports.captureError = captureError2;
  }
});

// node_modules/rxjs/dist/cjs/internal/Subscriber.js
var require_Subscriber = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Subscriber.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = void 0;
    var isFunction_1 = require_isFunction();
    var Subscription_1 = require_Subscription();
    var config_1 = require_config();
    var reportUnhandledError_1 = require_reportUnhandledError();
    var noop_1 = require_noop();
    var NotificationFactories_1 = require_NotificationFactories();
    var timeoutProvider_1 = require_timeoutProvider();
    var errorContext_1 = require_errorContext();
    var Subscriber2 = function(_super) {
      __extends2(Subscriber3, _super);
      function Subscriber3(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
          _this.destination = destination;
          if (Subscription_1.isSubscription(destination)) {
            destination.add(_this);
          }
        } else {
          _this.destination = exports.EMPTY_OBSERVER;
        }
        return _this;
      }
      Subscriber3.create = function(next, error2, complete) {
        return new SafeSubscriber2(next, error2, complete);
      };
      Subscriber3.prototype.next = function(value) {
        if (this.isStopped) {
          handleStoppedNotification2(NotificationFactories_1.nextNotification(value), this);
        } else {
          this._next(value);
        }
      };
      Subscriber3.prototype.error = function(err) {
        if (this.isStopped) {
          handleStoppedNotification2(NotificationFactories_1.errorNotification(err), this);
        } else {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber3.prototype.complete = function() {
        if (this.isStopped) {
          handleStoppedNotification2(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
        } else {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber3.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.isStopped = true;
          _super.prototype.unsubscribe.call(this);
          this.destination = null;
        }
      };
      Subscriber3.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber3.prototype._error = function(err) {
        try {
          this.destination.error(err);
        } finally {
          this.unsubscribe();
        }
      };
      Subscriber3.prototype._complete = function() {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      };
      return Subscriber3;
    }(Subscription_1.Subscription);
    exports.Subscriber = Subscriber2;
    var _bind2 = Function.prototype.bind;
    function bind2(fn2, thisArg) {
      return _bind2.call(fn2, thisArg);
    }
    var ConsumerObserver2 = function() {
      function ConsumerObserver3(partialObserver) {
        this.partialObserver = partialObserver;
      }
      ConsumerObserver3.prototype.next = function(value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) {
          try {
            partialObserver.next(value);
          } catch (error2) {
            handleUnhandledError2(error2);
          }
        }
      };
      ConsumerObserver3.prototype.error = function(err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) {
          try {
            partialObserver.error(err);
          } catch (error2) {
            handleUnhandledError2(error2);
          }
        } else {
          handleUnhandledError2(err);
        }
      };
      ConsumerObserver3.prototype.complete = function() {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) {
          try {
            partialObserver.complete();
          } catch (error2) {
            handleUnhandledError2(error2);
          }
        }
      };
      return ConsumerObserver3;
    }();
    var SafeSubscriber2 = function(_super) {
      __extends2(SafeSubscriber3, _super);
      function SafeSubscriber3(observerOrNext, error2, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
          partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
            error: error2 !== null && error2 !== void 0 ? error2 : void 0,
            complete: complete !== null && complete !== void 0 ? complete : void 0
          };
        } else {
          var context_1;
          if (_this && config_1.config.useDeprecatedNextContext) {
            context_1 = Object.create(observerOrNext);
            context_1.unsubscribe = function() {
              return _this.unsubscribe();
            };
            partialObserver = {
              next: observerOrNext.next && bind2(observerOrNext.next, context_1),
              error: observerOrNext.error && bind2(observerOrNext.error, context_1),
              complete: observerOrNext.complete && bind2(observerOrNext.complete, context_1)
            };
          } else {
            partialObserver = observerOrNext;
          }
        }
        _this.destination = new ConsumerObserver2(partialObserver);
        return _this;
      }
      return SafeSubscriber3;
    }(Subscriber2);
    exports.SafeSubscriber = SafeSubscriber2;
    function handleUnhandledError2(error2) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        errorContext_1.captureError(error2);
      } else {
        reportUnhandledError_1.reportUnhandledError(error2);
      }
    }
    function defaultErrorHandler2(err) {
      throw err;
    }
    function handleStoppedNotification2(notification, subscriber) {
      var onStoppedNotification = config_1.config.onStoppedNotification;
      onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
        return onStoppedNotification(notification, subscriber);
      });
    }
    exports.EMPTY_OBSERVER = {
      closed: true,
      next: noop_1.noop,
      error: defaultErrorHandler2,
      complete: noop_1.noop
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/symbol/observable.js
var require_observable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/symbol/observable.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.observable = void 0;
    exports.observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/identity.js
var require_identity = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/identity.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.identity = void 0;
    function identity2(x) {
      return x;
    }
    exports.identity = identity2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/pipe.js
var require_pipe = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/pipe.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pipeFromArray = exports.pipe = void 0;
    var identity_1 = require_identity();
    function pipe2() {
      var fns = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
      }
      return pipeFromArray2(fns);
    }
    exports.pipe = pipe2;
    function pipeFromArray2(fns) {
      if (fns.length === 0) {
        return identity_1.identity;
      }
      if (fns.length === 1) {
        return fns[0];
      }
      return function piped(input) {
        return fns.reduce(function(prev, fn2) {
          return fn2(prev);
        }, input);
      };
    }
    exports.pipeFromArray = pipeFromArray2;
  }
});

// node_modules/rxjs/dist/cjs/internal/Observable.js
var require_Observable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Observable.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Observable = void 0;
    var Subscriber_1 = require_Subscriber();
    var Subscription_1 = require_Subscription();
    var observable_1 = require_observable();
    var pipe_1 = require_pipe();
    var config_1 = require_config();
    var isFunction_1 = require_isFunction();
    var errorContext_1 = require_errorContext();
    var Observable2 = function() {
      function Observable3(subscribe) {
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      Observable3.prototype.lift = function(operator) {
        var observable2 = new Observable3();
        observable2.source = this;
        observable2.operator = operator;
        return observable2;
      };
      Observable3.prototype.subscribe = function(observerOrNext, error2, complete) {
        var _this = this;
        var subscriber = isSubscriber2(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error2, complete);
        errorContext_1.errorContext(function() {
          var _a = _this, operator = _a.operator, source = _a.source;
          subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
        });
        return subscriber;
      };
      Observable3.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          sink.error(err);
        }
      };
      Observable3.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor2(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var subscriber = new Subscriber_1.SafeSubscriber({
            next: function(value) {
              try {
                next(value);
              } catch (err) {
                reject(err);
                subscriber.unsubscribe();
              }
            },
            error: reject,
            complete: resolve
          });
          _this.subscribe(subscriber);
        });
      };
      Observable3.prototype._subscribe = function(subscriber) {
        var _a;
        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
      };
      Observable3.prototype[observable_1.observable] = function() {
        return this;
      };
      Observable3.prototype.pipe = function() {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i] = arguments[_i];
        }
        return pipe_1.pipeFromArray(operations)(this);
      };
      Observable3.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor2(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var value;
          _this.subscribe(function(x) {
            return value = x;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve(value);
          });
        });
      };
      Observable3.create = function(subscribe) {
        return new Observable3(subscribe);
      };
      return Observable3;
    }();
    exports.Observable = Observable2;
    function getPromiseCtor2(promiseCtor) {
      var _a;
      return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
    }
    function isObserver2(value) {
      return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
    }
    function isSubscriber2(value) {
      return value && value instanceof Subscriber_1.Subscriber || isObserver2(value) && Subscription_1.isSubscription(value);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/lift.js
var require_lift = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/lift.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.operate = exports.hasLift = void 0;
    var isFunction_1 = require_isFunction();
    function hasLift2(source) {
      return isFunction_1.isFunction(source === null || source === void 0 ? void 0 : source.lift);
    }
    exports.hasLift = hasLift2;
    function operate2(init) {
      return function(source) {
        if (hasLift2(source)) {
          return source.lift(function(liftedSource) {
            try {
              return init(liftedSource, this);
            } catch (err) {
              this.error(err);
            }
          });
        }
        throw new TypeError("Unable to lift unknown Observable type");
      };
    }
    exports.operate = operate2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js
var require_OperatorSubscriber = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.OperatorSubscriber = exports.createOperatorSubscriber = void 0;
    var Subscriber_1 = require_Subscriber();
    function createOperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize) {
      return new OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize);
    }
    exports.createOperatorSubscriber = createOperatorSubscriber2;
    var OperatorSubscriber2 = function(_super) {
      __extends2(OperatorSubscriber3, _super);
      function OperatorSubscriber3(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this.shouldUnsubscribe = shouldUnsubscribe;
        _this._next = onNext ? function(value) {
          try {
            onNext(value);
          } catch (err) {
            destination.error(err);
          }
        } : _super.prototype._next;
        _this._error = onError ? function(err) {
          try {
            onError(err);
          } catch (err2) {
            destination.error(err2);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._error;
        _this._complete = onComplete ? function() {
          try {
            onComplete();
          } catch (err) {
            destination.error(err);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._complete;
        return _this;
      }
      OperatorSubscriber3.prototype.unsubscribe = function() {
        var _a;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
          var closed_1 = this.closed;
          _super.prototype.unsubscribe.call(this);
          !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
        }
      };
      return OperatorSubscriber3;
    }(Subscriber_1.Subscriber);
    exports.OperatorSubscriber = OperatorSubscriber2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/refCount.js
var require_refCount = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/refCount.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.refCount = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function refCount2() {
      return lift_1.operate(function(source, subscriber) {
        var connection = null;
        source._refCount++;
        var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
          if (!source || source._refCount <= 0 || 0 < --source._refCount) {
            connection = null;
            return;
          }
          var sharedConnection = source._connection;
          var conn = connection;
          connection = null;
          if (sharedConnection && (!conn || sharedConnection === conn)) {
            sharedConnection.unsubscribe();
          }
          subscriber.unsubscribe();
        });
        source.subscribe(refCounter);
        if (!refCounter.closed) {
          connection = source.connect();
        }
      });
    }
    exports.refCount = refCount2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js
var require_ConnectableObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ConnectableObservable = void 0;
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var refCount_1 = require_refCount();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var lift_1 = require_lift();
    var ConnectableObservable2 = function(_super) {
      __extends2(ConnectableObservable3, _super);
      function ConnectableObservable3(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._subject = null;
        _this._refCount = 0;
        _this._connection = null;
        if (lift_1.hasLift(source)) {
          _this.lift = source.lift;
        }
        return _this;
      }
      ConnectableObservable3.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
      };
      ConnectableObservable3.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }
        return this._subject;
      };
      ConnectableObservable3.prototype._teardown = function() {
        this._refCount = 0;
        var _connection = this._connection;
        this._subject = this._connection = null;
        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
      };
      ConnectableObservable3.prototype.connect = function() {
        var _this = this;
        var connection = this._connection;
        if (!connection) {
          connection = this._connection = new Subscription_1.Subscription();
          var subject_1 = this.getSubject();
          connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, void 0, function() {
            _this._teardown();
            subject_1.complete();
          }, function(err) {
            _this._teardown();
            subject_1.error(err);
          }, function() {
            return _this._teardown();
          })));
          if (connection.closed) {
            this._connection = null;
            connection = Subscription_1.Subscription.EMPTY;
          }
        }
        return connection;
      };
      ConnectableObservable3.prototype.refCount = function() {
        return refCount_1.refCount()(this);
      };
      return ConnectableObservable3;
    }(Observable_1.Observable);
    exports.ConnectableObservable = ConnectableObservable2;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js
var require_performanceTimestampProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.performanceTimestampProvider = void 0;
    exports.performanceTimestampProvider = {
      now: function() {
        return (exports.performanceTimestampProvider.delegate || performance).now();
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js
var require_animationFrameProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.animationFrameProvider = void 0;
    var Subscription_1 = require_Subscription();
    exports.animationFrameProvider = {
      schedule: function(callback) {
        var request = requestAnimationFrame;
        var cancel = cancelAnimationFrame;
        var delegate = exports.animationFrameProvider.delegate;
        if (delegate) {
          request = delegate.requestAnimationFrame;
          cancel = delegate.cancelAnimationFrame;
        }
        var handle = request(function(timestamp2) {
          cancel = void 0;
          callback(timestamp2);
        });
        return new Subscription_1.Subscription(function() {
          return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
        });
      },
      requestAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray2([], __read2(args)));
      },
      cancelAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray2([], __read2(args)));
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js
var require_animationFrames = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.animationFrames = void 0;
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var performanceTimestampProvider_1 = require_performanceTimestampProvider();
    var animationFrameProvider_1 = require_animationFrameProvider();
    function animationFrames2(timestampProvider) {
      return timestampProvider ? animationFramesFactory2(timestampProvider) : DEFAULT_ANIMATION_FRAMES2;
    }
    exports.animationFrames = animationFrames2;
    function animationFramesFactory2(timestampProvider) {
      var schedule = animationFrameProvider_1.animationFrameProvider.schedule;
      return new Observable_1.Observable(function(subscriber) {
        var subscription = new Subscription_1.Subscription();
        var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
        var start = provider.now();
        var run = function(timestamp2) {
          var now = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now : timestamp2,
            elapsed: now - start
          });
          if (!subscriber.closed) {
            subscription.add(schedule(run));
          }
        };
        subscription.add(schedule(run));
        return subscription;
      });
    }
    var DEFAULT_ANIMATION_FRAMES2 = animationFramesFactory2();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js
var require_ObjectUnsubscribedError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ObjectUnsubscribedError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
      return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = "ObjectUnsubscribedError";
        this.message = "object unsubscribed";
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/Subject.js
var require_Subject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Subject.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __values2 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return {
              value: o && o[i++],
              done: !o
            };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AnonymousSubject = exports.Subject = void 0;
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    var arrRemove_1 = require_arrRemove();
    var errorContext_1 = require_errorContext();
    var Subject2 = function(_super) {
      __extends2(Subject3, _super);
      function Subject3() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.currentObservers = null;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }
      Subject3.prototype.lift = function(operator) {
        var subject = new AnonymousSubject2(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject3.prototype._throwIfClosed = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
      };
      Subject3.prototype.next = function(value) {
        var _this = this;
        errorContext_1.errorContext(function() {
          var e_1, _a;
          _this._throwIfClosed();
          if (!_this.isStopped) {
            if (!_this.currentObservers) {
              _this.currentObservers = Array.from(_this.observers);
            }
            try {
              for (var _b = __values2(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var observer = _c.value;
                observer.next(value);
              }
            } catch (e_1_1) {
              e_1 = {
                error: e_1_1
              };
            } finally {
              try {
                if (_c && !_c.done && (_a = _b.return))
                  _a.call(_b);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }
        });
      };
      Subject3.prototype.error = function(err) {
        var _this = this;
        errorContext_1.errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.hasError = _this.isStopped = true;
            _this.thrownError = err;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().error(err);
            }
          }
        });
      };
      Subject3.prototype.complete = function() {
        var _this = this;
        errorContext_1.errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.isStopped = true;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().complete();
            }
          }
        });
      };
      Subject3.prototype.unsubscribe = function() {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
      };
      Object.defineProperty(Subject3.prototype, "observed", {
        get: function() {
          var _a;
          return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
        },
        enumerable: false,
        configurable: true
      });
      Subject3.prototype._trySubscribe = function(subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
      };
      Subject3.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
      };
      Subject3.prototype._innerSubscribe = function(subscriber) {
        var _this = this;
        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
        if (hasError || isStopped) {
          return Subscription_1.EMPTY_SUBSCRIPTION;
        }
        this.currentObservers = null;
        observers.push(subscriber);
        return new Subscription_1.Subscription(function() {
          _this.currentObservers = null;
          arrRemove_1.arrRemove(observers, subscriber);
        });
      };
      Subject3.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped) {
          subscriber.complete();
        }
      };
      Subject3.prototype.asObservable = function() {
        var observable2 = new Observable_1.Observable();
        observable2.source = this;
        return observable2;
      };
      Subject3.create = function(destination, source) {
        return new AnonymousSubject2(destination, source);
      };
      return Subject3;
    }(Observable_1.Observable);
    exports.Subject = Subject2;
    var AnonymousSubject2 = function(_super) {
      __extends2(AnonymousSubject3, _super);
      function AnonymousSubject3(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
      }
      AnonymousSubject3.prototype.next = function(value) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
      };
      AnonymousSubject3.prototype.error = function(err) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
      };
      AnonymousSubject3.prototype.complete = function() {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
      };
      AnonymousSubject3.prototype._subscribe = function(subscriber) {
        var _a, _b;
        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1.EMPTY_SUBSCRIPTION;
      };
      return AnonymousSubject3;
    }(Subject2);
    exports.AnonymousSubject = AnonymousSubject2;
  }
});

// node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js
var require_BehaviorSubject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BehaviorSubject = void 0;
    var Subject_1 = require_Subject();
    var BehaviorSubject2 = function(_super) {
      __extends2(BehaviorSubject3, _super);
      function BehaviorSubject3(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
      }
      Object.defineProperty(BehaviorSubject3.prototype, "value", {
        get: function() {
          return this.getValue();
        },
        enumerable: false,
        configurable: true
      });
      BehaviorSubject3.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
      };
      BehaviorSubject3.prototype.getValue = function() {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
        if (hasError) {
          throw thrownError;
        }
        this._throwIfClosed();
        return _value;
      };
      BehaviorSubject3.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
      };
      return BehaviorSubject3;
    }(Subject_1.Subject);
    exports.BehaviorSubject = BehaviorSubject2;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js
var require_dateTimestampProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.dateTimestampProvider = void 0;
    exports.dateTimestampProvider = {
      now: function() {
        return (exports.dateTimestampProvider.delegate || Date).now();
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/ReplaySubject.js
var require_ReplaySubject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/ReplaySubject.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ReplaySubject = void 0;
    var Subject_1 = require_Subject();
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var ReplaySubject2 = function(_super) {
      __extends2(ReplaySubject3, _super);
      function ReplaySubject3(_bufferSize, _windowTime, _timestampProvider) {
        if (_bufferSize === void 0) {
          _bufferSize = Infinity;
        }
        if (_windowTime === void 0) {
          _windowTime = Infinity;
        }
        if (_timestampProvider === void 0) {
          _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
        }
        var _this = _super.call(this) || this;
        _this._bufferSize = _bufferSize;
        _this._windowTime = _windowTime;
        _this._timestampProvider = _timestampProvider;
        _this._buffer = [];
        _this._infiniteTimeWindow = true;
        _this._infiniteTimeWindow = _windowTime === Infinity;
        _this._bufferSize = Math.max(1, _bufferSize);
        _this._windowTime = Math.max(1, _windowTime);
        return _this;
      }
      ReplaySubject3.prototype.next = function(value) {
        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
        if (!isStopped) {
          _buffer.push(value);
          !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
        }
        this._trimBuffer();
        _super.prototype.next.call(this, value);
      };
      ReplaySubject3.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._trimBuffer();
        var subscription = this._innerSubscribe(subscriber);
        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
        var copy = _buffer.slice();
        for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
          subscriber.next(copy[i]);
        }
        this._checkFinalizedStatuses(subscriber);
        return subscription;
      };
      ReplaySubject3.prototype._trimBuffer = function() {
        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
        if (!_infiniteTimeWindow) {
          var now = _timestampProvider.now();
          var last3 = 0;
          for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
            last3 = i;
          }
          last3 && _buffer.splice(0, last3 + 1);
        }
      };
      return ReplaySubject3;
    }(Subject_1.Subject);
    exports.ReplaySubject = ReplaySubject2;
  }
});

// node_modules/rxjs/dist/cjs/internal/AsyncSubject.js
var require_AsyncSubject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/AsyncSubject.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AsyncSubject = void 0;
    var Subject_1 = require_Subject();
    var AsyncSubject2 = function(_super) {
      __extends2(AsyncSubject3, _super);
      function AsyncSubject3() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._value = null;
        _this._hasValue = false;
        _this._isComplete = false;
        return _this;
      }
      AsyncSubject3.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped || _isComplete) {
          _hasValue && subscriber.next(_value);
          subscriber.complete();
        }
      };
      AsyncSubject3.prototype.next = function(value) {
        if (!this.isStopped) {
          this._value = value;
          this._hasValue = true;
        }
      };
      AsyncSubject3.prototype.complete = function() {
        var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
        if (!_isComplete) {
          this._isComplete = true;
          _hasValue && _super.prototype.next.call(this, _value);
          _super.prototype.complete.call(this);
        }
      };
      return AsyncSubject3;
    }(Subject_1.Subject);
    exports.AsyncSubject = AsyncSubject2;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/Action.js
var require_Action = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/Action.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Action = void 0;
    var Subscription_1 = require_Subscription();
    var Action2 = function(_super) {
      __extends2(Action3, _super);
      function Action3(scheduler, work) {
        return _super.call(this) || this;
      }
      Action3.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return this;
      };
      return Action3;
    }(Subscription_1.Subscription);
    exports.Action = Action2;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js
var require_intervalProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.intervalProvider = void 0;
    exports.intervalProvider = {
      setInterval: function(handler, timeout2) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = exports.intervalProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
          return delegate.setInterval.apply(delegate, __spreadArray2([handler, timeout2], __read2(args)));
        }
        return setInterval.apply(void 0, __spreadArray2([handler, timeout2], __read2(args)));
      },
      clearInterval: function(handle) {
        var delegate = exports.intervalProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js
var require_AsyncAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AsyncAction = void 0;
    var Action_1 = require_Action();
    var intervalProvider_1 = require_intervalProvider();
    var arrRemove_1 = require_arrRemove();
    var AsyncAction2 = function(_super) {
      __extends2(AsyncAction3, _super);
      function AsyncAction3(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
      }
      AsyncAction3.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (this.closed) {
          return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, delay2);
        }
        this.pending = true;
        this.delay = delay2;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay2);
        return this;
      };
      AsyncAction3.prototype.requestAsyncId = function(scheduler, _id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
      };
      AsyncAction3.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 != null && this.delay === delay2 && this.pending === false) {
          return id;
        }
        intervalProvider_1.intervalProvider.clearInterval(id);
        return void 0;
      };
      AsyncAction3.prototype.execute = function(state, delay2) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        var error2 = this._execute(state, delay2);
        if (error2) {
          return error2;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      };
      AsyncAction3.prototype._execute = function(state, _delay) {
        var errored = false;
        var errorValue;
        try {
          this.work(state);
        } catch (e) {
          errored = true;
          errorValue = e ? e : new Error("Scheduled action threw falsy error");
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      };
      AsyncAction3.prototype.unsubscribe = function() {
        if (!this.closed) {
          var _a = this, id = _a.id, scheduler = _a.scheduler;
          var actions = scheduler.actions;
          this.work = this.state = this.scheduler = null;
          this.pending = false;
          arrRemove_1.arrRemove(actions, this);
          if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
          }
          this.delay = null;
          _super.prototype.unsubscribe.call(this);
        }
      };
      return AsyncAction3;
    }(Action_1.Action);
    exports.AsyncAction = AsyncAction2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/Immediate.js
var require_Immediate = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/Immediate.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TestTools = exports.Immediate = void 0;
    var nextHandle2 = 1;
    var resolved2;
    var activeHandles2 = {};
    function findAndClearHandle2(handle) {
      if (handle in activeHandles2) {
        delete activeHandles2[handle];
        return true;
      }
      return false;
    }
    exports.Immediate = {
      setImmediate: function(cb) {
        var handle = nextHandle2++;
        activeHandles2[handle] = true;
        if (!resolved2) {
          resolved2 = Promise.resolve();
        }
        resolved2.then(function() {
          return findAndClearHandle2(handle) && cb();
        });
        return handle;
      },
      clearImmediate: function(handle) {
        findAndClearHandle2(handle);
      }
    };
    exports.TestTools = {
      pending: function() {
        return Object.keys(activeHandles2).length;
      }
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js
var require_immediateProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.immediateProvider = void 0;
    var Immediate_1 = require_Immediate();
    var setImmediate2 = Immediate_1.Immediate.setImmediate;
    var clearImmediate2 = Immediate_1.Immediate.clearImmediate;
    exports.immediateProvider = {
      setImmediate: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate2).apply(void 0, __spreadArray2([], __read2(args)));
      },
      clearImmediate: function(handle) {
        var delegate = exports.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate2)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js
var require_AsapAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AsapAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var immediateProvider_1 = require_immediateProvider();
    var AsapAction2 = function(_super) {
      __extends2(AsapAction3, _super);
      function AsapAction3(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AsapAction3.prototype.requestAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
      };
      AsapAction3.prototype.recycleAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
        }
        if (!scheduler.actions.some(function(action) {
          return action.id === id;
        })) {
          immediateProvider_1.immediateProvider.clearImmediate(id);
          scheduler._scheduled = void 0;
        }
        return void 0;
      };
      return AsapAction3;
    }(AsyncAction_1.AsyncAction);
    exports.AsapAction = AsapAction2;
  }
});

// node_modules/rxjs/dist/cjs/internal/Scheduler.js
var require_Scheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Scheduler.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Scheduler = void 0;
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var Scheduler2 = function() {
      function Scheduler3(schedulerActionCtor, now) {
        if (now === void 0) {
          now = Scheduler3.now;
        }
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now;
      }
      Scheduler3.prototype.schedule = function(work, delay2, state) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return new this.schedulerActionCtor(this, work).schedule(state, delay2);
      };
      Scheduler3.now = dateTimestampProvider_1.dateTimestampProvider.now;
      return Scheduler3;
    }();
    exports.Scheduler = Scheduler2;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js
var require_AsyncScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AsyncScheduler = void 0;
    var Scheduler_1 = require_Scheduler();
    var AsyncScheduler2 = function(_super) {
      __extends2(AsyncScheduler3, _super);
      function AsyncScheduler3(SchedulerAction, now) {
        if (now === void 0) {
          now = Scheduler_1.Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, now) || this;
        _this.actions = [];
        _this._active = false;
        _this._scheduled = void 0;
        return _this;
      }
      AsyncScheduler3.prototype.flush = function(action) {
        var actions = this.actions;
        if (this._active) {
          actions.push(action);
          return;
        }
        var error2;
        this._active = true;
        do {
          if (error2 = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this._active = false;
        if (error2) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error2;
        }
      };
      return AsyncScheduler3;
    }(Scheduler_1.Scheduler);
    exports.AsyncScheduler = AsyncScheduler2;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js
var require_AsapScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AsapScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var AsapScheduler2 = function(_super) {
      __extends2(AsapScheduler3, _super);
      function AsapScheduler3() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AsapScheduler3.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error2;
        action = action || actions.shift();
        do {
          if (error2 = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error2) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error2;
        }
      };
      return AsapScheduler3;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.AsapScheduler = AsapScheduler2;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/asap.js
var require_asap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/asap.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.asap = exports.asapScheduler = void 0;
    var AsapAction_1 = require_AsapAction();
    var AsapScheduler_1 = require_AsapScheduler();
    exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
    exports.asap = exports.asapScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/async.js
var require_async = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/async.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.async = exports.asyncScheduler = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var AsyncScheduler_1 = require_AsyncScheduler();
    exports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
    exports.async = exports.asyncScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js
var require_QueueAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.QueueAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var QueueAction2 = function(_super) {
      __extends2(QueueAction3, _super);
      function QueueAction3(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      QueueAction3.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 > 0) {
          return _super.prototype.schedule.call(this, state, delay2);
        }
        this.delay = delay2;
        this.state = state;
        this.scheduler.flush(this);
        return this;
      };
      QueueAction3.prototype.execute = function(state, delay2) {
        return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
      };
      QueueAction3.prototype.requestAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
        }
        return scheduler.flush(this);
      };
      return QueueAction3;
    }(AsyncAction_1.AsyncAction);
    exports.QueueAction = QueueAction2;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js
var require_QueueScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.QueueScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var QueueScheduler2 = function(_super) {
      __extends2(QueueScheduler3, _super);
      function QueueScheduler3() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return QueueScheduler3;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.QueueScheduler = QueueScheduler2;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/queue.js
var require_queue = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/queue.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.queue = exports.queueScheduler = void 0;
    var QueueAction_1 = require_QueueAction();
    var QueueScheduler_1 = require_QueueScheduler();
    exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
    exports.queue = exports.queueScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js
var require_AnimationFrameAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AnimationFrameAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var animationFrameProvider_1 = require_animationFrameProvider();
    var AnimationFrameAction2 = function(_super) {
      __extends2(AnimationFrameAction3, _super);
      function AnimationFrameAction3(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AnimationFrameAction3.prototype.requestAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
          return scheduler.flush(void 0);
        }));
      };
      AnimationFrameAction3.prototype.recycleAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
        }
        if (!scheduler.actions.some(function(action) {
          return action.id === id;
        })) {
          animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
          scheduler._scheduled = void 0;
        }
        return void 0;
      };
      return AnimationFrameAction3;
    }(AsyncAction_1.AsyncAction);
    exports.AnimationFrameAction = AnimationFrameAction2;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js
var require_AnimationFrameScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AnimationFrameScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var AnimationFrameScheduler2 = function(_super) {
      __extends2(AnimationFrameScheduler3, _super);
      function AnimationFrameScheduler3() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AnimationFrameScheduler3.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error2;
        action = action || actions.shift();
        do {
          if (error2 = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error2) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error2;
        }
      };
      return AnimationFrameScheduler3;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.AnimationFrameScheduler = AnimationFrameScheduler2;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js
var require_animationFrame = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.animationFrame = exports.animationFrameScheduler = void 0;
    var AnimationFrameAction_1 = require_AnimationFrameAction();
    var AnimationFrameScheduler_1 = require_AnimationFrameScheduler();
    exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
    exports.animationFrame = exports.animationFrameScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js
var require_VirtualTimeScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.VirtualAction = exports.VirtualTimeScheduler = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var Subscription_1 = require_Subscription();
    var AsyncScheduler_1 = require_AsyncScheduler();
    var VirtualTimeScheduler2 = function(_super) {
      __extends2(VirtualTimeScheduler3, _super);
      function VirtualTimeScheduler3(schedulerActionCtor, maxFrames) {
        if (schedulerActionCtor === void 0) {
          schedulerActionCtor = VirtualAction2;
        }
        if (maxFrames === void 0) {
          maxFrames = Infinity;
        }
        var _this = _super.call(this, schedulerActionCtor, function() {
          return _this.frame;
        }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
      }
      VirtualTimeScheduler3.prototype.flush = function() {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error2;
        var action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
          actions.shift();
          this.frame = action.delay;
          if (error2 = action.execute(action.state, action.delay)) {
            break;
          }
        }
        if (error2) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error2;
        }
      };
      VirtualTimeScheduler3.frameTimeFactor = 10;
      return VirtualTimeScheduler3;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.VirtualTimeScheduler = VirtualTimeScheduler2;
    var VirtualAction2 = function(_super) {
      __extends2(VirtualAction3, _super);
      function VirtualAction3(scheduler, work, index) {
        if (index === void 0) {
          index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
      }
      VirtualAction3.prototype.schedule = function(state, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (Number.isFinite(delay2)) {
          if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay2);
          }
          this.active = false;
          var action = new VirtualAction3(this.scheduler, this.work);
          this.add(action);
          return action.schedule(state, delay2);
        } else {
          return Subscription_1.Subscription.EMPTY;
        }
      };
      VirtualAction3.prototype.requestAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        this.delay = scheduler.frame + delay2;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction3.sortActions);
        return true;
      };
      VirtualAction3.prototype.recycleAsyncId = function(scheduler, id, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return void 0;
      };
      VirtualAction3.prototype._execute = function(state, delay2) {
        if (this.active === true) {
          return _super.prototype._execute.call(this, state, delay2);
        }
      };
      VirtualAction3.sortActions = function(a, b) {
        if (a.delay === b.delay) {
          if (a.index === b.index) {
            return 0;
          } else if (a.index > b.index) {
            return 1;
          } else {
            return -1;
          }
        } else if (a.delay > b.delay) {
          return 1;
        } else {
          return -1;
        }
      };
      return VirtualAction3;
    }(AsyncAction_1.AsyncAction);
    exports.VirtualAction = VirtualAction2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/empty.js
var require_empty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/empty.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.empty = exports.EMPTY = void 0;
    var Observable_1 = require_Observable();
    exports.EMPTY = new Observable_1.Observable(function(subscriber) {
      return subscriber.complete();
    });
    function empty2(scheduler) {
      return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
    }
    exports.empty = empty2;
    function emptyScheduled(scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        return scheduler.schedule(function() {
          return subscriber.complete();
        });
      });
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isScheduler.js
var require_isScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isScheduler.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isScheduler = void 0;
    var isFunction_1 = require_isFunction();
    function isScheduler2(value) {
      return value && isFunction_1.isFunction(value.schedule);
    }
    exports.isScheduler = isScheduler2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/args.js
var require_args = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/args.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.popNumber = exports.popScheduler = exports.popResultSelector = void 0;
    var isFunction_1 = require_isFunction();
    var isScheduler_1 = require_isScheduler();
    function last3(arr) {
      return arr[arr.length - 1];
    }
    function popResultSelector2(args) {
      return isFunction_1.isFunction(last3(args)) ? args.pop() : void 0;
    }
    exports.popResultSelector = popResultSelector2;
    function popScheduler2(args) {
      return isScheduler_1.isScheduler(last3(args)) ? args.pop() : void 0;
    }
    exports.popScheduler = popScheduler2;
    function popNumber2(args, defaultValue) {
      return typeof last3(args) === "number" ? args.pop() : defaultValue;
    }
    exports.popNumber = popNumber2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isArrayLike = void 0;
    exports.isArrayLike = function(x) {
      return x && typeof x.length === "number" && typeof x !== "function";
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isPromise.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isPromise = void 0;
    var isFunction_1 = require_isFunction();
    function isPromise3(value) {
      return isFunction_1.isFunction(value === null || value === void 0 ? void 0 : value.then);
    }
    exports.isPromise = isPromise3;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js
var require_isInteropObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isInteropObservable = void 0;
    var observable_1 = require_observable();
    var isFunction_1 = require_isFunction();
    function isInteropObservable2(input) {
      return isFunction_1.isFunction(input[observable_1.observable]);
    }
    exports.isInteropObservable = isInteropObservable2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js
var require_isAsyncIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isAsyncIterable = void 0;
    var isFunction_1 = require_isFunction();
    function isAsyncIterable2(obj) {
      return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
    }
    exports.isAsyncIterable = isAsyncIterable2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js
var require_throwUnobservableError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createInvalidObservableTypeError = void 0;
    function createInvalidObservableTypeError2(input) {
      return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
    }
    exports.createInvalidObservableTypeError = createInvalidObservableTypeError2;
  }
});

// node_modules/rxjs/dist/cjs/internal/symbol/iterator.js
var require_iterator = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/symbol/iterator.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.iterator = exports.getSymbolIterator = void 0;
    function getSymbolIterator3() {
      if (typeof Symbol !== "function" || !Symbol.iterator) {
        return "@@iterator";
      }
      return Symbol.iterator;
    }
    exports.getSymbolIterator = getSymbolIterator3;
    exports.iterator = getSymbolIterator3();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isIterable.js
var require_isIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isIterable.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isIterable = void 0;
    var iterator_1 = require_iterator();
    var isFunction_1 = require_isFunction();
    function isIterable2(input) {
      return isFunction_1.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1.iterator]);
    }
    exports.isIterable = isIterable2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js
var require_isReadableStreamLike = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    var __await2 = exports && exports.__await || function(v) {
      return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
    };
    var __asyncGenerator2 = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isReadableStreamLike = exports.readableStreamLikeToAsyncGenerator = void 0;
    var isFunction_1 = require_isFunction();
    function readableStreamLikeToAsyncGenerator2(readableStream) {
      return __asyncGenerator2(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
        var reader, _a, value, done;
        return __generator2(this, function(_b) {
          switch (_b.label) {
            case 0:
              reader = readableStream.getReader();
              _b.label = 1;
            case 1:
              _b.trys.push([1, , 9, 10]);
              _b.label = 2;
            case 2:
              if (false)
                return [3, 8];
              return [4, __await2(reader.read())];
            case 3:
              _a = _b.sent(), value = _a.value, done = _a.done;
              if (!done)
                return [3, 5];
              return [4, __await2(void 0)];
            case 4:
              return [2, _b.sent()];
            case 5:
              return [4, __await2(value)];
            case 6:
              return [4, _b.sent()];
            case 7:
              _b.sent();
              return [3, 2];
            case 8:
              return [3, 10];
            case 9:
              reader.releaseLock();
              return [7];
            case 10:
              return [2];
          }
        });
      });
    }
    exports.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator2;
    function isReadableStreamLike2(obj) {
      return isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
    }
    exports.isReadableStreamLike = isReadableStreamLike2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js
var require_innerFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    var __asyncValues2 = exports && exports.__asyncValues || function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({
            value: v2,
            done: d
          });
        }, reject);
      }
    };
    var __values2 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return {
              value: o && o[i++],
              done: !o
            };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.fromReadableStreamLike = exports.fromAsyncIterable = exports.fromIterable = exports.fromPromise = exports.fromArrayLike = exports.fromInteropObservable = exports.innerFrom = void 0;
    var isArrayLike_1 = require_isArrayLike();
    var isPromise_1 = require_isPromise();
    var Observable_1 = require_Observable();
    var isInteropObservable_1 = require_isInteropObservable();
    var isAsyncIterable_1 = require_isAsyncIterable();
    var throwUnobservableError_1 = require_throwUnobservableError();
    var isIterable_1 = require_isIterable();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    var isFunction_1 = require_isFunction();
    var reportUnhandledError_1 = require_reportUnhandledError();
    var observable_1 = require_observable();
    function innerFrom2(input) {
      if (input instanceof Observable_1.Observable) {
        return input;
      }
      if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
          return fromInteropObservable2(input);
        }
        if (isArrayLike_1.isArrayLike(input)) {
          return fromArrayLike2(input);
        }
        if (isPromise_1.isPromise(input)) {
          return fromPromise2(input);
        }
        if (isAsyncIterable_1.isAsyncIterable(input)) {
          return fromAsyncIterable2(input);
        }
        if (isIterable_1.isIterable(input)) {
          return fromIterable2(input);
        }
        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
          return fromReadableStreamLike2(input);
        }
      }
      throw throwUnobservableError_1.createInvalidObservableTypeError(input);
    }
    exports.innerFrom = innerFrom2;
    function fromInteropObservable2(obj) {
      return new Observable_1.Observable(function(subscriber) {
        var obs = obj[observable_1.observable]();
        if (isFunction_1.isFunction(obs.subscribe)) {
          return obs.subscribe(subscriber);
        }
        throw new TypeError("Provided object does not correctly implement Symbol.observable");
      });
    }
    exports.fromInteropObservable = fromInteropObservable2;
    function fromArrayLike2(array) {
      return new Observable_1.Observable(function(subscriber) {
        for (var i = 0; i < array.length && !subscriber.closed; i++) {
          subscriber.next(array[i]);
        }
        subscriber.complete();
      });
    }
    exports.fromArrayLike = fromArrayLike2;
    function fromPromise2(promise2) {
      return new Observable_1.Observable(function(subscriber) {
        promise2.then(function(value) {
          if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
          }
        }, function(err) {
          return subscriber.error(err);
        }).then(null, reportUnhandledError_1.reportUnhandledError);
      });
    }
    exports.fromPromise = fromPromise2;
    function fromIterable2(iterable) {
      return new Observable_1.Observable(function(subscriber) {
        var e_1, _a;
        try {
          for (var iterable_1 = __values2(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
            var value = iterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return;
            }
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
              _a.call(iterable_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        subscriber.complete();
      });
    }
    exports.fromIterable = fromIterable2;
    function fromAsyncIterable2(asyncIterable) {
      return new Observable_1.Observable(function(subscriber) {
        process2(asyncIterable, subscriber).catch(function(err) {
          return subscriber.error(err);
        });
      });
    }
    exports.fromAsyncIterable = fromAsyncIterable2;
    function fromReadableStreamLike2(readableStream) {
      return fromAsyncIterable2(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
    }
    exports.fromReadableStreamLike = fromReadableStreamLike2;
    function process2(asyncIterable, subscriber) {
      var asyncIterable_1, asyncIterable_1_1;
      var e_2, _a;
      return __awaiter2(this, void 0, void 0, function() {
        var value, e_2_1;
        return __generator2(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 5, 6, 11]);
              asyncIterable_1 = __asyncValues2(asyncIterable);
              _b.label = 1;
            case 1:
              return [4, asyncIterable_1.next()];
            case 2:
              if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
                return [3, 4];
              value = asyncIterable_1_1.value;
              subscriber.next(value);
              if (subscriber.closed) {
                return [2];
              }
              _b.label = 3;
            case 3:
              return [3, 1];
            case 4:
              return [3, 11];
            case 5:
              e_2_1 = _b.sent();
              e_2 = {
                error: e_2_1
              };
              return [3, 11];
            case 6:
              _b.trys.push([6, , 9, 10]);
              if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
                return [3, 8];
              return [4, _a.call(asyncIterable_1)];
            case 7:
              _b.sent();
              _b.label = 8;
            case 8:
              return [3, 10];
            case 9:
              if (e_2)
                throw e_2.error;
              return [7];
            case 10:
              return [7];
            case 11:
              subscriber.complete();
              return [2];
          }
        });
      });
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js
var require_executeSchedule = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.executeSchedule = void 0;
    function executeSchedule2(parentSubscription, scheduler, work, delay2, repeat2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (repeat2 === void 0) {
        repeat2 = false;
      }
      var scheduleSubscription = scheduler.schedule(function() {
        work();
        if (repeat2) {
          parentSubscription.add(this.schedule(null, delay2));
        } else {
          this.unsubscribe();
        }
      }, delay2);
      parentSubscription.add(scheduleSubscription);
      if (!repeat2) {
        return scheduleSubscription;
      }
    }
    exports.executeSchedule = executeSchedule2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/observeOn.js
var require_observeOn = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/observeOn.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.observeOn = void 0;
    var executeSchedule_1 = require_executeSchedule();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function observeOn2(scheduler, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.next(value);
          }, delay2);
        }, function() {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.complete();
          }, delay2);
        }, function(err) {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.error(err);
          }, delay2);
        }));
      });
    }
    exports.observeOn = observeOn2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js
var require_subscribeOn = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.subscribeOn = void 0;
    var lift_1 = require_lift();
    function subscribeOn2(scheduler, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return lift_1.operate(function(source, subscriber) {
        subscriber.add(scheduler.schedule(function() {
          return source.subscribe(subscriber);
        }, delay2));
      });
    }
    exports.subscribeOn = subscribeOn2;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js
var require_scheduleObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.scheduleObservable = void 0;
    var innerFrom_1 = require_innerFrom();
    var observeOn_1 = require_observeOn();
    var subscribeOn_1 = require_subscribeOn();
    function scheduleObservable2(input, scheduler) {
      return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
    }
    exports.scheduleObservable = scheduleObservable2;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js
var require_schedulePromise = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.schedulePromise = void 0;
    var innerFrom_1 = require_innerFrom();
    var observeOn_1 = require_observeOn();
    var subscribeOn_1 = require_subscribeOn();
    function schedulePromise2(input, scheduler) {
      return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
    }
    exports.schedulePromise = schedulePromise2;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js
var require_scheduleArray = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.scheduleArray = void 0;
    var Observable_1 = require_Observable();
    function scheduleArray2(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var i = 0;
        return scheduler.schedule(function() {
          if (i === input.length) {
            subscriber.complete();
          } else {
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
              this.schedule();
            }
          }
        });
      });
    }
    exports.scheduleArray = scheduleArray2;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js
var require_scheduleIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.scheduleIterable = void 0;
    var Observable_1 = require_Observable();
    var iterator_1 = require_iterator();
    var isFunction_1 = require_isFunction();
    var executeSchedule_1 = require_executeSchedule();
    function scheduleIterable2(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var iterator2;
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          iterator2 = input[iterator_1.iterator]();
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            var _a;
            var value;
            var done;
            try {
              _a = iterator2.next(), value = _a.value, done = _a.done;
            } catch (err) {
              subscriber.error(err);
              return;
            }
            if (done) {
              subscriber.complete();
            } else {
              subscriber.next(value);
            }
          }, 0, true);
        });
        return function() {
          return isFunction_1.isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
        };
      });
    }
    exports.scheduleIterable = scheduleIterable2;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js
var require_scheduleAsyncIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.scheduleAsyncIterable = void 0;
    var Observable_1 = require_Observable();
    var executeSchedule_1 = require_executeSchedule();
    function scheduleAsyncIterable2(input, scheduler) {
      if (!input) {
        throw new Error("Iterable cannot be null");
      }
      return new Observable_1.Observable(function(subscriber) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          var iterator2 = input[Symbol.asyncIterator]();
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            iterator2.next().then(function(result) {
              if (result.done) {
                subscriber.complete();
              } else {
                subscriber.next(result.value);
              }
            });
          }, 0, true);
        });
      });
    }
    exports.scheduleAsyncIterable = scheduleAsyncIterable2;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js
var require_scheduleReadableStreamLike = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.scheduleReadableStreamLike = void 0;
    var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    function scheduleReadableStreamLike2(input, scheduler) {
      return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
    }
    exports.scheduleReadableStreamLike = scheduleReadableStreamLike2;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js
var require_scheduled = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.scheduled = void 0;
    var scheduleObservable_1 = require_scheduleObservable();
    var schedulePromise_1 = require_schedulePromise();
    var scheduleArray_1 = require_scheduleArray();
    var scheduleIterable_1 = require_scheduleIterable();
    var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
    var isInteropObservable_1 = require_isInteropObservable();
    var isPromise_1 = require_isPromise();
    var isArrayLike_1 = require_isArrayLike();
    var isIterable_1 = require_isIterable();
    var isAsyncIterable_1 = require_isAsyncIterable();
    var throwUnobservableError_1 = require_throwUnobservableError();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    var scheduleReadableStreamLike_1 = require_scheduleReadableStreamLike();
    function scheduled2(input, scheduler) {
      if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
          return scheduleObservable_1.scheduleObservable(input, scheduler);
        }
        if (isArrayLike_1.isArrayLike(input)) {
          return scheduleArray_1.scheduleArray(input, scheduler);
        }
        if (isPromise_1.isPromise(input)) {
          return schedulePromise_1.schedulePromise(input, scheduler);
        }
        if (isAsyncIterable_1.isAsyncIterable(input)) {
          return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
        }
        if (isIterable_1.isIterable(input)) {
          return scheduleIterable_1.scheduleIterable(input, scheduler);
        }
        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
          return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
        }
      }
      throw throwUnobservableError_1.createInvalidObservableTypeError(input);
    }
    exports.scheduled = scheduled2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/from.js
var require_from = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/from.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.from = void 0;
    var scheduled_1 = require_scheduled();
    var innerFrom_1 = require_innerFrom();
    function from2(input, scheduler) {
      return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
    }
    exports.from = from2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/of.js
var require_of = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/of.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.of = void 0;
    var args_1 = require_args();
    var from_1 = require_from();
    function of2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      return from_1.from(args, scheduler);
    }
    exports.of = of2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/throwError.js
var require_throwError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/throwError.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.throwError = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    function throwError3(errorOrErrorFactory, scheduler) {
      var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
        return errorOrErrorFactory;
      };
      var init = function(subscriber) {
        return subscriber.error(errorFactory());
      };
      return new Observable_1.Observable(scheduler ? function(subscriber) {
        return scheduler.schedule(init, 0, subscriber);
      } : init);
    }
    exports.throwError = throwError3;
  }
});

// node_modules/rxjs/dist/cjs/internal/Notification.js
var require_Notification = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Notification.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.observeNotification = exports.Notification = exports.NotificationKind = void 0;
    var empty_1 = require_empty();
    var of_1 = require_of();
    var throwError_1 = require_throwError();
    var isFunction_1 = require_isFunction();
    var NotificationKind2;
    (function(NotificationKind3) {
      NotificationKind3["NEXT"] = "N";
      NotificationKind3["ERROR"] = "E";
      NotificationKind3["COMPLETE"] = "C";
    })(NotificationKind2 = exports.NotificationKind || (exports.NotificationKind = {}));
    var Notification2 = function() {
      function Notification3(kind, value, error2) {
        this.kind = kind;
        this.value = value;
        this.error = error2;
        this.hasValue = kind === "N";
      }
      Notification3.prototype.observe = function(observer) {
        return observeNotification2(this, observer);
      };
      Notification3.prototype.do = function(nextHandler, errorHandler2, completeHandler) {
        var _a = this, kind = _a.kind, value = _a.value, error2 = _a.error;
        return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler2 === null || errorHandler2 === void 0 ? void 0 : errorHandler2(error2) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
      };
      Notification3.prototype.accept = function(nextOrObserver, error2, complete) {
        var _a;
        return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error2, complete);
      };
      Notification3.prototype.toObservable = function() {
        var _a = this, kind = _a.kind, value = _a.value, error2 = _a.error;
        var result = kind === "N" ? of_1.of(value) : kind === "E" ? throwError_1.throwError(function() {
          return error2;
        }) : kind === "C" ? empty_1.EMPTY : 0;
        if (!result) {
          throw new TypeError("Unexpected notification kind " + kind);
        }
        return result;
      };
      Notification3.createNext = function(value) {
        return new Notification3("N", value);
      };
      Notification3.createError = function(err) {
        return new Notification3("E", void 0, err);
      };
      Notification3.createComplete = function() {
        return Notification3.completeNotification;
      };
      Notification3.completeNotification = new Notification3("C");
      return Notification3;
    }();
    exports.Notification = Notification2;
    function observeNotification2(notification, observer) {
      var _a, _b, _c;
      var _d = notification, kind = _d.kind, value = _d.value, error2 = _d.error;
      if (typeof kind !== "string") {
        throw new TypeError('Invalid notification, missing "kind"');
      }
      kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error2) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
    }
    exports.observeNotification = observeNotification2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isObservable.js
var require_isObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isObservable.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isObservable = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    function isObservable3(obj) {
      return !!obj && (obj instanceof Observable_1.Observable || isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe));
    }
    exports.isObservable = isObservable3;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/EmptyError.js
var require_EmptyError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/EmptyError.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EmptyError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
      return function EmptyErrorImpl() {
        _super(this);
        this.name = "EmptyError";
        this.message = "no elements in sequence";
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/lastValueFrom.js
var require_lastValueFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/lastValueFrom.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.lastValueFrom = void 0;
    var EmptyError_1 = require_EmptyError();
    function lastValueFrom2(source, config2) {
      var hasConfig = typeof config2 === "object";
      return new Promise(function(resolve, reject) {
        var _hasValue = false;
        var _value;
        source.subscribe({
          next: function(value) {
            _value = value;
            _hasValue = true;
          },
          error: reject,
          complete: function() {
            if (_hasValue) {
              resolve(_value);
            } else if (hasConfig) {
              resolve(config2.defaultValue);
            } else {
              reject(new EmptyError_1.EmptyError());
            }
          }
        });
      });
    }
    exports.lastValueFrom = lastValueFrom2;
  }
});

// node_modules/rxjs/dist/cjs/internal/firstValueFrom.js
var require_firstValueFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/firstValueFrom.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.firstValueFrom = void 0;
    var EmptyError_1 = require_EmptyError();
    var Subscriber_1 = require_Subscriber();
    function firstValueFrom2(source, config2) {
      var hasConfig = typeof config2 === "object";
      return new Promise(function(resolve, reject) {
        var subscriber = new Subscriber_1.SafeSubscriber({
          next: function(value) {
            resolve(value);
            subscriber.unsubscribe();
          },
          error: reject,
          complete: function() {
            if (hasConfig) {
              resolve(config2.defaultValue);
            } else {
              reject(new EmptyError_1.EmptyError());
            }
          }
        });
        source.subscribe(subscriber);
      });
    }
    exports.firstValueFrom = firstValueFrom2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js
var require_ArgumentOutOfRangeError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ArgumentOutOfRangeError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
      return function ArgumentOutOfRangeErrorImpl() {
        _super(this);
        this.name = "ArgumentOutOfRangeError";
        this.message = "argument out of range";
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js
var require_NotFoundError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NotFoundError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
      return function NotFoundErrorImpl(message) {
        _super(this);
        this.name = "NotFoundError";
        this.message = message;
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/SequenceError.js
var require_SequenceError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/SequenceError.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SequenceError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
      return function SequenceErrorImpl(message) {
        _super(this);
        this.name = "SequenceError";
        this.message = message;
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isDate.js
var require_isDate = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isDate.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isValidDate = void 0;
    function isValidDate2(value) {
      return value instanceof Date && !isNaN(value);
    }
    exports.isValidDate = isValidDate2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timeout.js
var require_timeout = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timeout.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.timeout = exports.TimeoutError = void 0;
    var async_1 = require_async();
    var isDate_1 = require_isDate();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var createErrorClass_1 = require_createErrorClass();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var executeSchedule_1 = require_executeSchedule();
    exports.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
      return function TimeoutErrorImpl(info) {
        if (info === void 0) {
          info = null;
        }
        _super(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        this.info = info;
      };
    });
    function timeout2(config2, schedulerArg) {
      var _a = isDate_1.isValidDate(config2) ? {
        first: config2
      } : typeof config2 === "number" ? {
        each: config2
      } : config2, first2 = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory2 : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_1.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
      if (first2 == null && each == null) {
        throw new TypeError("No timeout provided.");
      }
      return lift_1.operate(function(source, subscriber) {
        var originalSourceSubscription;
        var timerSubscription;
        var lastValue = null;
        var seen = 0;
        var startTimer = function(delay2) {
          timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            try {
              originalSourceSubscription.unsubscribe();
              innerFrom_1.innerFrom(_with({
                meta,
                lastValue,
                seen
              })).subscribe(subscriber);
            } catch (err) {
              subscriber.error(err);
            }
          }, delay2);
        };
        originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          seen++;
          subscriber.next(lastValue = value);
          each > 0 && startTimer(each);
        }, void 0, void 0, function() {
          if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
            timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          }
          lastValue = null;
        }));
        !seen && startTimer(first2 != null ? typeof first2 === "number" ? first2 : +first2 - scheduler.now() : each);
      });
    }
    exports.timeout = timeout2;
    function timeoutErrorFactory2(info) {
      throw new exports.TimeoutError(info);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/map.js
var require_map = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/map.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.map = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function map2(project, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          subscriber.next(project.call(thisArg, value, index++));
        }));
      });
    }
    exports.map = map2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js
var require_mapOneOrManyArgs = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.mapOneOrManyArgs = void 0;
    var map_1 = require_map();
    var isArray4 = Array.isArray;
    function callOrApply2(fn2, args) {
      return isArray4(args) ? fn2.apply(void 0, __spreadArray2([], __read2(args))) : fn2(args);
    }
    function mapOneOrManyArgs2(fn2) {
      return map_1.map(function(args) {
        return callOrApply2(fn2, args);
      });
    }
    exports.mapOneOrManyArgs = mapOneOrManyArgs2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js
var require_bindCallbackInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bindCallbackInternals = void 0;
    var isScheduler_1 = require_isScheduler();
    var Observable_1 = require_Observable();
    var subscribeOn_1 = require_subscribeOn();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var observeOn_1 = require_observeOn();
    var AsyncSubject_1 = require_AsyncSubject();
    function bindCallbackInternals2(isNodeStyle, callbackFunc, resultSelector, scheduler) {
      if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
          scheduler = resultSelector;
        } else {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return bindCallbackInternals2(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
          };
        }
      }
      if (scheduler) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return bindCallbackInternals2(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
        };
      }
      return function() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var subject = new AsyncSubject_1.AsyncSubject();
        var uninitialized = true;
        return new Observable_1.Observable(function(subscriber) {
          var subs = subject.subscribe(subscriber);
          if (uninitialized) {
            uninitialized = false;
            var isAsync_1 = false;
            var isComplete_1 = false;
            callbackFunc.apply(_this, __spreadArray2(__spreadArray2([], __read2(args)), [function() {
              var results = [];
              for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                results[_i2] = arguments[_i2];
              }
              if (isNodeStyle) {
                var err = results.shift();
                if (err != null) {
                  subject.error(err);
                  return;
                }
              }
              subject.next(1 < results.length ? results : results[0]);
              isComplete_1 = true;
              if (isAsync_1) {
                subject.complete();
              }
            }]));
            if (isComplete_1) {
              subject.complete();
            }
            isAsync_1 = true;
          }
          return subs;
        });
      };
    }
    exports.bindCallbackInternals = bindCallbackInternals2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js
var require_bindCallback = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bindCallback = void 0;
    var bindCallbackInternals_1 = require_bindCallbackInternals();
    function bindCallback2(callbackFunc, resultSelector, scheduler) {
      return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
    }
    exports.bindCallback = bindCallback2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js
var require_bindNodeCallback = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bindNodeCallback = void 0;
    var bindCallbackInternals_1 = require_bindCallbackInternals();
    function bindNodeCallback2(callbackFunc, resultSelector, scheduler) {
      return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
    }
    exports.bindNodeCallback = bindNodeCallback2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js
var require_argsArgArrayOrObject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.argsArgArrayOrObject = void 0;
    var isArray4 = Array.isArray;
    var getPrototypeOf2 = Object.getPrototypeOf;
    var objectProto2 = Object.prototype;
    var getKeys2 = Object.keys;
    function argsArgArrayOrObject2(args) {
      if (args.length === 1) {
        var first_1 = args[0];
        if (isArray4(first_1)) {
          return {
            args: first_1,
            keys: null
          };
        }
        if (isPOJO2(first_1)) {
          var keys = getKeys2(first_1);
          return {
            args: keys.map(function(key) {
              return first_1[key];
            }),
            keys
          };
        }
      }
      return {
        args,
        keys: null
      };
    }
    exports.argsArgArrayOrObject = argsArgArrayOrObject2;
    function isPOJO2(obj) {
      return obj && typeof obj === "object" && getPrototypeOf2(obj) === objectProto2;
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/createObject.js
var require_createObject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/createObject.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createObject = void 0;
    function createObject2(keys, values) {
      return keys.reduce(function(result, key, i) {
        return result[key] = values[i], result;
      }, {});
    }
    exports.createObject = createObject2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js
var require_combineLatest = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.combineLatestInit = exports.combineLatest = void 0;
    var Observable_1 = require_Observable();
    var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
    var from_1 = require_from();
    var identity_1 = require_identity();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var args_1 = require_args();
    var createObject_1 = require_createObject();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var executeSchedule_1 = require_executeSchedule();
    function combineLatest3() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var resultSelector = args_1.popResultSelector(args);
      var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
      if (observables.length === 0) {
        return from_1.from([], scheduler);
      }
      var result = new Observable_1.Observable(combineLatestInit2(observables, scheduler, keys ? function(values) {
        return createObject_1.createObject(keys, values);
      } : identity_1.identity));
      return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
    }
    exports.combineLatest = combineLatest3;
    function combineLatestInit2(observables, scheduler, valueTransform) {
      if (valueTransform === void 0) {
        valueTransform = identity_1.identity;
      }
      return function(subscriber) {
        maybeSchedule2(scheduler, function() {
          var length = observables.length;
          var values = new Array(length);
          var active = length;
          var remainingFirstValues = length;
          var _loop_1 = function(i2) {
            maybeSchedule2(scheduler, function() {
              var source = from_1.from(observables[i2], scheduler);
              var hasFirstValue = false;
              source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                values[i2] = value;
                if (!hasFirstValue) {
                  hasFirstValue = true;
                  remainingFirstValues--;
                }
                if (!remainingFirstValues) {
                  subscriber.next(valueTransform(values.slice()));
                }
              }, function() {
                if (!--active) {
                  subscriber.complete();
                }
              }));
            }, subscriber);
          };
          for (var i = 0; i < length; i++) {
            _loop_1(i);
          }
        }, subscriber);
      };
    }
    exports.combineLatestInit = combineLatestInit2;
    function maybeSchedule2(scheduler, execute, subscription) {
      if (scheduler) {
        executeSchedule_1.executeSchedule(subscription, scheduler, execute);
      } else {
        execute();
      }
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js
var require_mergeInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.mergeInternals = void 0;
    var innerFrom_1 = require_innerFrom();
    var executeSchedule_1 = require_executeSchedule();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function mergeInternals2(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
      var buffer2 = [];
      var active = 0;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        if (isComplete && !buffer2.length && !active) {
          subscriber.complete();
        }
      };
      var outerNext = function(value) {
        return active < concurrent ? doInnerSub(value) : buffer2.push(value);
      };
      var doInnerSub = function(value) {
        expand2 && subscriber.next(value);
        active++;
        var innerComplete = false;
        innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
          onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
          if (expand2) {
            outerNext(innerValue);
          } else {
            subscriber.next(innerValue);
          }
        }, function() {
          innerComplete = true;
        }, void 0, function() {
          if (innerComplete) {
            try {
              active--;
              var _loop_1 = function() {
                var bufferedValue = buffer2.shift();
                if (innerSubScheduler) {
                  executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                    return doInnerSub(bufferedValue);
                  });
                } else {
                  doInnerSub(bufferedValue);
                }
              };
              while (buffer2.length && active < concurrent) {
                _loop_1();
              }
              checkComplete();
            } catch (err) {
              subscriber.error(err);
            }
          }
        }));
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
        isComplete = true;
        checkComplete();
      }));
      return function() {
        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
      };
    }
    exports.mergeInternals = mergeInternals2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js
var require_mergeMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.mergeMap = void 0;
    var map_1 = require_map();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    var isFunction_1 = require_isFunction();
    function mergeMap2(project, resultSelector, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      if (isFunction_1.isFunction(resultSelector)) {
        return mergeMap2(function(a, i) {
          return map_1.map(function(b, ii) {
            return resultSelector(a, b, i, ii);
          })(innerFrom_1.innerFrom(project(a, i)));
        }, concurrent);
      } else if (typeof resultSelector === "number") {
        concurrent = resultSelector;
      }
      return lift_1.operate(function(source, subscriber) {
        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent);
      });
    }
    exports.mergeMap = mergeMap2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js
var require_mergeAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.mergeAll = void 0;
    var mergeMap_1 = require_mergeMap();
    var identity_1 = require_identity();
    function mergeAll2(concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      return mergeMap_1.mergeMap(identity_1.identity, concurrent);
    }
    exports.mergeAll = mergeAll2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatAll.js
var require_concatAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatAll.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.concatAll = void 0;
    var mergeAll_1 = require_mergeAll();
    function concatAll2() {
      return mergeAll_1.mergeAll(1);
    }
    exports.concatAll = concatAll2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/concat.js
var require_concat = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/concat.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.concat = void 0;
    var concatAll_1 = require_concatAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function concat3() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
    }
    exports.concat = concat3;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/defer.js
var require_defer = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/defer.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.defer = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    function defer2(observableFactory) {
      return new Observable_1.Observable(function(subscriber) {
        innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
      });
    }
    exports.defer = defer2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/connectable.js
var require_connectable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/connectable.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.connectable = void 0;
    var Subject_1 = require_Subject();
    var Observable_1 = require_Observable();
    var defer_1 = require_defer();
    var DEFAULT_CONFIG2 = {
      connector: function() {
        return new Subject_1.Subject();
      },
      resetOnDisconnect: true
    };
    function connectable2(source, config2) {
      if (config2 === void 0) {
        config2 = DEFAULT_CONFIG2;
      }
      var connection = null;
      var connector = config2.connector, _a = config2.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
      var subject = connector();
      var result = new Observable_1.Observable(function(subscriber) {
        return subject.subscribe(subscriber);
      });
      result.connect = function() {
        if (!connection || connection.closed) {
          connection = defer_1.defer(function() {
            return source;
          }).subscribe(subject);
          if (resetOnDisconnect) {
            connection.add(function() {
              return subject = connector();
            });
          }
        }
        return connection;
      };
      return result;
    }
    exports.connectable = connectable2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js
var require_forkJoin = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.forkJoin = void 0;
    var Observable_1 = require_Observable();
    var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
    var innerFrom_1 = require_innerFrom();
    var args_1 = require_args();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var createObject_1 = require_createObject();
    function forkJoin2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
      var result = new Observable_1.Observable(function(subscriber) {
        var length = sources.length;
        if (!length) {
          subscriber.complete();
          return;
        }
        var values = new Array(length);
        var remainingCompletions = length;
        var remainingEmissions = length;
        var _loop_1 = function(sourceIndex2) {
          var hasValue = false;
          innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (!hasValue) {
              hasValue = true;
              remainingEmissions--;
            }
            values[sourceIndex2] = value;
          }, function() {
            return remainingCompletions--;
          }, void 0, function() {
            if (!remainingCompletions || !hasValue) {
              if (!remainingEmissions) {
                subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
              }
              subscriber.complete();
            }
          }));
        };
        for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
          _loop_1(sourceIndex);
        }
      });
      return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
    }
    exports.forkJoin = forkJoin2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js
var require_fromEvent = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.fromEvent = void 0;
    var innerFrom_1 = require_innerFrom();
    var Observable_1 = require_Observable();
    var mergeMap_1 = require_mergeMap();
    var isArrayLike_1 = require_isArrayLike();
    var isFunction_1 = require_isFunction();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var nodeEventEmitterMethods = ["addListener", "removeListener"];
    var eventTargetMethods = ["addEventListener", "removeEventListener"];
    var jqueryMethods = ["on", "off"];
    function fromEvent2(target, eventName, options, resultSelector) {
      if (isFunction_1.isFunction(options)) {
        resultSelector = options;
        options = void 0;
      }
      if (resultSelector) {
        return fromEvent2(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
      }
      var _a = __read2(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
        return function(handler) {
          return target[methodName](eventName, handler, options);
        };
      }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove2 = _a[1];
      if (!add) {
        if (isArrayLike_1.isArrayLike(target)) {
          return mergeMap_1.mergeMap(function(subTarget) {
            return fromEvent2(subTarget, eventName, options);
          })(innerFrom_1.innerFrom(target));
        }
      }
      if (!add) {
        throw new TypeError("Invalid event target");
      }
      return new Observable_1.Observable(function(subscriber) {
        var handler = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return subscriber.next(1 < args.length ? args : args[0]);
        };
        add(handler);
        return function() {
          return remove2(handler);
        };
      });
    }
    exports.fromEvent = fromEvent2;
    function toCommonHandlerRegistry(target, eventName) {
      return function(methodName) {
        return function(handler) {
          return target[methodName](eventName, handler);
        };
      };
    }
    function isNodeStyleEventEmitter(target) {
      return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
    }
    function isJQueryStyleEventEmitter(target) {
      return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
    }
    function isEventTarget(target) {
      return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js
var require_fromEventPattern = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.fromEventPattern = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    function fromEventPattern2(addHandler, removeHandler, resultSelector) {
      if (resultSelector) {
        return fromEventPattern2(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
      }
      return new Observable_1.Observable(function(subscriber) {
        var handler = function() {
          var e = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            e[_i] = arguments[_i];
          }
          return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue = addHandler(handler);
        return isFunction_1.isFunction(removeHandler) ? function() {
          return removeHandler(handler, retValue);
        } : void 0;
      });
    }
    exports.fromEventPattern = fromEventPattern2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/generate.js
var require_generate = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/generate.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __generator2 = exports && exports.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {
                  value: op[1],
                  done: false
                };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.generate = void 0;
    var identity_1 = require_identity();
    var isScheduler_1 = require_isScheduler();
    var defer_1 = require_defer();
    var scheduleIterable_1 = require_scheduleIterable();
    function generate2(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
      var _a, _b;
      var resultSelector;
      var initialState;
      if (arguments.length === 1) {
        _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1.identity : _b, scheduler = _a.scheduler;
      } else {
        initialState = initialStateOrOptions;
        if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
          resultSelector = identity_1.identity;
          scheduler = resultSelectorOrScheduler;
        } else {
          resultSelector = resultSelectorOrScheduler;
        }
      }
      function gen() {
        var state;
        return __generator2(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              state = initialState;
              _a2.label = 1;
            case 1:
              if (!(!condition || condition(state)))
                return [3, 4];
              return [4, resultSelector(state)];
            case 2:
              _a2.sent();
              _a2.label = 3;
            case 3:
              state = iterate(state);
              return [3, 1];
            case 4:
              return [2];
          }
        });
      }
      return defer_1.defer(scheduler ? function() {
        return scheduleIterable_1.scheduleIterable(gen(), scheduler);
      } : gen);
    }
    exports.generate = generate2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/iif.js
var require_iif = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/iif.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.iif = void 0;
    var defer_1 = require_defer();
    function iif2(condition, trueResult, falseResult) {
      return defer_1.defer(function() {
        return condition() ? trueResult : falseResult;
      });
    }
    exports.iif = iif2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/timer.js
var require_timer = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/timer.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.timer = void 0;
    var Observable_1 = require_Observable();
    var async_1 = require_async();
    var isScheduler_1 = require_isScheduler();
    var isDate_1 = require_isDate();
    function timer2(dueTime, intervalOrScheduler, scheduler) {
      if (dueTime === void 0) {
        dueTime = 0;
      }
      if (scheduler === void 0) {
        scheduler = async_1.async;
      }
      var intervalDuration = -1;
      if (intervalOrScheduler != null) {
        if (isScheduler_1.isScheduler(intervalOrScheduler)) {
          scheduler = intervalOrScheduler;
        } else {
          intervalDuration = intervalOrScheduler;
        }
      }
      return new Observable_1.Observable(function(subscriber) {
        var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
        if (due < 0) {
          due = 0;
        }
        var n = 0;
        return scheduler.schedule(function() {
          if (!subscriber.closed) {
            subscriber.next(n++);
            if (0 <= intervalDuration) {
              this.schedule(void 0, intervalDuration);
            } else {
              subscriber.complete();
            }
          }
        }, due);
      });
    }
    exports.timer = timer2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/interval.js
var require_interval = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/interval.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.interval = void 0;
    var async_1 = require_async();
    var timer_1 = require_timer();
    function interval2(period, scheduler) {
      if (period === void 0) {
        period = 0;
      }
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      if (period < 0) {
        period = 0;
      }
      return timer_1.timer(period, period, scheduler);
    }
    exports.interval = interval2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/merge.js
var require_merge = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/merge.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.merge = void 0;
    var mergeAll_1 = require_mergeAll();
    var innerFrom_1 = require_innerFrom();
    var empty_1 = require_empty();
    var args_1 = require_args();
    var from_1 = require_from();
    function merge4() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var concurrent = args_1.popNumber(args, Infinity);
      var sources = args;
      return !sources.length ? empty_1.EMPTY : sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));
    }
    exports.merge = merge4;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/never.js
var require_never = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/never.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.never = exports.NEVER = void 0;
    var Observable_1 = require_Observable();
    var noop_1 = require_noop();
    exports.NEVER = new Observable_1.Observable(noop_1.noop);
    function never2() {
      return exports.NEVER;
    }
    exports.never = never2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js
var require_argsOrArgArray = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.argsOrArgArray = void 0;
    var isArray4 = Array.isArray;
    function argsOrArgArray2(args) {
      return args.length === 1 && isArray4(args[0]) ? args[0] : args;
    }
    exports.argsOrArgArray = argsOrArgArray2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNext.js
var require_onErrorResumeNext = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNext.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.onErrorResumeNext = void 0;
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    function onErrorResumeNext3() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
      return lift_1.operate(function(source, subscriber) {
        var remaining = __spreadArray2([source], __read2(nextSources));
        var subscribeNext = function() {
          if (!subscriber.closed) {
            if (remaining.length > 0) {
              var nextSource = void 0;
              try {
                nextSource = innerFrom_1.innerFrom(remaining.shift());
              } catch (err) {
                subscribeNext();
                return;
              }
              var innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, noop_1.noop, noop_1.noop);
              nextSource.subscribe(innerSub);
              innerSub.add(subscribeNext);
            } else {
              subscriber.complete();
            }
          }
        };
        subscribeNext();
      });
    }
    exports.onErrorResumeNext = onErrorResumeNext3;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js
var require_onErrorResumeNext2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.onErrorResumeNext = void 0;
    var empty_1 = require_empty();
    var onErrorResumeNext_1 = require_onErrorResumeNext();
    var argsOrArgArray_1 = require_argsOrArgArray();
    function onErrorResumeNext3() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      return onErrorResumeNext_1.onErrorResumeNext(argsOrArgArray_1.argsOrArgArray(sources))(empty_1.EMPTY);
    }
    exports.onErrorResumeNext = onErrorResumeNext3;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/pairs.js
var require_pairs = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/pairs.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pairs = void 0;
    var from_1 = require_from();
    function pairs2(obj, scheduler) {
      return from_1.from(Object.entries(obj), scheduler);
    }
    exports.pairs = pairs2;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/not.js
var require_not = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/not.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.not = void 0;
    function not3(pred, thisArg) {
      return function(value, index) {
        return !pred.call(thisArg, value, index);
      };
    }
    exports.not = not3;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/filter.js
var require_filter = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/filter.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.filter = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function filter2(predicate, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return predicate.call(thisArg, value, index++) && subscriber.next(value);
        }));
      });
    }
    exports.filter = filter2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/partition.js
var require_partition = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/partition.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.partition = void 0;
    var not_1 = require_not();
    var filter_1 = require_filter();
    var innerFrom_1 = require_innerFrom();
    function partition3(source, predicate, thisArg) {
      return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];
    }
    exports.partition = partition3;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/race.js
var require_race = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/race.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.raceInit = exports.race = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function race3() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      sources = argsOrArgArray_1.argsOrArgArray(sources);
      return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit2(sources));
    }
    exports.race = race3;
    function raceInit2(sources) {
      return function(subscriber) {
        var subscriptions = [];
        var _loop_1 = function(i2) {
          subscriptions.push(innerFrom_1.innerFrom(sources[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (subscriptions) {
              for (var s = 0; s < subscriptions.length; s++) {
                s !== i2 && subscriptions[s].unsubscribe();
              }
              subscriptions = null;
            }
            subscriber.next(value);
          })));
        };
        for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
          _loop_1(i);
        }
      };
    }
    exports.raceInit = raceInit2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/range.js
var require_range = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/range.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.range = void 0;
    var Observable_1 = require_Observable();
    var empty_1 = require_empty();
    function range2(start, count2, scheduler) {
      if (count2 == null) {
        count2 = start;
        start = 0;
      }
      if (count2 <= 0) {
        return empty_1.EMPTY;
      }
      var end = count2 + start;
      return new Observable_1.Observable(scheduler ? function(subscriber) {
        var n = start;
        return scheduler.schedule(function() {
          if (n < end) {
            subscriber.next(n++);
            this.schedule();
          } else {
            subscriber.complete();
          }
        });
      } : function(subscriber) {
        var n = start;
        while (n < end && !subscriber.closed) {
          subscriber.next(n++);
        }
        subscriber.complete();
      });
    }
    exports.range = range2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/using.js
var require_using = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/using.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.using = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var empty_1 = require_empty();
    function using2(resourceFactory, observableFactory) {
      return new Observable_1.Observable(function(subscriber) {
        var resource = resourceFactory();
        var result = observableFactory(resource);
        var source = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
        source.subscribe(subscriber);
        return function() {
          if (resource) {
            resource.unsubscribe();
          }
        };
      });
    }
    exports.using = using2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/zip.js
var require_zip = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/zip.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.zip = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var empty_1 = require_empty();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var args_1 = require_args();
    function zip3() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      var sources = argsOrArgArray_1.argsOrArgArray(args);
      return sources.length ? new Observable_1.Observable(function(subscriber) {
        var buffers = sources.map(function() {
          return [];
        });
        var completed = sources.map(function() {
          return false;
        });
        subscriber.add(function() {
          buffers = completed = null;
        });
        var _loop_1 = function(sourceIndex2) {
          innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            buffers[sourceIndex2].push(value);
            if (buffers.every(function(buffer2) {
              return buffer2.length;
            })) {
              var result = buffers.map(function(buffer2) {
                return buffer2.shift();
              });
              subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray2([], __read2(result))) : result);
              if (buffers.some(function(buffer2, i) {
                return !buffer2.length && completed[i];
              })) {
                subscriber.complete();
              }
            }
          }, function() {
            completed[sourceIndex2] = true;
            !buffers[sourceIndex2].length && subscriber.complete();
          }));
        };
        for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
          _loop_1(sourceIndex);
        }
        return function() {
          buffers = completed = null;
        };
      }) : empty_1.EMPTY;
    }
    exports.zip = zip3;
  }
});

// node_modules/rxjs/dist/cjs/internal/types.js
var require_types = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/types.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/audit.js
var require_audit = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/audit.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.audit = void 0;
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function audit2(durationSelector) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        var durationSubscriber = null;
        var isComplete = false;
        var endDuration = function() {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          durationSubscriber = null;
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
          isComplete && subscriber.complete();
        };
        var cleanupDuration = function() {
          durationSubscriber = null;
          isComplete && subscriber.complete();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          lastValue = value;
          if (!durationSubscriber) {
            innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
          }
        }, function() {
          isComplete = true;
          (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
        }));
      });
    }
    exports.audit = audit2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/auditTime.js
var require_auditTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/auditTime.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.auditTime = void 0;
    var async_1 = require_async();
    var audit_1 = require_audit();
    var timer_1 = require_timer();
    function auditTime2(duration, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return audit_1.audit(function() {
        return timer_1.timer(duration, scheduler);
      });
    }
    exports.auditTime = auditTime2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/buffer.js
var require_buffer = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/buffer.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.buffer = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function buffer2(closingNotifier) {
      return lift_1.operate(function(source, subscriber) {
        var currentBuffer = [];
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return currentBuffer.push(value);
        }, function() {
          subscriber.next(currentBuffer);
          subscriber.complete();
        }));
        closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          var b = currentBuffer;
          currentBuffer = [];
          subscriber.next(b);
        }, noop_1.noop));
        return function() {
          currentBuffer = null;
        };
      });
    }
    exports.buffer = buffer2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js
var require_bufferCount = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __values2 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return {
              value: o && o[i++],
              done: !o
            };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bufferCount = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    function bufferCount2(bufferSize, startBufferEvery) {
      if (startBufferEvery === void 0) {
        startBufferEvery = null;
      }
      startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
      return lift_1.operate(function(source, subscriber) {
        var buffers = [];
        var count2 = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a, e_2, _b;
          var toEmit = null;
          if (count2++ % startBufferEvery === 0) {
            buffers.push([]);
          }
          try {
            for (var buffers_1 = __values2(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
              var buffer2 = buffers_1_1.value;
              buffer2.push(value);
              if (bufferSize <= buffer2.length) {
                toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
                toEmit.push(buffer2);
              }
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1
            };
          } finally {
            try {
              if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
                _a.call(buffers_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          if (toEmit) {
            try {
              for (var toEmit_1 = __values2(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
                var buffer2 = toEmit_1_1.value;
                arrRemove_1.arrRemove(buffers, buffer2);
                subscriber.next(buffer2);
              }
            } catch (e_2_1) {
              e_2 = {
                error: e_2_1
              };
            } finally {
              try {
                if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return))
                  _b.call(toEmit_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
        }, function() {
          var e_3, _a;
          try {
            for (var buffers_2 = __values2(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
              var buffer2 = buffers_2_1.value;
              subscriber.next(buffer2);
            }
          } catch (e_3_1) {
            e_3 = {
              error: e_3_1
            };
          } finally {
            try {
              if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return))
                _a.call(buffers_2);
            } finally {
              if (e_3)
                throw e_3.error;
            }
          }
          subscriber.complete();
        }, void 0, function() {
          buffers = null;
        }));
      });
    }
    exports.bufferCount = bufferCount2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js
var require_bufferTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __values2 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return {
              value: o && o[i++],
              done: !o
            };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bufferTime = void 0;
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    var async_1 = require_async();
    var args_1 = require_args();
    var executeSchedule_1 = require_executeSchedule();
    function bufferTime2(bufferTimeSpan) {
      var _a, _b;
      var otherArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        otherArgs[_i - 1] = arguments[_i];
      }
      var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
      var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
      var maxBufferSize = otherArgs[1] || Infinity;
      return lift_1.operate(function(source, subscriber) {
        var bufferRecords = [];
        var restartOnEmit = false;
        var emit = function(record) {
          var buffer2 = record.buffer, subs = record.subs;
          subs.unsubscribe();
          arrRemove_1.arrRemove(bufferRecords, record);
          subscriber.next(buffer2);
          restartOnEmit && startBuffer();
        };
        var startBuffer = function() {
          if (bufferRecords) {
            var subs = new Subscription_1.Subscription();
            subscriber.add(subs);
            var buffer2 = [];
            var record_1 = {
              buffer: buffer2,
              subs
            };
            bufferRecords.push(record_1);
            executeSchedule_1.executeSchedule(subs, scheduler, function() {
              return emit(record_1);
            }, bufferTimeSpan);
          }
        };
        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
          executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
        } else {
          restartOnEmit = true;
        }
        startBuffer();
        var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a2;
          var recordsCopy = bufferRecords.slice();
          try {
            for (var recordsCopy_1 = __values2(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
              var record = recordsCopy_1_1.value;
              var buffer2 = record.buffer;
              buffer2.push(value);
              maxBufferSize <= buffer2.length && emit(record);
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1
            };
          } finally {
            try {
              if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return))
                _a2.call(recordsCopy_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }, function() {
          while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
            subscriber.next(bufferRecords.shift().buffer);
          }
          bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
          subscriber.complete();
          subscriber.unsubscribe();
        }, void 0, function() {
          return bufferRecords = null;
        });
        source.subscribe(bufferTimeSubscriber);
      });
    }
    exports.bufferTime = bufferTime2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js
var require_bufferToggle = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __values2 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return {
              value: o && o[i++],
              done: !o
            };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bufferToggle = void 0;
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var arrRemove_1 = require_arrRemove();
    function bufferToggle2(openings, closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var buffers = [];
        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
          var buffer2 = [];
          buffers.push(buffer2);
          var closingSubscription = new Subscription_1.Subscription();
          var emitBuffer = function() {
            arrRemove_1.arrRemove(buffers, buffer2);
            subscriber.next(buffer2);
            closingSubscription.unsubscribe();
          };
          closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
        }, noop_1.noop));
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          try {
            for (var buffers_1 = __values2(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
              var buffer2 = buffers_1_1.value;
              buffer2.push(value);
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1
            };
          } finally {
            try {
              if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
                _a.call(buffers_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }, function() {
          while (buffers.length > 0) {
            subscriber.next(buffers.shift());
          }
          subscriber.complete();
        }));
      });
    }
    exports.bufferToggle = bufferToggle2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js
var require_bufferWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bufferWhen = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function bufferWhen2(closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var buffer2 = null;
        var closingSubscriber = null;
        var openBuffer = function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          var b = buffer2;
          buffer2 = [];
          b && subscriber.next(b);
          innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
        };
        openBuffer();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.push(value);
        }, function() {
          buffer2 && subscriber.next(buffer2);
          subscriber.complete();
        }, void 0, function() {
          return buffer2 = closingSubscriber = null;
        }));
      });
    }
    exports.bufferWhen = bufferWhen2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/catchError.js
var require_catchError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/catchError.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.catchError = void 0;
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var lift_1 = require_lift();
    function catchError2(selector) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub = null;
        var syncUnsub = false;
        var handledResult;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
          handledResult = innerFrom_1.innerFrom(selector(err, catchError2(selector)(source)));
          if (innerSub) {
            innerSub.unsubscribe();
            innerSub = null;
            handledResult.subscribe(subscriber);
          } else {
            syncUnsub = true;
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        }
      });
    }
    exports.catchError = catchError2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js
var require_scanInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.scanInternals = void 0;
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function scanInternals2(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
      return function(source, subscriber) {
        var hasState = hasSeed;
        var state = seed;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var i = index++;
          state = hasState ? accumulator(state, value, i) : (hasState = true, value);
          emitOnNext && subscriber.next(state);
        }, emitBeforeComplete && function() {
          hasState && subscriber.next(state);
          subscriber.complete();
        }));
      };
    }
    exports.scanInternals = scanInternals2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/reduce.js
var require_reduce = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/reduce.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.reduce = void 0;
    var scanInternals_1 = require_scanInternals();
    var lift_1 = require_lift();
    function reduce2(accumulator, seed) {
      return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
    }
    exports.reduce = reduce2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/toArray.js
var require_toArray = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/toArray.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.toArray = void 0;
    var reduce_1 = require_reduce();
    var lift_1 = require_lift();
    var arrReducer2 = function(arr, value) {
      return arr.push(value), arr;
    };
    function toArray2() {
      return lift_1.operate(function(source, subscriber) {
        reduce_1.reduce(arrReducer2, [])(source).subscribe(subscriber);
      });
    }
    exports.toArray = toArray2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js
var require_joinAllInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.joinAllInternals = void 0;
    var identity_1 = require_identity();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var pipe_1 = require_pipe();
    var mergeMap_1 = require_mergeMap();
    var toArray_1 = require_toArray();
    function joinAllInternals2(joinFn, project) {
      return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources) {
        return joinFn(sources);
      }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
    }
    exports.joinAllInternals = joinAllInternals2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js
var require_combineLatestAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.combineLatestAll = void 0;
    var combineLatest_1 = require_combineLatest();
    var joinAllInternals_1 = require_joinAllInternals();
    function combineLatestAll2(project) {
      return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
    }
    exports.combineLatestAll = combineLatestAll2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineAll.js
var require_combineAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineAll.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.combineAll = void 0;
    var combineLatestAll_1 = require_combineLatestAll();
    exports.combineAll = combineLatestAll_1.combineLatestAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js
var require_combineLatest2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.combineLatest = void 0;
    var combineLatest_1 = require_combineLatest();
    var lift_1 = require_lift();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var pipe_1 = require_pipe();
    var args_1 = require_args();
    function combineLatest3() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      return resultSelector ? pipe_1.pipe(combineLatest3.apply(void 0, __spreadArray2([], __read2(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source, subscriber) {
        combineLatest_1.combineLatestInit(__spreadArray2([source], __read2(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
      });
    }
    exports.combineLatest = combineLatest3;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js
var require_combineLatestWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.combineLatestWith = void 0;
    var combineLatest_1 = require_combineLatest2();
    function combineLatestWith2() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return combineLatest_1.combineLatest.apply(void 0, __spreadArray2([], __read2(otherSources)));
    }
    exports.combineLatestWith = combineLatestWith2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMap.js
var require_concatMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatMap.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.concatMap = void 0;
    var mergeMap_1 = require_mergeMap();
    var isFunction_1 = require_isFunction();
    function concatMap2(project, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
    }
    exports.concatMap = concatMap2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js
var require_concatMapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.concatMapTo = void 0;
    var concatMap_1 = require_concatMap();
    var isFunction_1 = require_isFunction();
    function concatMapTo2(innerObservable, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
        return innerObservable;
      }, resultSelector) : concatMap_1.concatMap(function() {
        return innerObservable;
      });
    }
    exports.concatMapTo = concatMapTo2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concat.js
var require_concat2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concat.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.concat = void 0;
    var lift_1 = require_lift();
    var concatAll_1 = require_concatAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function concat3() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      return lift_1.operate(function(source, subscriber) {
        concatAll_1.concatAll()(from_1.from(__spreadArray2([source], __read2(args)), scheduler)).subscribe(subscriber);
      });
    }
    exports.concat = concat3;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatWith.js
var require_concatWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatWith.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.concatWith = void 0;
    var concat_1 = require_concat2();
    function concatWith2() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return concat_1.concat.apply(void 0, __spreadArray2([], __read2(otherSources)));
    }
    exports.concatWith = concatWith2;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js
var require_fromSubscribable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.fromSubscribable = void 0;
    var Observable_1 = require_Observable();
    function fromSubscribable2(subscribable) {
      return new Observable_1.Observable(function(subscriber) {
        return subscribable.subscribe(subscriber);
      });
    }
    exports.fromSubscribable = fromSubscribable2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/connect.js
var require_connect = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/connect.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.connect = void 0;
    var Subject_1 = require_Subject();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var fromSubscribable_1 = require_fromSubscribable();
    var DEFAULT_CONFIG2 = {
      connector: function() {
        return new Subject_1.Subject();
      }
    };
    function connect2(selector, config2) {
      if (config2 === void 0) {
        config2 = DEFAULT_CONFIG2;
      }
      var connector = config2.connector;
      return lift_1.operate(function(source, subscriber) {
        var subject = connector();
        innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
        subscriber.add(source.subscribe(subject));
      });
    }
    exports.connect = connect2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/count.js
var require_count = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/count.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.count = void 0;
    var reduce_1 = require_reduce();
    function count2(predicate) {
      return reduce_1.reduce(function(total, value, i) {
        return !predicate || predicate(value, i) ? total + 1 : total;
      }, 0);
    }
    exports.count = count2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/debounce.js
var require_debounce = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/debounce.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.debounce = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function debounce2(durationSelector) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        var durationSubscriber = null;
        var emit = function() {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          durationSubscriber = null;
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          hasValue = true;
          lastValue = value;
          durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
          innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
        }, function() {
          emit();
          subscriber.complete();
        }, void 0, function() {
          lastValue = durationSubscriber = null;
        }));
      });
    }
    exports.debounce = debounce2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js
var require_debounceTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.debounceTime = void 0;
    var async_1 = require_async();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function debounceTime2(dueTime, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return lift_1.operate(function(source, subscriber) {
        var activeTask = null;
        var lastValue = null;
        var lastTime = null;
        var emit = function() {
          if (activeTask) {
            activeTask.unsubscribe();
            activeTask = null;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        };
        function emitWhenIdle() {
          var targetTime = lastTime + dueTime;
          var now = scheduler.now();
          if (now < targetTime) {
            activeTask = this.schedule(void 0, targetTime - now);
            subscriber.add(activeTask);
            return;
          }
          emit();
        }
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          lastValue = value;
          lastTime = scheduler.now();
          if (!activeTask) {
            activeTask = scheduler.schedule(emitWhenIdle, dueTime);
            subscriber.add(activeTask);
          }
        }, function() {
          emit();
          subscriber.complete();
        }, void 0, function() {
          lastValue = activeTask = null;
        }));
      });
    }
    exports.debounceTime = debounceTime2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js
var require_defaultIfEmpty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.defaultIfEmpty = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function defaultIfEmpty2(defaultValue) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          subscriber.next(value);
        }, function() {
          if (!hasValue) {
            subscriber.next(defaultValue);
          }
          subscriber.complete();
        }));
      });
    }
    exports.defaultIfEmpty = defaultIfEmpty2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/take.js
var require_take = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/take.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.take = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function take2(count2) {
      return count2 <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var seen = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (++seen <= count2) {
            subscriber.next(value);
            if (count2 <= seen) {
              subscriber.complete();
            }
          }
        }));
      });
    }
    exports.take = take2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js
var require_ignoreElements = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ignoreElements = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    function ignoreElements2() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
      });
    }
    exports.ignoreElements = ignoreElements2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mapTo.js
var require_mapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mapTo.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.mapTo = void 0;
    var map_1 = require_map();
    function mapTo2(value) {
      return map_1.map(function() {
        return value;
      });
    }
    exports.mapTo = mapTo2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js
var require_delayWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.delayWhen = void 0;
    var concat_1 = require_concat();
    var take_1 = require_take();
    var ignoreElements_1 = require_ignoreElements();
    var mapTo_1 = require_mapTo();
    var mergeMap_1 = require_mergeMap();
    function delayWhen2(delayDurationSelector, subscriptionDelay) {
      if (subscriptionDelay) {
        return function(source) {
          return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen2(delayDurationSelector)));
        };
      }
      return mergeMap_1.mergeMap(function(value, index) {
        return delayDurationSelector(value, index).pipe(take_1.take(1), mapTo_1.mapTo(value));
      });
    }
    exports.delayWhen = delayWhen2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/delay.js
var require_delay = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/delay.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.delay = void 0;
    var async_1 = require_async();
    var delayWhen_1 = require_delayWhen();
    var timer_1 = require_timer();
    function delay2(due, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      var duration = timer_1.timer(due, scheduler);
      return delayWhen_1.delayWhen(function() {
        return duration;
      });
    }
    exports.delay = delay2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js
var require_dematerialize = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.dematerialize = void 0;
    var Notification_1 = require_Notification();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function dematerialize2() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
          return Notification_1.observeNotification(notification, subscriber);
        }));
      });
    }
    exports.dematerialize = dematerialize2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinct.js
var require_distinct = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/distinct.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.distinct = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    function distinct2(keySelector, flushes) {
      return lift_1.operate(function(source, subscriber) {
        var distinctKeys = /* @__PURE__ */ new Set();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var key = keySelector ? keySelector(value) : value;
          if (!distinctKeys.has(key)) {
            distinctKeys.add(key);
            subscriber.next(value);
          }
        }));
        flushes === null || flushes === void 0 ? void 0 : flushes.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          return distinctKeys.clear();
        }, noop_1.noop));
      });
    }
    exports.distinct = distinct2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js
var require_distinctUntilChanged = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.distinctUntilChanged = void 0;
    var identity_1 = require_identity();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function distinctUntilChanged2(comparator, keySelector) {
      if (keySelector === void 0) {
        keySelector = identity_1.identity;
      }
      comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare2;
      return lift_1.operate(function(source, subscriber) {
        var previousKey;
        var first2 = true;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var currentKey = keySelector(value);
          if (first2 || !comparator(previousKey, currentKey)) {
            first2 = false;
            previousKey = currentKey;
            subscriber.next(value);
          }
        }));
      });
    }
    exports.distinctUntilChanged = distinctUntilChanged2;
    function defaultCompare2(a, b) {
      return a === b;
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js
var require_distinctUntilKeyChanged = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.distinctUntilKeyChanged = void 0;
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    function distinctUntilKeyChanged2(key, compare) {
      return distinctUntilChanged_1.distinctUntilChanged(function(x, y) {
        return compare ? compare(x[key], y[key]) : x[key] === y[key];
      });
    }
    exports.distinctUntilKeyChanged = distinctUntilKeyChanged2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js
var require_throwIfEmpty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.throwIfEmpty = void 0;
    var EmptyError_1 = require_EmptyError();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function throwIfEmpty2(errorFactory) {
      if (errorFactory === void 0) {
        errorFactory = defaultErrorFactory2;
      }
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          subscriber.next(value);
        }, function() {
          return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
        }));
      });
    }
    exports.throwIfEmpty = throwIfEmpty2;
    function defaultErrorFactory2() {
      return new EmptyError_1.EmptyError();
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/elementAt.js
var require_elementAt = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/elementAt.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.elementAt = void 0;
    var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
    var filter_1 = require_filter();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var take_1 = require_take();
    function elementAt2(index, defaultValue) {
      if (index < 0) {
        throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
      }
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(filter_1.filter(function(v, i) {
          return i === index;
        }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
        }));
      };
    }
    exports.elementAt = elementAt2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/endWith.js
var require_endWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/endWith.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.endWith = void 0;
    var concat_1 = require_concat();
    var of_1 = require_of();
    function endWith2() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      return function(source) {
        return concat_1.concat(source, of_1.of.apply(void 0, __spreadArray2([], __read2(values))));
      };
    }
    exports.endWith = endWith2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/every.js
var require_every = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/every.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.every = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function every2(predicate, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (!predicate.call(thisArg, value, index++, source)) {
            subscriber.next(false);
            subscriber.complete();
          }
        }, function() {
          subscriber.next(true);
          subscriber.complete();
        }));
      });
    }
    exports.every = every2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js
var require_exhaustMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.exhaustMap = void 0;
    var map_1 = require_map();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function exhaustMap2(project, resultSelector) {
      if (resultSelector) {
        return function(source) {
          return source.pipe(exhaustMap2(function(a, i) {
            return innerFrom_1.innerFrom(project(a, i)).pipe(map_1.map(function(b, ii) {
              return resultSelector(a, b, i, ii);
            }));
          }));
        };
      }
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        var innerSub = null;
        var isComplete = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
          if (!innerSub) {
            innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
              innerSub = null;
              isComplete && subscriber.complete();
            });
            innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
          }
        }, function() {
          isComplete = true;
          !innerSub && subscriber.complete();
        }));
      });
    }
    exports.exhaustMap = exhaustMap2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js
var require_exhaustAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.exhaustAll = void 0;
    var exhaustMap_1 = require_exhaustMap();
    var identity_1 = require_identity();
    function exhaustAll2() {
      return exhaustMap_1.exhaustMap(identity_1.identity);
    }
    exports.exhaustAll = exhaustAll2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaust.js
var require_exhaust = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/exhaust.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.exhaust = void 0;
    var exhaustAll_1 = require_exhaustAll();
    exports.exhaust = exhaustAll_1.exhaustAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/expand.js
var require_expand = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/expand.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.expand = void 0;
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    function expand2(project, concurrent, scheduler) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
      return lift_1.operate(function(source, subscriber) {
        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, void 0, true, scheduler);
      });
    }
    exports.expand = expand2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/finalize.js
var require_finalize = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/finalize.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.finalize = void 0;
    var lift_1 = require_lift();
    function finalize2(callback) {
      return lift_1.operate(function(source, subscriber) {
        try {
          source.subscribe(subscriber);
        } finally {
          subscriber.add(callback);
        }
      });
    }
    exports.finalize = finalize2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/find.js
var require_find = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/find.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createFind = exports.find = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function find2(predicate, thisArg) {
      return lift_1.operate(createFind2(predicate, thisArg, "value"));
    }
    exports.find = find2;
    function createFind2(predicate, thisArg, emit) {
      var findIndex2 = emit === "index";
      return function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var i = index++;
          if (predicate.call(thisArg, value, i, source)) {
            subscriber.next(findIndex2 ? i : value);
            subscriber.complete();
          }
        }, function() {
          subscriber.next(findIndex2 ? -1 : void 0);
          subscriber.complete();
        }));
      };
    }
    exports.createFind = createFind2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/findIndex.js
var require_findIndex = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/findIndex.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.findIndex = void 0;
    var lift_1 = require_lift();
    var find_1 = require_find();
    function findIndex2(predicate, thisArg) {
      return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
    }
    exports.findIndex = findIndex2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/first.js
var require_first = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/first.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.first = void 0;
    var EmptyError_1 = require_EmptyError();
    var filter_1 = require_filter();
    var take_1 = require_take();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var identity_1 = require_identity();
    function first2(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(predicate ? filter_1.filter(function(v, i) {
          return predicate(v, i, source);
        }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new EmptyError_1.EmptyError();
        }));
      };
    }
    exports.first = first2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/groupBy.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.groupBy = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function groupBy2(keySelector, elementOrOptions, duration, connector) {
      return lift_1.operate(function(source, subscriber) {
        var element;
        if (!elementOrOptions || typeof elementOrOptions === "function") {
          element = elementOrOptions;
        } else {
          duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
        }
        var groups = /* @__PURE__ */ new Map();
        var notify = function(cb) {
          groups.forEach(cb);
          cb(subscriber);
        };
        var handleError2 = function(err) {
          return notify(function(consumer) {
            return consumer.error(err);
          });
        };
        var activeGroups = 0;
        var teardownAttempted = false;
        var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value) {
          try {
            var key_1 = keySelector(value);
            var group_1 = groups.get(key_1);
            if (!group_1) {
              groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject());
              var grouped = createGroupedObservable(key_1, group_1);
              subscriber.next(grouped);
              if (duration) {
                var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                  group_1.complete();
                  durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
                }, void 0, void 0, function() {
                  return groups.delete(key_1);
                });
                groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
              }
            }
            group_1.next(element ? element(value) : value);
          } catch (err) {
            handleError2(err);
          }
        }, function() {
          return notify(function(consumer) {
            return consumer.complete();
          });
        }, handleError2, function() {
          return groups.clear();
        }, function() {
          teardownAttempted = true;
          return activeGroups === 0;
        });
        source.subscribe(groupBySourceSubscriber);
        function createGroupedObservable(key, groupSubject) {
          var result = new Observable_1.Observable(function(groupSubscriber) {
            activeGroups++;
            var innerSub = groupSubject.subscribe(groupSubscriber);
            return function() {
              innerSub.unsubscribe();
              --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
            };
          });
          result.key = key;
          return result;
        }
      });
    }
    exports.groupBy = groupBy2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isEmpty = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function isEmpty2() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          subscriber.next(false);
          subscriber.complete();
        }, function() {
          subscriber.next(true);
          subscriber.complete();
        }));
      });
    }
    exports.isEmpty = isEmpty2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/takeLast.js
var require_takeLast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/takeLast.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __values2 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return {
              value: o && o[i++],
              done: !o
            };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.takeLast = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function takeLast2(count2) {
      return count2 <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var buffer2 = [];
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          buffer2.push(value);
          count2 < buffer2.length && buffer2.shift();
        }, function() {
          var e_1, _a;
          try {
            for (var buffer_1 = __values2(buffer2), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
              var value = buffer_1_1.value;
              subscriber.next(value);
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1
            };
          } finally {
            try {
              if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
                _a.call(buffer_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          subscriber.complete();
        }, void 0, function() {
          buffer2 = null;
        }));
      });
    }
    exports.takeLast = takeLast2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/last.js
var require_last = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/last.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.last = void 0;
    var EmptyError_1 = require_EmptyError();
    var filter_1 = require_filter();
    var takeLast_1 = require_takeLast();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var identity_1 = require_identity();
    function last3(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(predicate ? filter_1.filter(function(v, i) {
          return predicate(v, i, source);
        }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new EmptyError_1.EmptyError();
        }));
      };
    }
    exports.last = last3;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/materialize.js
var require_materialize = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/materialize.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.materialize = void 0;
    var Notification_1 = require_Notification();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function materialize2() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          subscriber.next(Notification_1.Notification.createNext(value));
        }, function() {
          subscriber.next(Notification_1.Notification.createComplete());
          subscriber.complete();
        }, function(err) {
          subscriber.next(Notification_1.Notification.createError(err));
          subscriber.complete();
        }));
      });
    }
    exports.materialize = materialize2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/max.js
var require_max = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/max.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.max = void 0;
    var reduce_1 = require_reduce();
    var isFunction_1 = require_isFunction();
    function max2(comparer) {
      return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
        return comparer(x, y) > 0 ? x : y;
      } : function(x, y) {
        return x > y ? x : y;
      });
    }
    exports.max = max2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/flatMap.js
var require_flatMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/flatMap.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.flatMap = void 0;
    var mergeMap_1 = require_mergeMap();
    exports.flatMap = mergeMap_1.mergeMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js
var require_mergeMapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.mergeMapTo = void 0;
    var mergeMap_1 = require_mergeMap();
    var isFunction_1 = require_isFunction();
    function mergeMapTo2(innerObservable, resultSelector, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      if (isFunction_1.isFunction(resultSelector)) {
        return mergeMap_1.mergeMap(function() {
          return innerObservable;
        }, resultSelector, concurrent);
      }
      if (typeof resultSelector === "number") {
        concurrent = resultSelector;
      }
      return mergeMap_1.mergeMap(function() {
        return innerObservable;
      }, concurrent);
    }
    exports.mergeMapTo = mergeMapTo2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js
var require_mergeScan = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.mergeScan = void 0;
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    function mergeScan2(accumulator, seed, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      return lift_1.operate(function(source, subscriber) {
        var state = seed;
        return mergeInternals_1.mergeInternals(source, subscriber, function(value, index) {
          return accumulator(state, value, index);
        }, concurrent, function(value) {
          state = value;
        }, false, void 0, function() {
          return state = null;
        });
      });
    }
    exports.mergeScan = mergeScan2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/merge.js
var require_merge2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/merge.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.merge = void 0;
    var lift_1 = require_lift();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var mergeAll_1 = require_mergeAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function merge4() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var concurrent = args_1.popNumber(args, Infinity);
      args = argsOrArgArray_1.argsOrArgArray(args);
      return lift_1.operate(function(source, subscriber) {
        mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray2([source], __read2(args)), scheduler)).subscribe(subscriber);
      });
    }
    exports.merge = merge4;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js
var require_mergeWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.mergeWith = void 0;
    var merge_1 = require_merge2();
    function mergeWith2() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return merge_1.merge.apply(void 0, __spreadArray2([], __read2(otherSources)));
    }
    exports.mergeWith = mergeWith2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/min.js
var require_min = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/min.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.min = void 0;
    var reduce_1 = require_reduce();
    var isFunction_1 = require_isFunction();
    function min2(comparer) {
      return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
        return comparer(x, y) < 0 ? x : y;
      } : function(x, y) {
        return x < y ? x : y;
      });
    }
    exports.min = min2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/multicast.js
var require_multicast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/multicast.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.multicast = void 0;
    var ConnectableObservable_1 = require_ConnectableObservable();
    var isFunction_1 = require_isFunction();
    var connect_1 = require_connect();
    function multicast2(subjectOrSubjectFactory, selector) {
      var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
        return subjectOrSubjectFactory;
      };
      if (isFunction_1.isFunction(selector)) {
        return connect_1.connect(selector, {
          connector: subjectFactory
        });
      }
      return function(source) {
        return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory);
      };
    }
    exports.multicast = multicast2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/pairwise.js
var require_pairwise = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/pairwise.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pairwise = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function pairwise2() {
      return lift_1.operate(function(source, subscriber) {
        var prev;
        var hasPrev = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var p = prev;
          prev = value;
          hasPrev && subscriber.next([p, value]);
          hasPrev = true;
        }));
      });
    }
    exports.pairwise = pairwise2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/pluck.js
var require_pluck = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/pluck.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pluck = void 0;
    var map_1 = require_map();
    function pluck2() {
      var properties = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i] = arguments[_i];
      }
      var length = properties.length;
      if (length === 0) {
        throw new Error("list of properties cannot be empty.");
      }
      return map_1.map(function(x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
          var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
          if (typeof p !== "undefined") {
            currentProp = p;
          } else {
            return void 0;
          }
        }
        return currentProp;
      });
    }
    exports.pluck = pluck2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publish.js
var require_publish = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publish.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.publish = void 0;
    var Subject_1 = require_Subject();
    var multicast_1 = require_multicast();
    var connect_1 = require_connect();
    function publish2(selector) {
      return selector ? function(source) {
        return connect_1.connect(selector)(source);
      } : function(source) {
        return multicast_1.multicast(new Subject_1.Subject())(source);
      };
    }
    exports.publish = publish2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js
var require_publishBehavior = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.publishBehavior = void 0;
    var BehaviorSubject_1 = require_BehaviorSubject();
    var ConnectableObservable_1 = require_ConnectableObservable();
    function publishBehavior2(initialValue) {
      return function(source) {
        var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
        return new ConnectableObservable_1.ConnectableObservable(source, function() {
          return subject;
        });
      };
    }
    exports.publishBehavior = publishBehavior2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publishLast.js
var require_publishLast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publishLast.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.publishLast = void 0;
    var AsyncSubject_1 = require_AsyncSubject();
    var ConnectableObservable_1 = require_ConnectableObservable();
    function publishLast2() {
      return function(source) {
        var subject = new AsyncSubject_1.AsyncSubject();
        return new ConnectableObservable_1.ConnectableObservable(source, function() {
          return subject;
        });
      };
    }
    exports.publishLast = publishLast2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js
var require_publishReplay = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.publishReplay = void 0;
    var ReplaySubject_1 = require_ReplaySubject();
    var multicast_1 = require_multicast();
    var isFunction_1 = require_isFunction();
    function publishReplay2(bufferSize, windowTime2, selectorOrScheduler, timestampProvider) {
      if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
        timestampProvider = selectorOrScheduler;
      }
      var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
      return function(source) {
        return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime2, timestampProvider), selector)(source);
      };
    }
    exports.publishReplay = publishReplay2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/raceWith.js
var require_raceWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/raceWith.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.raceWith = void 0;
    var race_1 = require_race();
    var lift_1 = require_lift();
    var identity_1 = require_identity();
    function raceWith2() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return !otherSources.length ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        race_1.raceInit(__spreadArray2([source], __read2(otherSources)))(subscriber);
      });
    }
    exports.raceWith = raceWith2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/repeat.js
var require_repeat = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/repeat.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.repeat = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var timer_1 = require_timer();
    function repeat2(countOrConfig) {
      var _a;
      var count2 = Infinity;
      var delay2;
      if (countOrConfig != null) {
        if (typeof countOrConfig === "object") {
          _a = countOrConfig.count, count2 = _a === void 0 ? Infinity : _a, delay2 = countOrConfig.delay;
        } else {
          count2 = countOrConfig;
        }
      }
      return count2 <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var soFar = 0;
        var sourceSub;
        var resubscribe = function() {
          sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
          sourceSub = null;
          if (delay2 != null) {
            var notifier = typeof delay2 === "number" ? timer_1.timer(delay2) : innerFrom_1.innerFrom(delay2(soFar));
            var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              subscribeToSource();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            subscribeToSource();
          }
        };
        var subscribeToSource = function() {
          var syncUnsub = false;
          sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
            if (++soFar < count2) {
              if (sourceSub) {
                resubscribe();
              } else {
                syncUnsub = true;
              }
            } else {
              subscriber.complete();
            }
          }));
          if (syncUnsub) {
            resubscribe();
          }
        };
        subscribeToSource();
      });
    }
    exports.repeat = repeat2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js
var require_repeatWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.repeatWhen = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function repeatWhen2(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub;
        var syncResub = false;
        var completions$;
        var isNotifierComplete = false;
        var isMainComplete = false;
        var checkComplete = function() {
          return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
        };
        var getCompletionSubject = function() {
          if (!completions$) {
            completions$ = new Subject_1.Subject();
            notifier(completions$).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              if (innerSub) {
                subscribeForRepeatWhen();
              } else {
                syncResub = true;
              }
            }, function() {
              isNotifierComplete = true;
              checkComplete();
            }));
          }
          return completions$;
        };
        var subscribeForRepeatWhen = function() {
          isMainComplete = false;
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
            isMainComplete = true;
            !checkComplete() && getCompletionSubject().next();
          }));
          if (syncResub) {
            innerSub.unsubscribe();
            innerSub = null;
            syncResub = false;
            subscribeForRepeatWhen();
          }
        };
        subscribeForRepeatWhen();
      });
    }
    exports.repeatWhen = repeatWhen2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/retry.js
var require_retry = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/retry.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.retry = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var identity_1 = require_identity();
    var timer_1 = require_timer();
    var innerFrom_1 = require_innerFrom();
    function retry2(configOrCount) {
      if (configOrCount === void 0) {
        configOrCount = Infinity;
      }
      var config2;
      if (configOrCount && typeof configOrCount === "object") {
        config2 = configOrCount;
      } else {
        config2 = {
          count: configOrCount
        };
      }
      var _a = config2.count, count2 = _a === void 0 ? Infinity : _a, delay2 = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
      return count2 <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        var soFar = 0;
        var innerSub;
        var subscribeForRetry = function() {
          var syncUnsub = false;
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (resetOnSuccess) {
              soFar = 0;
            }
            subscriber.next(value);
          }, void 0, function(err) {
            if (soFar++ < count2) {
              var resub_1 = function() {
                if (innerSub) {
                  innerSub.unsubscribe();
                  innerSub = null;
                  subscribeForRetry();
                } else {
                  syncUnsub = true;
                }
              };
              if (delay2 != null) {
                var notifier = typeof delay2 === "number" ? timer_1.timer(delay2) : innerFrom_1.innerFrom(delay2(err, soFar));
                var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                  notifierSubscriber_1.unsubscribe();
                  resub_1();
                }, function() {
                  subscriber.complete();
                });
                notifier.subscribe(notifierSubscriber_1);
              } else {
                resub_1();
              }
            } else {
              subscriber.error(err);
            }
          }));
          if (syncUnsub) {
            innerSub.unsubscribe();
            innerSub = null;
            subscribeForRetry();
          }
        };
        subscribeForRetry();
      });
    }
    exports.retry = retry2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js
var require_retryWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.retryWhen = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function retryWhen2(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub;
        var syncResub = false;
        var errors$;
        var subscribeForRetryWhen = function() {
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
            if (!errors$) {
              errors$ = new Subject_1.Subject();
              notifier(errors$).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                return innerSub ? subscribeForRetryWhen() : syncResub = true;
              }));
            }
            if (errors$) {
              errors$.next(err);
            }
          }));
          if (syncResub) {
            innerSub.unsubscribe();
            innerSub = null;
            syncResub = false;
            subscribeForRetryWhen();
          }
        };
        subscribeForRetryWhen();
      });
    }
    exports.retryWhen = retryWhen2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/sample.js
var require_sample = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/sample.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.sample = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function sample2(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          lastValue = value;
        }));
        notifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        }, noop_1.noop));
      });
    }
    exports.sample = sample2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js
var require_sampleTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.sampleTime = void 0;
    var async_1 = require_async();
    var sample_1 = require_sample();
    var interval_1 = require_interval();
    function sampleTime2(period, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return sample_1.sample(interval_1.interval(period, scheduler));
    }
    exports.sampleTime = sampleTime2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/scan.js
var require_scan = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/scan.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.scan = void 0;
    var lift_1 = require_lift();
    var scanInternals_1 = require_scanInternals();
    function scan2(accumulator, seed) {
      return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
    }
    exports.scan = scan2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js
var require_sequenceEqual = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.sequenceEqual = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function sequenceEqual2(compareTo, comparator) {
      if (comparator === void 0) {
        comparator = function(a, b) {
          return a === b;
        };
      }
      return lift_1.operate(function(source, subscriber) {
        var aState = createState2();
        var bState = createState2();
        var emit = function(isEqual) {
          subscriber.next(isEqual);
          subscriber.complete();
        };
        var createSubscriber = function(selfState, otherState) {
          var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a) {
            var buffer2 = otherState.buffer, complete = otherState.complete;
            if (buffer2.length === 0) {
              complete ? emit(false) : selfState.buffer.push(a);
            } else {
              !comparator(a, buffer2.shift()) && emit(false);
            }
          }, function() {
            selfState.complete = true;
            var complete = otherState.complete, buffer2 = otherState.buffer;
            complete && emit(buffer2.length === 0);
            sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
          });
          return sequenceEqualSubscriber;
        };
        source.subscribe(createSubscriber(aState, bState));
        compareTo.subscribe(createSubscriber(bState, aState));
      });
    }
    exports.sequenceEqual = sequenceEqual2;
    function createState2() {
      return {
        buffer: [],
        complete: false
      };
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/share.js
var require_share = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/share.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.share = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var Subscriber_1 = require_Subscriber();
    var lift_1 = require_lift();
    function share2(options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.connector, connector = _a === void 0 ? function() {
        return new Subject_1.Subject();
      } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
      return function(wrapperSource) {
        var connection;
        var resetConnection;
        var subject;
        var refCount2 = 0;
        var hasCompleted = false;
        var hasErrored = false;
        var cancelReset = function() {
          resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
          resetConnection = void 0;
        };
        var reset = function() {
          cancelReset();
          connection = subject = void 0;
          hasCompleted = hasErrored = false;
        };
        var resetAndUnsubscribe = function() {
          var conn = connection;
          reset();
          conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
        };
        return lift_1.operate(function(source, subscriber) {
          refCount2++;
          if (!hasErrored && !hasCompleted) {
            cancelReset();
          }
          var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
          subscriber.add(function() {
            refCount2--;
            if (refCount2 === 0 && !hasErrored && !hasCompleted) {
              resetConnection = handleReset2(resetAndUnsubscribe, resetOnRefCountZero);
            }
          });
          dest.subscribe(subscriber);
          if (!connection && refCount2 > 0) {
            connection = new Subscriber_1.SafeSubscriber({
              next: function(value) {
                return dest.next(value);
              },
              error: function(err) {
                hasErrored = true;
                cancelReset();
                resetConnection = handleReset2(reset, resetOnError, err);
                dest.error(err);
              },
              complete: function() {
                hasCompleted = true;
                cancelReset();
                resetConnection = handleReset2(reset, resetOnComplete);
                dest.complete();
              }
            });
            innerFrom_1.innerFrom(source).subscribe(connection);
          }
        })(wrapperSource);
      };
    }
    exports.share = share2;
    function handleReset2(reset, on) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (on === true) {
        reset();
        return;
      }
      if (on === false) {
        return;
      }
      var onSubscriber = new Subscriber_1.SafeSubscriber({
        next: function() {
          onSubscriber.unsubscribe();
          reset();
        }
      });
      return on.apply(void 0, __spreadArray2([], __read2(args))).subscribe(onSubscriber);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js
var require_shareReplay = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.shareReplay = void 0;
    var ReplaySubject_1 = require_ReplaySubject();
    var share_1 = require_share();
    function shareReplay2(configOrBufferSize, windowTime2, scheduler) {
      var _a, _b, _c;
      var bufferSize;
      var refCount2 = false;
      if (configOrBufferSize && typeof configOrBufferSize === "object") {
        _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount2 = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
      } else {
        bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
      }
      return share_1.share({
        connector: function() {
          return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime2, scheduler);
        },
        resetOnError: true,
        resetOnComplete: false,
        resetOnRefCountZero: refCount2
      });
    }
    exports.shareReplay = shareReplay2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/single.js
var require_single = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/single.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.single = void 0;
    var EmptyError_1 = require_EmptyError();
    var SequenceError_1 = require_SequenceError();
    var NotFoundError_1 = require_NotFoundError();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function single2(predicate) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var singleValue;
        var seenValue = false;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          seenValue = true;
          if (!predicate || predicate(value, index++, source)) {
            hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
            hasValue = true;
            singleValue = value;
          }
        }, function() {
          if (hasValue) {
            subscriber.next(singleValue);
            subscriber.complete();
          } else {
            subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError());
          }
        }));
      });
    }
    exports.single = single2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skip.js
var require_skip = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skip.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.skip = void 0;
    var filter_1 = require_filter();
    function skip2(count2) {
      return filter_1.filter(function(_, index) {
        return count2 <= index;
      });
    }
    exports.skip = skip2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skipLast.js
var require_skipLast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skipLast.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.skipLast = void 0;
    var identity_1 = require_identity();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function skipLast2(skipCount) {
      return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        var ring = new Array(skipCount);
        var seen = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var valueIndex = seen++;
          if (valueIndex < skipCount) {
            ring[valueIndex] = value;
          } else {
            var index = valueIndex % skipCount;
            var oldValue = ring[index];
            ring[index] = value;
            subscriber.next(oldValue);
          }
        }));
        return function() {
          ring = null;
        };
      });
    }
    exports.skipLast = skipLast2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js
var require_skipUntil = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.skipUntil = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var noop_1 = require_noop();
    function skipUntil2(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var taking = false;
        var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
          taking = true;
        }, noop_1.noop);
        innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return taking && subscriber.next(value);
        }));
      });
    }
    exports.skipUntil = skipUntil2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js
var require_skipWhile = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.skipWhile = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function skipWhile2(predicate) {
      return lift_1.operate(function(source, subscriber) {
        var taking = false;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
        }));
      });
    }
    exports.skipWhile = skipWhile2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/startWith.js
var require_startWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/startWith.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.startWith = void 0;
    var concat_1 = require_concat();
    var args_1 = require_args();
    var lift_1 = require_lift();
    function startWith2() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(values);
      return lift_1.operate(function(source, subscriber) {
        (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
      });
    }
    exports.startWith = startWith2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMap.js
var require_switchMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchMap.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.switchMap = void 0;
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function switchMap2(project, resultSelector) {
      return lift_1.operate(function(source, subscriber) {
        var innerSubscriber = null;
        var index = 0;
        var isComplete = false;
        var checkComplete = function() {
          return isComplete && !innerSubscriber && subscriber.complete();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
          var innerIndex = 0;
          var outerIndex = index++;
          innerFrom_1.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
            return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
          }, function() {
            innerSubscriber = null;
            checkComplete();
          }));
        }, function() {
          isComplete = true;
          checkComplete();
        }));
      });
    }
    exports.switchMap = switchMap2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchAll.js
var require_switchAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchAll.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.switchAll = void 0;
    var switchMap_1 = require_switchMap();
    var identity_1 = require_identity();
    function switchAll2() {
      return switchMap_1.switchMap(identity_1.identity);
    }
    exports.switchAll = switchAll2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js
var require_switchMapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.switchMapTo = void 0;
    var switchMap_1 = require_switchMap();
    var isFunction_1 = require_isFunction();
    function switchMapTo2(innerObservable, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
        return innerObservable;
      }, resultSelector) : switchMap_1.switchMap(function() {
        return innerObservable;
      });
    }
    exports.switchMapTo = switchMapTo2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchScan.js
var require_switchScan = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchScan.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.switchScan = void 0;
    var switchMap_1 = require_switchMap();
    var lift_1 = require_lift();
    function switchScan2(accumulator, seed) {
      return lift_1.operate(function(source, subscriber) {
        var state = seed;
        switchMap_1.switchMap(function(value, index) {
          return accumulator(state, value, index);
        }, function(_, innerValue) {
          return state = innerValue, innerValue;
        })(source).subscribe(subscriber);
        return function() {
          state = null;
        };
      });
    }
    exports.switchScan = switchScan2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js
var require_takeUntil = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.takeUntil = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var noop_1 = require_noop();
    function takeUntil2(notifier) {
      return lift_1.operate(function(source, subscriber) {
        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          return subscriber.complete();
        }, noop_1.noop));
        !subscriber.closed && source.subscribe(subscriber);
      });
    }
    exports.takeUntil = takeUntil2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js
var require_takeWhile = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.takeWhile = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function takeWhile2(predicate, inclusive) {
      if (inclusive === void 0) {
        inclusive = false;
      }
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var result = predicate(value, index++);
          (result || inclusive) && subscriber.next(value);
          !result && subscriber.complete();
        }));
      });
    }
    exports.takeWhile = takeWhile2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/tap.js
var require_tap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/tap.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.tap = void 0;
    var isFunction_1 = require_isFunction();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var identity_1 = require_identity();
    function tap2(observerOrNext, error2, complete) {
      var tapObserver = isFunction_1.isFunction(observerOrNext) || error2 || complete ? {
        next: observerOrNext,
        error: error2,
        complete
      } : observerOrNext;
      return tapObserver ? lift_1.operate(function(source, subscriber) {
        var _a;
        (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
        var isUnsub = true;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var _a2;
          (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
          subscriber.next(value);
        }, function() {
          var _a2;
          isUnsub = false;
          (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
          subscriber.complete();
        }, function(err) {
          var _a2;
          isUnsub = false;
          (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
          subscriber.error(err);
        }, function() {
          var _a2, _b;
          if (isUnsub) {
            (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
          }
          (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
        }));
      }) : identity_1.identity;
    }
    exports.tap = tap2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/throttle.js
var require_throttle = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/throttle.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.throttle = exports.defaultThrottleConfig = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    exports.defaultThrottleConfig = {
      leading: true,
      trailing: false
    };
    function throttle2(durationSelector, config2) {
      if (config2 === void 0) {
        config2 = exports.defaultThrottleConfig;
      }
      return lift_1.operate(function(source, subscriber) {
        var leading = config2.leading, trailing = config2.trailing;
        var hasValue = false;
        var sendValue = null;
        var throttled = null;
        var isComplete = false;
        var endThrottling = function() {
          throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
          throttled = null;
          if (trailing) {
            send();
            isComplete && subscriber.complete();
          }
        };
        var cleanupThrottling = function() {
          throttled = null;
          isComplete && subscriber.complete();
        };
        var startThrottle = function(value) {
          return throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
        };
        var send = function() {
          if (hasValue) {
            hasValue = false;
            var value = sendValue;
            sendValue = null;
            subscriber.next(value);
            !isComplete && startThrottle(value);
          }
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          sendValue = value;
          !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
        }, function() {
          isComplete = true;
          !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
        }));
      });
    }
    exports.throttle = throttle2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js
var require_throttleTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.throttleTime = void 0;
    var async_1 = require_async();
    var throttle_1 = require_throttle();
    var timer_1 = require_timer();
    function throttleTime2(duration, scheduler, config2) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      if (config2 === void 0) {
        config2 = throttle_1.defaultThrottleConfig;
      }
      var duration$ = timer_1.timer(duration, scheduler);
      return throttle_1.throttle(function() {
        return duration$;
      }, config2);
    }
    exports.throttleTime = throttleTime2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js
var require_timeInterval = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TimeInterval = exports.timeInterval = void 0;
    var async_1 = require_async();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function timeInterval2(scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return lift_1.operate(function(source, subscriber) {
        var last3 = scheduler.now();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var now = scheduler.now();
          var interval2 = now - last3;
          last3 = now;
          subscriber.next(new TimeInterval2(value, interval2));
        }));
      });
    }
    exports.timeInterval = timeInterval2;
    var TimeInterval2 = function() {
      function TimeInterval3(value, interval2) {
        this.value = value;
        this.interval = interval2;
      }
      return TimeInterval3;
    }();
    exports.TimeInterval = TimeInterval2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js
var require_timeoutWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.timeoutWith = void 0;
    var async_1 = require_async();
    var isDate_1 = require_isDate();
    var timeout_1 = require_timeout();
    function timeoutWith2(due, withObservable, scheduler) {
      var first2;
      var each;
      var _with;
      scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1.async;
      if (isDate_1.isValidDate(due)) {
        first2 = due;
      } else if (typeof due === "number") {
        each = due;
      }
      if (withObservable) {
        _with = function() {
          return withObservable;
        };
      } else {
        throw new TypeError("No observable provided to switch to");
      }
      if (first2 == null && each == null) {
        throw new TypeError("No timeout provided.");
      }
      return timeout_1.timeout({
        first: first2,
        each,
        scheduler,
        with: _with
      });
    }
    exports.timeoutWith = timeoutWith2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timestamp.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.timestamp = void 0;
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var map_1 = require_map();
    function timestamp2(timestampProvider) {
      if (timestampProvider === void 0) {
        timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
      }
      return map_1.map(function(value) {
        return {
          value,
          timestamp: timestampProvider.now()
        };
      });
    }
    exports.timestamp = timestamp2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/window.js
var require_window2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/window.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.window = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    function window3(windowBoundaries) {
      return lift_1.operate(function(source, subscriber) {
        var windowSubject = new Subject_1.Subject();
        subscriber.next(windowSubject.asObservable());
        var errorHandler2 = function(err) {
          windowSubject.error(err);
          subscriber.error(err);
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
        }, function() {
          windowSubject.complete();
          subscriber.complete();
        }, errorHandler2));
        windowBoundaries.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          windowSubject.complete();
          subscriber.next(windowSubject = new Subject_1.Subject());
        }, noop_1.noop, errorHandler2));
        return function() {
          windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
          windowSubject = null;
        };
      });
    }
    exports.window = window3;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowCount.js
var require_windowCount = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowCount.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __values2 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return {
              value: o && o[i++],
              done: !o
            };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.windowCount = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function windowCount2(windowSize, startWindowEvery) {
      if (startWindowEvery === void 0) {
        startWindowEvery = 0;
      }
      var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
      return lift_1.operate(function(source, subscriber) {
        var windows = [new Subject_1.Subject()];
        var starts = [];
        var count2 = 0;
        subscriber.next(windows[0].asObservable());
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          try {
            for (var windows_1 = __values2(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
              var window_1 = windows_1_1.value;
              window_1.next(value);
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1
            };
          } finally {
            try {
              if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return))
                _a.call(windows_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          var c = count2 - windowSize + 1;
          if (c >= 0 && c % startEvery === 0) {
            windows.shift().complete();
          }
          if (++count2 % startEvery === 0) {
            var window_2 = new Subject_1.Subject();
            windows.push(window_2);
            subscriber.next(window_2.asObservable());
          }
        }, function() {
          while (windows.length > 0) {
            windows.shift().complete();
          }
          subscriber.complete();
        }, function(err) {
          while (windows.length > 0) {
            windows.shift().error(err);
          }
          subscriber.error(err);
        }, function() {
          starts = null;
          windows = null;
        }));
      });
    }
    exports.windowCount = windowCount2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowTime.js
var require_windowTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowTime.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.windowTime = void 0;
    var Subject_1 = require_Subject();
    var async_1 = require_async();
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    var args_1 = require_args();
    var executeSchedule_1 = require_executeSchedule();
    function windowTime2(windowTimeSpan) {
      var _a, _b;
      var otherArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        otherArgs[_i - 1] = arguments[_i];
      }
      var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
      var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
      var maxWindowSize = otherArgs[1] || Infinity;
      return lift_1.operate(function(source, subscriber) {
        var windowRecords = [];
        var restartOnClose = false;
        var closeWindow = function(record) {
          var window3 = record.window, subs = record.subs;
          window3.complete();
          subs.unsubscribe();
          arrRemove_1.arrRemove(windowRecords, record);
          restartOnClose && startWindow();
        };
        var startWindow = function() {
          if (windowRecords) {
            var subs = new Subscription_1.Subscription();
            subscriber.add(subs);
            var window_1 = new Subject_1.Subject();
            var record_1 = {
              window: window_1,
              subs,
              seen: 0
            };
            windowRecords.push(record_1);
            subscriber.next(window_1.asObservable());
            executeSchedule_1.executeSchedule(subs, scheduler, function() {
              return closeWindow(record_1);
            }, windowTimeSpan);
          }
        };
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
          executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
        } else {
          restartOnClose = true;
        }
        startWindow();
        var loop = function(cb) {
          return windowRecords.slice().forEach(cb);
        };
        var terminate = function(cb) {
          loop(function(_a2) {
            var window3 = _a2.window;
            return cb(window3);
          });
          cb(subscriber);
          subscriber.unsubscribe();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          loop(function(record) {
            record.window.next(value);
            maxWindowSize <= ++record.seen && closeWindow(record);
          });
        }, function() {
          return terminate(function(consumer) {
            return consumer.complete();
          });
        }, function(err) {
          return terminate(function(consumer) {
            return consumer.error(err);
          });
        }));
        return function() {
          windowRecords = null;
        };
      });
    }
    exports.windowTime = windowTime2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js
var require_windowToggle = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __values2 = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return {
              value: o && o[i++],
              done: !o
            };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.windowToggle = void 0;
    var Subject_1 = require_Subject();
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var arrRemove_1 = require_arrRemove();
    function windowToggle2(openings, closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var windows = [];
        var handleError2 = function(err) {
          while (0 < windows.length) {
            windows.shift().error(err);
          }
          subscriber.error(err);
        };
        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
          var window3 = new Subject_1.Subject();
          windows.push(window3);
          var closingSubscription = new Subscription_1.Subscription();
          var closeWindow = function() {
            arrRemove_1.arrRemove(windows, window3);
            window3.complete();
            closingSubscription.unsubscribe();
          };
          var closingNotifier;
          try {
            closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
          } catch (err) {
            handleError2(err);
            return;
          }
          subscriber.next(window3.asObservable());
          closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError2)));
        }, noop_1.noop));
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          var windowsCopy = windows.slice();
          try {
            for (var windowsCopy_1 = __values2(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
              var window_1 = windowsCopy_1_1.value;
              window_1.next(value);
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1
            };
          } finally {
            try {
              if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return))
                _a.call(windowsCopy_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }, function() {
          while (0 < windows.length) {
            windows.shift().complete();
          }
          subscriber.complete();
        }, handleError2, function() {
          while (0 < windows.length) {
            windows.shift().unsubscribe();
          }
        }));
      });
    }
    exports.windowToggle = windowToggle2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js
var require_windowWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.windowWhen = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function windowWhen2(closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var window3;
        var closingSubscriber;
        var handleError2 = function(err) {
          window3.error(err);
          subscriber.error(err);
        };
        var openWindow = function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          window3 === null || window3 === void 0 ? void 0 : window3.complete();
          window3 = new Subject_1.Subject();
          subscriber.next(window3.asObservable());
          var closingNotifier;
          try {
            closingNotifier = innerFrom_1.innerFrom(closingSelector());
          } catch (err) {
            handleError2(err);
            return;
          }
          closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError2));
        };
        openWindow();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return window3.next(value);
        }, function() {
          window3.complete();
          subscriber.complete();
        }, handleError2, function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          window3 = null;
        }));
      });
    }
    exports.windowWhen = windowWhen2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js
var require_withLatestFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.withLatestFrom = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var identity_1 = require_identity();
    var noop_1 = require_noop();
    var args_1 = require_args();
    function withLatestFrom2() {
      var inputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        inputs[_i] = arguments[_i];
      }
      var project = args_1.popResultSelector(inputs);
      return lift_1.operate(function(source, subscriber) {
        var len = inputs.length;
        var otherValues = new Array(len);
        var hasValue = inputs.map(function() {
          return false;
        });
        var ready = false;
        var _loop_1 = function(i2) {
          innerFrom_1.innerFrom(inputs[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            otherValues[i2] = value;
            if (!ready && !hasValue[i2]) {
              hasValue[i2] = true;
              (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
            }
          }, noop_1.noop));
        };
        for (var i = 0; i < len; i++) {
          _loop_1(i);
        }
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (ready) {
            var values = __spreadArray2([value], __read2(otherValues));
            subscriber.next(project ? project.apply(void 0, __spreadArray2([], __read2(values))) : values);
          }
        }));
      });
    }
    exports.withLatestFrom = withLatestFrom2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/zipAll.js
var require_zipAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/zipAll.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.zipAll = void 0;
    var zip_1 = require_zip();
    var joinAllInternals_1 = require_joinAllInternals();
    function zipAll2(project) {
      return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
    }
    exports.zipAll = zipAll2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/zip.js
var require_zip2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/zip.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.zip = void 0;
    var zip_1 = require_zip();
    var lift_1 = require_lift();
    function zip3() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      return lift_1.operate(function(source, subscriber) {
        zip_1.zip.apply(void 0, __spreadArray2([source], __read2(sources))).subscribe(subscriber);
      });
    }
    exports.zip = zip3;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/zipWith.js
var require_zipWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/zipWith.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __read2 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = {
          error: error2
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
      for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
        to[j] = from2[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.zipWith = void 0;
    var zip_1 = require_zip2();
    function zipWith2() {
      var otherInputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherInputs[_i] = arguments[_i];
      }
      return zip_1.zip.apply(void 0, __spreadArray2([], __read2(otherInputs)));
    }
    exports.zipWith = zipWith2;
  }
});

// node_modules/rxjs/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/rxjs/dist/cjs/index.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
          return m[k];
        }
      });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
    exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
    exports.switchMapTo = exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
    exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = void 0;
    var Observable_1 = require_Observable();
    Object.defineProperty(exports, "Observable", {
      enumerable: true,
      get: function() {
        return Observable_1.Observable;
      }
    });
    var ConnectableObservable_1 = require_ConnectableObservable();
    Object.defineProperty(exports, "ConnectableObservable", {
      enumerable: true,
      get: function() {
        return ConnectableObservable_1.ConnectableObservable;
      }
    });
    var observable_1 = require_observable();
    Object.defineProperty(exports, "observable", {
      enumerable: true,
      get: function() {
        return observable_1.observable;
      }
    });
    var animationFrames_1 = require_animationFrames();
    Object.defineProperty(exports, "animationFrames", {
      enumerable: true,
      get: function() {
        return animationFrames_1.animationFrames;
      }
    });
    var Subject_1 = require_Subject();
    Object.defineProperty(exports, "Subject", {
      enumerable: true,
      get: function() {
        return Subject_1.Subject;
      }
    });
    var BehaviorSubject_1 = require_BehaviorSubject();
    Object.defineProperty(exports, "BehaviorSubject", {
      enumerable: true,
      get: function() {
        return BehaviorSubject_1.BehaviorSubject;
      }
    });
    var ReplaySubject_1 = require_ReplaySubject();
    Object.defineProperty(exports, "ReplaySubject", {
      enumerable: true,
      get: function() {
        return ReplaySubject_1.ReplaySubject;
      }
    });
    var AsyncSubject_1 = require_AsyncSubject();
    Object.defineProperty(exports, "AsyncSubject", {
      enumerable: true,
      get: function() {
        return AsyncSubject_1.AsyncSubject;
      }
    });
    var asap_1 = require_asap();
    Object.defineProperty(exports, "asap", {
      enumerable: true,
      get: function() {
        return asap_1.asap;
      }
    });
    Object.defineProperty(exports, "asapScheduler", {
      enumerable: true,
      get: function() {
        return asap_1.asapScheduler;
      }
    });
    var async_1 = require_async();
    Object.defineProperty(exports, "async", {
      enumerable: true,
      get: function() {
        return async_1.async;
      }
    });
    Object.defineProperty(exports, "asyncScheduler", {
      enumerable: true,
      get: function() {
        return async_1.asyncScheduler;
      }
    });
    var queue_1 = require_queue();
    Object.defineProperty(exports, "queue", {
      enumerable: true,
      get: function() {
        return queue_1.queue;
      }
    });
    Object.defineProperty(exports, "queueScheduler", {
      enumerable: true,
      get: function() {
        return queue_1.queueScheduler;
      }
    });
    var animationFrame_1 = require_animationFrame();
    Object.defineProperty(exports, "animationFrame", {
      enumerable: true,
      get: function() {
        return animationFrame_1.animationFrame;
      }
    });
    Object.defineProperty(exports, "animationFrameScheduler", {
      enumerable: true,
      get: function() {
        return animationFrame_1.animationFrameScheduler;
      }
    });
    var VirtualTimeScheduler_1 = require_VirtualTimeScheduler();
    Object.defineProperty(exports, "VirtualTimeScheduler", {
      enumerable: true,
      get: function() {
        return VirtualTimeScheduler_1.VirtualTimeScheduler;
      }
    });
    Object.defineProperty(exports, "VirtualAction", {
      enumerable: true,
      get: function() {
        return VirtualTimeScheduler_1.VirtualAction;
      }
    });
    var Scheduler_1 = require_Scheduler();
    Object.defineProperty(exports, "Scheduler", {
      enumerable: true,
      get: function() {
        return Scheduler_1.Scheduler;
      }
    });
    var Subscription_1 = require_Subscription();
    Object.defineProperty(exports, "Subscription", {
      enumerable: true,
      get: function() {
        return Subscription_1.Subscription;
      }
    });
    var Subscriber_1 = require_Subscriber();
    Object.defineProperty(exports, "Subscriber", {
      enumerable: true,
      get: function() {
        return Subscriber_1.Subscriber;
      }
    });
    var Notification_1 = require_Notification();
    Object.defineProperty(exports, "Notification", {
      enumerable: true,
      get: function() {
        return Notification_1.Notification;
      }
    });
    Object.defineProperty(exports, "NotificationKind", {
      enumerable: true,
      get: function() {
        return Notification_1.NotificationKind;
      }
    });
    var pipe_1 = require_pipe();
    Object.defineProperty(exports, "pipe", {
      enumerable: true,
      get: function() {
        return pipe_1.pipe;
      }
    });
    var noop_1 = require_noop();
    Object.defineProperty(exports, "noop", {
      enumerable: true,
      get: function() {
        return noop_1.noop;
      }
    });
    var identity_1 = require_identity();
    Object.defineProperty(exports, "identity", {
      enumerable: true,
      get: function() {
        return identity_1.identity;
      }
    });
    var isObservable_1 = require_isObservable();
    Object.defineProperty(exports, "isObservable", {
      enumerable: true,
      get: function() {
        return isObservable_1.isObservable;
      }
    });
    var lastValueFrom_1 = require_lastValueFrom();
    Object.defineProperty(exports, "lastValueFrom", {
      enumerable: true,
      get: function() {
        return lastValueFrom_1.lastValueFrom;
      }
    });
    var firstValueFrom_1 = require_firstValueFrom();
    Object.defineProperty(exports, "firstValueFrom", {
      enumerable: true,
      get: function() {
        return firstValueFrom_1.firstValueFrom;
      }
    });
    var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
    Object.defineProperty(exports, "ArgumentOutOfRangeError", {
      enumerable: true,
      get: function() {
        return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
      }
    });
    var EmptyError_1 = require_EmptyError();
    Object.defineProperty(exports, "EmptyError", {
      enumerable: true,
      get: function() {
        return EmptyError_1.EmptyError;
      }
    });
    var NotFoundError_1 = require_NotFoundError();
    Object.defineProperty(exports, "NotFoundError", {
      enumerable: true,
      get: function() {
        return NotFoundError_1.NotFoundError;
      }
    });
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    Object.defineProperty(exports, "ObjectUnsubscribedError", {
      enumerable: true,
      get: function() {
        return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
      }
    });
    var SequenceError_1 = require_SequenceError();
    Object.defineProperty(exports, "SequenceError", {
      enumerable: true,
      get: function() {
        return SequenceError_1.SequenceError;
      }
    });
    var timeout_1 = require_timeout();
    Object.defineProperty(exports, "TimeoutError", {
      enumerable: true,
      get: function() {
        return timeout_1.TimeoutError;
      }
    });
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    Object.defineProperty(exports, "UnsubscriptionError", {
      enumerable: true,
      get: function() {
        return UnsubscriptionError_1.UnsubscriptionError;
      }
    });
    var bindCallback_1 = require_bindCallback();
    Object.defineProperty(exports, "bindCallback", {
      enumerable: true,
      get: function() {
        return bindCallback_1.bindCallback;
      }
    });
    var bindNodeCallback_1 = require_bindNodeCallback();
    Object.defineProperty(exports, "bindNodeCallback", {
      enumerable: true,
      get: function() {
        return bindNodeCallback_1.bindNodeCallback;
      }
    });
    var combineLatest_1 = require_combineLatest();
    Object.defineProperty(exports, "combineLatest", {
      enumerable: true,
      get: function() {
        return combineLatest_1.combineLatest;
      }
    });
    var concat_1 = require_concat();
    Object.defineProperty(exports, "concat", {
      enumerable: true,
      get: function() {
        return concat_1.concat;
      }
    });
    var connectable_1 = require_connectable();
    Object.defineProperty(exports, "connectable", {
      enumerable: true,
      get: function() {
        return connectable_1.connectable;
      }
    });
    var defer_1 = require_defer();
    Object.defineProperty(exports, "defer", {
      enumerable: true,
      get: function() {
        return defer_1.defer;
      }
    });
    var empty_1 = require_empty();
    Object.defineProperty(exports, "empty", {
      enumerable: true,
      get: function() {
        return empty_1.empty;
      }
    });
    var forkJoin_1 = require_forkJoin();
    Object.defineProperty(exports, "forkJoin", {
      enumerable: true,
      get: function() {
        return forkJoin_1.forkJoin;
      }
    });
    var from_1 = require_from();
    Object.defineProperty(exports, "from", {
      enumerable: true,
      get: function() {
        return from_1.from;
      }
    });
    var fromEvent_1 = require_fromEvent();
    Object.defineProperty(exports, "fromEvent", {
      enumerable: true,
      get: function() {
        return fromEvent_1.fromEvent;
      }
    });
    var fromEventPattern_1 = require_fromEventPattern();
    Object.defineProperty(exports, "fromEventPattern", {
      enumerable: true,
      get: function() {
        return fromEventPattern_1.fromEventPattern;
      }
    });
    var generate_1 = require_generate();
    Object.defineProperty(exports, "generate", {
      enumerable: true,
      get: function() {
        return generate_1.generate;
      }
    });
    var iif_1 = require_iif();
    Object.defineProperty(exports, "iif", {
      enumerable: true,
      get: function() {
        return iif_1.iif;
      }
    });
    var interval_1 = require_interval();
    Object.defineProperty(exports, "interval", {
      enumerable: true,
      get: function() {
        return interval_1.interval;
      }
    });
    var merge_1 = require_merge();
    Object.defineProperty(exports, "merge", {
      enumerable: true,
      get: function() {
        return merge_1.merge;
      }
    });
    var never_1 = require_never();
    Object.defineProperty(exports, "never", {
      enumerable: true,
      get: function() {
        return never_1.never;
      }
    });
    var of_1 = require_of();
    Object.defineProperty(exports, "of", {
      enumerable: true,
      get: function() {
        return of_1.of;
      }
    });
    var onErrorResumeNext_1 = require_onErrorResumeNext2();
    Object.defineProperty(exports, "onErrorResumeNext", {
      enumerable: true,
      get: function() {
        return onErrorResumeNext_1.onErrorResumeNext;
      }
    });
    var pairs_1 = require_pairs();
    Object.defineProperty(exports, "pairs", {
      enumerable: true,
      get: function() {
        return pairs_1.pairs;
      }
    });
    var partition_1 = require_partition();
    Object.defineProperty(exports, "partition", {
      enumerable: true,
      get: function() {
        return partition_1.partition;
      }
    });
    var race_1 = require_race();
    Object.defineProperty(exports, "race", {
      enumerable: true,
      get: function() {
        return race_1.race;
      }
    });
    var range_1 = require_range();
    Object.defineProperty(exports, "range", {
      enumerable: true,
      get: function() {
        return range_1.range;
      }
    });
    var throwError_1 = require_throwError();
    Object.defineProperty(exports, "throwError", {
      enumerable: true,
      get: function() {
        return throwError_1.throwError;
      }
    });
    var timer_1 = require_timer();
    Object.defineProperty(exports, "timer", {
      enumerable: true,
      get: function() {
        return timer_1.timer;
      }
    });
    var using_1 = require_using();
    Object.defineProperty(exports, "using", {
      enumerable: true,
      get: function() {
        return using_1.using;
      }
    });
    var zip_1 = require_zip();
    Object.defineProperty(exports, "zip", {
      enumerable: true,
      get: function() {
        return zip_1.zip;
      }
    });
    var scheduled_1 = require_scheduled();
    Object.defineProperty(exports, "scheduled", {
      enumerable: true,
      get: function() {
        return scheduled_1.scheduled;
      }
    });
    var empty_2 = require_empty();
    Object.defineProperty(exports, "EMPTY", {
      enumerable: true,
      get: function() {
        return empty_2.EMPTY;
      }
    });
    var never_2 = require_never();
    Object.defineProperty(exports, "NEVER", {
      enumerable: true,
      get: function() {
        return never_2.NEVER;
      }
    });
    __exportStar(require_types(), exports);
    var config_1 = require_config();
    Object.defineProperty(exports, "config", {
      enumerable: true,
      get: function() {
        return config_1.config;
      }
    });
    var audit_1 = require_audit();
    Object.defineProperty(exports, "audit", {
      enumerable: true,
      get: function() {
        return audit_1.audit;
      }
    });
    var auditTime_1 = require_auditTime();
    Object.defineProperty(exports, "auditTime", {
      enumerable: true,
      get: function() {
        return auditTime_1.auditTime;
      }
    });
    var buffer_1 = require_buffer();
    Object.defineProperty(exports, "buffer", {
      enumerable: true,
      get: function() {
        return buffer_1.buffer;
      }
    });
    var bufferCount_1 = require_bufferCount();
    Object.defineProperty(exports, "bufferCount", {
      enumerable: true,
      get: function() {
        return bufferCount_1.bufferCount;
      }
    });
    var bufferTime_1 = require_bufferTime();
    Object.defineProperty(exports, "bufferTime", {
      enumerable: true,
      get: function() {
        return bufferTime_1.bufferTime;
      }
    });
    var bufferToggle_1 = require_bufferToggle();
    Object.defineProperty(exports, "bufferToggle", {
      enumerable: true,
      get: function() {
        return bufferToggle_1.bufferToggle;
      }
    });
    var bufferWhen_1 = require_bufferWhen();
    Object.defineProperty(exports, "bufferWhen", {
      enumerable: true,
      get: function() {
        return bufferWhen_1.bufferWhen;
      }
    });
    var catchError_1 = require_catchError();
    Object.defineProperty(exports, "catchError", {
      enumerable: true,
      get: function() {
        return catchError_1.catchError;
      }
    });
    var combineAll_1 = require_combineAll();
    Object.defineProperty(exports, "combineAll", {
      enumerable: true,
      get: function() {
        return combineAll_1.combineAll;
      }
    });
    var combineLatestAll_1 = require_combineLatestAll();
    Object.defineProperty(exports, "combineLatestAll", {
      enumerable: true,
      get: function() {
        return combineLatestAll_1.combineLatestAll;
      }
    });
    var combineLatestWith_1 = require_combineLatestWith();
    Object.defineProperty(exports, "combineLatestWith", {
      enumerable: true,
      get: function() {
        return combineLatestWith_1.combineLatestWith;
      }
    });
    var concatAll_1 = require_concatAll();
    Object.defineProperty(exports, "concatAll", {
      enumerable: true,
      get: function() {
        return concatAll_1.concatAll;
      }
    });
    var concatMap_1 = require_concatMap();
    Object.defineProperty(exports, "concatMap", {
      enumerable: true,
      get: function() {
        return concatMap_1.concatMap;
      }
    });
    var concatMapTo_1 = require_concatMapTo();
    Object.defineProperty(exports, "concatMapTo", {
      enumerable: true,
      get: function() {
        return concatMapTo_1.concatMapTo;
      }
    });
    var concatWith_1 = require_concatWith();
    Object.defineProperty(exports, "concatWith", {
      enumerable: true,
      get: function() {
        return concatWith_1.concatWith;
      }
    });
    var connect_1 = require_connect();
    Object.defineProperty(exports, "connect", {
      enumerable: true,
      get: function() {
        return connect_1.connect;
      }
    });
    var count_1 = require_count();
    Object.defineProperty(exports, "count", {
      enumerable: true,
      get: function() {
        return count_1.count;
      }
    });
    var debounce_1 = require_debounce();
    Object.defineProperty(exports, "debounce", {
      enumerable: true,
      get: function() {
        return debounce_1.debounce;
      }
    });
    var debounceTime_1 = require_debounceTime();
    Object.defineProperty(exports, "debounceTime", {
      enumerable: true,
      get: function() {
        return debounceTime_1.debounceTime;
      }
    });
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    Object.defineProperty(exports, "defaultIfEmpty", {
      enumerable: true,
      get: function() {
        return defaultIfEmpty_1.defaultIfEmpty;
      }
    });
    var delay_1 = require_delay();
    Object.defineProperty(exports, "delay", {
      enumerable: true,
      get: function() {
        return delay_1.delay;
      }
    });
    var delayWhen_1 = require_delayWhen();
    Object.defineProperty(exports, "delayWhen", {
      enumerable: true,
      get: function() {
        return delayWhen_1.delayWhen;
      }
    });
    var dematerialize_1 = require_dematerialize();
    Object.defineProperty(exports, "dematerialize", {
      enumerable: true,
      get: function() {
        return dematerialize_1.dematerialize;
      }
    });
    var distinct_1 = require_distinct();
    Object.defineProperty(exports, "distinct", {
      enumerable: true,
      get: function() {
        return distinct_1.distinct;
      }
    });
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    Object.defineProperty(exports, "distinctUntilChanged", {
      enumerable: true,
      get: function() {
        return distinctUntilChanged_1.distinctUntilChanged;
      }
    });
    var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
    Object.defineProperty(exports, "distinctUntilKeyChanged", {
      enumerable: true,
      get: function() {
        return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
      }
    });
    var elementAt_1 = require_elementAt();
    Object.defineProperty(exports, "elementAt", {
      enumerable: true,
      get: function() {
        return elementAt_1.elementAt;
      }
    });
    var endWith_1 = require_endWith();
    Object.defineProperty(exports, "endWith", {
      enumerable: true,
      get: function() {
        return endWith_1.endWith;
      }
    });
    var every_1 = require_every();
    Object.defineProperty(exports, "every", {
      enumerable: true,
      get: function() {
        return every_1.every;
      }
    });
    var exhaust_1 = require_exhaust();
    Object.defineProperty(exports, "exhaust", {
      enumerable: true,
      get: function() {
        return exhaust_1.exhaust;
      }
    });
    var exhaustAll_1 = require_exhaustAll();
    Object.defineProperty(exports, "exhaustAll", {
      enumerable: true,
      get: function() {
        return exhaustAll_1.exhaustAll;
      }
    });
    var exhaustMap_1 = require_exhaustMap();
    Object.defineProperty(exports, "exhaustMap", {
      enumerable: true,
      get: function() {
        return exhaustMap_1.exhaustMap;
      }
    });
    var expand_1 = require_expand();
    Object.defineProperty(exports, "expand", {
      enumerable: true,
      get: function() {
        return expand_1.expand;
      }
    });
    var filter_1 = require_filter();
    Object.defineProperty(exports, "filter", {
      enumerable: true,
      get: function() {
        return filter_1.filter;
      }
    });
    var finalize_1 = require_finalize();
    Object.defineProperty(exports, "finalize", {
      enumerable: true,
      get: function() {
        return finalize_1.finalize;
      }
    });
    var find_1 = require_find();
    Object.defineProperty(exports, "find", {
      enumerable: true,
      get: function() {
        return find_1.find;
      }
    });
    var findIndex_1 = require_findIndex();
    Object.defineProperty(exports, "findIndex", {
      enumerable: true,
      get: function() {
        return findIndex_1.findIndex;
      }
    });
    var first_1 = require_first();
    Object.defineProperty(exports, "first", {
      enumerable: true,
      get: function() {
        return first_1.first;
      }
    });
    var groupBy_1 = require_groupBy();
    Object.defineProperty(exports, "groupBy", {
      enumerable: true,
      get: function() {
        return groupBy_1.groupBy;
      }
    });
    var ignoreElements_1 = require_ignoreElements();
    Object.defineProperty(exports, "ignoreElements", {
      enumerable: true,
      get: function() {
        return ignoreElements_1.ignoreElements;
      }
    });
    var isEmpty_1 = require_isEmpty();
    Object.defineProperty(exports, "isEmpty", {
      enumerable: true,
      get: function() {
        return isEmpty_1.isEmpty;
      }
    });
    var last_1 = require_last();
    Object.defineProperty(exports, "last", {
      enumerable: true,
      get: function() {
        return last_1.last;
      }
    });
    var map_1 = require_map();
    Object.defineProperty(exports, "map", {
      enumerable: true,
      get: function() {
        return map_1.map;
      }
    });
    var mapTo_1 = require_mapTo();
    Object.defineProperty(exports, "mapTo", {
      enumerable: true,
      get: function() {
        return mapTo_1.mapTo;
      }
    });
    var materialize_1 = require_materialize();
    Object.defineProperty(exports, "materialize", {
      enumerable: true,
      get: function() {
        return materialize_1.materialize;
      }
    });
    var max_1 = require_max();
    Object.defineProperty(exports, "max", {
      enumerable: true,
      get: function() {
        return max_1.max;
      }
    });
    var mergeAll_1 = require_mergeAll();
    Object.defineProperty(exports, "mergeAll", {
      enumerable: true,
      get: function() {
        return mergeAll_1.mergeAll;
      }
    });
    var flatMap_1 = require_flatMap();
    Object.defineProperty(exports, "flatMap", {
      enumerable: true,
      get: function() {
        return flatMap_1.flatMap;
      }
    });
    var mergeMap_1 = require_mergeMap();
    Object.defineProperty(exports, "mergeMap", {
      enumerable: true,
      get: function() {
        return mergeMap_1.mergeMap;
      }
    });
    var mergeMapTo_1 = require_mergeMapTo();
    Object.defineProperty(exports, "mergeMapTo", {
      enumerable: true,
      get: function() {
        return mergeMapTo_1.mergeMapTo;
      }
    });
    var mergeScan_1 = require_mergeScan();
    Object.defineProperty(exports, "mergeScan", {
      enumerable: true,
      get: function() {
        return mergeScan_1.mergeScan;
      }
    });
    var mergeWith_1 = require_mergeWith();
    Object.defineProperty(exports, "mergeWith", {
      enumerable: true,
      get: function() {
        return mergeWith_1.mergeWith;
      }
    });
    var min_1 = require_min();
    Object.defineProperty(exports, "min", {
      enumerable: true,
      get: function() {
        return min_1.min;
      }
    });
    var multicast_1 = require_multicast();
    Object.defineProperty(exports, "multicast", {
      enumerable: true,
      get: function() {
        return multicast_1.multicast;
      }
    });
    var observeOn_1 = require_observeOn();
    Object.defineProperty(exports, "observeOn", {
      enumerable: true,
      get: function() {
        return observeOn_1.observeOn;
      }
    });
    var pairwise_1 = require_pairwise();
    Object.defineProperty(exports, "pairwise", {
      enumerable: true,
      get: function() {
        return pairwise_1.pairwise;
      }
    });
    var pluck_1 = require_pluck();
    Object.defineProperty(exports, "pluck", {
      enumerable: true,
      get: function() {
        return pluck_1.pluck;
      }
    });
    var publish_1 = require_publish();
    Object.defineProperty(exports, "publish", {
      enumerable: true,
      get: function() {
        return publish_1.publish;
      }
    });
    var publishBehavior_1 = require_publishBehavior();
    Object.defineProperty(exports, "publishBehavior", {
      enumerable: true,
      get: function() {
        return publishBehavior_1.publishBehavior;
      }
    });
    var publishLast_1 = require_publishLast();
    Object.defineProperty(exports, "publishLast", {
      enumerable: true,
      get: function() {
        return publishLast_1.publishLast;
      }
    });
    var publishReplay_1 = require_publishReplay();
    Object.defineProperty(exports, "publishReplay", {
      enumerable: true,
      get: function() {
        return publishReplay_1.publishReplay;
      }
    });
    var raceWith_1 = require_raceWith();
    Object.defineProperty(exports, "raceWith", {
      enumerable: true,
      get: function() {
        return raceWith_1.raceWith;
      }
    });
    var reduce_1 = require_reduce();
    Object.defineProperty(exports, "reduce", {
      enumerable: true,
      get: function() {
        return reduce_1.reduce;
      }
    });
    var repeat_1 = require_repeat();
    Object.defineProperty(exports, "repeat", {
      enumerable: true,
      get: function() {
        return repeat_1.repeat;
      }
    });
    var repeatWhen_1 = require_repeatWhen();
    Object.defineProperty(exports, "repeatWhen", {
      enumerable: true,
      get: function() {
        return repeatWhen_1.repeatWhen;
      }
    });
    var retry_1 = require_retry();
    Object.defineProperty(exports, "retry", {
      enumerable: true,
      get: function() {
        return retry_1.retry;
      }
    });
    var retryWhen_1 = require_retryWhen();
    Object.defineProperty(exports, "retryWhen", {
      enumerable: true,
      get: function() {
        return retryWhen_1.retryWhen;
      }
    });
    var refCount_1 = require_refCount();
    Object.defineProperty(exports, "refCount", {
      enumerable: true,
      get: function() {
        return refCount_1.refCount;
      }
    });
    var sample_1 = require_sample();
    Object.defineProperty(exports, "sample", {
      enumerable: true,
      get: function() {
        return sample_1.sample;
      }
    });
    var sampleTime_1 = require_sampleTime();
    Object.defineProperty(exports, "sampleTime", {
      enumerable: true,
      get: function() {
        return sampleTime_1.sampleTime;
      }
    });
    var scan_1 = require_scan();
    Object.defineProperty(exports, "scan", {
      enumerable: true,
      get: function() {
        return scan_1.scan;
      }
    });
    var sequenceEqual_1 = require_sequenceEqual();
    Object.defineProperty(exports, "sequenceEqual", {
      enumerable: true,
      get: function() {
        return sequenceEqual_1.sequenceEqual;
      }
    });
    var share_1 = require_share();
    Object.defineProperty(exports, "share", {
      enumerable: true,
      get: function() {
        return share_1.share;
      }
    });
    var shareReplay_1 = require_shareReplay();
    Object.defineProperty(exports, "shareReplay", {
      enumerable: true,
      get: function() {
        return shareReplay_1.shareReplay;
      }
    });
    var single_1 = require_single();
    Object.defineProperty(exports, "single", {
      enumerable: true,
      get: function() {
        return single_1.single;
      }
    });
    var skip_1 = require_skip();
    Object.defineProperty(exports, "skip", {
      enumerable: true,
      get: function() {
        return skip_1.skip;
      }
    });
    var skipLast_1 = require_skipLast();
    Object.defineProperty(exports, "skipLast", {
      enumerable: true,
      get: function() {
        return skipLast_1.skipLast;
      }
    });
    var skipUntil_1 = require_skipUntil();
    Object.defineProperty(exports, "skipUntil", {
      enumerable: true,
      get: function() {
        return skipUntil_1.skipUntil;
      }
    });
    var skipWhile_1 = require_skipWhile();
    Object.defineProperty(exports, "skipWhile", {
      enumerable: true,
      get: function() {
        return skipWhile_1.skipWhile;
      }
    });
    var startWith_1 = require_startWith();
    Object.defineProperty(exports, "startWith", {
      enumerable: true,
      get: function() {
        return startWith_1.startWith;
      }
    });
    var subscribeOn_1 = require_subscribeOn();
    Object.defineProperty(exports, "subscribeOn", {
      enumerable: true,
      get: function() {
        return subscribeOn_1.subscribeOn;
      }
    });
    var switchAll_1 = require_switchAll();
    Object.defineProperty(exports, "switchAll", {
      enumerable: true,
      get: function() {
        return switchAll_1.switchAll;
      }
    });
    var switchMap_1 = require_switchMap();
    Object.defineProperty(exports, "switchMap", {
      enumerable: true,
      get: function() {
        return switchMap_1.switchMap;
      }
    });
    var switchMapTo_1 = require_switchMapTo();
    Object.defineProperty(exports, "switchMapTo", {
      enumerable: true,
      get: function() {
        return switchMapTo_1.switchMapTo;
      }
    });
    var switchScan_1 = require_switchScan();
    Object.defineProperty(exports, "switchScan", {
      enumerable: true,
      get: function() {
        return switchScan_1.switchScan;
      }
    });
    var take_1 = require_take();
    Object.defineProperty(exports, "take", {
      enumerable: true,
      get: function() {
        return take_1.take;
      }
    });
    var takeLast_1 = require_takeLast();
    Object.defineProperty(exports, "takeLast", {
      enumerable: true,
      get: function() {
        return takeLast_1.takeLast;
      }
    });
    var takeUntil_1 = require_takeUntil();
    Object.defineProperty(exports, "takeUntil", {
      enumerable: true,
      get: function() {
        return takeUntil_1.takeUntil;
      }
    });
    var takeWhile_1 = require_takeWhile();
    Object.defineProperty(exports, "takeWhile", {
      enumerable: true,
      get: function() {
        return takeWhile_1.takeWhile;
      }
    });
    var tap_1 = require_tap();
    Object.defineProperty(exports, "tap", {
      enumerable: true,
      get: function() {
        return tap_1.tap;
      }
    });
    var throttle_1 = require_throttle();
    Object.defineProperty(exports, "throttle", {
      enumerable: true,
      get: function() {
        return throttle_1.throttle;
      }
    });
    var throttleTime_1 = require_throttleTime();
    Object.defineProperty(exports, "throttleTime", {
      enumerable: true,
      get: function() {
        return throttleTime_1.throttleTime;
      }
    });
    var throwIfEmpty_1 = require_throwIfEmpty();
    Object.defineProperty(exports, "throwIfEmpty", {
      enumerable: true,
      get: function() {
        return throwIfEmpty_1.throwIfEmpty;
      }
    });
    var timeInterval_1 = require_timeInterval();
    Object.defineProperty(exports, "timeInterval", {
      enumerable: true,
      get: function() {
        return timeInterval_1.timeInterval;
      }
    });
    var timeout_2 = require_timeout();
    Object.defineProperty(exports, "timeout", {
      enumerable: true,
      get: function() {
        return timeout_2.timeout;
      }
    });
    var timeoutWith_1 = require_timeoutWith();
    Object.defineProperty(exports, "timeoutWith", {
      enumerable: true,
      get: function() {
        return timeoutWith_1.timeoutWith;
      }
    });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports, "timestamp", {
      enumerable: true,
      get: function() {
        return timestamp_1.timestamp;
      }
    });
    var toArray_1 = require_toArray();
    Object.defineProperty(exports, "toArray", {
      enumerable: true,
      get: function() {
        return toArray_1.toArray;
      }
    });
    var window_1 = require_window2();
    Object.defineProperty(exports, "window", {
      enumerable: true,
      get: function() {
        return window_1.window;
      }
    });
    var windowCount_1 = require_windowCount();
    Object.defineProperty(exports, "windowCount", {
      enumerable: true,
      get: function() {
        return windowCount_1.windowCount;
      }
    });
    var windowTime_1 = require_windowTime();
    Object.defineProperty(exports, "windowTime", {
      enumerable: true,
      get: function() {
        return windowTime_1.windowTime;
      }
    });
    var windowToggle_1 = require_windowToggle();
    Object.defineProperty(exports, "windowToggle", {
      enumerable: true,
      get: function() {
        return windowToggle_1.windowToggle;
      }
    });
    var windowWhen_1 = require_windowWhen();
    Object.defineProperty(exports, "windowWhen", {
      enumerable: true,
      get: function() {
        return windowWhen_1.windowWhen;
      }
    });
    var withLatestFrom_1 = require_withLatestFrom();
    Object.defineProperty(exports, "withLatestFrom", {
      enumerable: true,
      get: function() {
        return withLatestFrom_1.withLatestFrom;
      }
    });
    var zipAll_1 = require_zipAll();
    Object.defineProperty(exports, "zipAll", {
      enumerable: true,
      get: function() {
        return zipAll_1.zipAll;
      }
    });
    var zipWith_1 = require_zipWith();
    Object.defineProperty(exports, "zipWith", {
      enumerable: true,
      get: function() {
        return zipWith_1.zipWith;
      }
    });
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/preview/angular/app.token.js
var require_app_token = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/preview/angular/app.token.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.STORY = void 0;
    var core_1 = (init_core(), __toCommonJS(core_exports));
    exports.STORY = new core_1.InjectionToken("story");
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/preview/angular/components/app.component.js
var require_app_component = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/preview/angular/components/app.component.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AppComponent = void 0;
    var core_1 = (init_core(), __toCommonJS(core_exports));
    var rxjs_1 = require_cjs();
    var operators_1 = (init_operators(), __toCommonJS(operators_exports));
    var app_token_1 = require_app_token();
    var AppComponent = class AppComponent {
      constructor(cfr, changeDetectorRef, data) {
        this.cfr = cfr;
        this.changeDetectorRef = changeDetectorRef;
        this.data = data;
        this.previousValues = {};
        this.propSubscriptions = /* @__PURE__ */ new Map();
      }
      ngOnInit() {
        this.data.pipe(operators_1.first()).subscribe((data) => {
          this.target.clear();
          const compFactory = this.cfr.resolveComponentFactory(data.component);
          const componentRef = this.target.createComponent(compFactory);
          const {
            instance
          } = componentRef;
          const childChangeDetectorRef = componentRef.injector.get(core_1.ChangeDetectorRef);
          this.subscription = this.data.subscribe((newData) => {
            this.setProps(instance, newData);
            childChangeDetectorRef.markForCheck();
            this.changeDetectorRef.detectChanges();
          });
        });
      }
      ngOnDestroy() {
        this.target.clear();
        if (this.subscription) {
          this.subscription.unsubscribe();
        }
        this.propSubscriptions.forEach((v) => {
          if (!v.sub.closed) {
            v.sub.unsubscribe();
          }
        });
        this.propSubscriptions.clear();
      }
      setProps(instance, {
        props = {}
      }) {
        const changes = {};
        const hasNgOnChangesHook = !!instance.ngOnChanges;
        Object.keys(props).forEach((key) => {
          const value = props[key];
          const instanceProperty = instance[key];
          if (!(instanceProperty instanceof core_1.EventEmitter) && value !== void 0 && value !== null) {
            instance[key] = value;
            if (hasNgOnChangesHook) {
              const previousValue = this.previousValues[key];
              if (previousValue !== value) {
                changes[key] = new core_1.SimpleChange(previousValue, value, !Object.prototype.hasOwnProperty.call(this.previousValues, key));
                this.previousValues[key] = value;
              }
            }
          } else if (typeof value === "function" && key !== "ngModelChange") {
            this.setPropSubscription(key, instanceProperty, value);
          }
        });
        this.callNgOnChangesHook(instance, changes);
        this.setNgModel(instance, props);
      }
      callNgOnChangesHook(instance, changes) {
        if (Object.keys(changes).length) {
          instance.ngOnChanges(changes);
        }
      }
      setNgModel(instance, props) {
        if (props.ngModel) {
          instance.writeValue(props.ngModel);
        }
        if (typeof props.ngModelChange === "function") {
          instance.registerOnChange(props.ngModelChange);
        }
      }
      setPropSubscription(key, instanceProperty, value) {
        if (this.propSubscriptions.has(key)) {
          const v = this.propSubscriptions.get(key);
          if (v.prop === value) {
            return;
          }
          if (!v.sub.closed) {
            v.sub.unsubscribe();
          }
        }
        const sub = instanceProperty.subscribe(value);
        this.propSubscriptions.set(key, {
          prop: value,
          sub
        });
      }
    };
    __decorate([core_1.ViewChild("target", {
      read: core_1.ViewContainerRef,
      static: true
    }), __metadata("design:type", core_1.ViewContainerRef)], AppComponent.prototype, "target", void 0);
    AppComponent = __decorate([core_1.Component({
      selector: "storybook-dynamic-app-root",
      template: "<ng-template #target></ng-template>"
    }), __param(2, core_1.Inject(app_token_1.STORY)), __metadata("design:paramtypes", [core_1.ComponentFactoryResolver, core_1.ChangeDetectorRef, rxjs_1.Observable])], AppComponent);
    exports.AppComponent = AppComponent;
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/preview/angular/helpers.js
var require_helpers = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/preview/angular/helpers.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.renderNgApp = void 0;
    var global_1 = __importDefault(require_window());
    var core_1 = (init_core(), __toCommonJS(core_exports));
    var forms_1 = (init_forms(), __toCommonJS(forms_exports));
    var platform_browser_dynamic_1 = (init_platform_browser_dynamic(), __toCommonJS(platform_browser_dynamic_exports));
    var platform_browser_1 = (init_platform_browser(), __toCommonJS(platform_browser_exports));
    var rxjs_1 = require_cjs();
    var app_component_1 = require_app_component();
    var app_token_1 = require_app_token();
    var {
      document: document2
    } = global_1.default;
    var platform = null;
    var promises = [];
    var storyData = new rxjs_1.ReplaySubject(1);
    var moduleClass = class DynamicModule {
    };
    var componentClass = class DynamicComponent {
    };
    function storyDataFactory(data) {
      return (ngZone) => new rxjs_1.Observable((subscriber) => {
        const sub = data.subscribe((v) => {
          ngZone.run(() => subscriber.next(v));
        }, (err) => {
          ngZone.run(() => subscriber.error(err));
        }, () => {
          ngZone.run(() => subscriber.complete());
        });
        return () => {
          sub.unsubscribe();
        };
      });
    }
    var getModule = (declarations, entryComponents, bootstrap, data, moduleMetadata) => {
      storyData.complete();
      storyData = new rxjs_1.ReplaySubject(1);
      storyData.next(data);
      const moduleMeta = {
        declarations: [...declarations, ...moduleMetadata.declarations || []],
        imports: [platform_browser_1.BrowserModule, forms_1.FormsModule, ...moduleMetadata.imports || []],
        providers: [{
          provide: app_token_1.STORY,
          useFactory: storyDataFactory(storyData.asObservable()),
          deps: [core_1.NgZone]
        }, ...moduleMetadata.providers || []],
        entryComponents: [...entryComponents, ...moduleMetadata.entryComponents || []],
        schemas: [...moduleMetadata.schemas || []],
        bootstrap: [...bootstrap]
      };
      return core_1.NgModule(moduleMeta)(moduleClass);
    };
    var createComponentFromTemplate = (template, styles) => {
      return core_1.Component({
        template,
        styles
      })(componentClass);
    };
    var extractNgModuleMetadata = (importItem) => {
      const target = importItem && importItem.ngModule ? importItem.ngModule : importItem;
      const decoratorKey = "__annotations__";
      const decorators = Reflect && Reflect.getOwnPropertyDescriptor && Reflect.getOwnPropertyDescriptor(target, decoratorKey) ? Reflect.getOwnPropertyDescriptor(target, decoratorKey).value : target[decoratorKey];
      if (!decorators || decorators.length === 0) {
        return null;
      }
      const ngModuleDecorator = decorators.find((decorator) => decorator instanceof core_1.NgModule);
      if (!ngModuleDecorator) {
        return null;
      }
      return ngModuleDecorator;
    };
    var getExistenceOfComponentInModules = (component, declarations, imports) => {
      if (declarations && declarations.some((declaration) => declaration === component)) {
        return true;
      }
      if (!imports) {
        return false;
      }
      return imports.some((importItem) => {
        const extractedNgModuleMetadata = extractNgModuleMetadata(importItem);
        if (!extractedNgModuleMetadata) {
          return false;
        }
        return getExistenceOfComponentInModules(component, extractedNgModuleMetadata.declarations, extractedNgModuleMetadata.imports);
      });
    };
    var initModule = (storyFn) => {
      const storyObj = storyFn();
      const {
        component,
        template,
        props,
        styles,
        moduleMetadata = {}
      } = storyObj;
      const isCreatingComponentFromTemplate = Boolean(template);
      const AnnotatedComponent = isCreatingComponentFromTemplate ? createComponentFromTemplate(template, styles) : component;
      const componentRequiresDeclaration = isCreatingComponentFromTemplate || !getExistenceOfComponentInModules(component, moduleMetadata.declarations, moduleMetadata.imports);
      const componentDeclarations = componentRequiresDeclaration ? [app_component_1.AppComponent, AnnotatedComponent] : [app_component_1.AppComponent];
      const story = {
        component: AnnotatedComponent,
        props
      };
      return getModule(componentDeclarations, [AnnotatedComponent], [app_component_1.AppComponent], story, moduleMetadata);
    };
    var staticRoot = document2.getElementById("root");
    var insertDynamicRoot = () => {
      const app = document2.createElement("storybook-dynamic-app-root");
      staticRoot.innerHTML = "";
      staticRoot.appendChild(app);
    };
    var draw = (newModule) => {
      if (!platform) {
        insertDynamicRoot();
        if (typeof NODE_ENV === "string" && NODE_ENV !== "development") {
          try {
            core_1.enableProdMode();
          } catch (e) {
          }
        }
        platform = platform_browser_dynamic_1.platformBrowserDynamic();
        promises.push(platform.bootstrapModule(newModule));
      } else {
        Promise.all(promises).then((modules2) => {
          modules2.forEach((mod) => mod.destroy());
          insertDynamicRoot();
          promises = [];
          promises.push(platform.bootstrapModule(newModule));
        });
      }
    };
    exports.renderNgApp = (storyFn, forced) => {
      if (!forced) {
        draw(initModule(storyFn));
      } else {
        storyData.next(storyFn());
      }
    };
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/StorybookProvider.js
var require_StorybookProvider = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/StorybookProvider.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.storyPropsProvider = exports.STORY_PROPS = void 0;
    var core_1 = (init_core(), __toCommonJS(core_exports));
    var rxjs_1 = require_cjs();
    exports.STORY_PROPS = new core_1.InjectionToken("STORY_PROPS");
    exports.storyPropsProvider = (storyProps$) => ({
      provide: exports.STORY_PROPS,
      useFactory: storyDataFactory(storyProps$.asObservable()),
      deps: [core_1.NgZone]
    });
    function storyDataFactory(data) {
      return (ngZone) => new rxjs_1.Observable((subscriber) => {
        const sub = data.subscribe((v) => {
          ngZone.run(() => subscriber.next(v));
        }, (err) => {
          ngZone.run(() => subscriber.error(err));
        }, () => {
          ngZone.run(() => subscriber.complete());
        });
        return () => {
          sub.unsubscribe();
        };
      });
    }
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/utils/NgModulesAnalyzer.js
var require_NgModulesAnalyzer = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/utils/NgModulesAnalyzer.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isComponentAlreadyDeclaredInModules = void 0;
    var core_1 = (init_core(), __toCommonJS(core_exports));
    var reflectionCapabilities = new core_1.\u0275ReflectionCapabilities();
    exports.isComponentAlreadyDeclaredInModules = (componentToFind, moduleDeclarations, moduleImports) => {
      if (moduleDeclarations && moduleDeclarations.some((declaration) => declaration === componentToFind)) {
        return true;
      }
      if (!moduleImports) {
        return false;
      }
      return moduleImports.some((importItem) => {
        const extractedNgModuleMetadata = extractNgModuleMetadata(importItem);
        if (!extractedNgModuleMetadata) {
          return false;
        }
        return exports.isComponentAlreadyDeclaredInModules(componentToFind, extractedNgModuleMetadata.declarations, extractedNgModuleMetadata.imports);
      });
    };
    var extractNgModuleMetadata = (importItem) => {
      const target = importItem && importItem.ngModule ? importItem.ngModule : importItem;
      const decorators = reflectionCapabilities.annotations(target);
      if (!decorators || decorators.length === 0) {
        return null;
      }
      const ngModuleDecorator = decorators.find((decorator) => decorator instanceof core_1.NgModule);
      if (!ngModuleDecorator) {
        return null;
      }
      return ngModuleDecorator;
    };
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/utils/NgComponentAnalyzer.js
var require_NgComponentAnalyzer = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/utils/NgComponentAnalyzer.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getComponentDecoratorMetadata = exports.getComponentPropsDecoratorMetadata = exports.isStandaloneComponent = exports.isComponent = exports.isDeclarable = exports.getComponentInputsOutputs = void 0;
    var core_1 = (init_core(), __toCommonJS(core_exports));
    var reflectionCapabilities = new core_1.\u0275ReflectionCapabilities();
    exports.getComponentInputsOutputs = (component) => {
      const componentMetadata = exports.getComponentDecoratorMetadata(component);
      const componentPropsMetadata = exports.getComponentPropsDecoratorMetadata(component);
      const initialValue = {
        inputs: [],
        outputs: []
      };
      if (componentMetadata && componentMetadata.inputs) {
        initialValue.inputs.push(...componentMetadata.inputs.map((i) => ({
          propName: i,
          templateName: i
        })));
      }
      if (componentMetadata && componentMetadata.outputs) {
        initialValue.outputs.push(...componentMetadata.outputs.map((i) => ({
          propName: i,
          templateName: i
        })));
      }
      if (!componentPropsMetadata) {
        return initialValue;
      }
      return Object.entries(componentPropsMetadata).reduce((previousValue, [propertyName, values]) => {
        var _a, _b;
        const value = values.find((v) => v instanceof core_1.Input || v instanceof core_1.Output);
        if (value instanceof core_1.Input) {
          const inputToAdd = {
            propName: propertyName,
            templateName: (_a = value.bindingPropertyName) !== null && _a !== void 0 ? _a : propertyName
          };
          const previousInputsFiltered = previousValue.inputs.filter((i) => i.templateName !== propertyName);
          return Object.assign(Object.assign({}, previousValue), {
            inputs: [...previousInputsFiltered, inputToAdd]
          });
        }
        if (value instanceof core_1.Output) {
          const outputToAdd = {
            propName: propertyName,
            templateName: (_b = value.bindingPropertyName) !== null && _b !== void 0 ? _b : propertyName
          };
          const previousOutputsFiltered = previousValue.outputs.filter((i) => i.templateName !== propertyName);
          return Object.assign(Object.assign({}, previousValue), {
            outputs: [...previousOutputsFiltered, outputToAdd]
          });
        }
        return previousValue;
      }, initialValue);
    };
    exports.isDeclarable = (component) => {
      if (!component) {
        return false;
      }
      const decorators = reflectionCapabilities.annotations(component);
      return !!(decorators || []).find((d) => d instanceof core_1.Directive || d instanceof core_1.Pipe || d instanceof core_1.Component);
    };
    exports.isComponent = (component) => {
      if (!component) {
        return false;
      }
      const decorators = reflectionCapabilities.annotations(component);
      return (decorators || []).some((d) => d instanceof core_1.Component);
    };
    exports.isStandaloneComponent = (component) => {
      if (!component) {
        return false;
      }
      const decorators = reflectionCapabilities.annotations(component);
      return (decorators || []).some((d) => d instanceof core_1.Component && d.standalone);
    };
    exports.getComponentPropsDecoratorMetadata = (component) => {
      return reflectionCapabilities.propMetadata(component);
    };
    exports.getComponentDecoratorMetadata = (component) => {
      const decorators = reflectionCapabilities.annotations(component);
      return decorators.reverse().find((d) => d instanceof core_1.Component);
    };
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/StorybookWrapperComponent.js
var require_StorybookWrapperComponent = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/StorybookWrapperComponent.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports && exports.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    var __param = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createStorybookWrapperComponent = void 0;
    var core_1 = (init_core(), __toCommonJS(core_exports));
    var rxjs_1 = require_cjs();
    var operators_1 = (init_operators(), __toCommonJS(operators_exports));
    var StorybookProvider_1 = require_StorybookProvider();
    var NgComponentAnalyzer_1 = require_NgComponentAnalyzer();
    var getNonInputsOutputsProps = (ngComponentInputsOutputs, props = {}) => {
      const inputs = ngComponentInputsOutputs.inputs.filter((i) => i.templateName in props).map((i) => i.templateName);
      const outputs = ngComponentInputsOutputs.outputs.filter((o) => o.templateName in props).map((o) => o.templateName);
      return Object.keys(props).filter((k) => ![...inputs, ...outputs].includes(k));
    };
    exports.createStorybookWrapperComponent = (selector, template, storyComponent, styles, initialProps) => {
      const viewChildSelector = storyComponent !== null && storyComponent !== void 0 ? storyComponent : "__storybook-noop";
      let StorybookWrapperComponent = class StorybookWrapperComponent {
        constructor(storyProps$, changeDetectorRef) {
          this.storyProps$ = storyProps$;
          this.changeDetectorRef = changeDetectorRef;
          this.storyComponent = storyComponent !== null && storyComponent !== void 0 ? storyComponent : "";
        }
        ngOnInit() {
          this.storyWrapperPropsSubscription = this.storyProps$.subscribe((storyProps = {}) => {
            Object.assign(this, storyProps);
            this.changeDetectorRef.detectChanges();
            this.changeDetectorRef.markForCheck();
          });
        }
        ngAfterViewInit() {
          if (this.storyComponentElementRef) {
            const ngComponentInputsOutputs = NgComponentAnalyzer_1.getComponentInputsOutputs(storyComponent);
            const initialOtherProps = getNonInputsOutputsProps(ngComponentInputsOutputs, initialProps);
            initialOtherProps.forEach((p) => {
              this.storyComponentElementRef[p] = initialProps[p];
            });
            this.storyComponentViewContainerRef.injector.get(core_1.ChangeDetectorRef).markForCheck();
            this.changeDetectorRef.detectChanges();
            this.storyComponentPropsSubscription = this.storyProps$.pipe(operators_1.skip(1), operators_1.map((props) => {
              const propsKeyToKeep = getNonInputsOutputsProps(ngComponentInputsOutputs, props);
              return propsKeyToKeep.reduce((acc, p) => Object.assign(Object.assign({}, acc), {
                [p]: props[p]
              }), {});
            })).subscribe((props) => {
              Object.assign(this.storyComponentElementRef, props);
              this.storyComponentViewContainerRef.injector.get(core_1.ChangeDetectorRef).markForCheck();
              this.changeDetectorRef.detectChanges();
            });
          }
        }
        ngOnDestroy() {
          if (this.storyComponentPropsSubscription != null) {
            this.storyComponentPropsSubscription.unsubscribe();
          }
          if (this.storyWrapperPropsSubscription != null) {
            this.storyWrapperPropsSubscription.unsubscribe();
          }
        }
      };
      __decorate([core_1.ViewChild(viewChildSelector, {
        static: true
      }), __metadata("design:type", core_1.ElementRef)], StorybookWrapperComponent.prototype, "storyComponentElementRef", void 0);
      __decorate([core_1.ViewChild(viewChildSelector, {
        read: core_1.ViewContainerRef,
        static: true
      }), __metadata("design:type", core_1.ViewContainerRef)], StorybookWrapperComponent.prototype, "storyComponentViewContainerRef", void 0);
      StorybookWrapperComponent = __decorate([core_1.Component({
        selector,
        template,
        styles
      }), __param(0, core_1.Inject(StorybookProvider_1.STORY_PROPS)), __metadata("design:paramtypes", [rxjs_1.Subject, core_1.ChangeDetectorRef])], StorybookWrapperComponent);
      return StorybookWrapperComponent;
    };
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/ComputesTemplateFromComponent.js
var require_ComputesTemplateFromComponent = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/ComputesTemplateFromComponent.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.computesTemplateSourceFromComponent = exports.computesTemplateFromComponent = void 0;
    var NgComponentAnalyzer_1 = require_NgComponentAnalyzer();
    var separateInputsOutputsAttributes = (ngComponentInputsOutputs, props = {}) => {
      const inputs = ngComponentInputsOutputs.inputs.filter((i) => i.templateName in props).map((i) => i.templateName);
      const outputs = ngComponentInputsOutputs.outputs.filter((o) => o.templateName in props).map((o) => o.templateName);
      return {
        inputs,
        outputs,
        otherProps: Object.keys(props).filter((k) => ![...inputs, ...outputs].includes(k))
      };
    };
    exports.computesTemplateFromComponent = (component, initialProps, innerTemplate = "") => {
      const ngComponentMetadata = NgComponentAnalyzer_1.getComponentDecoratorMetadata(component);
      const ngComponentInputsOutputs = NgComponentAnalyzer_1.getComponentInputsOutputs(component);
      if (!ngComponentMetadata.selector) {
        return `<ng-container *ngComponentOutlet="storyComponent"></ng-container>`;
      }
      const {
        inputs: initialInputs,
        outputs: initialOutputs
      } = separateInputsOutputsAttributes(ngComponentInputsOutputs, initialProps);
      const templateInputs = initialInputs.length > 0 ? ` ${initialInputs.map((i) => `[${i}]="${i}"`).join(" ")}` : "";
      const templateOutputs = initialOutputs.length > 0 ? ` ${initialOutputs.map((i) => `(${i})="${i}($event)"`).join(" ")}` : "";
      return buildTemplate(ngComponentMetadata.selector, innerTemplate, templateInputs, templateOutputs);
    };
    var createAngularInputProperty = ({
      propertyName,
      value,
      argType
    }) => {
      const {
        name: type = null,
        summary = null
      } = (argType === null || argType === void 0 ? void 0 : argType.type) || {};
      let templateValue = type === "enum" && !!summary ? `${summary}.${value}` : value;
      const actualType = type === "enum" && summary ? "enum" : typeof value;
      const requiresBrackets = ["object", "any", "boolean", "enum", "number"].includes(actualType);
      if (typeof value === "object") {
        templateValue = propertyName;
      }
      return `${requiresBrackets ? "[" : ""}${propertyName}${requiresBrackets ? "]" : ""}="${templateValue}"`;
    };
    exports.computesTemplateSourceFromComponent = (component, initialProps, argTypes) => {
      const ngComponentMetadata = NgComponentAnalyzer_1.getComponentDecoratorMetadata(component);
      if (!ngComponentMetadata) {
        return null;
      }
      if (!ngComponentMetadata.selector) {
        return `<ng-container *ngComponentOutlet="${component.name}"></ng-container>`;
      }
      const ngComponentInputsOutputs = NgComponentAnalyzer_1.getComponentInputsOutputs(component);
      const {
        inputs: initialInputs,
        outputs: initialOutputs
      } = separateInputsOutputsAttributes(ngComponentInputsOutputs, initialProps);
      const templateInputs = initialInputs.length > 0 ? ` ${initialInputs.map((propertyName) => createAngularInputProperty({
        propertyName,
        value: initialProps[propertyName],
        argType: argTypes === null || argTypes === void 0 ? void 0 : argTypes[propertyName]
      })).join(" ")}` : "";
      const templateOutputs = initialOutputs.length > 0 ? ` ${initialOutputs.map((i) => `(${i})="${i}($event)"`).join(" ")}` : "";
      return buildTemplate(ngComponentMetadata.selector, "", templateInputs, templateOutputs);
    };
    var buildTemplate = (selector, innerTemplate, inputs, outputs) => {
      const voidElements = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
      const firstSelector = selector.split(",")[0];
      const templateReplacers = [[/(^.*?)(?=[,])/, "$1"], [/(^\..+)/, "div$1"], [/(^\[.+?])/, "div$1"], [/([\w[\]]+)(\s*,[\w\s-[\],]+)+/, `$1`], [/#([\w-]+)/, ` id="$1"`], [/((\.[\w-]+)+)/, (_, c) => ` class="${c.split`.`.join` `.trim()}"`], [/(\[.+?])/g, (_, a) => ` ${a.slice(1, -1)}`], [/([\S]+)(.*)/, (template, elementSelector) => {
        return voidElements.some((element) => elementSelector === element) ? template.replace(/([\S]+)(.*)/, `<$1$2${inputs}${outputs} />`) : template.replace(/([\S]+)(.*)/, `<$1$2${inputs}${outputs}>${innerTemplate}</$1>`);
      }]];
      return templateReplacers.reduce((prevSelector, [searchValue, replacer]) => prevSelector.replace(searchValue, replacer), firstSelector);
    };
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/StorybookModule.js
var require_StorybookModule = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/StorybookModule.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createStorybookModule = exports.getStorybookModuleMetadata = void 0;
    var core_1 = (init_core(), __toCommonJS(core_exports));
    var platform_browser_1 = (init_platform_browser(), __toCommonJS(platform_browser_exports));
    var ts_dedent_1 = __importDefault((init_esm(), __toCommonJS(esm_exports)));
    var util_deprecate_1 = __importDefault(require_browser());
    var StorybookProvider_1 = require_StorybookProvider();
    var NgModulesAnalyzer_1 = require_NgModulesAnalyzer();
    var NgComponentAnalyzer_1 = require_NgComponentAnalyzer();
    var StorybookWrapperComponent_1 = require_StorybookWrapperComponent();
    var ComputesTemplateFromComponent_1 = require_ComputesTemplateFromComponent();
    var deprecatedStoryComponentWarning = util_deprecate_1.default(() => {
    }, ts_dedent_1.default`\`component\` story return value is deprecated, and will be removed in Storybook 7.0.
        Instead, use \`export const default = () => ({ component: AppComponent });\`
        or
        \`\`\`
        export const Primary: Story = () => ({});
        Primary.parameters = { component: AppComponent };
        \`\`\`
        Read more at 
        - https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-angular-story-component).
        - https://storybook.js.org/docs/angular/writing-stories/parameters
      `);
    exports.getStorybookModuleMetadata = ({
      storyFnAngular,
      component: annotatedComponent,
      targetSelector
    }, storyProps$) => {
      var _a, _b, _c, _d, _e;
      const {
        component: storyComponent,
        props,
        styles,
        moduleMetadata = {}
      } = storyFnAngular;
      let {
        template
      } = storyFnAngular;
      if (storyComponent) {
        deprecatedStoryComponentWarning();
      }
      const component = storyComponent !== null && storyComponent !== void 0 ? storyComponent : annotatedComponent;
      if (hasNoTemplate(template) && component) {
        template = ComputesTemplateFromComponent_1.computesTemplateFromComponent(component, props, "");
      }
      const ComponentToInject = StorybookWrapperComponent_1.createStorybookWrapperComponent(targetSelector, template, component, styles, props);
      const isStandalone2 = NgComponentAnalyzer_1.isStandaloneComponent(component);
      const requiresComponentDeclaration = NgComponentAnalyzer_1.isDeclarable(component) && !NgModulesAnalyzer_1.isComponentAlreadyDeclaredInModules(component, moduleMetadata.declarations, moduleMetadata.imports) && !isStandalone2;
      return {
        declarations: [...requiresComponentDeclaration ? [component] : [], ComponentToInject, ...(_a = moduleMetadata.declarations) !== null && _a !== void 0 ? _a : []],
        imports: [platform_browser_1.BrowserModule, ...isStandalone2 ? [component] : [], ...(_b = moduleMetadata.imports) !== null && _b !== void 0 ? _b : []],
        providers: [StorybookProvider_1.storyPropsProvider(storyProps$), ...(_c = moduleMetadata.providers) !== null && _c !== void 0 ? _c : []],
        entryComponents: [...(_d = moduleMetadata.entryComponents) !== null && _d !== void 0 ? _d : []],
        schemas: [...(_e = moduleMetadata.schemas) !== null && _e !== void 0 ? _e : []],
        bootstrap: [ComponentToInject]
      };
    };
    exports.createStorybookModule = (ngModule) => {
      let StorybookModule = class StorybookModule {
      };
      StorybookModule = __decorate([core_1.NgModule(ngModule)], StorybookModule);
      return StorybookModule;
    };
    function hasNoTemplate(template) {
      return template === null || template === void 0;
    }
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/AbstractRenderer.js
var require_AbstractRenderer = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/AbstractRenderer.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
          return m[k];
        }
      });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AbstractRenderer = void 0;
    var core_1 = (init_core(), __toCommonJS(core_exports));
    var platform_browser_dynamic_1 = (init_platform_browser_dynamic(), __toCommonJS(platform_browser_dynamic_exports));
    var rxjs_1 = require_cjs();
    var telejson_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var StorybookModule_1 = require_StorybookModule();
    var platformRef;
    function getPlatform2(newPlatform) {
      if (!platformRef || newPlatform) {
        platformRef = platform_browser_dynamic_1.platformBrowserDynamic();
      }
      return platformRef;
    }
    var AbstractRenderer = class {
      constructor(storyId) {
        this.storyId = storyId;
        if (typeof NODE_ENV === "string" && NODE_ENV !== "development") {
          try {
            core_1.enableProdMode();
          } catch (e) {
            console.debug(e);
          }
        }
      }
      static resetPlatformBrowserDynamic() {
        return new Promise((resolve) => {
          if (platformRef && !platformRef.destroyed) {
            platformRef.onDestroy(() => __awaiter2(this, void 0, void 0, function* () {
              resolve();
            }));
            platformRef.destroy();
            return;
          }
          resolve();
        }).then(() => {
          getPlatform2(true);
        });
      }
      render({
        storyFnAngular,
        forced,
        parameters,
        component,
        targetDOMNode
      }) {
        var _a;
        return __awaiter2(this, void 0, void 0, function* () {
          const targetSelector = `${this.generateTargetSelectorFromStoryId()}`;
          const newStoryProps$ = new rxjs_1.BehaviorSubject(storyFnAngular.props);
          const moduleMetadata = StorybookModule_1.getStorybookModuleMetadata({
            storyFnAngular,
            component,
            targetSelector
          }, newStoryProps$);
          if (!this.fullRendererRequired({
            storyFnAngular,
            moduleMetadata,
            forced
          })) {
            this.storyProps$.next(storyFnAngular.props);
            return;
          }
          yield this.beforeFullRender();
          if (this.storyProps$) {
            this.storyProps$.complete();
          }
          this.storyProps$ = newStoryProps$;
          this.initAngularRootElement(targetDOMNode, targetSelector);
          yield getPlatform2().bootstrapModule(StorybookModule_1.createStorybookModule(moduleMetadata), (_a = parameters.bootstrapModuleOptions) !== null && _a !== void 0 ? _a : void 0);
          yield this.afterFullRender();
        });
      }
      generateTargetSelectorFromStoryId() {
        const invalidHtmlTag = /[^A-Za-z0-9-]/g;
        const storyIdIsInvalidHtmlTagName = invalidHtmlTag.test(this.storyId);
        return storyIdIsInvalidHtmlTagName ? `sb-${this.storyId.replace(invalidHtmlTag, "")}-component` : this.storyId;
      }
      initAngularRootElement(targetDOMNode, targetSelector) {
        targetDOMNode.innerHTML = "";
        targetDOMNode.appendChild(document.createElement(targetSelector));
      }
      fullRendererRequired({
        storyFnAngular,
        moduleMetadata,
        forced
      }) {
        var _a;
        const {
          previousStoryRenderInfo
        } = this;
        const currentStoryRender = {
          storyFnAngular,
          moduleMetadataSnapshot: telejson_1.stringify(moduleMetadata)
        };
        this.previousStoryRenderInfo = currentStoryRender;
        if (!forced || !this.storyProps$) {
          return true;
        }
        const hasChangedTemplate = !!(storyFnAngular === null || storyFnAngular === void 0 ? void 0 : storyFnAngular.template) && ((_a = previousStoryRenderInfo === null || previousStoryRenderInfo === void 0 ? void 0 : previousStoryRenderInfo.storyFnAngular) === null || _a === void 0 ? void 0 : _a.template) !== storyFnAngular.template;
        if (hasChangedTemplate) {
          return true;
        }
        const hasChangedModuleMetadata = currentStoryRender.moduleMetadataSnapshot !== (previousStoryRenderInfo === null || previousStoryRenderInfo === void 0 ? void 0 : previousStoryRenderInfo.moduleMetadataSnapshot);
        return hasChangedModuleMetadata;
      }
    };
    exports.AbstractRenderer = AbstractRenderer;
    AbstractRenderer.resetCompiledComponents = () => __awaiter2(void 0, void 0, void 0, function* () {
      try {
        const {
          \u0275resetCompiledComponents
        } = yield Promise.resolve().then(() => __importStar((init_core(), __toCommonJS(core_exports))));
        \u0275resetCompiledComponents();
      } catch (e) {
      }
    });
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/DocsRenderer.js
var require_DocsRenderer = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/DocsRenderer.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DocsRenderer = void 0;
    var addons_1 = (init_public_api(), __toCommonJS(public_api_exports));
    var core_events_1 = __importDefault((init_esm2(), __toCommonJS(esm_exports2)));
    var AbstractRenderer_1 = require_AbstractRenderer();
    var DocsRenderer = class extends AbstractRenderer_1.AbstractRenderer {
      render(options) {
        const _super = Object.create(null, {
          render: {
            get: () => super.render
          }
        });
        return __awaiter2(this, void 0, void 0, function* () {
          const channel = addons_1.addons.getChannel();
          channel.once(core_events_1.default.STORY_CHANGED, () => __awaiter2(this, void 0, void 0, function* () {
            yield DocsRenderer.resetPlatformBrowserDynamic();
          }));
          channel.once(core_events_1.default.DOCS_RENDERED, () => __awaiter2(this, void 0, void 0, function* () {
            yield DocsRenderer.resetPlatformBrowserDynamic();
          }));
          yield _super.render.call(this, Object.assign(Object.assign({}, options), {
            forced: false
          }));
        });
      }
      beforeFullRender() {
        return __awaiter2(this, void 0, void 0, function* () {
        });
      }
      afterFullRender() {
        return __awaiter2(this, void 0, void 0, function* () {
          yield AbstractRenderer_1.AbstractRenderer.resetCompiledComponents();
        });
      }
    };
    exports.DocsRenderer = DocsRenderer;
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/CanvasRenderer.js
var require_CanvasRenderer = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/CanvasRenderer.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CanvasRenderer = void 0;
    var AbstractRenderer_1 = require_AbstractRenderer();
    var CanvasRenderer = class extends AbstractRenderer_1.AbstractRenderer {
      render(options) {
        const _super = Object.create(null, {
          render: {
            get: () => super.render
          }
        });
        return __awaiter2(this, void 0, void 0, function* () {
          yield _super.render.call(this, options);
        });
      }
      beforeFullRender() {
        return __awaiter2(this, void 0, void 0, function* () {
          yield CanvasRenderer.resetPlatformBrowserDynamic();
        });
      }
      afterFullRender() {
        return __awaiter2(this, void 0, void 0, function* () {
          yield AbstractRenderer_1.AbstractRenderer.resetCompiledComponents();
        });
      }
    };
    exports.CanvasRenderer = CanvasRenderer;
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/RendererFactory.js
var require_RendererFactory = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-beta/RendererFactory.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.clearRootHTMLElement = exports.getRenderType = exports.RendererFactory = void 0;
    var AbstractRenderer_1 = require_AbstractRenderer();
    var DocsRenderer_1 = require_DocsRenderer();
    var CanvasRenderer_1 = require_CanvasRenderer();
    var RendererFactory = class {
      constructor() {
        this.rendererMap = /* @__PURE__ */ new Map();
      }
      getRendererInstance(storyId, targetDOMNode) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (targetDOMNode === null) {
            return null;
          }
          const renderType = exports.getRenderType(targetDOMNode);
          if (this.lastRenderType && this.lastRenderType !== renderType) {
            yield AbstractRenderer_1.AbstractRenderer.resetPlatformBrowserDynamic();
            clearRootHTMLElement(renderType);
            this.rendererMap.clear();
          }
          if (!this.rendererMap.has(storyId)) {
            this.rendererMap.set(storyId, this.buildRenderer(storyId, renderType));
          }
          this.lastRenderType = renderType;
          return this.rendererMap.get(storyId);
        });
      }
      buildRenderer(storyId, renderType) {
        if (renderType === "docs") {
          return new DocsRenderer_1.DocsRenderer(storyId);
        }
        return new CanvasRenderer_1.CanvasRenderer(storyId);
      }
    };
    exports.RendererFactory = RendererFactory;
    exports.getRenderType = (targetDOMNode) => {
      return targetDOMNode.id === "root" ? "canvas" : "docs";
    };
    function clearRootHTMLElement(renderType) {
      switch (renderType) {
        case "canvas":
          global.document.getElementById("docs-root").innerHTML = "";
          break;
        case "docs":
          global.document.getElementById("root").innerHTML = "";
          break;
        default:
          break;
      }
    }
    exports.clearRootHTMLElement = clearRootHTMLElement;
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/preview/render.js
var require_render = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/preview/render.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.renderToDOM = exports.render = exports.rendererFactory = void 0;
    var helpers_1 = require_helpers();
    var RendererFactory_1 = require_RendererFactory();
    exports.rendererFactory = new RendererFactory_1.RendererFactory();
    exports.render = (props) => ({
      props
    });
    function renderToDOM({
      storyFn,
      showMain,
      forceRemount,
      storyContext: {
        parameters,
        component
      },
      id
    }, element) {
      return __awaiter2(this, void 0, void 0, function* () {
        showMain();
        if (parameters.angularLegacyRendering) {
          helpers_1.renderNgApp(storyFn, !forceRemount);
          return;
        }
        const renderer = yield exports.rendererFactory.getRendererInstance(id, element);
        yield renderer.render({
          storyFnAngular: storyFn(),
          component,
          parameters,
          forced: !forceRemount,
          targetDOMNode: element
        });
      });
    }
    exports.renderToDOM = renderToDOM;
  }
});

export {
  require_NgComponentAnalyzer,
  require_ComputesTemplateFromComponent,
  require_StorybookModule,
  require_AbstractRenderer,
  require_render
};
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license Angular v14.1.0
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */
/**
 * @license Angular v14.1.1
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */
//# sourceMappingURL=chunk-LJ3IEFZ4.js.map

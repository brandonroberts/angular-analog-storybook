{
  "version": 3,
  "sources": ["../../../../node_modules/memoizerific/memoizerific.js"],
  "sourcesContent": ["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.memoizerific = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\nmodule.exports = function(forceSimilar) {\n\tif (typeof Map !== 'function' || forceSimilar) {\n\t\tvar Similar = _dereq_('./similar');\n\t\treturn new Similar();\n\t}\n\telse {\n\t\treturn new Map();\n\t}\n}\n\n},{\"./similar\":2}],2:[function(_dereq_,module,exports){\nfunction Similar() {\n\tthis.list = [];\n\tthis.lastItem = undefined;\n\tthis.size = 0;\n\n\treturn this;\n}\n\nSimilar.prototype.get = function(key) {\n\tvar index;\n\n\tif (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n\t\treturn this.lastItem.val;\n\t}\n\n\tindex = this.indexOf(key);\n\tif (index >= 0) {\n\t\tthis.lastItem = this.list[index];\n\t\treturn this.list[index].val;\n\t}\n\n\treturn undefined;\n};\n\nSimilar.prototype.set = function(key, val) {\n\tvar index;\n\n\tif (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n\t\tthis.lastItem.val = val;\n\t\treturn this;\n\t}\n\n\tindex = this.indexOf(key);\n\tif (index >= 0) {\n\t\tthis.lastItem = this.list[index];\n\t\tthis.list[index].val = val;\n\t\treturn this;\n\t}\n\n\tthis.lastItem = { key: key, val: val };\n\tthis.list.push(this.lastItem);\n\tthis.size++;\n\n\treturn this;\n};\n\nSimilar.prototype.delete = function(key) {\n\tvar index;\n\n\tif (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n\t\tthis.lastItem = undefined;\n\t}\n\n\tindex = this.indexOf(key);\n\tif (index >= 0) {\n\t\tthis.size--;\n\t\treturn this.list.splice(index, 1)[0];\n\t}\n\n\treturn undefined;\n};\n\n\n// important that has() doesn't use get() in case an existing key has a falsy value, in which case has() would return false\nSimilar.prototype.has = function(key) {\n\tvar index;\n\n\tif (this.lastItem && this.isEqual(this.lastItem.key, key)) {\n\t\treturn true;\n\t}\n\n\tindex = this.indexOf(key);\n\tif (index >= 0) {\n\t\tthis.lastItem = this.list[index];\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\nSimilar.prototype.forEach = function(callback, thisArg) {\n\tvar i;\n\tfor (i = 0; i < this.size; i++) {\n\t\tcallback.call(thisArg || this, this.list[i].val, this.list[i].key, this);\n\t}\n};\n\nSimilar.prototype.indexOf = function(key) {\n\tvar i;\n\tfor (i = 0; i < this.size; i++) {\n\t\tif (this.isEqual(this.list[i].key, key)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\n// check if the numbers are equal, or whether they are both precisely NaN (isNaN returns true for all non-numbers)\nSimilar.prototype.isEqual = function(val1, val2) {\n\treturn val1 === val2 || (val1 !== val1 && val2 !== val2);\n};\n\nmodule.exports = Similar;\n},{}],3:[function(_dereq_,module,exports){\nvar MapOrSimilar = _dereq_('map-or-similar');\n\nmodule.exports = function (limit) {\n\tvar cache = new MapOrSimilar(undefined === 'true'),\n\t\tlru = [];\n\n\treturn function (fn) {\n\t\tvar memoizerific = function () {\n\t\t\tvar currentCache = cache,\n\t\t\t\tnewMap,\n\t\t\t\tfnResult,\n\t\t\t\targsLengthMinusOne = arguments.length - 1,\n\t\t\t\tlruPath = Array(argsLengthMinusOne + 1),\n\t\t\t\tisMemoized = true,\n\t\t\t\ti;\n\n\t\t\tif ((memoizerific.numArgs || memoizerific.numArgs === 0) && memoizerific.numArgs !== argsLengthMinusOne + 1) {\n\t\t\t\tthrow new Error('Memoizerific functions should always be called with the same number of arguments');\n\t\t\t}\n\n\t\t\t// loop through each argument to traverse the map tree\n\t\t\tfor (i = 0; i < argsLengthMinusOne; i++) {\n\t\t\t\tlruPath[i] = {\n\t\t\t\t\tcacheItem: currentCache,\n\t\t\t\t\targ: arguments[i]\n\t\t\t\t};\n\n\t\t\t\t// climb through the hierarchical map tree until the second-last argument has been found, or an argument is missing.\n\t\t\t\t// if all arguments up to the second-last have been found, this will potentially be a cache hit (determined later)\n\t\t\t\tif (currentCache.has(arguments[i])) {\n\t\t\t\t\tcurrentCache = currentCache.get(arguments[i]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tisMemoized = false;\n\n\t\t\t\t// make maps until last value\n\t\t\t\tnewMap = new MapOrSimilar(undefined === 'true');\n\t\t\t\tcurrentCache.set(arguments[i], newMap);\n\t\t\t\tcurrentCache = newMap;\n\t\t\t}\n\n\t\t\t// we are at the last arg, check if it is really memoized\n\t\t\tif (isMemoized) {\n\t\t\t\tif (currentCache.has(arguments[argsLengthMinusOne])) {\n\t\t\t\t\tfnResult = currentCache.get(arguments[argsLengthMinusOne]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tisMemoized = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!isMemoized) {\n\t\t\t\tfnResult = fn.apply(null, arguments);\n\t\t\t\tcurrentCache.set(arguments[argsLengthMinusOne], fnResult);\n\t\t\t}\n\n\t\t\tif (limit > 0) {\n\t\t\t\tlruPath[argsLengthMinusOne] = {\n\t\t\t\t\tcacheItem: currentCache,\n\t\t\t\t\targ: arguments[argsLengthMinusOne]\n\t\t\t\t};\n\n\t\t\t\tif (isMemoized) {\n\t\t\t\t\tmoveToMostRecentLru(lru, lruPath);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlru.push(lruPath);\n\t\t\t\t}\n\n\t\t\t\tif (lru.length > limit) {\n\t\t\t\t\tremoveCachedResult(lru.shift());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemoizerific.wasMemoized = isMemoized;\n\t\t\tmemoizerific.numArgs = argsLengthMinusOne + 1;\n\n\t\t\treturn fnResult;\n\t\t};\n\n\t\tmemoizerific.limit = limit;\n\t\tmemoizerific.wasMemoized = false;\n\t\tmemoizerific.cache = cache;\n\t\tmemoizerific.lru = lru;\n\n\t\treturn memoizerific;\n\t};\n};\n\n// move current args to most recent position\nfunction moveToMostRecentLru(lru, lruPath) {\n\tvar lruLen = lru.length,\n\t\tlruPathLen = lruPath.length,\n\t\tisMatch,\n\t\ti, ii;\n\n\tfor (i = 0; i < lruLen; i++) {\n\t\tisMatch = true;\n\t\tfor (ii = 0; ii < lruPathLen; ii++) {\n\t\t\tif (!isEqual(lru[i][ii].arg, lruPath[ii].arg)) {\n\t\t\t\tisMatch = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isMatch) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlru.push(lru.splice(i, 1)[0]);\n}\n\n// remove least recently used cache item and all dead branches\nfunction removeCachedResult(removedLru) {\n\tvar removedLruLen = removedLru.length,\n\t\tcurrentLru = removedLru[removedLruLen - 1],\n\t\ttmp,\n\t\ti;\n\n\tcurrentLru.cacheItem.delete(currentLru.arg);\n\n\t// walk down the tree removing dead branches (size 0) along the way\n\tfor (i = removedLruLen - 2; i >= 0; i--) {\n\t\tcurrentLru = removedLru[i];\n\t\ttmp = currentLru.cacheItem.get(currentLru.arg);\n\n\t\tif (!tmp || !tmp.size) {\n\t\t\tcurrentLru.cacheItem.delete(currentLru.arg);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// check if the numbers are equal, or whether they are both precisely NaN (isNaN returns true for all non-numbers)\nfunction isEqual(val1, val2) {\n\treturn val1 === val2 || (val1 !== val1 && val2 !== val2);\n}\n},{\"map-or-similar\":1}]},{},[3])(3)\n});"],
  "mappings": "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",
  "names": ["f", "exports", "module", "define", "amd", "g", "window", "global", "self", "memoizerific", "e", "t", "n", "r", "s", "o", "u", "a", "require", "i", "Error", "code", "l", "call", "length", "_dereq_", "forceSimilar", "Map", "Similar", "list", "lastItem", "undefined", "size", "prototype", "get", "key", "index", "isEqual", "val", "indexOf", "set", "push", "delete", "splice", "has", "forEach", "callback", "thisArg", "val1", "val2", "MapOrSimilar", "limit", "cache", "lru", "fn", "currentCache", "newMap", "fnResult", "argsLengthMinusOne", "arguments", "lruPath", "Array", "isMemoized", "numArgs", "cacheItem", "arg", "apply", "moveToMostRecentLru", "removeCachedResult", "shift", "wasMemoized", "lruLen", "lruPathLen", "isMatch", "ii", "removedLru", "removedLruLen", "currentLru", "tmp"]
}

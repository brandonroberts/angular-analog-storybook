import {
  require_ComputesTemplateFromComponent
} from "./chunk-LJ3IEFZ4.js";
import {
  require_es_reflect_get,
  require_is_data_descriptor
} from "./chunk-J5DFVZVL.js";
import {
  require_es_map
} from "./chunk-OQZL3WW3.js";
import {
  require_es_reflect_construct
} from "./chunk-RR2HNM4P.js";
import {
  esm_exports,
  init_esm
} from "./chunk-KTUVAV7V.js";
import {
  require_es_weak_map
} from "./chunk-RM5OFEJP.js";
import {
  require_path
} from "./chunk-OPAZLAKG.js";
import {
  require_array_species_create,
  require_correct_prototype_getter,
  require_freezing,
  require_object_get_prototype_of,
  require_object_is_extensible
} from "./chunk-WDY4P2NX.js";
import {
  require_a_callable,
  require_a_possible_prototype,
  require_an_object,
  require_create_property_descriptor,
  require_descriptors,
  require_es_object_to_string,
  require_export,
  require_fails,
  require_function_apply,
  require_function_call,
  require_function_uncurry_this,
  require_get_built_in,
  require_global,
  require_is_object,
  require_length_of_array_like,
  require_object_define_property,
  require_object_get_own_property_descriptor,
  require_object_set_prototype_of,
  require_own_keys,
  require_set_to_string_tag,
  require_shared,
  require_to_object,
  require_to_property_key
} from "./chunk-IPK6NK5O.js";
import {
  require_window
} from "./chunk-XCM4TOIV.js";
import {
  __commonJS,
  __toCommonJS,
  init_define_ngDevMode
} from "./chunk-XN7ES5DP.js";

// node_modules/core-js/modules/es.reflect.apply.js
var require_es_reflect_apply = __commonJS({
  "node_modules/core-js/modules/es.reflect.apply.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var functionApply = require_function_apply();
    var aCallable = require_a_callable();
    var anObject = require_an_object();
    var fails = require_fails();
    var OPTIONAL_ARGUMENTS_LIST = !fails(function() {
      Reflect.apply(function() {
      });
    });
    $({
      target: "Reflect",
      stat: true,
      forced: OPTIONAL_ARGUMENTS_LIST
    }, {
      apply: function apply(target, thisArgument, argumentsList) {
        return functionApply(aCallable(target), thisArgument, anObject(argumentsList));
      }
    });
  }
});

// node_modules/core-js/modules/es.reflect.define-property.js
var require_es_reflect_define_property = __commonJS({
  "node_modules/core-js/modules/es.reflect.define-property.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var anObject = require_an_object();
    var toPropertyKey = require_to_property_key();
    var definePropertyModule = require_object_define_property();
    var fails = require_fails();
    var ERROR_INSTEAD_OF_FALSE = fails(function() {
      Reflect.defineProperty(definePropertyModule.f({}, 1, {
        value: 1
      }), 1, {
        value: 2
      });
    });
    $({
      target: "Reflect",
      stat: true,
      forced: ERROR_INSTEAD_OF_FALSE,
      sham: !DESCRIPTORS
    }, {
      defineProperty: function defineProperty(target, propertyKey, attributes) {
        anObject(target);
        var key = toPropertyKey(propertyKey);
        anObject(attributes);
        try {
          definePropertyModule.f(target, key, attributes);
          return true;
        } catch (error) {
          return false;
        }
      }
    });
  }
});

// node_modules/core-js/modules/es.reflect.delete-property.js
var require_es_reflect_delete_property = __commonJS({
  "node_modules/core-js/modules/es.reflect.delete-property.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var anObject = require_an_object();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    $({
      target: "Reflect",
      stat: true
    }, {
      deleteProperty: function deleteProperty(target, propertyKey) {
        var descriptor = getOwnPropertyDescriptor(anObject(target), propertyKey);
        return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
      }
    });
  }
});

// node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js
var require_es_reflect_get_own_property_descriptor = __commonJS({
  "node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var DESCRIPTORS = require_descriptors();
    var anObject = require_an_object();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    $({
      target: "Reflect",
      stat: true,
      sham: !DESCRIPTORS
    }, {
      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
        return getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
      }
    });
  }
});

// node_modules/core-js/modules/es.reflect.get-prototype-of.js
var require_es_reflect_get_prototype_of = __commonJS({
  "node_modules/core-js/modules/es.reflect.get-prototype-of.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var anObject = require_an_object();
    var objectGetPrototypeOf = require_object_get_prototype_of();
    var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
    $({
      target: "Reflect",
      stat: true,
      sham: !CORRECT_PROTOTYPE_GETTER
    }, {
      getPrototypeOf: function getPrototypeOf(target) {
        return objectGetPrototypeOf(anObject(target));
      }
    });
  }
});

// node_modules/core-js/modules/es.reflect.has.js
var require_es_reflect_has = __commonJS({
  "node_modules/core-js/modules/es.reflect.has.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    $({
      target: "Reflect",
      stat: true
    }, {
      has: function has(target, propertyKey) {
        return propertyKey in target;
      }
    });
  }
});

// node_modules/core-js/modules/es.reflect.is-extensible.js
var require_es_reflect_is_extensible = __commonJS({
  "node_modules/core-js/modules/es.reflect.is-extensible.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var anObject = require_an_object();
    var $isExtensible = require_object_is_extensible();
    $({
      target: "Reflect",
      stat: true
    }, {
      isExtensible: function isExtensible(target) {
        anObject(target);
        return $isExtensible(target);
      }
    });
  }
});

// node_modules/core-js/modules/es.reflect.own-keys.js
var require_es_reflect_own_keys = __commonJS({
  "node_modules/core-js/modules/es.reflect.own-keys.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var ownKeys = require_own_keys();
    $({
      target: "Reflect",
      stat: true
    }, {
      ownKeys
    });
  }
});

// node_modules/core-js/modules/es.reflect.prevent-extensions.js
var require_es_reflect_prevent_extensions = __commonJS({
  "node_modules/core-js/modules/es.reflect.prevent-extensions.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var anObject = require_an_object();
    var FREEZING = require_freezing();
    $({
      target: "Reflect",
      stat: true,
      sham: !FREEZING
    }, {
      preventExtensions: function preventExtensions(target) {
        anObject(target);
        try {
          var objectPreventExtensions = getBuiltIn("Object", "preventExtensions");
          if (objectPreventExtensions)
            objectPreventExtensions(target);
          return true;
        } catch (error) {
          return false;
        }
      }
    });
  }
});

// node_modules/core-js/modules/es.reflect.set.js
var require_es_reflect_set = __commonJS({
  "node_modules/core-js/modules/es.reflect.set.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var call = require_function_call();
    var anObject = require_an_object();
    var isObject = require_is_object();
    var isDataDescriptor = require_is_data_descriptor();
    var fails = require_fails();
    var definePropertyModule = require_object_define_property();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var getPrototypeOf = require_object_get_prototype_of();
    var createPropertyDescriptor = require_create_property_descriptor();
    function set(target, propertyKey, V) {
      var receiver = arguments.length < 4 ? target : arguments[3];
      var ownDescriptor = getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
      var existingDescriptor, prototype, setter;
      if (!ownDescriptor) {
        if (isObject(prototype = getPrototypeOf(target))) {
          return set(prototype, propertyKey, V, receiver);
        }
        ownDescriptor = createPropertyDescriptor(0);
      }
      if (isDataDescriptor(ownDescriptor)) {
        if (ownDescriptor.writable === false || !isObject(receiver))
          return false;
        if (existingDescriptor = getOwnPropertyDescriptorModule.f(receiver, propertyKey)) {
          if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false)
            return false;
          existingDescriptor.value = V;
          definePropertyModule.f(receiver, propertyKey, existingDescriptor);
        } else
          definePropertyModule.f(receiver, propertyKey, createPropertyDescriptor(0, V));
      } else {
        setter = ownDescriptor.set;
        if (setter === void 0)
          return false;
        call(setter, receiver, V);
      }
      return true;
    }
    var MS_EDGE_BUG = fails(function() {
      var Constructor = function() {
      };
      var object = definePropertyModule.f(new Constructor(), "a", {
        configurable: true
      });
      return Reflect.set(Constructor.prototype, "a", 1, object) !== false;
    });
    $({
      target: "Reflect",
      stat: true,
      forced: MS_EDGE_BUG
    }, {
      set
    });
  }
});

// node_modules/core-js/modules/es.reflect.set-prototype-of.js
var require_es_reflect_set_prototype_of = __commonJS({
  "node_modules/core-js/modules/es.reflect.set-prototype-of.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var anObject = require_an_object();
    var aPossiblePrototype = require_a_possible_prototype();
    var objectSetPrototypeOf = require_object_set_prototype_of();
    if (objectSetPrototypeOf)
      $({
        target: "Reflect",
        stat: true
      }, {
        setPrototypeOf: function setPrototypeOf(target, proto) {
          anObject(target);
          aPossiblePrototype(proto);
          try {
            objectSetPrototypeOf(target, proto);
            return true;
          } catch (error) {
            return false;
          }
        }
      });
  }
});

// node_modules/core-js/modules/es.reflect.to-string-tag.js
var require_es_reflect_to_string_tag = __commonJS({
  "node_modules/core-js/modules/es.reflect.to-string-tag.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var global2 = require_global();
    var setToStringTag = require_set_to_string_tag();
    $({
      global: true
    }, {
      Reflect: {}
    });
    setToStringTag(global2.Reflect, "Reflect", true);
  }
});

// node_modules/core-js/es/reflect/index.js
var require_reflect = __commonJS({
  "node_modules/core-js/es/reflect/index.js"(exports, module) {
    init_define_ngDevMode();
    require_es_object_to_string();
    require_es_reflect_apply();
    require_es_reflect_construct();
    require_es_reflect_define_property();
    require_es_reflect_delete_property();
    require_es_reflect_get();
    require_es_reflect_get_own_property_descriptor();
    require_es_reflect_get_prototype_of();
    require_es_reflect_has();
    require_es_reflect_is_extensible();
    require_es_reflect_own_keys();
    require_es_reflect_prevent_extensions();
    require_es_reflect_set();
    require_es_reflect_set_prototype_of();
    require_es_reflect_to_string_tag();
    var path = require_path();
    module.exports = path.Reflect;
  }
});

// node_modules/core-js/internals/reflect-metadata.js
var require_reflect_metadata = __commonJS({
  "node_modules/core-js/internals/reflect-metadata.js"(exports, module) {
    init_define_ngDevMode();
    require_es_map();
    require_es_weak_map();
    var getBuiltIn = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var shared = require_shared();
    var Map = getBuiltIn("Map");
    var WeakMap = getBuiltIn("WeakMap");
    var push = uncurryThis([].push);
    var metadata = shared("metadata");
    var store = metadata.store || (metadata.store = new WeakMap());
    var getOrCreateMetadataMap = function(target, targetKey, create) {
      var targetMetadata = store.get(target);
      if (!targetMetadata) {
        if (!create)
          return;
        store.set(target, targetMetadata = new Map());
      }
      var keyMetadata = targetMetadata.get(targetKey);
      if (!keyMetadata) {
        if (!create)
          return;
        targetMetadata.set(targetKey, keyMetadata = new Map());
      }
      return keyMetadata;
    };
    var ordinaryHasOwnMetadata = function(MetadataKey, O, P) {
      var metadataMap = getOrCreateMetadataMap(O, P, false);
      return metadataMap === void 0 ? false : metadataMap.has(MetadataKey);
    };
    var ordinaryGetOwnMetadata = function(MetadataKey, O, P) {
      var metadataMap = getOrCreateMetadataMap(O, P, false);
      return metadataMap === void 0 ? void 0 : metadataMap.get(MetadataKey);
    };
    var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P) {
      getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
    };
    var ordinaryOwnMetadataKeys = function(target, targetKey) {
      var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
      var keys = [];
      if (metadataMap)
        metadataMap.forEach(function(_, key) {
          push(keys, key);
        });
      return keys;
    };
    var toMetadataKey = function(it) {
      return it === void 0 || typeof it == "symbol" ? it : String(it);
    };
    module.exports = {
      store,
      getMap: getOrCreateMetadataMap,
      has: ordinaryHasOwnMetadata,
      get: ordinaryGetOwnMetadata,
      set: ordinaryDefineOwnMetadata,
      keys: ordinaryOwnMetadataKeys,
      toKey: toMetadataKey
    };
  }
});

// node_modules/core-js/modules/esnext.reflect.define-metadata.js
var require_esnext_reflect_define_metadata = __commonJS({
  "node_modules/core-js/modules/esnext.reflect.define-metadata.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var ReflectMetadataModule = require_reflect_metadata();
    var anObject = require_an_object();
    var toMetadataKey = ReflectMetadataModule.toKey;
    var ordinaryDefineOwnMetadata = ReflectMetadataModule.set;
    $({
      target: "Reflect",
      stat: true
    }, {
      defineMetadata: function defineMetadata(metadataKey, metadataValue, target) {
        var targetKey = arguments.length < 4 ? void 0 : toMetadataKey(arguments[3]);
        ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), targetKey);
      }
    });
  }
});

// node_modules/core-js/modules/esnext.reflect.delete-metadata.js
var require_esnext_reflect_delete_metadata = __commonJS({
  "node_modules/core-js/modules/esnext.reflect.delete-metadata.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var ReflectMetadataModule = require_reflect_metadata();
    var anObject = require_an_object();
    var toMetadataKey = ReflectMetadataModule.toKey;
    var getOrCreateMetadataMap = ReflectMetadataModule.getMap;
    var store = ReflectMetadataModule.store;
    $({
      target: "Reflect",
      stat: true
    }, {
      deleteMetadata: function deleteMetadata(metadataKey, target) {
        var targetKey = arguments.length < 3 ? void 0 : toMetadataKey(arguments[2]);
        var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
        if (metadataMap === void 0 || !metadataMap["delete"](metadataKey))
          return false;
        if (metadataMap.size)
          return true;
        var targetMetadata = store.get(target);
        targetMetadata["delete"](targetKey);
        return !!targetMetadata.size || store["delete"](target);
      }
    });
  }
});

// node_modules/core-js/modules/esnext.reflect.get-metadata.js
var require_esnext_reflect_get_metadata = __commonJS({
  "node_modules/core-js/modules/esnext.reflect.get-metadata.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var ReflectMetadataModule = require_reflect_metadata();
    var anObject = require_an_object();
    var getPrototypeOf = require_object_get_prototype_of();
    var ordinaryHasOwnMetadata = ReflectMetadataModule.has;
    var ordinaryGetOwnMetadata = ReflectMetadataModule.get;
    var toMetadataKey = ReflectMetadataModule.toKey;
    var ordinaryGetMetadata = function(MetadataKey, O, P) {
      var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn)
        return ordinaryGetOwnMetadata(MetadataKey, O, P);
      var parent = getPrototypeOf(O);
      return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : void 0;
    };
    $({
      target: "Reflect",
      stat: true
    }, {
      getMetadata: function getMetadata(metadataKey, target) {
        var targetKey = arguments.length < 3 ? void 0 : toMetadataKey(arguments[2]);
        return ordinaryGetMetadata(metadataKey, anObject(target), targetKey);
      }
    });
  }
});

// node_modules/core-js/internals/array-unique-by.js
var require_array_unique_by = __commonJS({
  "node_modules/core-js/internals/array-unique-by.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    var getBuiltIn = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    var lengthOfArrayLike = require_length_of_array_like();
    var toObject = require_to_object();
    var arraySpeciesCreate = require_array_species_create();
    var Map = getBuiltIn("Map");
    var MapPrototype = Map.prototype;
    var mapForEach = uncurryThis(MapPrototype.forEach);
    var mapHas = uncurryThis(MapPrototype.has);
    var mapSet = uncurryThis(MapPrototype.set);
    var push = uncurryThis([].push);
    module.exports = function uniqueBy(resolver) {
      var that = toObject(this);
      var length = lengthOfArrayLike(that);
      var result = arraySpeciesCreate(that, 0);
      var map = new Map();
      var resolverFunction = resolver != null ? aCallable(resolver) : function(value) {
        return value;
      };
      var index, item, key;
      for (index = 0; index < length; index++) {
        item = that[index];
        key = resolverFunction(item);
        if (!mapHas(map, key))
          mapSet(map, key, item);
      }
      mapForEach(map, function(value) {
        push(result, value);
      });
      return result;
    };
  }
});

// node_modules/core-js/modules/esnext.reflect.get-metadata-keys.js
var require_esnext_reflect_get_metadata_keys = __commonJS({
  "node_modules/core-js/modules/esnext.reflect.get-metadata-keys.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var uncurryThis = require_function_uncurry_this();
    var ReflectMetadataModule = require_reflect_metadata();
    var anObject = require_an_object();
    var getPrototypeOf = require_object_get_prototype_of();
    var $arrayUniqueBy = require_array_unique_by();
    var arrayUniqueBy = uncurryThis($arrayUniqueBy);
    var concat = uncurryThis([].concat);
    var ordinaryOwnMetadataKeys = ReflectMetadataModule.keys;
    var toMetadataKey = ReflectMetadataModule.toKey;
    var ordinaryMetadataKeys = function(O, P) {
      var oKeys = ordinaryOwnMetadataKeys(O, P);
      var parent = getPrototypeOf(O);
      if (parent === null)
        return oKeys;
      var pKeys = ordinaryMetadataKeys(parent, P);
      return pKeys.length ? oKeys.length ? arrayUniqueBy(concat(oKeys, pKeys)) : pKeys : oKeys;
    };
    $({
      target: "Reflect",
      stat: true
    }, {
      getMetadataKeys: function getMetadataKeys(target) {
        var targetKey = arguments.length < 2 ? void 0 : toMetadataKey(arguments[1]);
        return ordinaryMetadataKeys(anObject(target), targetKey);
      }
    });
  }
});

// node_modules/core-js/modules/esnext.reflect.get-own-metadata.js
var require_esnext_reflect_get_own_metadata = __commonJS({
  "node_modules/core-js/modules/esnext.reflect.get-own-metadata.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var ReflectMetadataModule = require_reflect_metadata();
    var anObject = require_an_object();
    var ordinaryGetOwnMetadata = ReflectMetadataModule.get;
    var toMetadataKey = ReflectMetadataModule.toKey;
    $({
      target: "Reflect",
      stat: true
    }, {
      getOwnMetadata: function getOwnMetadata(metadataKey, target) {
        var targetKey = arguments.length < 3 ? void 0 : toMetadataKey(arguments[2]);
        return ordinaryGetOwnMetadata(metadataKey, anObject(target), targetKey);
      }
    });
  }
});

// node_modules/core-js/modules/esnext.reflect.get-own-metadata-keys.js
var require_esnext_reflect_get_own_metadata_keys = __commonJS({
  "node_modules/core-js/modules/esnext.reflect.get-own-metadata-keys.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var ReflectMetadataModule = require_reflect_metadata();
    var anObject = require_an_object();
    var ordinaryOwnMetadataKeys = ReflectMetadataModule.keys;
    var toMetadataKey = ReflectMetadataModule.toKey;
    $({
      target: "Reflect",
      stat: true
    }, {
      getOwnMetadataKeys: function getOwnMetadataKeys(target) {
        var targetKey = arguments.length < 2 ? void 0 : toMetadataKey(arguments[1]);
        return ordinaryOwnMetadataKeys(anObject(target), targetKey);
      }
    });
  }
});

// node_modules/core-js/modules/esnext.reflect.has-metadata.js
var require_esnext_reflect_has_metadata = __commonJS({
  "node_modules/core-js/modules/esnext.reflect.has-metadata.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var ReflectMetadataModule = require_reflect_metadata();
    var anObject = require_an_object();
    var getPrototypeOf = require_object_get_prototype_of();
    var ordinaryHasOwnMetadata = ReflectMetadataModule.has;
    var toMetadataKey = ReflectMetadataModule.toKey;
    var ordinaryHasMetadata = function(MetadataKey, O, P) {
      var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn)
        return true;
      var parent = getPrototypeOf(O);
      return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
    };
    $({
      target: "Reflect",
      stat: true
    }, {
      hasMetadata: function hasMetadata(metadataKey, target) {
        var targetKey = arguments.length < 3 ? void 0 : toMetadataKey(arguments[2]);
        return ordinaryHasMetadata(metadataKey, anObject(target), targetKey);
      }
    });
  }
});

// node_modules/core-js/modules/esnext.reflect.has-own-metadata.js
var require_esnext_reflect_has_own_metadata = __commonJS({
  "node_modules/core-js/modules/esnext.reflect.has-own-metadata.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var ReflectMetadataModule = require_reflect_metadata();
    var anObject = require_an_object();
    var ordinaryHasOwnMetadata = ReflectMetadataModule.has;
    var toMetadataKey = ReflectMetadataModule.toKey;
    $({
      target: "Reflect",
      stat: true
    }, {
      hasOwnMetadata: function hasOwnMetadata(metadataKey, target) {
        var targetKey = arguments.length < 3 ? void 0 : toMetadataKey(arguments[2]);
        return ordinaryHasOwnMetadata(metadataKey, anObject(target), targetKey);
      }
    });
  }
});

// node_modules/core-js/modules/esnext.reflect.metadata.js
var require_esnext_reflect_metadata = __commonJS({
  "node_modules/core-js/modules/esnext.reflect.metadata.js"() {
    init_define_ngDevMode();
    var $ = require_export();
    var ReflectMetadataModule = require_reflect_metadata();
    var anObject = require_an_object();
    var toMetadataKey = ReflectMetadataModule.toKey;
    var ordinaryDefineOwnMetadata = ReflectMetadataModule.set;
    $({
      target: "Reflect",
      stat: true
    }, {
      metadata: function metadata(metadataKey, metadataValue) {
        return function decorator(target, key) {
          ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetadataKey(key));
        };
      }
    });
  }
});

// node_modules/core-js/proposals/reflect-metadata.js
var require_reflect_metadata2 = __commonJS({
  "node_modules/core-js/proposals/reflect-metadata.js"() {
    init_define_ngDevMode();
    require_esnext_reflect_define_metadata();
    require_esnext_reflect_delete_metadata();
    require_esnext_reflect_get_metadata();
    require_esnext_reflect_get_metadata_keys();
    require_esnext_reflect_get_own_metadata();
    require_esnext_reflect_get_own_metadata_keys();
    require_esnext_reflect_has_metadata();
    require_esnext_reflect_has_own_metadata();
    require_esnext_reflect_metadata();
  }
});

// node_modules/zone.js/dist/zone.js
var require_zone = __commonJS({
  "node_modules/zone.js/dist/zone.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    (function(factory) {
      typeof define === "function" && define.amd ? define(factory) : factory();
    })(function() {
      "use strict";
      (function(global2) {
        var performance = global2["performance"];
        function mark(name) {
          performance && performance["mark"] && performance["mark"](name);
        }
        function performanceMeasure(name, label) {
          performance && performance["measure"] && performance["measure"](name, label);
        }
        mark("Zone");
        var symbolPrefix = global2["__Zone_symbol_prefix"] || "__zone_symbol__";
        function __symbol__(name) {
          return symbolPrefix + name;
        }
        var checkDuplicate = global2[__symbol__("forceDuplicateZoneCheck")] === true;
        if (global2["Zone"]) {
          if (checkDuplicate || typeof global2["Zone"].__symbol__ !== "function") {
            throw new Error("Zone already loaded.");
          } else {
            return global2["Zone"];
          }
        }
        var Zone2 = function() {
          function Zone3(parent, zoneSpec) {
            this._parent = parent;
            this._name = zoneSpec ? zoneSpec.name || "unnamed" : "<root>";
            this._properties = zoneSpec && zoneSpec.properties || {};
            this._zoneDelegate = new _ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);
          }
          Zone3.assertZonePatched = function() {
            if (global2["Promise"] !== patches["ZoneAwarePromise"]) {
              throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)");
            }
          };
          Object.defineProperty(Zone3, "root", {
            get: function() {
              var zone = Zone3.current;
              while (zone.parent) {
                zone = zone.parent;
              }
              return zone;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Zone3, "current", {
            get: function() {
              return _currentZoneFrame.zone;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Zone3, "currentTask", {
            get: function() {
              return _currentTask;
            },
            enumerable: false,
            configurable: true
          });
          Zone3.__load_patch = function(name, fn, ignoreDuplicate) {
            if (ignoreDuplicate === void 0) {
              ignoreDuplicate = false;
            }
            if (patches.hasOwnProperty(name)) {
              if (!ignoreDuplicate && checkDuplicate) {
                throw Error("Already loaded patch: " + name);
              }
            } else if (!global2["__Zone_disable_" + name]) {
              var perfName = "Zone:" + name;
              mark(perfName);
              patches[name] = fn(global2, Zone3, _api);
              performanceMeasure(perfName, perfName);
            }
          };
          Object.defineProperty(Zone3.prototype, "parent", {
            get: function() {
              return this._parent;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Zone3.prototype, "name", {
            get: function() {
              return this._name;
            },
            enumerable: false,
            configurable: true
          });
          Zone3.prototype.get = function(key) {
            var zone = this.getZoneWith(key);
            if (zone)
              return zone._properties[key];
          };
          Zone3.prototype.getZoneWith = function(key) {
            var current = this;
            while (current) {
              if (current._properties.hasOwnProperty(key)) {
                return current;
              }
              current = current._parent;
            }
            return null;
          };
          Zone3.prototype.fork = function(zoneSpec) {
            if (!zoneSpec)
              throw new Error("ZoneSpec required!");
            return this._zoneDelegate.fork(this, zoneSpec);
          };
          Zone3.prototype.wrap = function(callback, source) {
            if (typeof callback !== "function") {
              throw new Error("Expecting function got: " + callback);
            }
            var _callback = this._zoneDelegate.intercept(this, callback, source);
            var zone = this;
            return function() {
              return zone.runGuarded(_callback, this, arguments, source);
            };
          };
          Zone3.prototype.run = function(callback, applyThis, applyArgs, source) {
            _currentZoneFrame = {
              parent: _currentZoneFrame,
              zone: this
            };
            try {
              return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
            } finally {
              _currentZoneFrame = _currentZoneFrame.parent;
            }
          };
          Zone3.prototype.runGuarded = function(callback, applyThis, applyArgs, source) {
            if (applyThis === void 0) {
              applyThis = null;
            }
            _currentZoneFrame = {
              parent: _currentZoneFrame,
              zone: this
            };
            try {
              try {
                return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
              } catch (error) {
                if (this._zoneDelegate.handleError(this, error)) {
                  throw error;
                }
              }
            } finally {
              _currentZoneFrame = _currentZoneFrame.parent;
            }
          };
          Zone3.prototype.runTask = function(task, applyThis, applyArgs) {
            if (task.zone != this) {
              throw new Error("A task can only be run in the zone of creation! (Creation: " + (task.zone || NO_ZONE).name + "; Execution: " + this.name + ")");
            }
            if (task.state === notScheduled && (task.type === eventTask || task.type === macroTask)) {
              return;
            }
            var reEntryGuard = task.state != running;
            reEntryGuard && task._transitionTo(running, scheduled);
            task.runCount++;
            var previousTask = _currentTask;
            _currentTask = task;
            _currentZoneFrame = {
              parent: _currentZoneFrame,
              zone: this
            };
            try {
              if (task.type == macroTask && task.data && !task.data.isPeriodic) {
                task.cancelFn = void 0;
              }
              try {
                return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);
              } catch (error) {
                if (this._zoneDelegate.handleError(this, error)) {
                  throw error;
                }
              }
            } finally {
              if (task.state !== notScheduled && task.state !== unknown) {
                if (task.type == eventTask || task.data && task.data.isPeriodic) {
                  reEntryGuard && task._transitionTo(scheduled, running);
                } else {
                  task.runCount = 0;
                  this._updateTaskCount(task, -1);
                  reEntryGuard && task._transitionTo(notScheduled, running, notScheduled);
                }
              }
              _currentZoneFrame = _currentZoneFrame.parent;
              _currentTask = previousTask;
            }
          };
          Zone3.prototype.scheduleTask = function(task) {
            if (task.zone && task.zone !== this) {
              var newZone = this;
              while (newZone) {
                if (newZone === task.zone) {
                  throw Error("can not reschedule task to ".concat(this.name, " which is descendants of the original zone ").concat(task.zone.name));
                }
                newZone = newZone.parent;
              }
            }
            task._transitionTo(scheduling, notScheduled);
            var zoneDelegates = [];
            task._zoneDelegates = zoneDelegates;
            task._zone = this;
            try {
              task = this._zoneDelegate.scheduleTask(this, task);
            } catch (err) {
              task._transitionTo(unknown, scheduling, notScheduled);
              this._zoneDelegate.handleError(this, err);
              throw err;
            }
            if (task._zoneDelegates === zoneDelegates) {
              this._updateTaskCount(task, 1);
            }
            if (task.state == scheduling) {
              task._transitionTo(scheduled, scheduling);
            }
            return task;
          };
          Zone3.prototype.scheduleMicroTask = function(source, callback, data, customSchedule) {
            return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, void 0));
          };
          Zone3.prototype.scheduleMacroTask = function(source, callback, data, customSchedule, customCancel) {
            return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));
          };
          Zone3.prototype.scheduleEventTask = function(source, callback, data, customSchedule, customCancel) {
            return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));
          };
          Zone3.prototype.cancelTask = function(task) {
            if (task.zone != this)
              throw new Error("A task can only be cancelled in the zone of creation! (Creation: " + (task.zone || NO_ZONE).name + "; Execution: " + this.name + ")");
            task._transitionTo(canceling, scheduled, running);
            try {
              this._zoneDelegate.cancelTask(this, task);
            } catch (err) {
              task._transitionTo(unknown, canceling);
              this._zoneDelegate.handleError(this, err);
              throw err;
            }
            this._updateTaskCount(task, -1);
            task._transitionTo(notScheduled, canceling);
            task.runCount = 0;
            return task;
          };
          Zone3.prototype._updateTaskCount = function(task, count) {
            var zoneDelegates = task._zoneDelegates;
            if (count == -1) {
              task._zoneDelegates = null;
            }
            for (var i = 0; i < zoneDelegates.length; i++) {
              zoneDelegates[i]._updateTaskCount(task.type, count);
            }
          };
          return Zone3;
        }();
        Zone2.__symbol__ = __symbol__;
        var DELEGATE_ZS = {
          name: "",
          onHasTask: function(delegate, _, target, hasTaskState) {
            return delegate.hasTask(target, hasTaskState);
          },
          onScheduleTask: function(delegate, _, target, task) {
            return delegate.scheduleTask(target, task);
          },
          onInvokeTask: function(delegate, _, target, task, applyThis, applyArgs) {
            return delegate.invokeTask(target, task, applyThis, applyArgs);
          },
          onCancelTask: function(delegate, _, target, task) {
            return delegate.cancelTask(target, task);
          }
        };
        var _ZoneDelegate = function() {
          function _ZoneDelegate2(zone, parentDelegate, zoneSpec) {
            this._taskCounts = {
              "microTask": 0,
              "macroTask": 0,
              "eventTask": 0
            };
            this.zone = zone;
            this._parentDelegate = parentDelegate;
            this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);
            this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);
            this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this.zone : parentDelegate._forkCurrZone);
            this._interceptZS = zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);
            this._interceptDlgt = zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);
            this._interceptCurrZone = zoneSpec && (zoneSpec.onIntercept ? this.zone : parentDelegate._interceptCurrZone);
            this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);
            this._invokeDlgt = zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);
            this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this.zone : parentDelegate._invokeCurrZone);
            this._handleErrorZS = zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);
            this._handleErrorDlgt = zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);
            this._handleErrorCurrZone = zoneSpec && (zoneSpec.onHandleError ? this.zone : parentDelegate._handleErrorCurrZone);
            this._scheduleTaskZS = zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);
            this._scheduleTaskDlgt = zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);
            this._scheduleTaskCurrZone = zoneSpec && (zoneSpec.onScheduleTask ? this.zone : parentDelegate._scheduleTaskCurrZone);
            this._invokeTaskZS = zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);
            this._invokeTaskDlgt = zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);
            this._invokeTaskCurrZone = zoneSpec && (zoneSpec.onInvokeTask ? this.zone : parentDelegate._invokeTaskCurrZone);
            this._cancelTaskZS = zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);
            this._cancelTaskDlgt = zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);
            this._cancelTaskCurrZone = zoneSpec && (zoneSpec.onCancelTask ? this.zone : parentDelegate._cancelTaskCurrZone);
            this._hasTaskZS = null;
            this._hasTaskDlgt = null;
            this._hasTaskDlgtOwner = null;
            this._hasTaskCurrZone = null;
            var zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;
            var parentHasTask = parentDelegate && parentDelegate._hasTaskZS;
            if (zoneSpecHasTask || parentHasTask) {
              this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;
              this._hasTaskDlgt = parentDelegate;
              this._hasTaskDlgtOwner = this;
              this._hasTaskCurrZone = zone;
              if (!zoneSpec.onScheduleTask) {
                this._scheduleTaskZS = DELEGATE_ZS;
                this._scheduleTaskDlgt = parentDelegate;
                this._scheduleTaskCurrZone = this.zone;
              }
              if (!zoneSpec.onInvokeTask) {
                this._invokeTaskZS = DELEGATE_ZS;
                this._invokeTaskDlgt = parentDelegate;
                this._invokeTaskCurrZone = this.zone;
              }
              if (!zoneSpec.onCancelTask) {
                this._cancelTaskZS = DELEGATE_ZS;
                this._cancelTaskDlgt = parentDelegate;
                this._cancelTaskCurrZone = this.zone;
              }
            }
          }
          _ZoneDelegate2.prototype.fork = function(targetZone, zoneSpec) {
            return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) : new Zone2(targetZone, zoneSpec);
          };
          _ZoneDelegate2.prototype.intercept = function(targetZone, callback, source) {
            return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) : callback;
          };
          _ZoneDelegate2.prototype.invoke = function(targetZone, callback, applyThis, applyArgs, source) {
            return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) : callback.apply(applyThis, applyArgs);
          };
          _ZoneDelegate2.prototype.handleError = function(targetZone, error) {
            return this._handleErrorZS ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) : true;
          };
          _ZoneDelegate2.prototype.scheduleTask = function(targetZone, task) {
            var returnTask = task;
            if (this._scheduleTaskZS) {
              if (this._hasTaskZS) {
                returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);
              }
              returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);
              if (!returnTask)
                returnTask = task;
            } else {
              if (task.scheduleFn) {
                task.scheduleFn(task);
              } else if (task.type == microTask) {
                scheduleMicroTask(task);
              } else {
                throw new Error("Task is missing scheduleFn.");
              }
            }
            return returnTask;
          };
          _ZoneDelegate2.prototype.invokeTask = function(targetZone, task, applyThis, applyArgs) {
            return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) : task.callback.apply(applyThis, applyArgs);
          };
          _ZoneDelegate2.prototype.cancelTask = function(targetZone, task) {
            var value;
            if (this._cancelTaskZS) {
              value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);
            } else {
              if (!task.cancelFn) {
                throw Error("Task is not cancelable");
              }
              value = task.cancelFn(task);
            }
            return value;
          };
          _ZoneDelegate2.prototype.hasTask = function(targetZone, isEmpty) {
            try {
              this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);
            } catch (err) {
              this.handleError(targetZone, err);
            }
          };
          _ZoneDelegate2.prototype._updateTaskCount = function(type, count) {
            var counts = this._taskCounts;
            var prev = counts[type];
            var next = counts[type] = prev + count;
            if (next < 0) {
              throw new Error("More tasks executed then were scheduled.");
            }
            if (prev == 0 || next == 0) {
              var isEmpty = {
                microTask: counts["microTask"] > 0,
                macroTask: counts["macroTask"] > 0,
                eventTask: counts["eventTask"] > 0,
                change: type
              };
              this.hasTask(this.zone, isEmpty);
            }
          };
          return _ZoneDelegate2;
        }();
        var ZoneTask = function() {
          function ZoneTask2(type, source, callback, options2, scheduleFn, cancelFn) {
            this._zone = null;
            this.runCount = 0;
            this._zoneDelegates = null;
            this._state = "notScheduled";
            this.type = type;
            this.source = source;
            this.data = options2;
            this.scheduleFn = scheduleFn;
            this.cancelFn = cancelFn;
            if (!callback) {
              throw new Error("callback is not defined");
            }
            this.callback = callback;
            var self2 = this;
            if (type === eventTask && options2 && options2.useG) {
              this.invoke = ZoneTask2.invokeTask;
            } else {
              this.invoke = function() {
                return ZoneTask2.invokeTask.call(global2, self2, this, arguments);
              };
            }
          }
          ZoneTask2.invokeTask = function(task, target, args) {
            if (!task) {
              task = this;
            }
            _numberOfNestedTaskFrames++;
            try {
              task.runCount++;
              return task.zone.runTask(task, target, args);
            } finally {
              if (_numberOfNestedTaskFrames == 1) {
                drainMicroTaskQueue();
              }
              _numberOfNestedTaskFrames--;
            }
          };
          Object.defineProperty(ZoneTask2.prototype, "zone", {
            get: function() {
              return this._zone;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(ZoneTask2.prototype, "state", {
            get: function() {
              return this._state;
            },
            enumerable: false,
            configurable: true
          });
          ZoneTask2.prototype.cancelScheduleRequest = function() {
            this._transitionTo(notScheduled, scheduling);
          };
          ZoneTask2.prototype._transitionTo = function(toState, fromState1, fromState2) {
            if (this._state === fromState1 || this._state === fromState2) {
              this._state = toState;
              if (toState == notScheduled) {
                this._zoneDelegates = null;
              }
            } else {
              throw new Error("".concat(this.type, " '").concat(this.source, "': can not transition to '").concat(toState, "', expecting state '").concat(fromState1, "'").concat(fromState2 ? " or '" + fromState2 + "'" : "", ", was '").concat(this._state, "'."));
            }
          };
          ZoneTask2.prototype.toString = function() {
            if (this.data && typeof this.data.handleId !== "undefined") {
              return this.data.handleId.toString();
            } else {
              return Object.prototype.toString.call(this);
            }
          };
          ZoneTask2.prototype.toJSON = function() {
            return {
              type: this.type,
              state: this.state,
              source: this.source,
              zone: this.zone.name,
              runCount: this.runCount
            };
          };
          return ZoneTask2;
        }();
        var symbolSetTimeout = __symbol__("setTimeout");
        var symbolPromise = __symbol__("Promise");
        var symbolThen = __symbol__("then");
        var _microTaskQueue = [];
        var _isDrainingMicrotaskQueue = false;
        var nativeMicroTaskQueuePromise;
        function nativeScheduleMicroTask(func) {
          if (!nativeMicroTaskQueuePromise) {
            if (global2[symbolPromise]) {
              nativeMicroTaskQueuePromise = global2[symbolPromise].resolve(0);
            }
          }
          if (nativeMicroTaskQueuePromise) {
            var nativeThen = nativeMicroTaskQueuePromise[symbolThen];
            if (!nativeThen) {
              nativeThen = nativeMicroTaskQueuePromise["then"];
            }
            nativeThen.call(nativeMicroTaskQueuePromise, func);
          } else {
            global2[symbolSetTimeout](func, 0);
          }
        }
        function scheduleMicroTask(task) {
          if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {
            nativeScheduleMicroTask(drainMicroTaskQueue);
          }
          task && _microTaskQueue.push(task);
        }
        function drainMicroTaskQueue() {
          if (!_isDrainingMicrotaskQueue) {
            _isDrainingMicrotaskQueue = true;
            while (_microTaskQueue.length) {
              var queue = _microTaskQueue;
              _microTaskQueue = [];
              for (var i = 0; i < queue.length; i++) {
                var task = queue[i];
                try {
                  task.zone.runTask(task, null, null);
                } catch (error) {
                  _api.onUnhandledError(error);
                }
              }
            }
            _api.microtaskDrainDone();
            _isDrainingMicrotaskQueue = false;
          }
        }
        var NO_ZONE = {
          name: "NO ZONE"
        };
        var notScheduled = "notScheduled", scheduling = "scheduling", scheduled = "scheduled", running = "running", canceling = "canceling", unknown = "unknown";
        var microTask = "microTask", macroTask = "macroTask", eventTask = "eventTask";
        var patches = {};
        var _api = {
          symbol: __symbol__,
          currentZoneFrame: function() {
            return _currentZoneFrame;
          },
          onUnhandledError: noop,
          microtaskDrainDone: noop,
          scheduleMicroTask,
          showUncaughtError: function() {
            return !Zone2[__symbol__("ignoreConsoleErrorUncaughtError")];
          },
          patchEventTarget: function() {
            return [];
          },
          patchOnProperties: noop,
          patchMethod: function() {
            return noop;
          },
          bindArguments: function() {
            return [];
          },
          patchThen: function() {
            return noop;
          },
          patchMacroTask: function() {
            return noop;
          },
          patchEventPrototype: function() {
            return noop;
          },
          isIEOrEdge: function() {
            return false;
          },
          getGlobalObjects: function() {
            return void 0;
          },
          ObjectDefineProperty: function() {
            return noop;
          },
          ObjectGetOwnPropertyDescriptor: function() {
            return void 0;
          },
          ObjectCreate: function() {
            return void 0;
          },
          ArraySlice: function() {
            return [];
          },
          patchClass: function() {
            return noop;
          },
          wrapWithCurrentZone: function() {
            return noop;
          },
          filterProperties: function() {
            return [];
          },
          attachOriginToPatched: function() {
            return noop;
          },
          _redefineProperty: function() {
            return noop;
          },
          patchCallbacks: function() {
            return noop;
          },
          nativeScheduleMicroTask
        };
        var _currentZoneFrame = {
          parent: null,
          zone: new Zone2(null, null)
        };
        var _currentTask = null;
        var _numberOfNestedTaskFrames = 0;
        function noop() {
        }
        performanceMeasure("Zone", "Zone");
        return global2["Zone"] = Zone2;
      })(typeof window !== "undefined" && window || typeof self !== "undefined" && self || global);
      var ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var ObjectDefineProperty = Object.defineProperty;
      var ObjectGetPrototypeOf = Object.getPrototypeOf;
      var ObjectCreate = Object.create;
      var ArraySlice = Array.prototype.slice;
      var ADD_EVENT_LISTENER_STR = "addEventListener";
      var REMOVE_EVENT_LISTENER_STR = "removeEventListener";
      var ZONE_SYMBOL_ADD_EVENT_LISTENER = Zone.__symbol__(ADD_EVENT_LISTENER_STR);
      var ZONE_SYMBOL_REMOVE_EVENT_LISTENER = Zone.__symbol__(REMOVE_EVENT_LISTENER_STR);
      var TRUE_STR = "true";
      var FALSE_STR = "false";
      var ZONE_SYMBOL_PREFIX = Zone.__symbol__("");
      function wrapWithCurrentZone(callback, source) {
        return Zone.current.wrap(callback, source);
      }
      function scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {
        return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);
      }
      var zoneSymbol$1 = Zone.__symbol__;
      var isWindowExists = typeof window !== "undefined";
      var internalWindow = isWindowExists ? window : void 0;
      var _global = isWindowExists && internalWindow || typeof self === "object" && self || global;
      var REMOVE_ATTRIBUTE = "removeAttribute";
      function bindArguments(args, source) {
        for (var i = args.length - 1; i >= 0; i--) {
          if (typeof args[i] === "function") {
            args[i] = wrapWithCurrentZone(args[i], source + "_" + i);
          }
        }
        return args;
      }
      function patchPrototype(prototype, fnNames) {
        var source = prototype.constructor["name"];
        var _loop_1 = function(i2) {
          var name_1 = fnNames[i2];
          var delegate = prototype[name_1];
          if (delegate) {
            var prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name_1);
            if (!isPropertyWritable(prototypeDesc)) {
              return "continue";
            }
            prototype[name_1] = function(delegate2) {
              var patched = function() {
                return delegate2.apply(this, bindArguments(arguments, source + "." + name_1));
              };
              attachOriginToPatched(patched, delegate2);
              return patched;
            }(delegate);
          }
        };
        for (var i = 0; i < fnNames.length; i++) {
          _loop_1(i);
        }
      }
      function isPropertyWritable(propertyDesc) {
        if (!propertyDesc) {
          return true;
        }
        if (propertyDesc.writable === false) {
          return false;
        }
        return !(typeof propertyDesc.get === "function" && typeof propertyDesc.set === "undefined");
      }
      var isWebWorker = typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
      var isNode = !("nw" in _global) && typeof _global.process !== "undefined" && {}.toString.call(_global.process) === "[object process]";
      var isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow["HTMLElement"]);
      var isMix = typeof _global.process !== "undefined" && {}.toString.call(_global.process) === "[object process]" && !isWebWorker && !!(isWindowExists && internalWindow["HTMLElement"]);
      var zoneSymbolEventNames$1 = {};
      var wrapFn = function(event) {
        event = event || _global.event;
        if (!event) {
          return;
        }
        var eventNameSymbol = zoneSymbolEventNames$1[event.type];
        if (!eventNameSymbol) {
          eventNameSymbol = zoneSymbolEventNames$1[event.type] = zoneSymbol$1("ON_PROPERTY" + event.type);
        }
        var target = this || event.target || _global;
        var listener = target[eventNameSymbol];
        var result;
        if (isBrowser && target === internalWindow && event.type === "error") {
          var errorEvent = event;
          result = listener && listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);
          if (result === true) {
            event.preventDefault();
          }
        } else {
          result = listener && listener.apply(this, arguments);
          if (result != void 0 && !result) {
            event.preventDefault();
          }
        }
        return result;
      };
      function patchProperty(obj, prop, prototype) {
        var desc = ObjectGetOwnPropertyDescriptor(obj, prop);
        if (!desc && prototype) {
          var prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);
          if (prototypeDesc) {
            desc = {
              enumerable: true,
              configurable: true
            };
          }
        }
        if (!desc || !desc.configurable) {
          return;
        }
        var onPropPatchedSymbol = zoneSymbol$1("on" + prop + "patched");
        if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) {
          return;
        }
        delete desc.writable;
        delete desc.value;
        var originalDescGet = desc.get;
        var originalDescSet = desc.set;
        var eventName = prop.slice(2);
        var eventNameSymbol = zoneSymbolEventNames$1[eventName];
        if (!eventNameSymbol) {
          eventNameSymbol = zoneSymbolEventNames$1[eventName] = zoneSymbol$1("ON_PROPERTY" + eventName);
        }
        desc.set = function(newValue) {
          var target = this;
          if (!target && obj === _global) {
            target = _global;
          }
          if (!target) {
            return;
          }
          var previousValue = target[eventNameSymbol];
          if (typeof previousValue === "function") {
            target.removeEventListener(eventName, wrapFn);
          }
          originalDescSet && originalDescSet.call(target, null);
          target[eventNameSymbol] = newValue;
          if (typeof newValue === "function") {
            target.addEventListener(eventName, wrapFn, false);
          }
        };
        desc.get = function() {
          var target = this;
          if (!target && obj === _global) {
            target = _global;
          }
          if (!target) {
            return null;
          }
          var listener = target[eventNameSymbol];
          if (listener) {
            return listener;
          } else if (originalDescGet) {
            var value = originalDescGet.call(this);
            if (value) {
              desc.set.call(this, value);
              if (typeof target[REMOVE_ATTRIBUTE] === "function") {
                target.removeAttribute(prop);
              }
              return value;
            }
          }
          return null;
        };
        ObjectDefineProperty(obj, prop, desc);
        obj[onPropPatchedSymbol] = true;
      }
      function patchOnProperties(obj, properties, prototype) {
        if (properties) {
          for (var i = 0; i < properties.length; i++) {
            patchProperty(obj, "on" + properties[i], prototype);
          }
        } else {
          var onProperties = [];
          for (var prop in obj) {
            if (prop.slice(0, 2) == "on") {
              onProperties.push(prop);
            }
          }
          for (var j = 0; j < onProperties.length; j++) {
            patchProperty(obj, onProperties[j], prototype);
          }
        }
      }
      var originalInstanceKey = zoneSymbol$1("originalInstance");
      function patchClass(className) {
        var OriginalClass = _global[className];
        if (!OriginalClass)
          return;
        _global[zoneSymbol$1(className)] = OriginalClass;
        _global[className] = function() {
          var a = bindArguments(arguments, className);
          switch (a.length) {
            case 0:
              this[originalInstanceKey] = new OriginalClass();
              break;
            case 1:
              this[originalInstanceKey] = new OriginalClass(a[0]);
              break;
            case 2:
              this[originalInstanceKey] = new OriginalClass(a[0], a[1]);
              break;
            case 3:
              this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);
              break;
            case 4:
              this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);
              break;
            default:
              throw new Error("Arg list too long.");
          }
        };
        attachOriginToPatched(_global[className], OriginalClass);
        var instance = new OriginalClass(function() {
        });
        var prop;
        for (prop in instance) {
          if (className === "XMLHttpRequest" && prop === "responseBlob")
            continue;
          (function(prop2) {
            if (typeof instance[prop2] === "function") {
              _global[className].prototype[prop2] = function() {
                return this[originalInstanceKey][prop2].apply(this[originalInstanceKey], arguments);
              };
            } else {
              ObjectDefineProperty(_global[className].prototype, prop2, {
                set: function(fn) {
                  if (typeof fn === "function") {
                    this[originalInstanceKey][prop2] = wrapWithCurrentZone(fn, className + "." + prop2);
                    attachOriginToPatched(this[originalInstanceKey][prop2], fn);
                  } else {
                    this[originalInstanceKey][prop2] = fn;
                  }
                },
                get: function() {
                  return this[originalInstanceKey][prop2];
                }
              });
            }
          })(prop);
        }
        for (prop in OriginalClass) {
          if (prop !== "prototype" && OriginalClass.hasOwnProperty(prop)) {
            _global[className][prop] = OriginalClass[prop];
          }
        }
      }
      function patchMethod(target, name, patchFn) {
        var proto = target;
        while (proto && !proto.hasOwnProperty(name)) {
          proto = ObjectGetPrototypeOf(proto);
        }
        if (!proto && target[name]) {
          proto = target;
        }
        var delegateName = zoneSymbol$1(name);
        var delegate = null;
        if (proto && (!(delegate = proto[delegateName]) || !proto.hasOwnProperty(delegateName))) {
          delegate = proto[delegateName] = proto[name];
          var desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);
          if (isPropertyWritable(desc)) {
            var patchDelegate_1 = patchFn(delegate, delegateName, name);
            proto[name] = function() {
              return patchDelegate_1(this, arguments);
            };
            attachOriginToPatched(proto[name], delegate);
          }
        }
        return delegate;
      }
      function patchMacroTask(obj, funcName, metaCreator) {
        var setNative = null;
        function scheduleTask(task) {
          var data = task.data;
          data.args[data.cbIdx] = function() {
            task.invoke.apply(this, arguments);
          };
          setNative.apply(data.target, data.args);
          return task;
        }
        setNative = patchMethod(obj, funcName, function(delegate) {
          return function(self2, args) {
            var meta = metaCreator(self2, args);
            if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === "function") {
              return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);
            } else {
              return delegate.apply(self2, args);
            }
          };
        });
      }
      function attachOriginToPatched(patched, original) {
        patched[zoneSymbol$1("OriginalDelegate")] = original;
      }
      var isDetectedIEOrEdge = false;
      var ieOrEdge = false;
      function isIE() {
        try {
          var ua = internalWindow.navigator.userAgent;
          if (ua.indexOf("MSIE ") !== -1 || ua.indexOf("Trident/") !== -1) {
            return true;
          }
        } catch (error) {
        }
        return false;
      }
      function isIEOrEdge() {
        if (isDetectedIEOrEdge) {
          return ieOrEdge;
        }
        isDetectedIEOrEdge = true;
        try {
          var ua = internalWindow.navigator.userAgent;
          if (ua.indexOf("MSIE ") !== -1 || ua.indexOf("Trident/") !== -1 || ua.indexOf("Edge/") !== -1) {
            ieOrEdge = true;
          }
        } catch (error) {
        }
        return ieOrEdge;
      }
      Zone.__load_patch("ZoneAwarePromise", function(global2, Zone2, api) {
        var ObjectGetOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
        var ObjectDefineProperty2 = Object.defineProperty;
        function readableObjectToString(obj) {
          if (obj && obj.toString === Object.prototype.toString) {
            var className = obj.constructor && obj.constructor.name;
            return (className ? className : "") + ": " + JSON.stringify(obj);
          }
          return obj ? obj.toString() : Object.prototype.toString.call(obj);
        }
        var __symbol__ = api.symbol;
        var _uncaughtPromiseErrors = [];
        var isDisableWrappingUncaughtPromiseRejection = global2[__symbol__("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")] === true;
        var symbolPromise = __symbol__("Promise");
        var symbolThen = __symbol__("then");
        var creationTrace = "__creationTrace__";
        api.onUnhandledError = function(e) {
          if (api.showUncaughtError()) {
            var rejection = e && e.rejection;
            if (rejection) {
              console.error("Unhandled Promise rejection:", rejection instanceof Error ? rejection.message : rejection, "; Zone:", e.zone.name, "; Task:", e.task && e.task.source, "; Value:", rejection, rejection instanceof Error ? rejection.stack : void 0);
            } else {
              console.error(e);
            }
          }
        };
        api.microtaskDrainDone = function() {
          var _loop_2 = function() {
            var uncaughtPromiseError = _uncaughtPromiseErrors.shift();
            try {
              uncaughtPromiseError.zone.runGuarded(function() {
                if (uncaughtPromiseError.throwOriginal) {
                  throw uncaughtPromiseError.rejection;
                }
                throw uncaughtPromiseError;
              });
            } catch (error) {
              handleUnhandledRejection(error);
            }
          };
          while (_uncaughtPromiseErrors.length) {
            _loop_2();
          }
        };
        var UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__("unhandledPromiseRejectionHandler");
        function handleUnhandledRejection(e) {
          api.onUnhandledError(e);
          try {
            var handler = Zone2[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];
            if (typeof handler === "function") {
              handler.call(this, e);
            }
          } catch (err) {
          }
        }
        function isThenable(value) {
          return value && value.then;
        }
        function forwardResolution(value) {
          return value;
        }
        function forwardRejection(rejection) {
          return ZoneAwarePromise.reject(rejection);
        }
        var symbolState = __symbol__("state");
        var symbolValue = __symbol__("value");
        var symbolFinally = __symbol__("finally");
        var symbolParentPromiseValue = __symbol__("parentPromiseValue");
        var symbolParentPromiseState = __symbol__("parentPromiseState");
        var source = "Promise.then";
        var UNRESOLVED = null;
        var RESOLVED = true;
        var REJECTED = false;
        var REJECTED_NO_CATCH = 0;
        function makeResolver(promise, state) {
          return function(v) {
            try {
              resolvePromise(promise, state, v);
            } catch (err) {
              resolvePromise(promise, false, err);
            }
          };
        }
        var once = function() {
          var wasCalled = false;
          return function wrapper(wrappedFunction) {
            return function() {
              if (wasCalled) {
                return;
              }
              wasCalled = true;
              wrappedFunction.apply(null, arguments);
            };
          };
        };
        var TYPE_ERROR = "Promise resolved with itself";
        var CURRENT_TASK_TRACE_SYMBOL = __symbol__("currentTaskTrace");
        function resolvePromise(promise, state, value) {
          var onceWrapper = once();
          if (promise === value) {
            throw new TypeError(TYPE_ERROR);
          }
          if (promise[symbolState] === UNRESOLVED) {
            var then = null;
            try {
              if (typeof value === "object" || typeof value === "function") {
                then = value && value.then;
              }
            } catch (err) {
              onceWrapper(function() {
                resolvePromise(promise, false, err);
              })();
              return promise;
            }
            if (state !== REJECTED && value instanceof ZoneAwarePromise && value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) && value[symbolState] !== UNRESOLVED) {
              clearRejectedNoCatch(value);
              resolvePromise(promise, value[symbolState], value[symbolValue]);
            } else if (state !== REJECTED && typeof then === "function") {
              try {
                then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));
              } catch (err) {
                onceWrapper(function() {
                  resolvePromise(promise, false, err);
                })();
              }
            } else {
              promise[symbolState] = state;
              var queue = promise[symbolValue];
              promise[symbolValue] = value;
              if (promise[symbolFinally] === symbolFinally) {
                if (state === RESOLVED) {
                  promise[symbolState] = promise[symbolParentPromiseState];
                  promise[symbolValue] = promise[symbolParentPromiseValue];
                }
              }
              if (state === REJECTED && value instanceof Error) {
                var trace = Zone2.currentTask && Zone2.currentTask.data && Zone2.currentTask.data[creationTrace];
                if (trace) {
                  ObjectDefineProperty2(value, CURRENT_TASK_TRACE_SYMBOL, {
                    configurable: true,
                    enumerable: false,
                    writable: true,
                    value: trace
                  });
                }
              }
              for (var i = 0; i < queue.length; ) {
                scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);
              }
              if (queue.length == 0 && state == REJECTED) {
                promise[symbolState] = REJECTED_NO_CATCH;
                var uncaughtPromiseError = value;
                try {
                  throw new Error("Uncaught (in promise): " + readableObjectToString(value) + (value && value.stack ? "\n" + value.stack : ""));
                } catch (err) {
                  uncaughtPromiseError = err;
                }
                if (isDisableWrappingUncaughtPromiseRejection) {
                  uncaughtPromiseError.throwOriginal = true;
                }
                uncaughtPromiseError.rejection = value;
                uncaughtPromiseError.promise = promise;
                uncaughtPromiseError.zone = Zone2.current;
                uncaughtPromiseError.task = Zone2.currentTask;
                _uncaughtPromiseErrors.push(uncaughtPromiseError);
                api.scheduleMicroTask();
              }
            }
          }
          return promise;
        }
        var REJECTION_HANDLED_HANDLER = __symbol__("rejectionHandledHandler");
        function clearRejectedNoCatch(promise) {
          if (promise[symbolState] === REJECTED_NO_CATCH) {
            try {
              var handler = Zone2[REJECTION_HANDLED_HANDLER];
              if (handler && typeof handler === "function") {
                handler.call(this, {
                  rejection: promise[symbolValue],
                  promise
                });
              }
            } catch (err) {
            }
            promise[symbolState] = REJECTED;
            for (var i = 0; i < _uncaughtPromiseErrors.length; i++) {
              if (promise === _uncaughtPromiseErrors[i].promise) {
                _uncaughtPromiseErrors.splice(i, 1);
              }
            }
          }
        }
        function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {
          clearRejectedNoCatch(promise);
          var promiseState = promise[symbolState];
          var delegate = promiseState ? typeof onFulfilled === "function" ? onFulfilled : forwardResolution : typeof onRejected === "function" ? onRejected : forwardRejection;
          zone.scheduleMicroTask(source, function() {
            try {
              var parentPromiseValue = promise[symbolValue];
              var isFinallyPromise = !!chainPromise && symbolFinally === chainPromise[symbolFinally];
              if (isFinallyPromise) {
                chainPromise[symbolParentPromiseValue] = parentPromiseValue;
                chainPromise[symbolParentPromiseState] = promiseState;
              }
              var value = zone.run(delegate, void 0, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ? [] : [parentPromiseValue]);
              resolvePromise(chainPromise, true, value);
            } catch (error) {
              resolvePromise(chainPromise, false, error);
            }
          }, chainPromise);
        }
        var ZONE_AWARE_PROMISE_TO_STRING = "function ZoneAwarePromise() { [native code] }";
        var noop = function() {
        };
        var AggregateError = global2.AggregateError;
        var ZoneAwarePromise = function() {
          function ZoneAwarePromise2(executor) {
            var promise = this;
            if (!(promise instanceof ZoneAwarePromise2)) {
              throw new Error("Must be an instanceof Promise.");
            }
            promise[symbolState] = UNRESOLVED;
            promise[symbolValue] = [];
            try {
              var onceWrapper = once();
              executor && executor(onceWrapper(makeResolver(promise, RESOLVED)), onceWrapper(makeResolver(promise, REJECTED)));
            } catch (error) {
              resolvePromise(promise, false, error);
            }
          }
          ZoneAwarePromise2.toString = function() {
            return ZONE_AWARE_PROMISE_TO_STRING;
          };
          ZoneAwarePromise2.resolve = function(value) {
            return resolvePromise(new this(null), RESOLVED, value);
          };
          ZoneAwarePromise2.reject = function(error) {
            return resolvePromise(new this(null), REJECTED, error);
          };
          ZoneAwarePromise2.any = function(values) {
            if (!values || typeof values[Symbol.iterator] !== "function") {
              return Promise.reject(new AggregateError([], "All promises were rejected"));
            }
            var promises = [];
            var count = 0;
            try {
              for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                var v = values_1[_i];
                count++;
                promises.push(ZoneAwarePromise2.resolve(v));
              }
            } catch (err) {
              return Promise.reject(new AggregateError([], "All promises were rejected"));
            }
            if (count === 0) {
              return Promise.reject(new AggregateError([], "All promises were rejected"));
            }
            var finished = false;
            var errors = [];
            return new ZoneAwarePromise2(function(resolve, reject) {
              for (var i = 0; i < promises.length; i++) {
                promises[i].then(function(v2) {
                  if (finished) {
                    return;
                  }
                  finished = true;
                  resolve(v2);
                }, function(err) {
                  errors.push(err);
                  count--;
                  if (count === 0) {
                    finished = true;
                    reject(new AggregateError(errors, "All promises were rejected"));
                  }
                });
              }
            });
          };
          ;
          ZoneAwarePromise2.race = function(values) {
            var resolve;
            var reject;
            var promise = new this(function(res, rej) {
              resolve = res;
              reject = rej;
            });
            function onResolve(value2) {
              resolve(value2);
            }
            function onReject(error) {
              reject(error);
            }
            for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {
              var value = values_2[_i];
              if (!isThenable(value)) {
                value = this.resolve(value);
              }
              value.then(onResolve, onReject);
            }
            return promise;
          };
          ZoneAwarePromise2.all = function(values) {
            return ZoneAwarePromise2.allWithCallback(values);
          };
          ZoneAwarePromise2.allSettled = function(values) {
            var P = this && this.prototype instanceof ZoneAwarePromise2 ? this : ZoneAwarePromise2;
            return P.allWithCallback(values, {
              thenCallback: function(value) {
                return {
                  status: "fulfilled",
                  value
                };
              },
              errorCallback: function(err) {
                return {
                  status: "rejected",
                  reason: err
                };
              }
            });
          };
          ZoneAwarePromise2.allWithCallback = function(values, callback) {
            var resolve;
            var reject;
            var promise = new this(function(res, rej) {
              resolve = res;
              reject = rej;
            });
            var unresolvedCount = 2;
            var valueIndex = 0;
            var resolvedValues = [];
            var _loop_3 = function(value2) {
              if (!isThenable(value2)) {
                value2 = this_1.resolve(value2);
              }
              var curValueIndex = valueIndex;
              try {
                value2.then(function(value3) {
                  resolvedValues[curValueIndex] = callback ? callback.thenCallback(value3) : value3;
                  unresolvedCount--;
                  if (unresolvedCount === 0) {
                    resolve(resolvedValues);
                  }
                }, function(err) {
                  if (!callback) {
                    reject(err);
                  } else {
                    resolvedValues[curValueIndex] = callback.errorCallback(err);
                    unresolvedCount--;
                    if (unresolvedCount === 0) {
                      resolve(resolvedValues);
                    }
                  }
                });
              } catch (thenErr) {
                reject(thenErr);
              }
              unresolvedCount++;
              valueIndex++;
            };
            var this_1 = this;
            for (var _i = 0, values_3 = values; _i < values_3.length; _i++) {
              var value = values_3[_i];
              _loop_3(value);
            }
            unresolvedCount -= 2;
            if (unresolvedCount === 0) {
              resolve(resolvedValues);
            }
            return promise;
          };
          Object.defineProperty(ZoneAwarePromise2.prototype, Symbol.toStringTag, {
            get: function() {
              return "Promise";
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(ZoneAwarePromise2.prototype, Symbol.species, {
            get: function() {
              return ZoneAwarePromise2;
            },
            enumerable: false,
            configurable: true
          });
          ZoneAwarePromise2.prototype.then = function(onFulfilled, onRejected) {
            var _a;
            var C = (_a = this.constructor) === null || _a === void 0 ? void 0 : _a[Symbol.species];
            if (!C || typeof C !== "function") {
              C = this.constructor || ZoneAwarePromise2;
            }
            var chainPromise = new C(noop);
            var zone = Zone2.current;
            if (this[symbolState] == UNRESOLVED) {
              this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);
            } else {
              scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);
            }
            return chainPromise;
          };
          ZoneAwarePromise2.prototype.catch = function(onRejected) {
            return this.then(null, onRejected);
          };
          ZoneAwarePromise2.prototype.finally = function(onFinally) {
            var _a;
            var C = (_a = this.constructor) === null || _a === void 0 ? void 0 : _a[Symbol.species];
            if (!C || typeof C !== "function") {
              C = ZoneAwarePromise2;
            }
            var chainPromise = new C(noop);
            chainPromise[symbolFinally] = symbolFinally;
            var zone = Zone2.current;
            if (this[symbolState] == UNRESOLVED) {
              this[symbolValue].push(zone, chainPromise, onFinally, onFinally);
            } else {
              scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);
            }
            return chainPromise;
          };
          return ZoneAwarePromise2;
        }();
        ZoneAwarePromise["resolve"] = ZoneAwarePromise.resolve;
        ZoneAwarePromise["reject"] = ZoneAwarePromise.reject;
        ZoneAwarePromise["race"] = ZoneAwarePromise.race;
        ZoneAwarePromise["all"] = ZoneAwarePromise.all;
        var NativePromise = global2[symbolPromise] = global2["Promise"];
        global2["Promise"] = ZoneAwarePromise;
        var symbolThenPatched = __symbol__("thenPatched");
        function patchThen(Ctor) {
          var proto = Ctor.prototype;
          var prop = ObjectGetOwnPropertyDescriptor2(proto, "then");
          if (prop && (prop.writable === false || !prop.configurable)) {
            return;
          }
          var originalThen = proto.then;
          proto[symbolThen] = originalThen;
          Ctor.prototype.then = function(onResolve, onReject) {
            var _this = this;
            var wrapped = new ZoneAwarePromise(function(resolve, reject) {
              originalThen.call(_this, resolve, reject);
            });
            return wrapped.then(onResolve, onReject);
          };
          Ctor[symbolThenPatched] = true;
        }
        api.patchThen = patchThen;
        function zoneify(fn) {
          return function(self2, args) {
            var resultPromise = fn.apply(self2, args);
            if (resultPromise instanceof ZoneAwarePromise) {
              return resultPromise;
            }
            var ctor = resultPromise.constructor;
            if (!ctor[symbolThenPatched]) {
              patchThen(ctor);
            }
            return resultPromise;
          };
        }
        if (NativePromise) {
          patchThen(NativePromise);
          patchMethod(global2, "fetch", function(delegate) {
            return zoneify(delegate);
          });
        }
        Promise[Zone2.__symbol__("uncaughtPromiseErrors")] = _uncaughtPromiseErrors;
        return ZoneAwarePromise;
      });
      Zone.__load_patch("toString", function(global2) {
        var originalFunctionToString = Function.prototype.toString;
        var ORIGINAL_DELEGATE_SYMBOL = zoneSymbol$1("OriginalDelegate");
        var PROMISE_SYMBOL = zoneSymbol$1("Promise");
        var ERROR_SYMBOL = zoneSymbol$1("Error");
        var newFunctionToString = function toString() {
          if (typeof this === "function") {
            var originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];
            if (originalDelegate) {
              if (typeof originalDelegate === "function") {
                return originalFunctionToString.call(originalDelegate);
              } else {
                return Object.prototype.toString.call(originalDelegate);
              }
            }
            if (this === Promise) {
              var nativePromise = global2[PROMISE_SYMBOL];
              if (nativePromise) {
                return originalFunctionToString.call(nativePromise);
              }
            }
            if (this === Error) {
              var nativeError = global2[ERROR_SYMBOL];
              if (nativeError) {
                return originalFunctionToString.call(nativeError);
              }
            }
          }
          return originalFunctionToString.call(this);
        };
        newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;
        Function.prototype.toString = newFunctionToString;
        var originalObjectToString = Object.prototype.toString;
        var PROMISE_OBJECT_TO_STRING = "[object Promise]";
        Object.prototype.toString = function() {
          if (typeof Promise === "function" && this instanceof Promise) {
            return PROMISE_OBJECT_TO_STRING;
          }
          return originalObjectToString.call(this);
        };
      });
      var passiveSupported = false;
      if (typeof window !== "undefined") {
        try {
          var options = Object.defineProperty({}, "passive", {
            get: function() {
              passiveSupported = true;
            }
          });
          window.addEventListener("test", options, options);
          window.removeEventListener("test", options, options);
        } catch (err) {
          passiveSupported = false;
        }
      }
      var OPTIMIZED_ZONE_EVENT_TASK_DATA = {
        useG: true
      };
      var zoneSymbolEventNames = {};
      var globalSources = {};
      var EVENT_NAME_SYMBOL_REGX = new RegExp("^" + ZONE_SYMBOL_PREFIX + "(\\w+)(true|false)$");
      var IMMEDIATE_PROPAGATION_SYMBOL = zoneSymbol$1("propagationStopped");
      function prepareEventNames(eventName, eventNameToString) {
        var falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;
        var trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;
        var symbol = ZONE_SYMBOL_PREFIX + falseEventName;
        var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
        zoneSymbolEventNames[eventName] = {};
        zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
        zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
      }
      function patchEventTarget(_global2, api, apis, patchOptions) {
        var ADD_EVENT_LISTENER = patchOptions && patchOptions.add || ADD_EVENT_LISTENER_STR;
        var REMOVE_EVENT_LISTENER = patchOptions && patchOptions.rm || REMOVE_EVENT_LISTENER_STR;
        var LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.listeners || "eventListeners";
        var REMOVE_ALL_LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.rmAll || "removeAllListeners";
        var zoneSymbolAddEventListener = zoneSymbol$1(ADD_EVENT_LISTENER);
        var ADD_EVENT_LISTENER_SOURCE = "." + ADD_EVENT_LISTENER + ":";
        var PREPEND_EVENT_LISTENER = "prependListener";
        var PREPEND_EVENT_LISTENER_SOURCE = "." + PREPEND_EVENT_LISTENER + ":";
        var invokeTask = function(task, target, event) {
          if (task.isRemoved) {
            return;
          }
          var delegate = task.callback;
          if (typeof delegate === "object" && delegate.handleEvent) {
            task.callback = function(event2) {
              return delegate.handleEvent(event2);
            };
            task.originalDelegate = delegate;
          }
          var error;
          try {
            task.invoke(task, target, [event]);
          } catch (err) {
            error = err;
          }
          var options2 = task.options;
          if (options2 && typeof options2 === "object" && options2.once) {
            var delegate_1 = task.originalDelegate ? task.originalDelegate : task.callback;
            target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate_1, options2);
          }
          return error;
        };
        function globalCallback(context, event, isCapture) {
          event = event || _global2.event;
          if (!event) {
            return;
          }
          var target = context || event.target || _global2;
          var tasks = target[zoneSymbolEventNames[event.type][isCapture ? TRUE_STR : FALSE_STR]];
          if (tasks) {
            var errors = [];
            if (tasks.length === 1) {
              var err = invokeTask(tasks[0], target, event);
              err && errors.push(err);
            } else {
              var copyTasks = tasks.slice();
              for (var i2 = 0; i2 < copyTasks.length; i2++) {
                if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {
                  break;
                }
                var err = invokeTask(copyTasks[i2], target, event);
                err && errors.push(err);
              }
            }
            if (errors.length === 1) {
              throw errors[0];
            } else {
              var _loop_4 = function(i3) {
                var err2 = errors[i3];
                api.nativeScheduleMicroTask(function() {
                  throw err2;
                });
              };
              for (var i2 = 0; i2 < errors.length; i2++) {
                _loop_4(i2);
              }
            }
          }
        }
        var globalZoneAwareCallback = function(event) {
          return globalCallback(this, event, false);
        };
        var globalZoneAwareCaptureCallback = function(event) {
          return globalCallback(this, event, true);
        };
        function patchEventTargetMethods(obj, patchOptions2) {
          if (!obj) {
            return false;
          }
          var useGlobalCallback = true;
          if (patchOptions2 && patchOptions2.useG !== void 0) {
            useGlobalCallback = patchOptions2.useG;
          }
          var validateHandler = patchOptions2 && patchOptions2.vh;
          var checkDuplicate = true;
          if (patchOptions2 && patchOptions2.chkDup !== void 0) {
            checkDuplicate = patchOptions2.chkDup;
          }
          var returnTarget = false;
          if (patchOptions2 && patchOptions2.rt !== void 0) {
            returnTarget = patchOptions2.rt;
          }
          var proto = obj;
          while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {
            proto = ObjectGetPrototypeOf(proto);
          }
          if (!proto && obj[ADD_EVENT_LISTENER]) {
            proto = obj;
          }
          if (!proto) {
            return false;
          }
          if (proto[zoneSymbolAddEventListener]) {
            return false;
          }
          var eventNameToString = patchOptions2 && patchOptions2.eventNameToString;
          var taskData = {};
          var nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];
          var nativeRemoveEventListener = proto[zoneSymbol$1(REMOVE_EVENT_LISTENER)] = proto[REMOVE_EVENT_LISTENER];
          var nativeListeners = proto[zoneSymbol$1(LISTENERS_EVENT_LISTENER)] = proto[LISTENERS_EVENT_LISTENER];
          var nativeRemoveAllListeners = proto[zoneSymbol$1(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] = proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];
          var nativePrependEventListener;
          if (patchOptions2 && patchOptions2.prepend) {
            nativePrependEventListener = proto[zoneSymbol$1(patchOptions2.prepend)] = proto[patchOptions2.prepend];
          }
          function buildEventListenerOptions(options2, passive) {
            if (!passiveSupported && typeof options2 === "object" && options2) {
              return !!options2.capture;
            }
            if (!passiveSupported || !passive) {
              return options2;
            }
            if (typeof options2 === "boolean") {
              return {
                capture: options2,
                passive: true
              };
            }
            if (!options2) {
              return {
                passive: true
              };
            }
            if (typeof options2 === "object" && options2.passive !== false) {
              return Object.assign(Object.assign({}, options2), {
                passive: true
              });
            }
            return options2;
          }
          var customScheduleGlobal = function(task) {
            if (taskData.isExisting) {
              return;
            }
            return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);
          };
          var customCancelGlobal = function(task) {
            if (!task.isRemoved) {
              var symbolEventNames = zoneSymbolEventNames[task.eventName];
              var symbolEventName = void 0;
              if (symbolEventNames) {
                symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];
              }
              var existingTasks = symbolEventName && task.target[symbolEventName];
              if (existingTasks) {
                for (var i2 = 0; i2 < existingTasks.length; i2++) {
                  var existingTask = existingTasks[i2];
                  if (existingTask === task) {
                    existingTasks.splice(i2, 1);
                    task.isRemoved = true;
                    if (existingTasks.length === 0) {
                      task.allRemoved = true;
                      task.target[symbolEventName] = null;
                    }
                    break;
                  }
                }
              }
            }
            if (!task.allRemoved) {
              return;
            }
            return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);
          };
          var customScheduleNonGlobal = function(task) {
            return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
          };
          var customSchedulePrepend = function(task) {
            return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
          };
          var customCancelNonGlobal = function(task) {
            return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);
          };
          var customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;
          var customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;
          var compareTaskCallbackVsDelegate = function(task, delegate) {
            var typeOfDelegate = typeof delegate;
            return typeOfDelegate === "function" && task.callback === delegate || typeOfDelegate === "object" && task.originalDelegate === delegate;
          };
          var compare = patchOptions2 && patchOptions2.diff ? patchOptions2.diff : compareTaskCallbackVsDelegate;
          var unpatchedEvents = Zone[zoneSymbol$1("UNPATCHED_EVENTS")];
          var passiveEvents = _global2[zoneSymbol$1("PASSIVE_EVENTS")];
          var makeAddListener = function(nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget2, prepend) {
            if (returnTarget2 === void 0) {
              returnTarget2 = false;
            }
            if (prepend === void 0) {
              prepend = false;
            }
            return function() {
              var target = this || _global2;
              var eventName = arguments[0];
              if (patchOptions2 && patchOptions2.transferEventName) {
                eventName = patchOptions2.transferEventName(eventName);
              }
              var delegate = arguments[1];
              if (!delegate) {
                return nativeListener.apply(this, arguments);
              }
              if (isNode && eventName === "uncaughtException") {
                return nativeListener.apply(this, arguments);
              }
              var isHandleEvent = false;
              if (typeof delegate !== "function") {
                if (!delegate.handleEvent) {
                  return nativeListener.apply(this, arguments);
                }
                isHandleEvent = true;
              }
              if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {
                return;
              }
              var passive = passiveSupported && !!passiveEvents && passiveEvents.indexOf(eventName) !== -1;
              var options2 = buildEventListenerOptions(arguments[2], passive);
              if (unpatchedEvents) {
                for (var i2 = 0; i2 < unpatchedEvents.length; i2++) {
                  if (eventName === unpatchedEvents[i2]) {
                    if (passive) {
                      return nativeListener.call(target, eventName, delegate, options2);
                    } else {
                      return nativeListener.apply(this, arguments);
                    }
                  }
                }
              }
              var capture = !options2 ? false : typeof options2 === "boolean" ? true : options2.capture;
              var once = options2 && typeof options2 === "object" ? options2.once : false;
              var zone = Zone.current;
              var symbolEventNames = zoneSymbolEventNames[eventName];
              if (!symbolEventNames) {
                prepareEventNames(eventName, eventNameToString);
                symbolEventNames = zoneSymbolEventNames[eventName];
              }
              var symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
              var existingTasks = target[symbolEventName];
              var isExisting = false;
              if (existingTasks) {
                isExisting = true;
                if (checkDuplicate) {
                  for (var i2 = 0; i2 < existingTasks.length; i2++) {
                    if (compare(existingTasks[i2], delegate)) {
                      return;
                    }
                  }
                }
              } else {
                existingTasks = target[symbolEventName] = [];
              }
              var source;
              var constructorName = target.constructor["name"];
              var targetSource = globalSources[constructorName];
              if (targetSource) {
                source = targetSource[eventName];
              }
              if (!source) {
                source = constructorName + addSource + (eventNameToString ? eventNameToString(eventName) : eventName);
              }
              taskData.options = options2;
              if (once) {
                taskData.options.once = false;
              }
              taskData.target = target;
              taskData.capture = capture;
              taskData.eventName = eventName;
              taskData.isExisting = isExisting;
              var data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : void 0;
              if (data) {
                data.taskData = taskData;
              }
              var task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);
              taskData.target = null;
              if (data) {
                data.taskData = null;
              }
              if (once) {
                options2.once = true;
              }
              if (!(!passiveSupported && typeof task.options === "boolean")) {
                task.options = options2;
              }
              task.target = target;
              task.capture = capture;
              task.eventName = eventName;
              if (isHandleEvent) {
                task.originalDelegate = delegate;
              }
              if (!prepend) {
                existingTasks.push(task);
              } else {
                existingTasks.unshift(task);
              }
              if (returnTarget2) {
                return target;
              }
            };
          };
          proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);
          if (nativePrependEventListener) {
            proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);
          }
          proto[REMOVE_EVENT_LISTENER] = function() {
            var target = this || _global2;
            var eventName = arguments[0];
            if (patchOptions2 && patchOptions2.transferEventName) {
              eventName = patchOptions2.transferEventName(eventName);
            }
            var options2 = arguments[2];
            var capture = !options2 ? false : typeof options2 === "boolean" ? true : options2.capture;
            var delegate = arguments[1];
            if (!delegate) {
              return nativeRemoveEventListener.apply(this, arguments);
            }
            if (validateHandler && !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {
              return;
            }
            var symbolEventNames = zoneSymbolEventNames[eventName];
            var symbolEventName;
            if (symbolEventNames) {
              symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
            }
            var existingTasks = symbolEventName && target[symbolEventName];
            if (existingTasks) {
              for (var i2 = 0; i2 < existingTasks.length; i2++) {
                var existingTask = existingTasks[i2];
                if (compare(existingTask, delegate)) {
                  existingTasks.splice(i2, 1);
                  existingTask.isRemoved = true;
                  if (existingTasks.length === 0) {
                    existingTask.allRemoved = true;
                    target[symbolEventName] = null;
                    if (typeof eventName === "string") {
                      var onPropertySymbol = ZONE_SYMBOL_PREFIX + "ON_PROPERTY" + eventName;
                      target[onPropertySymbol] = null;
                    }
                  }
                  existingTask.zone.cancelTask(existingTask);
                  if (returnTarget) {
                    return target;
                  }
                  return;
                }
              }
            }
            return nativeRemoveEventListener.apply(this, arguments);
          };
          proto[LISTENERS_EVENT_LISTENER] = function() {
            var target = this || _global2;
            var eventName = arguments[0];
            if (patchOptions2 && patchOptions2.transferEventName) {
              eventName = patchOptions2.transferEventName(eventName);
            }
            var listeners = [];
            var tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);
            for (var i2 = 0; i2 < tasks.length; i2++) {
              var task = tasks[i2];
              var delegate = task.originalDelegate ? task.originalDelegate : task.callback;
              listeners.push(delegate);
            }
            return listeners;
          };
          proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function() {
            var target = this || _global2;
            var eventName = arguments[0];
            if (!eventName) {
              var keys = Object.keys(target);
              for (var i2 = 0; i2 < keys.length; i2++) {
                var prop = keys[i2];
                var match = EVENT_NAME_SYMBOL_REGX.exec(prop);
                var evtName = match && match[1];
                if (evtName && evtName !== "removeListener") {
                  this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);
                }
              }
              this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, "removeListener");
            } else {
              if (patchOptions2 && patchOptions2.transferEventName) {
                eventName = patchOptions2.transferEventName(eventName);
              }
              var symbolEventNames = zoneSymbolEventNames[eventName];
              if (symbolEventNames) {
                var symbolEventName = symbolEventNames[FALSE_STR];
                var symbolCaptureEventName = symbolEventNames[TRUE_STR];
                var tasks = target[symbolEventName];
                var captureTasks = target[symbolCaptureEventName];
                if (tasks) {
                  var removeTasks = tasks.slice();
                  for (var i2 = 0; i2 < removeTasks.length; i2++) {
                    var task = removeTasks[i2];
                    var delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                    this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
                  }
                }
                if (captureTasks) {
                  var removeTasks = captureTasks.slice();
                  for (var i2 = 0; i2 < removeTasks.length; i2++) {
                    var task = removeTasks[i2];
                    var delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                    this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
                  }
                }
              }
            }
            if (returnTarget) {
              return this;
            }
          };
          attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);
          attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);
          if (nativeRemoveAllListeners) {
            attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);
          }
          if (nativeListeners) {
            attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);
          }
          return true;
        }
        var results = [];
        for (var i = 0; i < apis.length; i++) {
          results[i] = patchEventTargetMethods(apis[i], patchOptions);
        }
        return results;
      }
      function findEventTasks(target, eventName) {
        if (!eventName) {
          var foundTasks = [];
          for (var prop in target) {
            var match = EVENT_NAME_SYMBOL_REGX.exec(prop);
            var evtName = match && match[1];
            if (evtName && (!eventName || evtName === eventName)) {
              var tasks = target[prop];
              if (tasks) {
                for (var i = 0; i < tasks.length; i++) {
                  foundTasks.push(tasks[i]);
                }
              }
            }
          }
          return foundTasks;
        }
        var symbolEventName = zoneSymbolEventNames[eventName];
        if (!symbolEventName) {
          prepareEventNames(eventName);
          symbolEventName = zoneSymbolEventNames[eventName];
        }
        var captureFalseTasks = target[symbolEventName[FALSE_STR]];
        var captureTrueTasks = target[symbolEventName[TRUE_STR]];
        if (!captureFalseTasks) {
          return captureTrueTasks ? captureTrueTasks.slice() : [];
        } else {
          return captureTrueTasks ? captureFalseTasks.concat(captureTrueTasks) : captureFalseTasks.slice();
        }
      }
      function patchEventPrototype(global2, api) {
        var Event = global2["Event"];
        if (Event && Event.prototype) {
          api.patchMethod(Event.prototype, "stopImmediatePropagation", function(delegate) {
            return function(self2, args) {
              self2[IMMEDIATE_PROPAGATION_SYMBOL] = true;
              delegate && delegate.apply(self2, args);
            };
          });
        }
      }
      function patchCallbacks(api, target, targetName, method, callbacks) {
        var symbol = Zone.__symbol__(method);
        if (target[symbol]) {
          return;
        }
        var nativeDelegate = target[symbol] = target[method];
        target[method] = function(name, opts, options2) {
          if (opts && opts.prototype) {
            callbacks.forEach(function(callback) {
              var source = "".concat(targetName, ".").concat(method, "::") + callback;
              var prototype = opts.prototype;
              try {
                if (prototype.hasOwnProperty(callback)) {
                  var descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);
                  if (descriptor && descriptor.value) {
                    descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);
                    api._redefineProperty(opts.prototype, callback, descriptor);
                  } else if (prototype[callback]) {
                    prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
                  }
                } else if (prototype[callback]) {
                  prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
                }
              } catch (_a) {
              }
            });
          }
          return nativeDelegate.call(target, name, opts, options2);
        };
        api.attachOriginToPatched(target[method], nativeDelegate);
      }
      function filterProperties(target, onProperties, ignoreProperties) {
        if (!ignoreProperties || ignoreProperties.length === 0) {
          return onProperties;
        }
        var tip = ignoreProperties.filter(function(ip) {
          return ip.target === target;
        });
        if (!tip || tip.length === 0) {
          return onProperties;
        }
        var targetIgnoreProperties = tip[0].ignoreProperties;
        return onProperties.filter(function(op) {
          return targetIgnoreProperties.indexOf(op) === -1;
        });
      }
      function patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {
        if (!target) {
          return;
        }
        var filteredProperties = filterProperties(target, onProperties, ignoreProperties);
        patchOnProperties(target, filteredProperties, prototype);
      }
      function getOnEventNames(target) {
        return Object.getOwnPropertyNames(target).filter(function(name) {
          return name.startsWith("on") && name.length > 2;
        }).map(function(name) {
          return name.substring(2);
        });
      }
      function propertyDescriptorPatch(api, _global2) {
        if (isNode && !isMix) {
          return;
        }
        if (Zone[api.symbol("patchEvents")]) {
          return;
        }
        var ignoreProperties = _global2["__Zone_ignore_on_properties"];
        var patchTargets = [];
        if (isBrowser) {
          var internalWindow_1 = window;
          patchTargets = patchTargets.concat(["Document", "SVGElement", "Element", "HTMLElement", "HTMLBodyElement", "HTMLMediaElement", "HTMLFrameSetElement", "HTMLFrameElement", "HTMLIFrameElement", "HTMLMarqueeElement", "Worker"]);
          var ignoreErrorProperties = isIE() ? [{
            target: internalWindow_1,
            ignoreProperties: ["error"]
          }] : [];
          patchFilteredProperties(internalWindow_1, getOnEventNames(internalWindow_1), ignoreProperties ? ignoreProperties.concat(ignoreErrorProperties) : ignoreProperties, ObjectGetPrototypeOf(internalWindow_1));
        }
        patchTargets = patchTargets.concat(["XMLHttpRequest", "XMLHttpRequestEventTarget", "IDBIndex", "IDBRequest", "IDBOpenDBRequest", "IDBDatabase", "IDBTransaction", "IDBCursor", "WebSocket"]);
        for (var i = 0; i < patchTargets.length; i++) {
          var target = _global2[patchTargets[i]];
          target && target.prototype && patchFilteredProperties(target.prototype, getOnEventNames(target.prototype), ignoreProperties);
        }
      }
      Zone.__load_patch("util", function(global2, Zone2, api) {
        var eventNames2 = getOnEventNames(global2);
        api.patchOnProperties = patchOnProperties;
        api.patchMethod = patchMethod;
        api.bindArguments = bindArguments;
        api.patchMacroTask = patchMacroTask;
        var SYMBOL_BLACK_LISTED_EVENTS = Zone2.__symbol__("BLACK_LISTED_EVENTS");
        var SYMBOL_UNPATCHED_EVENTS = Zone2.__symbol__("UNPATCHED_EVENTS");
        if (global2[SYMBOL_UNPATCHED_EVENTS]) {
          global2[SYMBOL_BLACK_LISTED_EVENTS] = global2[SYMBOL_UNPATCHED_EVENTS];
        }
        if (global2[SYMBOL_BLACK_LISTED_EVENTS]) {
          Zone2[SYMBOL_BLACK_LISTED_EVENTS] = Zone2[SYMBOL_UNPATCHED_EVENTS] = global2[SYMBOL_BLACK_LISTED_EVENTS];
        }
        api.patchEventPrototype = patchEventPrototype;
        api.patchEventTarget = patchEventTarget;
        api.isIEOrEdge = isIEOrEdge;
        api.ObjectDefineProperty = ObjectDefineProperty;
        api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;
        api.ObjectCreate = ObjectCreate;
        api.ArraySlice = ArraySlice;
        api.patchClass = patchClass;
        api.wrapWithCurrentZone = wrapWithCurrentZone;
        api.filterProperties = filterProperties;
        api.attachOriginToPatched = attachOriginToPatched;
        api._redefineProperty = Object.defineProperty;
        api.patchCallbacks = patchCallbacks;
        api.getGlobalObjects = function() {
          return {
            globalSources,
            zoneSymbolEventNames,
            eventNames: eventNames2,
            isBrowser,
            isMix,
            isNode,
            TRUE_STR,
            FALSE_STR,
            ZONE_SYMBOL_PREFIX,
            ADD_EVENT_LISTENER_STR,
            REMOVE_EVENT_LISTENER_STR
          };
        };
      });
      var zoneSymbol;
      var _defineProperty;
      var _getOwnPropertyDescriptor;
      var _create;
      var unconfigurablesKey;
      function propertyPatch() {
        zoneSymbol = Zone.__symbol__;
        _defineProperty = Object[zoneSymbol("defineProperty")] = Object.defineProperty;
        _getOwnPropertyDescriptor = Object[zoneSymbol("getOwnPropertyDescriptor")] = Object.getOwnPropertyDescriptor;
        _create = Object.create;
        unconfigurablesKey = zoneSymbol("unconfigurables");
        Object.defineProperty = function(obj, prop, desc) {
          if (isUnconfigurable(obj, prop)) {
            throw new TypeError("Cannot assign to read only property '" + prop + "' of " + obj);
          }
          var originalConfigurableFlag = desc.configurable;
          if (prop !== "prototype") {
            desc = rewriteDescriptor(obj, prop, desc);
          }
          return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);
        };
        Object.defineProperties = function(obj, props) {
          Object.keys(props).forEach(function(prop) {
            Object.defineProperty(obj, prop, props[prop]);
          });
          for (var _i = 0, _b = Object.getOwnPropertySymbols(props); _i < _b.length; _i++) {
            var sym = _b[_i];
            var desc = Object.getOwnPropertyDescriptor(props, sym);
            if (desc === null || desc === void 0 ? void 0 : desc.enumerable) {
              Object.defineProperty(obj, sym, props[sym]);
            }
          }
          return obj;
        };
        Object.create = function(proto, propertiesObject) {
          if (typeof propertiesObject === "object" && !Object.isFrozen(propertiesObject)) {
            Object.keys(propertiesObject).forEach(function(prop) {
              propertiesObject[prop] = rewriteDescriptor(proto, prop, propertiesObject[prop]);
            });
          }
          return _create(proto, propertiesObject);
        };
        Object.getOwnPropertyDescriptor = function(obj, prop) {
          var desc = _getOwnPropertyDescriptor(obj, prop);
          if (desc && isUnconfigurable(obj, prop)) {
            desc.configurable = false;
          }
          return desc;
        };
      }
      function _redefineProperty(obj, prop, desc) {
        var originalConfigurableFlag = desc.configurable;
        desc = rewriteDescriptor(obj, prop, desc);
        return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);
      }
      function isUnconfigurable(obj, prop) {
        return obj && obj[unconfigurablesKey] && obj[unconfigurablesKey][prop];
      }
      function rewriteDescriptor(obj, prop, desc) {
        if (!Object.isFrozen(desc)) {
          desc.configurable = true;
        }
        if (!desc.configurable) {
          if (!obj[unconfigurablesKey] && !Object.isFrozen(obj)) {
            _defineProperty(obj, unconfigurablesKey, {
              writable: true,
              value: {}
            });
          }
          if (obj[unconfigurablesKey]) {
            obj[unconfigurablesKey][prop] = true;
          }
        }
        return desc;
      }
      function _tryDefineProperty(obj, prop, desc, originalConfigurableFlag) {
        try {
          return _defineProperty(obj, prop, desc);
        } catch (error) {
          if (desc.configurable) {
            if (typeof originalConfigurableFlag == "undefined") {
              delete desc.configurable;
            } else {
              desc.configurable = originalConfigurableFlag;
            }
            try {
              return _defineProperty(obj, prop, desc);
            } catch (error2) {
              var swallowError = false;
              if (prop === "createdCallback" || prop === "attachedCallback" || prop === "detachedCallback" || prop === "attributeChangedCallback") {
                swallowError = true;
              }
              if (!swallowError) {
                throw error2;
              }
              var descJson = null;
              try {
                descJson = JSON.stringify(desc);
              } catch (error3) {
                descJson = desc.toString();
              }
              console.log("Attempting to configure '".concat(prop, "' with descriptor '").concat(descJson, "' on object '").concat(obj, "' and got error, giving up: ").concat(error2));
            }
          } else {
            throw error;
          }
        }
      }
      function eventTargetLegacyPatch(_global2, api) {
        var _b = api.getGlobalObjects(), eventNames2 = _b.eventNames, globalSources2 = _b.globalSources, zoneSymbolEventNames2 = _b.zoneSymbolEventNames, TRUE_STR2 = _b.TRUE_STR, FALSE_STR2 = _b.FALSE_STR, ZONE_SYMBOL_PREFIX2 = _b.ZONE_SYMBOL_PREFIX;
        var WTF_ISSUE_555 = "Anchor,Area,Audio,BR,Base,BaseFont,Body,Button,Canvas,Content,DList,Directory,Div,Embed,FieldSet,Font,Form,Frame,FrameSet,HR,Head,Heading,Html,IFrame,Image,Input,Keygen,LI,Label,Legend,Link,Map,Marquee,Media,Menu,Meta,Meter,Mod,OList,Object,OptGroup,Option,Output,Paragraph,Pre,Progress,Quote,Script,Select,Source,Span,Style,TableCaption,TableCell,TableCol,Table,TableRow,TableSection,TextArea,Title,Track,UList,Unknown,Video";
        var NO_EVENT_TARGET = "ApplicationCache,EventSource,FileReader,InputMethodContext,MediaController,MessagePort,Node,Performance,SVGElementInstance,SharedWorker,TextTrack,TextTrackCue,TextTrackList,WebKitNamedFlow,Window,Worker,WorkerGlobalScope,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload,IDBRequest,IDBOpenDBRequest,IDBDatabase,IDBTransaction,IDBCursor,DBIndex,WebSocket".split(",");
        var EVENT_TARGET = "EventTarget";
        var apis = [];
        var isWtf = _global2["wtf"];
        var WTF_ISSUE_555_ARRAY = WTF_ISSUE_555.split(",");
        if (isWtf) {
          apis = WTF_ISSUE_555_ARRAY.map(function(v) {
            return "HTML" + v + "Element";
          }).concat(NO_EVENT_TARGET);
        } else if (_global2[EVENT_TARGET]) {
          apis.push(EVENT_TARGET);
        } else {
          apis = NO_EVENT_TARGET;
        }
        var isDisableIECheck = _global2["__Zone_disable_IE_check"] || false;
        var isEnableCrossContextCheck = _global2["__Zone_enable_cross_context_check"] || false;
        var ieOrEdge2 = api.isIEOrEdge();
        var ADD_EVENT_LISTENER_SOURCE = ".addEventListener:";
        var FUNCTION_WRAPPER = "[object FunctionWrapper]";
        var BROWSER_TOOLS = "function __BROWSERTOOLS_CONSOLE_SAFEFUNC() { [native code] }";
        var pointerEventsMap = {
          "MSPointerCancel": "pointercancel",
          "MSPointerDown": "pointerdown",
          "MSPointerEnter": "pointerenter",
          "MSPointerHover": "pointerhover",
          "MSPointerLeave": "pointerleave",
          "MSPointerMove": "pointermove",
          "MSPointerOut": "pointerout",
          "MSPointerOver": "pointerover",
          "MSPointerUp": "pointerup"
        };
        for (var i = 0; i < eventNames2.length; i++) {
          var eventName = eventNames2[i];
          var falseEventName = eventName + FALSE_STR2;
          var trueEventName = eventName + TRUE_STR2;
          var symbol = ZONE_SYMBOL_PREFIX2 + falseEventName;
          var symbolCapture = ZONE_SYMBOL_PREFIX2 + trueEventName;
          zoneSymbolEventNames2[eventName] = {};
          zoneSymbolEventNames2[eventName][FALSE_STR2] = symbol;
          zoneSymbolEventNames2[eventName][TRUE_STR2] = symbolCapture;
        }
        for (var i = 0; i < WTF_ISSUE_555_ARRAY.length; i++) {
          var target = WTF_ISSUE_555_ARRAY[i];
          var targets = globalSources2[target] = {};
          for (var j = 0; j < eventNames2.length; j++) {
            var eventName = eventNames2[j];
            targets[eventName] = target + ADD_EVENT_LISTENER_SOURCE + eventName;
          }
        }
        var checkIEAndCrossContext = function(nativeDelegate, delegate, target2, args) {
          if (!isDisableIECheck && ieOrEdge2) {
            if (isEnableCrossContextCheck) {
              try {
                var testString = delegate.toString();
                if (testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS) {
                  nativeDelegate.apply(target2, args);
                  return false;
                }
              } catch (error) {
                nativeDelegate.apply(target2, args);
                return false;
              }
            } else {
              var testString = delegate.toString();
              if (testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS) {
                nativeDelegate.apply(target2, args);
                return false;
              }
            }
          } else if (isEnableCrossContextCheck) {
            try {
              delegate.toString();
            } catch (error) {
              nativeDelegate.apply(target2, args);
              return false;
            }
          }
          return true;
        };
        var apiTypes = [];
        for (var i = 0; i < apis.length; i++) {
          var type = _global2[apis[i]];
          apiTypes.push(type && type.prototype);
        }
        api.patchEventTarget(_global2, api, apiTypes, {
          vh: checkIEAndCrossContext,
          transferEventName: function(eventName2) {
            var pointerEventName = pointerEventsMap[eventName2];
            return pointerEventName || eventName2;
          }
        });
        Zone[api.symbol("patchEventTarget")] = !!_global2[EVENT_TARGET];
        return true;
      }
      function apply(api, _global2) {
        var _b = api.getGlobalObjects(), ADD_EVENT_LISTENER_STR2 = _b.ADD_EVENT_LISTENER_STR, REMOVE_EVENT_LISTENER_STR2 = _b.REMOVE_EVENT_LISTENER_STR;
        var WS = _global2.WebSocket;
        if (!_global2.EventTarget) {
          api.patchEventTarget(_global2, api, [WS.prototype]);
        }
        _global2.WebSocket = function(x, y) {
          var socket = arguments.length > 1 ? new WS(x, y) : new WS(x);
          var proxySocket;
          var proxySocketProto;
          var onmessageDesc = api.ObjectGetOwnPropertyDescriptor(socket, "onmessage");
          if (onmessageDesc && onmessageDesc.configurable === false) {
            proxySocket = api.ObjectCreate(socket);
            proxySocketProto = socket;
            [ADD_EVENT_LISTENER_STR2, REMOVE_EVENT_LISTENER_STR2, "send", "close"].forEach(function(propName) {
              proxySocket[propName] = function() {
                var args = api.ArraySlice.call(arguments);
                if (propName === ADD_EVENT_LISTENER_STR2 || propName === REMOVE_EVENT_LISTENER_STR2) {
                  var eventName = args.length > 0 ? args[0] : void 0;
                  if (eventName) {
                    var propertySymbol = Zone.__symbol__("ON_PROPERTY" + eventName);
                    socket[propertySymbol] = proxySocket[propertySymbol];
                  }
                }
                return socket[propName].apply(socket, args);
              };
            });
          } else {
            proxySocket = socket;
          }
          api.patchOnProperties(proxySocket, ["close", "error", "message", "open"], proxySocketProto);
          return proxySocket;
        };
        var globalWebSocket = _global2["WebSocket"];
        for (var prop in WS) {
          globalWebSocket[prop] = WS[prop];
        }
      }
      function propertyDescriptorLegacyPatch(api, _global2) {
        var _b = api.getGlobalObjects(), isNode2 = _b.isNode, isMix2 = _b.isMix;
        if (isNode2 && !isMix2) {
          return;
        }
        if (!canPatchViaPropertyDescriptor(api, _global2)) {
          var supportsWebSocket = typeof WebSocket !== "undefined";
          patchViaCapturingAllTheEvents(api);
          api.patchClass("XMLHttpRequest");
          if (supportsWebSocket) {
            apply(api, _global2);
          }
          Zone[api.symbol("patchEvents")] = true;
        }
      }
      function canPatchViaPropertyDescriptor(api, _global2) {
        var _b = api.getGlobalObjects(), isBrowser2 = _b.isBrowser, isMix2 = _b.isMix;
        if ((isBrowser2 || isMix2) && !api.ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, "onclick") && typeof Element !== "undefined") {
          var desc = api.ObjectGetOwnPropertyDescriptor(Element.prototype, "onclick");
          if (desc && !desc.configurable)
            return false;
          if (desc) {
            api.ObjectDefineProperty(Element.prototype, "onclick", {
              enumerable: true,
              configurable: true,
              get: function() {
                return true;
              }
            });
            var div = document.createElement("div");
            var result = !!div.onclick;
            api.ObjectDefineProperty(Element.prototype, "onclick", desc);
            return result;
          }
        }
        var XMLHttpRequest = _global2["XMLHttpRequest"];
        if (!XMLHttpRequest) {
          return false;
        }
        var ON_READY_STATE_CHANGE = "onreadystatechange";
        var XMLHttpRequestPrototype = XMLHttpRequest.prototype;
        var xhrDesc = api.ObjectGetOwnPropertyDescriptor(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE);
        if (xhrDesc) {
          api.ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {
            enumerable: true,
            configurable: true,
            get: function() {
              return true;
            }
          });
          var req = new XMLHttpRequest();
          var result = !!req.onreadystatechange;
          api.ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, xhrDesc || {});
          return result;
        } else {
          var SYMBOL_FAKE_ONREADYSTATECHANGE_1 = api.symbol("fake");
          api.ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {
            enumerable: true,
            configurable: true,
            get: function() {
              return this[SYMBOL_FAKE_ONREADYSTATECHANGE_1];
            },
            set: function(value) {
              this[SYMBOL_FAKE_ONREADYSTATECHANGE_1] = value;
            }
          });
          var req = new XMLHttpRequest();
          var detectFunc = function() {
          };
          req.onreadystatechange = detectFunc;
          var result = req[SYMBOL_FAKE_ONREADYSTATECHANGE_1] === detectFunc;
          req.onreadystatechange = null;
          return result;
        }
      }
      var globalEventHandlersEventNames = ["abort", "animationcancel", "animationend", "animationiteration", "auxclick", "beforeinput", "blur", "cancel", "canplay", "canplaythrough", "change", "compositionstart", "compositionupdate", "compositionend", "cuechange", "click", "close", "contextmenu", "curechange", "dblclick", "drag", "dragend", "dragenter", "dragexit", "dragleave", "dragover", "drop", "durationchange", "emptied", "ended", "error", "focus", "focusin", "focusout", "gotpointercapture", "input", "invalid", "keydown", "keypress", "keyup", "load", "loadstart", "loadeddata", "loadedmetadata", "lostpointercapture", "mousedown", "mouseenter", "mouseleave", "mousemove", "mouseout", "mouseover", "mouseup", "mousewheel", "orientationchange", "pause", "play", "playing", "pointercancel", "pointerdown", "pointerenter", "pointerleave", "pointerlockchange", "mozpointerlockchange", "webkitpointerlockerchange", "pointerlockerror", "mozpointerlockerror", "webkitpointerlockerror", "pointermove", "pointout", "pointerover", "pointerup", "progress", "ratechange", "reset", "resize", "scroll", "seeked", "seeking", "select", "selectionchange", "selectstart", "show", "sort", "stalled", "submit", "suspend", "timeupdate", "volumechange", "touchcancel", "touchmove", "touchstart", "touchend", "transitioncancel", "transitionend", "waiting", "wheel"];
      var documentEventNames = ["afterscriptexecute", "beforescriptexecute", "DOMContentLoaded", "freeze", "fullscreenchange", "mozfullscreenchange", "webkitfullscreenchange", "msfullscreenchange", "fullscreenerror", "mozfullscreenerror", "webkitfullscreenerror", "msfullscreenerror", "readystatechange", "visibilitychange", "resume"];
      var windowEventNames = ["absolutedeviceorientation", "afterinput", "afterprint", "appinstalled", "beforeinstallprompt", "beforeprint", "beforeunload", "devicelight", "devicemotion", "deviceorientation", "deviceorientationabsolute", "deviceproximity", "hashchange", "languagechange", "message", "mozbeforepaint", "offline", "online", "paint", "pageshow", "pagehide", "popstate", "rejectionhandled", "storage", "unhandledrejection", "unload", "userproximity", "vrdisplayconnected", "vrdisplaydisconnected", "vrdisplaypresentchange"];
      var htmlElementEventNames = ["beforecopy", "beforecut", "beforepaste", "copy", "cut", "paste", "dragstart", "loadend", "animationstart", "search", "transitionrun", "transitionstart", "webkitanimationend", "webkitanimationiteration", "webkitanimationstart", "webkittransitionend"];
      var ieElementEventNames = ["activate", "afterupdate", "ariarequest", "beforeactivate", "beforedeactivate", "beforeeditfocus", "beforeupdate", "cellchange", "controlselect", "dataavailable", "datasetchanged", "datasetcomplete", "errorupdate", "filterchange", "layoutcomplete", "losecapture", "move", "moveend", "movestart", "propertychange", "resizeend", "resizestart", "rowenter", "rowexit", "rowsdelete", "rowsinserted", "command", "compassneedscalibration", "deactivate", "help", "mscontentzoom", "msmanipulationstatechanged", "msgesturechange", "msgesturedoubletap", "msgestureend", "msgesturehold", "msgesturestart", "msgesturetap", "msgotpointercapture", "msinertiastart", "mslostpointercapture", "mspointercancel", "mspointerdown", "mspointerenter", "mspointerhover", "mspointerleave", "mspointermove", "mspointerout", "mspointerover", "mspointerup", "pointerout", "mssitemodejumplistitemremoved", "msthumbnailclick", "stop", "storagecommit"];
      var webglEventNames = ["webglcontextrestored", "webglcontextlost", "webglcontextcreationerror"];
      var formEventNames = ["autocomplete", "autocompleteerror"];
      var detailEventNames = ["toggle"];
      var eventNames = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], globalEventHandlersEventNames, true), webglEventNames, true), formEventNames, true), detailEventNames, true), documentEventNames, true), windowEventNames, true), htmlElementEventNames, true), ieElementEventNames, true);
      function patchViaCapturingAllTheEvents(api) {
        var unboundKey = api.symbol("unbound");
        var _loop_5 = function(i2) {
          var property = eventNames[i2];
          var onproperty = "on" + property;
          self.addEventListener(property, function(event) {
            var elt = event.target, bound, source;
            if (elt) {
              source = elt.constructor["name"] + "." + onproperty;
            } else {
              source = "unknown." + onproperty;
            }
            while (elt) {
              if (elt[onproperty] && !elt[onproperty][unboundKey]) {
                bound = api.wrapWithCurrentZone(elt[onproperty], source);
                bound[unboundKey] = elt[onproperty];
                elt[onproperty] = bound;
              }
              elt = elt.parentElement;
            }
          }, true);
        };
        for (var i = 0; i < eventNames.length; i++) {
          _loop_5(i);
        }
      }
      function registerElementPatch(_global2, api) {
        var _b = api.getGlobalObjects(), isBrowser2 = _b.isBrowser, isMix2 = _b.isMix;
        if (!isBrowser2 && !isMix2 || !("registerElement" in _global2.document)) {
          return;
        }
        var callbacks = ["createdCallback", "attachedCallback", "detachedCallback", "attributeChangedCallback"];
        api.patchCallbacks(api, document, "Document", "registerElement", callbacks);
      }
      (function(_global2) {
        var symbolPrefix = _global2["__Zone_symbol_prefix"] || "__zone_symbol__";
        function __symbol__(name) {
          return symbolPrefix + name;
        }
        _global2[__symbol__("legacyPatch")] = function() {
          var Zone2 = _global2["Zone"];
          Zone2.__load_patch("defineProperty", function(global2, Zone3, api) {
            api._redefineProperty = _redefineProperty;
            propertyPatch();
          });
          Zone2.__load_patch("registerElement", function(global2, Zone3, api) {
            registerElementPatch(global2, api);
          });
          Zone2.__load_patch("EventTargetLegacy", function(global2, Zone3, api) {
            eventTargetLegacyPatch(global2, api);
            propertyDescriptorLegacyPatch(api, global2);
          });
        };
      })(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {});
      var taskSymbol = zoneSymbol$1("zoneTask");
      function patchTimer(window2, setName, cancelName, nameSuffix) {
        var setNative = null;
        var clearNative = null;
        setName += nameSuffix;
        cancelName += nameSuffix;
        var tasksByHandleId = {};
        function scheduleTask(task) {
          var data = task.data;
          data.args[0] = function() {
            return task.invoke.apply(this, arguments);
          };
          data.handleId = setNative.apply(window2, data.args);
          return task;
        }
        function clearTask(task) {
          return clearNative.call(window2, task.data.handleId);
        }
        setNative = patchMethod(window2, setName, function(delegate) {
          return function(self2, args) {
            if (typeof args[0] === "function") {
              var options_1 = {
                isPeriodic: nameSuffix === "Interval",
                delay: nameSuffix === "Timeout" || nameSuffix === "Interval" ? args[1] || 0 : void 0,
                args
              };
              var callback_1 = args[0];
              args[0] = function timer() {
                try {
                  return callback_1.apply(this, arguments);
                } finally {
                  if (!options_1.isPeriodic) {
                    if (typeof options_1.handleId === "number") {
                      delete tasksByHandleId[options_1.handleId];
                    } else if (options_1.handleId) {
                      options_1.handleId[taskSymbol] = null;
                    }
                  }
                }
              };
              var task = scheduleMacroTaskWithCurrentZone(setName, args[0], options_1, scheduleTask, clearTask);
              if (!task) {
                return task;
              }
              var handle = task.data.handleId;
              if (typeof handle === "number") {
                tasksByHandleId[handle] = task;
              } else if (handle) {
                handle[taskSymbol] = task;
              }
              if (handle && handle.ref && handle.unref && typeof handle.ref === "function" && typeof handle.unref === "function") {
                task.ref = handle.ref.bind(handle);
                task.unref = handle.unref.bind(handle);
              }
              if (typeof handle === "number" || handle) {
                return handle;
              }
              return task;
            } else {
              return delegate.apply(window2, args);
            }
          };
        });
        clearNative = patchMethod(window2, cancelName, function(delegate) {
          return function(self2, args) {
            var id = args[0];
            var task;
            if (typeof id === "number") {
              task = tasksByHandleId[id];
            } else {
              task = id && id[taskSymbol];
              if (!task) {
                task = id;
              }
            }
            if (task && typeof task.type === "string") {
              if (task.state !== "notScheduled" && (task.cancelFn && task.data.isPeriodic || task.runCount === 0)) {
                if (typeof id === "number") {
                  delete tasksByHandleId[id];
                } else if (id) {
                  id[taskSymbol] = null;
                }
                task.zone.cancelTask(task);
              }
            } else {
              delegate.apply(window2, args);
            }
          };
        });
      }
      function patchCustomElements(_global2, api) {
        var _b = api.getGlobalObjects(), isBrowser2 = _b.isBrowser, isMix2 = _b.isMix;
        if (!isBrowser2 && !isMix2 || !_global2["customElements"] || !("customElements" in _global2)) {
          return;
        }
        var callbacks = ["connectedCallback", "disconnectedCallback", "adoptedCallback", "attributeChangedCallback"];
        api.patchCallbacks(api, _global2.customElements, "customElements", "define", callbacks);
      }
      function eventTargetPatch(_global2, api) {
        if (Zone[api.symbol("patchEventTarget")]) {
          return;
        }
        var _b = api.getGlobalObjects(), eventNames2 = _b.eventNames, zoneSymbolEventNames2 = _b.zoneSymbolEventNames, TRUE_STR2 = _b.TRUE_STR, FALSE_STR2 = _b.FALSE_STR, ZONE_SYMBOL_PREFIX2 = _b.ZONE_SYMBOL_PREFIX;
        for (var i = 0; i < eventNames2.length; i++) {
          var eventName = eventNames2[i];
          var falseEventName = eventName + FALSE_STR2;
          var trueEventName = eventName + TRUE_STR2;
          var symbol = ZONE_SYMBOL_PREFIX2 + falseEventName;
          var symbolCapture = ZONE_SYMBOL_PREFIX2 + trueEventName;
          zoneSymbolEventNames2[eventName] = {};
          zoneSymbolEventNames2[eventName][FALSE_STR2] = symbol;
          zoneSymbolEventNames2[eventName][TRUE_STR2] = symbolCapture;
        }
        var EVENT_TARGET = _global2["EventTarget"];
        if (!EVENT_TARGET || !EVENT_TARGET.prototype) {
          return;
        }
        api.patchEventTarget(_global2, api, [EVENT_TARGET && EVENT_TARGET.prototype]);
        return true;
      }
      function patchEvent(global2, api) {
        api.patchEventPrototype(global2, api);
      }
      Zone.__load_patch("legacy", function(global2) {
        var legacyPatch = global2[Zone.__symbol__("legacyPatch")];
        if (legacyPatch) {
          legacyPatch();
        }
      });
      Zone.__load_patch("queueMicrotask", function(global2, Zone2, api) {
        api.patchMethod(global2, "queueMicrotask", function(delegate) {
          return function(self2, args) {
            Zone2.current.scheduleMicroTask("queueMicrotask", args[0]);
          };
        });
      });
      Zone.__load_patch("timers", function(global2) {
        var set = "set";
        var clear = "clear";
        patchTimer(global2, set, clear, "Timeout");
        patchTimer(global2, set, clear, "Interval");
        patchTimer(global2, set, clear, "Immediate");
      });
      Zone.__load_patch("requestAnimationFrame", function(global2) {
        patchTimer(global2, "request", "cancel", "AnimationFrame");
        patchTimer(global2, "mozRequest", "mozCancel", "AnimationFrame");
        patchTimer(global2, "webkitRequest", "webkitCancel", "AnimationFrame");
      });
      Zone.__load_patch("blocking", function(global2, Zone2) {
        var blockingMethods = ["alert", "prompt", "confirm"];
        for (var i = 0; i < blockingMethods.length; i++) {
          var name_2 = blockingMethods[i];
          patchMethod(global2, name_2, function(delegate, symbol, name) {
            return function(s, args) {
              return Zone2.current.run(delegate, global2, args, name);
            };
          });
        }
      });
      Zone.__load_patch("EventTarget", function(global2, Zone2, api) {
        patchEvent(global2, api);
        eventTargetPatch(global2, api);
        var XMLHttpRequestEventTarget = global2["XMLHttpRequestEventTarget"];
        if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {
          api.patchEventTarget(global2, api, [XMLHttpRequestEventTarget.prototype]);
        }
      });
      Zone.__load_patch("MutationObserver", function(global2, Zone2, api) {
        patchClass("MutationObserver");
        patchClass("WebKitMutationObserver");
      });
      Zone.__load_patch("IntersectionObserver", function(global2, Zone2, api) {
        patchClass("IntersectionObserver");
      });
      Zone.__load_patch("FileReader", function(global2, Zone2, api) {
        patchClass("FileReader");
      });
      Zone.__load_patch("on_property", function(global2, Zone2, api) {
        propertyDescriptorPatch(api, global2);
      });
      Zone.__load_patch("customElements", function(global2, Zone2, api) {
        patchCustomElements(global2, api);
      });
      Zone.__load_patch("XHR", function(global2, Zone2) {
        patchXHR(global2);
        var XHR_TASK = zoneSymbol$1("xhrTask");
        var XHR_SYNC = zoneSymbol$1("xhrSync");
        var XHR_LISTENER = zoneSymbol$1("xhrListener");
        var XHR_SCHEDULED = zoneSymbol$1("xhrScheduled");
        var XHR_URL = zoneSymbol$1("xhrURL");
        var XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol$1("xhrErrorBeforeScheduled");
        function patchXHR(window2) {
          var XMLHttpRequest = window2["XMLHttpRequest"];
          if (!XMLHttpRequest) {
            return;
          }
          var XMLHttpRequestPrototype = XMLHttpRequest.prototype;
          function findPendingTask(target) {
            return target[XHR_TASK];
          }
          var oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
          var oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
          if (!oriAddListener) {
            var XMLHttpRequestEventTarget_1 = window2["XMLHttpRequestEventTarget"];
            if (XMLHttpRequestEventTarget_1) {
              var XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget_1.prototype;
              oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
              oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
            }
          }
          var READY_STATE_CHANGE = "readystatechange";
          var SCHEDULED = "scheduled";
          function scheduleTask(task) {
            var data = task.data;
            var target = data.target;
            target[XHR_SCHEDULED] = false;
            target[XHR_ERROR_BEFORE_SCHEDULED] = false;
            var listener = target[XHR_LISTENER];
            if (!oriAddListener) {
              oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];
              oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
            }
            if (listener) {
              oriRemoveListener.call(target, READY_STATE_CHANGE, listener);
            }
            var newListener = target[XHR_LISTENER] = function() {
              if (target.readyState === target.DONE) {
                if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED) {
                  var loadTasks = target[Zone2.__symbol__("loadfalse")];
                  if (target.status !== 0 && loadTasks && loadTasks.length > 0) {
                    var oriInvoke_1 = task.invoke;
                    task.invoke = function() {
                      var loadTasks2 = target[Zone2.__symbol__("loadfalse")];
                      for (var i = 0; i < loadTasks2.length; i++) {
                        if (loadTasks2[i] === task) {
                          loadTasks2.splice(i, 1);
                        }
                      }
                      if (!data.aborted && task.state === SCHEDULED) {
                        oriInvoke_1.call(task);
                      }
                    };
                    loadTasks.push(task);
                  } else {
                    task.invoke();
                  }
                } else if (!data.aborted && target[XHR_SCHEDULED] === false) {
                  target[XHR_ERROR_BEFORE_SCHEDULED] = true;
                }
              }
            };
            oriAddListener.call(target, READY_STATE_CHANGE, newListener);
            var storedTask = target[XHR_TASK];
            if (!storedTask) {
              target[XHR_TASK] = task;
            }
            sendNative.apply(target, data.args);
            target[XHR_SCHEDULED] = true;
            return task;
          }
          function placeholderCallback() {
          }
          function clearTask(task) {
            var data = task.data;
            data.aborted = true;
            return abortNative.apply(data.target, data.args);
          }
          var openNative = patchMethod(XMLHttpRequestPrototype, "open", function() {
            return function(self2, args) {
              self2[XHR_SYNC] = args[2] == false;
              self2[XHR_URL] = args[1];
              return openNative.apply(self2, args);
            };
          });
          var XMLHTTPREQUEST_SOURCE = "XMLHttpRequest.send";
          var fetchTaskAborting = zoneSymbol$1("fetchTaskAborting");
          var fetchTaskScheduling = zoneSymbol$1("fetchTaskScheduling");
          var sendNative = patchMethod(XMLHttpRequestPrototype, "send", function() {
            return function(self2, args) {
              if (Zone2.current[fetchTaskScheduling] === true) {
                return sendNative.apply(self2, args);
              }
              if (self2[XHR_SYNC]) {
                return sendNative.apply(self2, args);
              } else {
                var options2 = {
                  target: self2,
                  url: self2[XHR_URL],
                  isPeriodic: false,
                  args,
                  aborted: false
                };
                var task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options2, scheduleTask, clearTask);
                if (self2 && self2[XHR_ERROR_BEFORE_SCHEDULED] === true && !options2.aborted && task.state === SCHEDULED) {
                  task.invoke();
                }
              }
            };
          });
          var abortNative = patchMethod(XMLHttpRequestPrototype, "abort", function() {
            return function(self2, args) {
              var task = findPendingTask(self2);
              if (task && typeof task.type == "string") {
                if (task.cancelFn == null || task.data && task.data.aborted) {
                  return;
                }
                task.zone.cancelTask(task);
              } else if (Zone2.current[fetchTaskAborting] === true) {
                return abortNative.apply(self2, args);
              }
            };
          });
        }
      });
      Zone.__load_patch("geolocation", function(global2) {
        if (global2["navigator"] && global2["navigator"].geolocation) {
          patchPrototype(global2["navigator"].geolocation, ["getCurrentPosition", "watchPosition"]);
        }
      });
      Zone.__load_patch("PromiseRejectionEvent", function(global2, Zone2) {
        function findPromiseRejectionHandler(evtName) {
          return function(e) {
            var eventTasks = findEventTasks(global2, evtName);
            eventTasks.forEach(function(eventTask) {
              var PromiseRejectionEvent = global2["PromiseRejectionEvent"];
              if (PromiseRejectionEvent) {
                var evt = new PromiseRejectionEvent(evtName, {
                  promise: e.promise,
                  reason: e.rejection
                });
                eventTask.invoke(evt);
              }
            });
          };
        }
        if (global2["PromiseRejectionEvent"]) {
          Zone2[zoneSymbol$1("unhandledPromiseRejectionHandler")] = findPromiseRejectionHandler("unhandledrejection");
          Zone2[zoneSymbol$1("rejectionHandledHandler")] = findPromiseRejectionHandler("rejectionhandled");
        }
      });
    });
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-polyfills.js
var require_angular_polyfills = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/preview/angular-polyfills.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    require_reflect();
    require_reflect_metadata2();
    require_zone();
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/preview/globals.js
var require_globals = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/preview/globals.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var global_1 = __importDefault(require_window());
    require_angular_polyfills();
    var {
      window: globalWindow
    } = global_1.default;
    globalWindow.STORYBOOK_ENV = "angular";
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/preview/decorateStory.js
var require_decorateStory = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/preview/decorateStory.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.decorateStory = void 0;
    var store_1 = (init_esm(), __toCommonJS(esm_exports));
    var ComputesTemplateFromComponent_1 = require_ComputesTemplateFromComponent();
    function decorateStory(mainStoryFn, decorators) {
      const returnDecorators = [cleanArgsDecorator, ...decorators].reduce((previousStoryFn, decorator) => (context) => {
        const decoratedStory = decorator((update) => {
          return previousStoryFn(Object.assign(Object.assign({}, context), store_1.sanitizeStoryContextUpdate(update)));
        }, context);
        return decoratedStory;
      }, (context) => prepareMain(mainStoryFn(context), context));
      return returnDecorators;
    }
    exports.default = decorateStory;
    exports.decorateStory = decorateStory;
    var prepareMain = (story, context) => {
      var _a;
      let {
        template
      } = story;
      const component = (_a = story.component) !== null && _a !== void 0 ? _a : context.component;
      const userDefinedTemplate = !hasNoTemplate(template);
      if (!userDefinedTemplate && component) {
        template = ComputesTemplateFromComponent_1.computesTemplateFromComponent(component, story.props, "");
      }
      return Object.assign(Object.assign({}, story), template ? {
        template,
        userDefinedTemplate
      } : {});
    };
    function hasNoTemplate(template) {
      return template === null || template === void 0;
    }
    var cleanArgsDecorator = (storyFn, context) => {
      if (!context.argTypes || !context.args) {
        return storyFn();
      }
      const argsToClean = context.args;
      context.args = Object.entries(argsToClean).reduce((obj, [key, arg]) => {
        const argType = context.argTypes[key];
        if (argType.action || argType.control) {
          return Object.assign(Object.assign({}, obj), {
            [key]: arg
          });
        }
        return obj;
      }, {});
      return storyFn();
    };
  }
});

export {
  require_globals,
  require_decorateStory
};
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license Angular v14.2.0-next.0
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */
//# sourceMappingURL=chunk-WJEW4R2Q.js.map

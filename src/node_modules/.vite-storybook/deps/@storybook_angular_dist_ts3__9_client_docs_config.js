import {
  require_AbstractRenderer,
  require_ComputesTemplateFromComponent,
  require_StorybookModule,
  require_render
} from "./chunk-LJ3IEFZ4.js";
import {
  esm_exports as esm_exports2,
  init_esm as init_esm2
} from "./chunk-RX73PFGZ.js";
import "./chunk-6FYGJW3W.js";
import "./chunk-QEU5N7GB.js";
import "./chunk-V45CFCVC.js";
import {
  require_react
} from "./chunk-K752SRNE.js";
import "./chunk-5O2WHUJJ.js";
import "./chunk-OZQQIWNJ.js";
import "./chunk-SNOMC6VJ.js";
import "./chunk-KG7BQZDK.js";
import "./chunk-KTUVAV7V.js";
import "./chunk-VDE36RDP.js";
import "./chunk-RMLPABRZ.js";
import "./chunk-W2D6HU57.js";
import "./chunk-RRLAOTK5.js";
import "./chunk-7A5D66RZ.js";
import "./chunk-PKAGMMWM.js";
import "./chunk-LPLROBCZ.js";
import "./chunk-XL3K3IFI.js";
import "./chunk-4PP7MJLK.js";
import "./chunk-PRKSDZJ7.js";
import "./chunk-NI6SYZXJ.js";
import "./chunk-BRGE3CC3.js";
import "./chunk-EGGYOLSG.js";
import "./chunk-KH72JYYV.js";
import "./chunk-HW3V75JW.js";
import "./chunk-CTWLEC5L.js";
import "./chunk-OWXYKFZF.js";
import "./chunk-CKPI7PPM.js";
import "./chunk-MVHXZJ7R.js";
import "./chunk-BBSLMMPY.js";
import "./chunk-A2M4WVPM.js";
import "./chunk-FYHQDFS5.js";
import "./chunk-6Z2FEXTT.js";
import "./chunk-5PVVCOXY.js";
import "./chunk-DOYNGMP7.js";
import "./chunk-PBOAUILL.js";
import "./chunk-TUC52E5H.js";
import "./chunk-CXGBN7TM.js";
import "./chunk-6U3CPX5O.js";
import "./chunk-5O2ZVARR.js";
import "./chunk-QVBDHYQC.js";
import "./chunk-KALBQNGD.js";
import "./chunk-TI3LP2MB.js";
import "./chunk-DILLJFT7.js";
import "./chunk-22MSJSSA.js";
import "./chunk-PDOCRJUQ.js";
import {
  init_public_api,
  public_api_exports
} from "./chunk-ZXUQATKE.js";
import "./chunk-SMUDPA5R.js";
import "./chunk-RM5OFEJP.js";
import "./chunk-AEOGDXCK.js";
import "./chunk-JFKL56PB.js";
import "./chunk-H4YRAWJN.js";
import "./chunk-FRD2Y65G.js";
import "./chunk-AKWMTN3F.js";
import "./chunk-OPAZLAKG.js";
import "./chunk-ZFQV7LAJ.js";
import "./chunk-ZBKRFRJR.js";
import "./chunk-I5E2LDZG.js";
import "./chunk-MLRES4EW.js";
import "./chunk-SOXTS23D.js";
import "./chunk-JL3N5MFZ.js";
import "./chunk-BRZ4O3VM.js";
import "./chunk-FFTII2VF.js";
import "./chunk-M44U7DA3.js";
import "./chunk-YTGDRGKZ.js";
import "./chunk-I23GJHOG.js";
import "./chunk-ONHSBKBM.js";
import "./chunk-O6SCRI3K.js";
import "./chunk-2FEBKAZL.js";
import "./chunk-4ZGR7LKU.js";
import "./chunk-VYLTT7BA.js";
import "./chunk-BNKHNS7O.js";
import "./chunk-CFMFTW6U.js";
import "./chunk-OLZ5WG4Z.js";
import "./chunk-N2FZLRTI.js";
import "./chunk-XAJ4SFQJ.js";
import {
  esm_exports,
  init_esm
} from "./chunk-WDY4P2NX.js";
import "./chunk-IPK6NK5O.js";
import "./chunk-XCM4TOIV.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  init_define_ngDevMode
} from "./chunk-XN7ES5DP.js";

// node_modules/@storybook/angular/dist/ts3.9/client/docs/compodoc.js
var require_compodoc = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/docs/compodoc.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.extractComponentDescription = exports.extractArgTypes = exports.extractArgTypesFromData = exports.extractType = exports.findComponentByName = exports.checkValidCompodocJson = exports.checkValidComponentOrDirective = exports.getCompodocJson = exports.setCompodocJson = exports.isMethod = void 0;
    var client_logger_1 = (init_esm(), __toCommonJS(esm_exports));
    exports.isMethod = (methodOrProp) => {
      return methodOrProp.args !== void 0;
    };
    exports.setCompodocJson = (compodocJson) => {
      window.__STORYBOOK_COMPODOC_JSON__ = compodocJson;
    };
    exports.getCompodocJson = () => window.__STORYBOOK_COMPODOC_JSON__;
    exports.checkValidComponentOrDirective = (component) => {
      if (!component.name) {
        throw new Error(`Invalid component ${JSON.stringify(component)}`);
      }
    };
    exports.checkValidCompodocJson = (compodocJson) => {
      if (!compodocJson || !compodocJson.components) {
        throw new Error("Invalid compodoc JSON");
      }
    };
    var hasDecorator = (item, decoratorName) => item.decorators && item.decorators.find((x) => x.name === decoratorName);
    var mapPropertyToSection = (item) => {
      if (hasDecorator(item, "ViewChild")) {
        return "view child";
      }
      if (hasDecorator(item, "ViewChildren")) {
        return "view children";
      }
      if (hasDecorator(item, "ContentChild")) {
        return "content child";
      }
      if (hasDecorator(item, "ContentChildren")) {
        return "content children";
      }
      return "properties";
    };
    var mapItemToSection = (key, item) => {
      switch (key) {
        case "methods":
        case "methodsClass":
          return "methods";
        case "inputsClass":
          return "inputs";
        case "outputsClass":
          return "outputs";
        case "properties":
        case "propertiesClass":
          if (exports.isMethod(item)) {
            throw new Error("Cannot be of type Method if key === 'propertiesClass'");
          }
          return mapPropertyToSection(item);
        default:
          throw new Error(`Unknown key: ${key}`);
      }
    };
    exports.findComponentByName = (name, compodocJson) => compodocJson.components.find((c) => c.name === name) || compodocJson.directives.find((c) => c.name === name) || compodocJson.pipes.find((c) => c.name === name) || compodocJson.injectables.find((c) => c.name === name) || compodocJson.classes.find((c) => c.name === name);
    var getComponentData = (component) => {
      if (!component) {
        return null;
      }
      exports.checkValidComponentOrDirective(component);
      const compodocJson = exports.getCompodocJson();
      if (!compodocJson) {
        return null;
      }
      exports.checkValidCompodocJson(compodocJson);
      const {
        name
      } = component;
      const metadata = exports.findComponentByName(name, compodocJson);
      if (!metadata) {
        client_logger_1.logger.warn(`Component not found in compodoc JSON: '${name}'`);
      }
      return metadata;
    };
    var displaySignature = (item) => {
      const args = item.args.map((arg) => `${arg.name}${arg.optional ? "?" : ""}: ${arg.type}`);
      return `(${args.join(", ")}) => ${item.returnType}`;
    };
    var extractTypeFromValue = (defaultValue) => {
      const valueType = typeof defaultValue;
      return defaultValue || valueType === "number" || valueType === "boolean" || valueType === "string" ? valueType : null;
    };
    var extractEnumValues = (compodocType) => {
      var _a, _b;
      const compodocJson = exports.getCompodocJson();
      const enumType = (_b = (_a = compodocJson === null || compodocJson === void 0 ? void 0 : compodocJson.miscellaneous) === null || _a === void 0 ? void 0 : _a.enumerations) === null || _b === void 0 ? void 0 : _b.find((x) => x.name === compodocType);
      if (enumType === null || enumType === void 0 ? void 0 : enumType.childs.every((x) => x.value)) {
        return enumType.childs.map((x) => x.value);
      }
      if (typeof compodocType !== "string" || compodocType.indexOf("|") === -1) {
        return null;
      }
      try {
        return compodocType.split("|").map((value) => JSON.parse(value));
      } catch (e) {
        return null;
      }
    };
    exports.extractType = (property, defaultValue) => {
      const compodocType = property.type || extractTypeFromValue(defaultValue);
      switch (compodocType) {
        case "string":
        case "boolean":
        case "number":
          return {
            name: compodocType
          };
        case void 0:
        case null:
          return {
            name: "void"
          };
        default: {
          const resolvedType = resolveTypealias(compodocType);
          const enumValues = extractEnumValues(resolvedType);
          return enumValues ? {
            name: "enum",
            value: enumValues
          } : {
            name: "object"
          };
        }
      }
    };
    var castDefaultValue = (property, defaultValue) => {
      const compodocType = property.type;
      if (["boolean", "number", "string", "EventEmitter"].includes(compodocType)) {
        switch (compodocType) {
          case "boolean":
            return defaultValue === "true";
          case "number":
            return Number(defaultValue);
          case "EventEmitter":
            return void 0;
          default:
            return defaultValue;
        }
      } else {
        switch (defaultValue) {
          case "true":
            return true;
          case "false":
            return false;
          case "null":
            return null;
          case "undefined":
            return void 0;
          default:
            return defaultValue;
        }
      }
    };
    var extractDefaultValueFromComments = (property, value) => {
      let commentValue = value;
      property.jsdoctags.forEach((tag) => {
        if (["default", "defaultvalue"].includes(tag.tagName.escapedText)) {
          const dom = new window.DOMParser().parseFromString(tag.comment, "text/html");
          commentValue = dom.body.textContent;
        }
      });
      return commentValue;
    };
    var extractDefaultValue = (property) => {
      var _a, _b;
      try {
        let value = (_a = property.defaultValue) === null || _a === void 0 ? void 0 : _a.replace(/^'(.*)'$/, "$1");
        value = castDefaultValue(property, value);
        if (value == null && ((_b = property.jsdoctags) === null || _b === void 0 ? void 0 : _b.length) > 0) {
          value = extractDefaultValueFromComments(property, value);
        }
        return value;
      } catch (err) {
        client_logger_1.logger.debug(`Error extracting ${property.name}: ${property.defaultValue}`);
        return void 0;
      }
    };
    var resolveTypealias = (compodocType) => {
      var _a, _b;
      const compodocJson = exports.getCompodocJson();
      const typeAlias = (_b = (_a = compodocJson === null || compodocJson === void 0 ? void 0 : compodocJson.miscellaneous) === null || _a === void 0 ? void 0 : _a.typealiases) === null || _b === void 0 ? void 0 : _b.find((x) => x.name === compodocType);
      return typeAlias ? resolveTypealias(typeAlias.rawtype) : compodocType;
    };
    exports.extractArgTypesFromData = (componentData) => {
      const sectionToItems = {};
      const compodocClasses = ["component", "directive"].includes(componentData.type) ? ["propertiesClass", "methodsClass", "inputsClass", "outputsClass"] : ["properties", "methods"];
      compodocClasses.forEach((key) => {
        const data = componentData[key] || [];
        data.forEach((item) => {
          const section = mapItemToSection(key, item);
          const defaultValue = exports.isMethod(item) ? void 0 : extractDefaultValue(item);
          const type = exports.isMethod(item) || section !== "inputs" && section !== "properties" ? {
            name: "void"
          } : exports.extractType(item, defaultValue);
          const action = section === "outputs" ? {
            action: item.name
          } : {};
          const argType = Object.assign(Object.assign({
            name: item.name,
            description: item.rawdescription || item.description,
            defaultValue,
            type
          }, action), {
            table: {
              category: section,
              type: {
                summary: exports.isMethod(item) ? displaySignature(item) : item.type,
                required: exports.isMethod(item) ? false : !item.optional
              },
              defaultValue: {
                summary: defaultValue
              }
            }
          });
          if (!sectionToItems[section]) {
            sectionToItems[section] = [];
          }
          sectionToItems[section].push(argType);
        });
      });
      const SECTIONS = ["properties", "inputs", "outputs", "methods", "view child", "view children", "content child", "content children"];
      const argTypes = {};
      SECTIONS.forEach((section) => {
        const items = sectionToItems[section];
        if (items) {
          items.forEach((argType) => {
            argTypes[argType.name] = argType;
          });
        }
      });
      return argTypes;
    };
    exports.extractArgTypes = (component) => {
      const componentData = getComponentData(component);
      return componentData && exports.extractArgTypesFromData(componentData);
    };
    exports.extractComponentDescription = (component) => {
      const componentData = getComponentData(component);
      return componentData && (componentData.rawdescription || componentData.description);
    };
  }
});

// node_modules/@storybook/angular/dist/ts3.9/renderer.js
var require_renderer = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/renderer.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var ComputesTemplateFromComponent_1 = require_ComputesTemplateFromComponent();
    Object.defineProperty(exports, "computesTemplateSourceFromComponent", {
      enumerable: true,
      get: function() {
        return ComputesTemplateFromComponent_1.computesTemplateSourceFromComponent;
      }
    });
    var render_1 = require_render();
    Object.defineProperty(exports, "rendererFactory", {
      enumerable: true,
      get: function() {
        return render_1.rendererFactory;
      }
    });
    var AbstractRenderer_1 = require_AbstractRenderer();
    Object.defineProperty(exports, "AbstractRenderer", {
      enumerable: true,
      get: function() {
        return AbstractRenderer_1.AbstractRenderer;
      }
    });
    var StorybookModule_1 = require_StorybookModule();
    Object.defineProperty(exports, "getStorybookModuleMetadata", {
      enumerable: true,
      get: function() {
        return StorybookModule_1.getStorybookModuleMetadata;
      }
    });
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/docs/sourceDecorator.js
var require_sourceDecorator = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/docs/sourceDecorator.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.sourceDecorator = exports.skipSourceRender = void 0;
    var addons_1 = (init_public_api(), __toCommonJS(public_api_exports));
    var docs_tools_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var renderer_1 = require_renderer();
    exports.skipSourceRender = (context) => {
      var _a;
      const sourceParams = (_a = context === null || context === void 0 ? void 0 : context.parameters.docs) === null || _a === void 0 ? void 0 : _a.source;
      if ((sourceParams === null || sourceParams === void 0 ? void 0 : sourceParams.type) === docs_tools_1.SourceType.DYNAMIC) {
        return false;
      }
      return (sourceParams === null || sourceParams === void 0 ? void 0 : sourceParams.code) || (sourceParams === null || sourceParams === void 0 ? void 0 : sourceParams.type) === docs_tools_1.SourceType.CODE;
    };
    exports.sourceDecorator = (storyFn, context) => {
      const story = storyFn();
      if (exports.skipSourceRender(context)) {
        return story;
      }
      const channel = addons_1.addons.getChannel();
      const {
        props,
        template,
        userDefinedTemplate
      } = story;
      const {
        component,
        argTypes
      } = context;
      let toEmit;
      addons_1.useEffect(() => {
        if (toEmit) {
          channel.emit(docs_tools_1.SNIPPET_RENDERED, context.id, toEmit, "angular");
        }
      });
      if (component && !userDefinedTemplate) {
        const source = renderer_1.computesTemplateSourceFromComponent(component, props, argTypes);
        if (source || template) {
          toEmit = source || template;
        }
      } else if (template) {
        toEmit = template;
      }
      return story;
    };
  }
});

// node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
var init_asyncToGenerator = __esm({
  "node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"() {
    init_define_ngDevMode();
  }
});

// node_modules/yocto-queue/index.js
var require_yocto_queue = __commonJS({
  "node_modules/yocto-queue/index.js"(exports, module) {
    init_define_ngDevMode();
    var Node = class {
      constructor(value) {
        this.value = value;
        this.next = void 0;
      }
    };
    var Queue = class {
      constructor() {
        this.clear();
      }
      enqueue(value) {
        const node = new Node(value);
        if (this._head) {
          this._tail.next = node;
          this._tail = node;
        } else {
          this._head = node;
          this._tail = node;
        }
        this._size++;
      }
      dequeue() {
        const current = this._head;
        if (!current) {
          return;
        }
        this._head = this._head.next;
        this._size--;
        return current.value;
      }
      clear() {
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
      }
      get size() {
        return this._size;
      }
      *[Symbol.iterator]() {
        let current = this._head;
        while (current) {
          yield current.value;
          current = current.next;
        }
      }
    };
    module.exports = Queue;
  }
});

// node_modules/p-limit/index.js
var require_p_limit = __commonJS({
  "node_modules/p-limit/index.js"(exports, module) {
    "use strict";
    init_define_ngDevMode();
    init_asyncToGenerator();
    var Queue = require_yocto_queue();
    var pLimit = (concurrency) => {
      if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
        throw new TypeError("Expected `concurrency` to be a number from 1 and up");
      }
      const queue = new Queue();
      let activeCount = 0;
      const next = () => {
        activeCount--;
        if (queue.size > 0) {
          queue.dequeue()();
        }
      };
      const run = function() {
        var _ref = _asyncToGenerator(function* (fn, resolve, ...args) {
          activeCount++;
          const result = _asyncToGenerator(function* () {
            return fn(...args);
          })();
          resolve(result);
          try {
            yield result;
          } catch {
          }
          next();
        });
        return function run2(_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }();
      const enqueue = (fn, resolve, ...args) => {
        queue.enqueue(run.bind(null, fn, resolve, ...args));
        _asyncToGenerator(function* () {
          yield Promise.resolve();
          if (activeCount < concurrency && queue.size > 0) {
            queue.dequeue()();
          }
        })();
      };
      const generator = (fn, ...args) => new Promise((resolve) => {
        enqueue(fn, resolve, ...args);
      });
      Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue.size
        },
        clearQueue: {
          value: () => {
            queue.clear();
          }
        }
      });
      return generator;
    };
    module.exports = pLimit;
  }
});

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet;
var init_url_alphabet = __esm({
  "node_modules/nanoid/url-alphabet/index.js"() {
    init_define_ngDevMode();
    urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  }
});

// node_modules/nanoid/index.browser.js
var index_browser_exports = {};
__export(index_browser_exports, {
  customAlphabet: () => customAlphabet,
  customRandom: () => customRandom,
  nanoid: () => nanoid,
  random: () => random,
  urlAlphabet: () => urlAlphabet
});
var random, customRandom, customAlphabet, nanoid;
var init_index_browser = __esm({
  "node_modules/nanoid/index.browser.js"() {
    init_define_ngDevMode();
    init_url_alphabet();
    random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
    customRandom = (alphabet, defaultSize, getRandom) => {
      let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
      let step = -~(1.6 * mask * defaultSize / alphabet.length);
      return (size = defaultSize) => {
        let id = "";
        while (true) {
          let bytes = getRandom(step);
          let j = step;
          while (j--) {
            id += alphabet[bytes[j] & mask] || "";
            if (id.length === size)
              return id;
          }
        }
      };
    };
    customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size, random);
    nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
      byte &= 63;
      if (byte < 36) {
        id += byte.toString(36);
      } else if (byte < 62) {
        id += (byte - 26).toString(36).toUpperCase();
      } else if (byte > 62) {
        id += "-";
      } else {
        id += "_";
      }
      return id;
    }, "");
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/docs/prepareForInline.js
var require_prepareForInline = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/docs/prepareForInline.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.prepareForInline = void 0;
    var react_1 = __importDefault(require_react());
    var p_limit_1 = __importDefault(require_p_limit());
    var nanoid_1 = (init_index_browser(), __toCommonJS(index_browser_exports));
    var renderer_1 = require_renderer();
    var limit = p_limit_1.default(1);
    exports.prepareForInline = (storyFn, {
      id,
      parameters,
      component
    }) => {
      const el = react_1.default.useRef();
      react_1.default.useEffect(() => {
        (() => __awaiter(void 0, void 0, void 0, function* () {
          limit(() => __awaiter(void 0, void 0, void 0, function* () {
            const renderer = yield renderer_1.rendererFactory.getRendererInstance(`${id}-${nanoid_1.nanoid(10)}`.toLowerCase(), el.current);
            if (renderer) {
              yield renderer.render({
                forced: false,
                component,
                parameters,
                storyFnAngular: storyFn(),
                targetDOMNode: el.current
              });
            }
          }));
        }))();
      });
      return react_1.default.createElement("div", {
        ref: el
      });
    };
  }
});

// node_modules/@storybook/angular/dist/ts3.9/client/docs/config.js
var require_config = __commonJS({
  "node_modules/@storybook/angular/dist/ts3.9/client/docs/config.js"(exports) {
    "use strict";
    init_define_ngDevMode();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.argTypesEnhancers = exports.decorators = exports.parameters = void 0;
    var docs_tools_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var compodoc_1 = require_compodoc();
    var sourceDecorator_1 = require_sourceDecorator();
    var prepareForInline_1 = require_prepareForInline();
    exports.parameters = {
      docs: {
        inlineStories: false,
        prepareForInline: prepareForInline_1.prepareForInline,
        extractArgTypes: compodoc_1.extractArgTypes,
        extractComponentDescription: compodoc_1.extractComponentDescription,
        source: {
          type: docs_tools_1.SourceType.DYNAMIC,
          language: "html"
        }
      }
    };
    exports.decorators = [sourceDecorator_1.sourceDecorator];
    exports.argTypesEnhancers = [docs_tools_1.enhanceArgTypes];
  }
});

// dep:@storybook_angular_dist_ts3__9_client_docs_config
init_define_ngDevMode();
var storybook_angular_dist_ts3_9_client_docs_config_default = require_config();
export {
  storybook_angular_dist_ts3_9_client_docs_config_default as default
};
//# sourceMappingURL=@storybook_angular_dist_ts3__9_client_docs_config.js.map

{
  "version": 3,
  "sources": ["../../../../node_modules/assert/node_modules/util/support/isBufferBrowser.js", "../../../../node_modules/assert/node_modules/inherits/inherits_browser.js", "../../../../node_modules/assert/node_modules/util/util.js", "../../../../node_modules/assert/assert.js", "../../../../node_modules/doctrine/lib/utility.js", "../../../../node_modules/doctrine/lib/typed.js", "../../../../node_modules/doctrine/lib/doctrine.js"],
  "sourcesContent": ["module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}", "if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n", "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n", "'use strict';\n\nvar objectAssign = require('object-assign');\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n// NB: The URL to the CommonJS spec is kept just for tradition.\n//     node-assert has evolved a lot since then, both in API and behavior.\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util/');\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\n// Expose a strict only variant of assert\nfunction strict(value, message) {\n  if (!value) fail(value, true, message, '==', strict);\n}\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n", "/*\n * @fileoverview Utilities for Doctrine\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n */\n\n\n(function () {\n    'use strict';\n\n    var VERSION;\n\n    VERSION = require('../package.json').version;\n    exports.VERSION = VERSION;\n\n    function DoctrineError(message) {\n        this.name = 'DoctrineError';\n        this.message = message;\n    }\n    DoctrineError.prototype = (function () {\n        var Middle = function () { };\n        Middle.prototype = Error.prototype;\n        return new Middle();\n    }());\n    DoctrineError.prototype.constructor = DoctrineError;\n    exports.DoctrineError = DoctrineError;\n\n    function throwError(message) {\n        throw new DoctrineError(message);\n    }\n    exports.throwError = throwError;\n\n    exports.assert = require('assert');\n}());\n\n/* vim: set sw=4 ts=4 et tw=80 : */\n", "/*\n * @fileoverview Type expression parser.\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n * @author Dan Tao <daniel.tao@gmail.com>\n * @author Andrew Eisenberg <andrew@eisenberg.as>\n */\n\n// \"typed\", the Type Expression Parser for doctrine.\n\n(function () {\n    'use strict';\n\n    var Syntax,\n        Token,\n        source,\n        length,\n        index,\n        previous,\n        token,\n        value,\n        esutils,\n        utility,\n        rangeOffset,\n        addRange;\n\n    esutils = require('esutils');\n    utility = require('./utility');\n\n    Syntax = {\n        NullableLiteral: 'NullableLiteral',\n        AllLiteral: 'AllLiteral',\n        NullLiteral: 'NullLiteral',\n        UndefinedLiteral: 'UndefinedLiteral',\n        VoidLiteral: 'VoidLiteral',\n        UnionType: 'UnionType',\n        ArrayType: 'ArrayType',\n        RecordType: 'RecordType',\n        FieldType: 'FieldType',\n        FunctionType: 'FunctionType',\n        ParameterType: 'ParameterType',\n        RestType: 'RestType',\n        NonNullableType: 'NonNullableType',\n        OptionalType: 'OptionalType',\n        NullableType: 'NullableType',\n        NameExpression: 'NameExpression',\n        TypeApplication: 'TypeApplication',\n        StringLiteralType: 'StringLiteralType',\n        NumericLiteralType: 'NumericLiteralType',\n        BooleanLiteralType: 'BooleanLiteralType'\n    };\n\n    Token = {\n        ILLEGAL: 0,    // ILLEGAL\n        DOT_LT: 1,     // .<\n        REST: 2,       // ...\n        LT: 3,         // <\n        GT: 4,         // >\n        LPAREN: 5,     // (\n        RPAREN: 6,     // )\n        LBRACE: 7,     // {\n        RBRACE: 8,     // }\n        LBRACK: 9,    // [\n        RBRACK: 10,    // ]\n        COMMA: 11,     // ,\n        COLON: 12,     // :\n        STAR: 13,      // *\n        PIPE: 14,      // |\n        QUESTION: 15,  // ?\n        BANG: 16,      // !\n        EQUAL: 17,     // =\n        NAME: 18,      // name token\n        STRING: 19,    // string\n        NUMBER: 20,    // number\n        EOF: 21\n    };\n\n    function isTypeName(ch) {\n        return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);\n    }\n\n    function Context(previous, index, token, value) {\n        this._previous = previous;\n        this._index = index;\n        this._token = token;\n        this._value = value;\n    }\n\n    Context.prototype.restore = function () {\n        previous = this._previous;\n        index = this._index;\n        token = this._token;\n        value = this._value;\n    };\n\n    Context.save = function () {\n        return new Context(previous, index, token, value);\n    };\n\n    function maybeAddRange(node, range) {\n        if (addRange) {\n            node.range = [range[0] + rangeOffset, range[1] + rangeOffset];\n        }\n        return node;\n    }\n\n    function advance() {\n        var ch = source.charAt(index);\n        index += 1;\n        return ch;\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {\n                ch = advance();\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanString() {\n        var str = '', quote, ch, code, unescaped, restore; //TODO review removal octal = false\n        quote = source.charAt(index);\n        ++index;\n\n        while (index < length) {\n            ch = advance();\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = advance();\n                if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        restore = index;\n                        unescaped = scanHexEscape(ch);\n                        if (unescaped) {\n                            str += unescaped;\n                        } else {\n                            index = restore;\n                            str += ch;\n                        }\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\v';\n                        break;\n\n                    default:\n                        if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            // Deprecating unused code. TODO review removal\n                            //if (code !== 0) {\n                            //    octal = true;\n                            //}\n\n                            if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                                //TODO Review Removal octal = true;\n                                code = code * 8 + '01234567'.indexOf(advance());\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        esutils.code.isOctalDigit(source.charCodeAt(index))) {\n                                    code = code * 8 + '01234567'.indexOf(advance());\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    if (ch ===  '\\r' && source.charCodeAt(index) === 0x0A  /* '\\n' */) {\n                        ++index;\n                    }\n                }\n            } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            utility.throwError('unexpected quote');\n        }\n\n        value = str;\n        return Token.STRING;\n    }\n\n    function scanNumber() {\n        var number, ch;\n\n        number = '';\n        ch = source.charCodeAt(index);\n\n        if (ch !== 0x2E  /* '.' */) {\n            number = advance();\n            ch = source.charCodeAt(index);\n\n            if (number === '0') {\n                if (ch === 0x78  /* 'x' */ || ch === 0x58  /* 'X' */) {\n                    number += advance();\n                    while (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (!esutils.code.isHexDigit(ch)) {\n                            break;\n                        }\n                        number += advance();\n                    }\n\n                    if (number.length <= 2) {\n                        // only 0x\n                        utility.throwError('unexpected token');\n                    }\n\n                    if (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (esutils.code.isIdentifierStartES5(ch)) {\n                            utility.throwError('unexpected token');\n                        }\n                    }\n                    value = parseInt(number, 16);\n                    return Token.NUMBER;\n                }\n\n                if (esutils.code.isOctalDigit(ch)) {\n                    number += advance();\n                    while (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (!esutils.code.isOctalDigit(ch)) {\n                            break;\n                        }\n                        number += advance();\n                    }\n\n                    if (index < length) {\n                        ch = source.charCodeAt(index);\n                        if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {\n                            utility.throwError('unexpected token');\n                        }\n                    }\n                    value = parseInt(number, 8);\n                    return Token.NUMBER;\n                }\n\n                if (esutils.code.isDecimalDigit(ch)) {\n                    utility.throwError('unexpected token');\n                }\n            }\n\n            while (index < length) {\n                ch = source.charCodeAt(index);\n                if (!esutils.code.isDecimalDigit(ch)) {\n                    break;\n                }\n                number += advance();\n            }\n        }\n\n        if (ch === 0x2E  /* '.' */) {\n            number += advance();\n            while (index < length) {\n                ch = source.charCodeAt(index);\n                if (!esutils.code.isDecimalDigit(ch)) {\n                    break;\n                }\n                number += advance();\n            }\n        }\n\n        if (ch === 0x65  /* 'e' */ || ch === 0x45  /* 'E' */) {\n            number += advance();\n\n            ch = source.charCodeAt(index);\n            if (ch === 0x2B  /* '+' */ || ch === 0x2D  /* '-' */) {\n                number += advance();\n            }\n\n            ch = source.charCodeAt(index);\n            if (esutils.code.isDecimalDigit(ch)) {\n                number += advance();\n                while (index < length) {\n                    ch = source.charCodeAt(index);\n                    if (!esutils.code.isDecimalDigit(ch)) {\n                        break;\n                    }\n                    number += advance();\n                }\n            } else {\n                utility.throwError('unexpected token');\n            }\n        }\n\n        if (index < length) {\n            ch = source.charCodeAt(index);\n            if (esutils.code.isIdentifierStartES5(ch)) {\n                utility.throwError('unexpected token');\n            }\n        }\n\n        value = parseFloat(number);\n        return Token.NUMBER;\n    }\n\n\n    function scanTypeName() {\n        var ch, ch2;\n\n        value = advance();\n        while (index < length && isTypeName(source.charCodeAt(index))) {\n            ch = source.charCodeAt(index);\n            if (ch === 0x2E  /* '.' */) {\n                if ((index + 1) >= length) {\n                    return Token.ILLEGAL;\n                }\n                ch2 = source.charCodeAt(index + 1);\n                if (ch2 === 0x3C  /* '<' */) {\n                    break;\n                }\n            }\n            value += advance();\n        }\n        return Token.NAME;\n    }\n\n    function next() {\n        var ch;\n\n        previous = index;\n\n        while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {\n            advance();\n        }\n        if (index >= length) {\n            token = Token.EOF;\n            return token;\n        }\n\n        ch = source.charCodeAt(index);\n        switch (ch) {\n        case 0x27:  /* ''' */\n        case 0x22:  /* '\"' */\n            token = scanString();\n            return token;\n\n        case 0x3A:  /* ':' */\n            advance();\n            token = Token.COLON;\n            return token;\n\n        case 0x2C:  /* ',' */\n            advance();\n            token = Token.COMMA;\n            return token;\n\n        case 0x28:  /* '(' */\n            advance();\n            token = Token.LPAREN;\n            return token;\n\n        case 0x29:  /* ')' */\n            advance();\n            token = Token.RPAREN;\n            return token;\n\n        case 0x5B:  /* '[' */\n            advance();\n            token = Token.LBRACK;\n            return token;\n\n        case 0x5D:  /* ']' */\n            advance();\n            token = Token.RBRACK;\n            return token;\n\n        case 0x7B:  /* '{' */\n            advance();\n            token = Token.LBRACE;\n            return token;\n\n        case 0x7D:  /* '}' */\n            advance();\n            token = Token.RBRACE;\n            return token;\n\n        case 0x2E:  /* '.' */\n            if (index + 1 < length) {\n                ch = source.charCodeAt(index + 1);\n                if (ch === 0x3C  /* '<' */) {\n                    advance();  // '.'\n                    advance();  // '<'\n                    token = Token.DOT_LT;\n                    return token;\n                }\n\n                if (ch === 0x2E  /* '.' */ && index + 2 < length && source.charCodeAt(index + 2) === 0x2E  /* '.' */) {\n                    advance();  // '.'\n                    advance();  // '.'\n                    advance();  // '.'\n                    token = Token.REST;\n                    return token;\n                }\n\n                if (esutils.code.isDecimalDigit(ch)) {\n                    token = scanNumber();\n                    return token;\n                }\n            }\n            token = Token.ILLEGAL;\n            return token;\n\n        case 0x3C:  /* '<' */\n            advance();\n            token = Token.LT;\n            return token;\n\n        case 0x3E:  /* '>' */\n            advance();\n            token = Token.GT;\n            return token;\n\n        case 0x2A:  /* '*' */\n            advance();\n            token = Token.STAR;\n            return token;\n\n        case 0x7C:  /* '|' */\n            advance();\n            token = Token.PIPE;\n            return token;\n\n        case 0x3F:  /* '?' */\n            advance();\n            token = Token.QUESTION;\n            return token;\n\n        case 0x21:  /* '!' */\n            advance();\n            token = Token.BANG;\n            return token;\n\n        case 0x3D:  /* '=' */\n            advance();\n            token = Token.EQUAL;\n            return token;\n\n        case 0x2D: /* '-' */\n            token = scanNumber();\n            return token;\n\n        default:\n            if (esutils.code.isDecimalDigit(ch)) {\n                token = scanNumber();\n                return token;\n            }\n\n            // type string permits following case,\n            //\n            // namespace.module.MyClass\n            //\n            // this reduced 1 token TK_NAME\n            utility.assert(isTypeName(ch));\n            token = scanTypeName();\n            return token;\n        }\n    }\n\n    function consume(target, text) {\n        utility.assert(token === target, text || 'consumed token not matched');\n        next();\n    }\n\n    function expect(target, message) {\n        if (token !== target) {\n            utility.throwError(message || 'unexpected token');\n        }\n        next();\n    }\n\n    // UnionType := '(' TypeUnionList ')'\n    //\n    // TypeUnionList :=\n    //     <<empty>>\n    //   | NonemptyTypeUnionList\n    //\n    // NonemptyTypeUnionList :=\n    //     TypeExpression\n    //   | TypeExpression '|' NonemptyTypeUnionList\n    function parseUnionType() {\n        var elements, startIndex = index - 1;\n        consume(Token.LPAREN, 'UnionType should start with (');\n        elements = [];\n        if (token !== Token.RPAREN) {\n            while (true) {\n                elements.push(parseTypeExpression());\n                if (token === Token.RPAREN) {\n                    break;\n                }\n                expect(Token.PIPE);\n            }\n        }\n        consume(Token.RPAREN, 'UnionType should end with )');\n        return maybeAddRange({\n            type: Syntax.UnionType,\n            elements: elements\n        }, [startIndex, previous]);\n    }\n\n    // ArrayType := '[' ElementTypeList ']'\n    //\n    // ElementTypeList :=\n    //     <<empty>>\n    //  | TypeExpression\n    //  | '...' TypeExpression\n    //  | TypeExpression ',' ElementTypeList\n    function parseArrayType() {\n        var elements, startIndex = index - 1, restStartIndex;\n        consume(Token.LBRACK, 'ArrayType should start with [');\n        elements = [];\n        while (token !== Token.RBRACK) {\n            if (token === Token.REST) {\n                restStartIndex = index - 3;\n                consume(Token.REST);\n                elements.push(maybeAddRange({\n                    type: Syntax.RestType,\n                    expression: parseTypeExpression()\n                }, [restStartIndex, previous]));\n                break;\n            } else {\n                elements.push(parseTypeExpression());\n            }\n            if (token !== Token.RBRACK) {\n                expect(Token.COMMA);\n            }\n        }\n        expect(Token.RBRACK);\n        return maybeAddRange({\n            type: Syntax.ArrayType,\n            elements: elements\n        }, [startIndex, previous]);\n    }\n\n    function parseFieldName() {\n        var v = value;\n        if (token === Token.NAME || token === Token.STRING) {\n            next();\n            return v;\n        }\n\n        if (token === Token.NUMBER) {\n            consume(Token.NUMBER);\n            return String(v);\n        }\n\n        utility.throwError('unexpected token');\n    }\n\n    // FieldType :=\n    //     FieldName\n    //   | FieldName ':' TypeExpression\n    //\n    // FieldName :=\n    //     NameExpression\n    //   | StringLiteral\n    //   | NumberLiteral\n    //   | ReservedIdentifier\n    function parseFieldType() {\n        var key, rangeStart = previous;\n\n        key = parseFieldName();\n        if (token === Token.COLON) {\n            consume(Token.COLON);\n            return maybeAddRange({\n                type: Syntax.FieldType,\n                key: key,\n                value: parseTypeExpression()\n            }, [rangeStart, previous]);\n        }\n        return maybeAddRange({\n            type: Syntax.FieldType,\n            key: key,\n            value: null\n        }, [rangeStart, previous]);\n    }\n\n    // RecordType := '{' FieldTypeList '}'\n    //\n    // FieldTypeList :=\n    //     <<empty>>\n    //   | FieldType\n    //   | FieldType ',' FieldTypeList\n    function parseRecordType() {\n        var fields, rangeStart = index - 1, rangeEnd;\n\n        consume(Token.LBRACE, 'RecordType should start with {');\n        fields = [];\n        if (token === Token.COMMA) {\n            consume(Token.COMMA);\n        } else {\n            while (token !== Token.RBRACE) {\n                fields.push(parseFieldType());\n                if (token !== Token.RBRACE) {\n                    expect(Token.COMMA);\n                }\n            }\n        }\n        rangeEnd = index;\n        expect(Token.RBRACE);\n        return maybeAddRange({\n            type: Syntax.RecordType,\n            fields: fields\n        }, [rangeStart, rangeEnd]);\n    }\n\n    // NameExpression :=\n    //    Identifier\n    //  | TagIdentifier ':' Identifier\n    //\n    // Tag identifier is one of \"module\", \"external\" or \"event\"\n    // Identifier is the same as Token.NAME, including any dots, something like\n    // namespace.module.MyClass\n    function parseNameExpression() {\n        var name = value, rangeStart = index - name.length;\n        expect(Token.NAME);\n\n        if (token === Token.COLON && (\n                name === 'module' ||\n                name === 'external' ||\n                name === 'event')) {\n            consume(Token.COLON);\n            name += ':' + value;\n            expect(Token.NAME);\n        }\n\n        return maybeAddRange({\n            type: Syntax.NameExpression,\n            name: name\n        }, [rangeStart, previous]);\n    }\n\n    // TypeExpressionList :=\n    //     TopLevelTypeExpression\n    //   | TopLevelTypeExpression ',' TypeExpressionList\n    function parseTypeExpressionList() {\n        var elements = [];\n\n        elements.push(parseTop());\n        while (token === Token.COMMA) {\n            consume(Token.COMMA);\n            elements.push(parseTop());\n        }\n        return elements;\n    }\n\n    // TypeName :=\n    //     NameExpression\n    //   | NameExpression TypeApplication\n    //\n    // TypeApplication :=\n    //     '.<' TypeExpressionList '>'\n    //   | '<' TypeExpressionList '>'   // this is extension of doctrine\n    function parseTypeName() {\n        var expr, applications, startIndex = index - value.length;\n\n        expr = parseNameExpression();\n        if (token === Token.DOT_LT || token === Token.LT) {\n            next();\n            applications = parseTypeExpressionList();\n            expect(Token.GT);\n            return maybeAddRange({\n                type: Syntax.TypeApplication,\n                expression: expr,\n                applications: applications\n            }, [startIndex, previous]);\n        }\n        return expr;\n    }\n\n    // ResultType :=\n    //     <<empty>>\n    //   | ':' void\n    //   | ':' TypeExpression\n    //\n    // BNF is above\n    // but, we remove <<empty>> pattern, so token is always TypeToken::COLON\n    function parseResultType() {\n        consume(Token.COLON, 'ResultType should start with :');\n        if (token === Token.NAME && value === 'void') {\n            consume(Token.NAME);\n            return {\n                type: Syntax.VoidLiteral\n            };\n        }\n        return parseTypeExpression();\n    }\n\n    // ParametersType :=\n    //     RestParameterType\n    //   | NonRestParametersType\n    //   | NonRestParametersType ',' RestParameterType\n    //\n    // RestParameterType :=\n    //     '...'\n    //     '...' Identifier\n    //\n    // NonRestParametersType :=\n    //     ParameterType ',' NonRestParametersType\n    //   | ParameterType\n    //   | OptionalParametersType\n    //\n    // OptionalParametersType :=\n    //     OptionalParameterType\n    //   | OptionalParameterType, OptionalParametersType\n    //\n    // OptionalParameterType := ParameterType=\n    //\n    // ParameterType := TypeExpression | Identifier ':' TypeExpression\n    //\n    // Identifier is \"new\" or \"this\"\n    function parseParametersType() {\n        var params = [], optionalSequence = false, expr, rest = false, startIndex, restStartIndex = index - 3, nameStartIndex;\n\n        while (token !== Token.RPAREN) {\n            if (token === Token.REST) {\n                // RestParameterType\n                consume(Token.REST);\n                rest = true;\n            }\n\n            startIndex = previous;\n\n            expr = parseTypeExpression();\n            if (expr.type === Syntax.NameExpression && token === Token.COLON) {\n                nameStartIndex = previous - expr.name.length;\n                // Identifier ':' TypeExpression\n                consume(Token.COLON);\n                expr = maybeAddRange({\n                    type: Syntax.ParameterType,\n                    name: expr.name,\n                    expression: parseTypeExpression()\n                }, [nameStartIndex, previous]);\n            }\n            if (token === Token.EQUAL) {\n                consume(Token.EQUAL);\n                expr = maybeAddRange({\n                    type: Syntax.OptionalType,\n                    expression: expr\n                }, [startIndex, previous]);\n                optionalSequence = true;\n            } else {\n                if (optionalSequence) {\n                    utility.throwError('unexpected token');\n                }\n            }\n            if (rest) {\n                expr = maybeAddRange({\n                    type: Syntax.RestType,\n                    expression: expr\n                }, [restStartIndex, previous]);\n            }\n            params.push(expr);\n            if (token !== Token.RPAREN) {\n                expect(Token.COMMA);\n            }\n        }\n        return params;\n    }\n\n    // FunctionType := 'function' FunctionSignatureType\n    //\n    // FunctionSignatureType :=\n    //   | TypeParameters '(' ')' ResultType\n    //   | TypeParameters '(' ParametersType ')' ResultType\n    //   | TypeParameters '(' 'this' ':' TypeName ')' ResultType\n    //   | TypeParameters '(' 'this' ':' TypeName ',' ParametersType ')' ResultType\n    function parseFunctionType() {\n        var isNew, thisBinding, params, result, fnType, startIndex = index - value.length;\n        utility.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \\'function\\'');\n        consume(Token.NAME);\n\n        // Google Closure Compiler is not implementing TypeParameters.\n        // So we do not. if we don't get '(', we see it as error.\n        expect(Token.LPAREN);\n\n        isNew = false;\n        params = [];\n        thisBinding = null;\n        if (token !== Token.RPAREN) {\n            // ParametersType or 'this'\n            if (token === Token.NAME &&\n                    (value === 'this' || value === 'new')) {\n                // 'this' or 'new'\n                // 'new' is Closure Compiler extension\n                isNew = value === 'new';\n                consume(Token.NAME);\n                expect(Token.COLON);\n                thisBinding = parseTypeName();\n                if (token === Token.COMMA) {\n                    consume(Token.COMMA);\n                    params = parseParametersType();\n                }\n            } else {\n                params = parseParametersType();\n            }\n        }\n\n        expect(Token.RPAREN);\n\n        result = null;\n        if (token === Token.COLON) {\n            result = parseResultType();\n        }\n\n        fnType = maybeAddRange({\n            type: Syntax.FunctionType,\n            params: params,\n            result: result\n        }, [startIndex, previous]);\n        if (thisBinding) {\n            // avoid adding null 'new' and 'this' properties\n            fnType['this'] = thisBinding;\n            if (isNew) {\n                fnType['new'] = true;\n            }\n        }\n        return fnType;\n    }\n\n    // BasicTypeExpression :=\n    //     '*'\n    //   | 'null'\n    //   | 'undefined'\n    //   | TypeName\n    //   | FunctionType\n    //   | UnionType\n    //   | RecordType\n    //   | ArrayType\n    function parseBasicTypeExpression() {\n        var context, startIndex;\n        switch (token) {\n        case Token.STAR:\n            consume(Token.STAR);\n            return maybeAddRange({\n                type: Syntax.AllLiteral\n            }, [previous - 1, previous]);\n\n        case Token.LPAREN:\n            return parseUnionType();\n\n        case Token.LBRACK:\n            return parseArrayType();\n\n        case Token.LBRACE:\n            return parseRecordType();\n\n        case Token.NAME:\n            startIndex = index - value.length;\n\n            if (value === 'null') {\n                consume(Token.NAME);\n                return maybeAddRange({\n                    type: Syntax.NullLiteral\n                }, [startIndex, previous]);\n            }\n\n            if (value === 'undefined') {\n                consume(Token.NAME);\n                return maybeAddRange({\n                    type: Syntax.UndefinedLiteral\n                }, [startIndex, previous]);\n            }\n\n            if (value === 'true' || value === 'false') {\n                consume(Token.NAME);\n                return maybeAddRange({\n                    type: Syntax.BooleanLiteralType,\n                    value: value === 'true'\n                }, [startIndex, previous]);\n            }\n\n            context = Context.save();\n            if (value === 'function') {\n                try {\n                    return parseFunctionType();\n                } catch (e) {\n                    context.restore();\n                }\n            }\n\n            return parseTypeName();\n\n        case Token.STRING:\n            next();\n            return maybeAddRange({\n                type: Syntax.StringLiteralType,\n                value: value\n            }, [previous - value.length - 2, previous]);\n\n        case Token.NUMBER:\n            next();\n            return maybeAddRange({\n                type: Syntax.NumericLiteralType,\n                value: value\n            }, [previous - String(value).length, previous]);\n\n        default:\n            utility.throwError('unexpected token');\n        }\n    }\n\n    // TypeExpression :=\n    //     BasicTypeExpression\n    //   | '?' BasicTypeExpression\n    //   | '!' BasicTypeExpression\n    //   | BasicTypeExpression '?'\n    //   | BasicTypeExpression '!'\n    //   | '?'\n    //   | BasicTypeExpression '[]'\n    function parseTypeExpression() {\n        var expr, rangeStart;\n\n        if (token === Token.QUESTION) {\n            rangeStart = index - 1;\n            consume(Token.QUESTION);\n            if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE ||\n                    token === Token.RPAREN || token === Token.PIPE || token === Token.EOF ||\n                    token === Token.RBRACK || token === Token.GT) {\n                return maybeAddRange({\n                    type: Syntax.NullableLiteral\n                }, [rangeStart, previous]);\n            }\n            return maybeAddRange({\n                type: Syntax.NullableType,\n                expression: parseBasicTypeExpression(),\n                prefix: true\n            }, [rangeStart, previous]);\n        } else if (token === Token.BANG) {\n            rangeStart = index - 1;\n            consume(Token.BANG);\n            return maybeAddRange({\n                type: Syntax.NonNullableType,\n                expression: parseBasicTypeExpression(),\n                prefix: true\n            }, [rangeStart, previous]);\n        } else {\n            rangeStart = previous;\n        }\n\n        expr = parseBasicTypeExpression();\n        if (token === Token.BANG) {\n            consume(Token.BANG);\n            return maybeAddRange({\n                type: Syntax.NonNullableType,\n                expression: expr,\n                prefix: false\n            }, [rangeStart, previous]);\n        }\n\n        if (token === Token.QUESTION) {\n            consume(Token.QUESTION);\n            return maybeAddRange({\n                type: Syntax.NullableType,\n                expression: expr,\n                prefix: false\n            }, [rangeStart, previous]);\n        }\n\n        if (token === Token.LBRACK) {\n            consume(Token.LBRACK);\n            expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');\n            return maybeAddRange({\n                type: Syntax.TypeApplication,\n                expression: maybeAddRange({\n                    type: Syntax.NameExpression,\n                    name: 'Array'\n                }, [rangeStart, previous]),\n                applications: [expr]\n            }, [rangeStart, previous]);\n        }\n\n        return expr;\n    }\n\n    // TopLevelTypeExpression :=\n    //      TypeExpression\n    //    | TypeUnionList\n    //\n    // This rule is Google Closure Compiler extension, not ES4\n    // like,\n    //   { number | string }\n    // If strict to ES4, we should write it as\n    //   { (number|string) }\n    function parseTop() {\n        var expr, elements;\n\n        expr = parseTypeExpression();\n        if (token !== Token.PIPE) {\n            return expr;\n        }\n\n        elements = [expr];\n        consume(Token.PIPE);\n        while (true) {\n            elements.push(parseTypeExpression());\n            if (token !== Token.PIPE) {\n                break;\n            }\n            consume(Token.PIPE);\n        }\n\n        return maybeAddRange({\n            type: Syntax.UnionType,\n            elements: elements\n        }, [0, index]);\n    }\n\n    function parseTopParamType() {\n        var expr;\n\n        if (token === Token.REST) {\n            consume(Token.REST);\n            return maybeAddRange({\n                type: Syntax.RestType,\n                expression: parseTop()\n            }, [0, index]);\n        }\n\n        expr = parseTop();\n        if (token === Token.EQUAL) {\n            consume(Token.EQUAL);\n            return maybeAddRange({\n                type: Syntax.OptionalType,\n                expression: expr\n            }, [0, index]);\n        }\n\n        return expr;\n    }\n\n    function parseType(src, opt) {\n        var expr;\n\n        source = src;\n        length = source.length;\n        index = 0;\n        previous = 0;\n        addRange = opt && opt.range;\n        rangeOffset = opt && opt.startIndex || 0;\n\n        next();\n        expr = parseTop();\n\n        if (opt && opt.midstream) {\n            return {\n                expression: expr,\n                index: previous\n            };\n        }\n\n        if (token !== Token.EOF) {\n            utility.throwError('not reach to EOF');\n        }\n\n        return expr;\n    }\n\n    function parseParamType(src, opt) {\n        var expr;\n\n        source = src;\n        length = source.length;\n        index = 0;\n        previous = 0;\n        addRange = opt && opt.range;\n        rangeOffset = opt && opt.startIndex || 0;\n\n        next();\n        expr = parseTopParamType();\n\n        if (opt && opt.midstream) {\n            return {\n                expression: expr,\n                index: previous\n            };\n        }\n\n        if (token !== Token.EOF) {\n            utility.throwError('not reach to EOF');\n        }\n\n        return expr;\n    }\n\n    function stringifyImpl(node, compact, topLevel) {\n        var result, i, iz;\n\n        switch (node.type) {\n        case Syntax.NullableLiteral:\n            result = '?';\n            break;\n\n        case Syntax.AllLiteral:\n            result = '*';\n            break;\n\n        case Syntax.NullLiteral:\n            result = 'null';\n            break;\n\n        case Syntax.UndefinedLiteral:\n            result = 'undefined';\n            break;\n\n        case Syntax.VoidLiteral:\n            result = 'void';\n            break;\n\n        case Syntax.UnionType:\n            if (!topLevel) {\n                result = '(';\n            } else {\n                result = '';\n            }\n\n            for (i = 0, iz = node.elements.length; i < iz; ++i) {\n                result += stringifyImpl(node.elements[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? '|' : ' | ';\n                }\n            }\n\n            if (!topLevel) {\n                result += ')';\n            }\n            break;\n\n        case Syntax.ArrayType:\n            result = '[';\n            for (i = 0, iz = node.elements.length; i < iz; ++i) {\n                result += stringifyImpl(node.elements[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n            result += ']';\n            break;\n\n        case Syntax.RecordType:\n            result = '{';\n            for (i = 0, iz = node.fields.length; i < iz; ++i) {\n                result += stringifyImpl(node.fields[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n            result += '}';\n            break;\n\n        case Syntax.FieldType:\n            if (node.value) {\n                result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);\n            } else {\n                result = node.key;\n            }\n            break;\n\n        case Syntax.FunctionType:\n            result = compact ? 'function(' : 'function (';\n\n            if (node['this']) {\n                if (node['new']) {\n                    result += (compact ? 'new:' : 'new: ');\n                } else {\n                    result += (compact ? 'this:' : 'this: ');\n                }\n\n                result += stringifyImpl(node['this'], compact);\n\n                if (node.params.length !== 0) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n\n            for (i = 0, iz = node.params.length; i < iz; ++i) {\n                result += stringifyImpl(node.params[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n\n            result += ')';\n\n            if (node.result) {\n                result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);\n            }\n            break;\n\n        case Syntax.ParameterType:\n            result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);\n            break;\n\n        case Syntax.RestType:\n            result = '...';\n            if (node.expression) {\n                result += stringifyImpl(node.expression, compact);\n            }\n            break;\n\n        case Syntax.NonNullableType:\n            if (node.prefix) {\n                result = '!' + stringifyImpl(node.expression, compact);\n            } else {\n                result = stringifyImpl(node.expression, compact) + '!';\n            }\n            break;\n\n        case Syntax.OptionalType:\n            result = stringifyImpl(node.expression, compact) + '=';\n            break;\n\n        case Syntax.NullableType:\n            if (node.prefix) {\n                result = '?' + stringifyImpl(node.expression, compact);\n            } else {\n                result = stringifyImpl(node.expression, compact) + '?';\n            }\n            break;\n\n        case Syntax.NameExpression:\n            result = node.name;\n            break;\n\n        case Syntax.TypeApplication:\n            result = stringifyImpl(node.expression, compact) + '.<';\n            for (i = 0, iz = node.applications.length; i < iz; ++i) {\n                result += stringifyImpl(node.applications[i], compact);\n                if ((i + 1) !== iz) {\n                    result += compact ? ',' : ', ';\n                }\n            }\n            result += '>';\n            break;\n\n        case Syntax.StringLiteralType:\n            result = '\"' + node.value + '\"';\n            break;\n\n        case Syntax.NumericLiteralType:\n            result = String(node.value);\n            break;\n\n        case Syntax.BooleanLiteralType:\n            result = String(node.value);\n            break;\n\n        default:\n            utility.throwError('Unknown type ' + node.type);\n        }\n\n        return result;\n    }\n\n    function stringify(node, options) {\n        if (options == null) {\n            options = {};\n        }\n        return stringifyImpl(node, options.compact, options.topLevel);\n    }\n\n    exports.parseType = parseType;\n    exports.parseParamType = parseParamType;\n    exports.stringify = stringify;\n    exports.Syntax = Syntax;\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n", "/*\n * @fileoverview Main Doctrine object\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\n * @author Dan Tao <daniel.tao@gmail.com>\n * @author Andrew Eisenberg <andrew@eisenberg.as>\n */\n\n(function () {\n    'use strict';\n\n    var typed,\n        utility,\n        jsdoc,\n        esutils,\n        hasOwnProperty;\n\n    esutils = require('esutils');\n    typed = require('./typed');\n    utility = require('./utility');\n\n    function sliceSource(source, index, last) {\n        return source.slice(index, last);\n    }\n\n    hasOwnProperty = (function () {\n        var func = Object.prototype.hasOwnProperty;\n        return function hasOwnProperty(obj, name) {\n            return func.call(obj, name);\n        };\n    }());\n    function shallowCopy(obj) {\n        var ret = {}, key;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n\n    function isASCIIAlphanumeric(ch) {\n        return (ch >= 0x61  /* 'a' */ && ch <= 0x7A  /* 'z' */) ||\n            (ch >= 0x41  /* 'A' */ && ch <= 0x5A  /* 'Z' */) ||\n            (ch >= 0x30  /* '0' */ && ch <= 0x39  /* '9' */);\n    }\n\n    function isParamTitle(title) {\n        return title === 'param' || title === 'argument' || title === 'arg';\n    }\n\n    function isReturnTitle(title) {\n        return title === 'return' || title === 'returns';\n    }\n\n    function isProperty(title) {\n        return title === 'property' || title === 'prop';\n    }\n\n    function isNameParameterRequired(title) {\n        return isParamTitle(title) || isProperty(title) ||\n            title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';\n    }\n\n    function isAllowedName(title) {\n        return isNameParameterRequired(title) || title === 'const' || title === 'constant';\n    }\n\n    function isAllowedNested(title) {\n        return isProperty(title) || isParamTitle(title);\n    }\n\n    function isAllowedOptional(title) {\n        return isProperty(title) || isParamTitle(title);\n    }\n\n    function isTypeParameterRequired(title) {\n        return isParamTitle(title) || isReturnTitle(title) ||\n            title === 'define' || title === 'enum' ||\n            title === 'implements' || title === 'this' ||\n            title === 'type' || title === 'typedef' || isProperty(title);\n    }\n\n    // Consider deprecation instead using 'isTypeParameterRequired' and 'Rules' declaration to pick when a type is optional/required\n    // This would require changes to 'parseType'\n    function isAllowedType(title) {\n        return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' ||\n            title === 'namespace' || title === 'member' || title === 'var' || title === 'module' ||\n            title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' ||\n            title === 'public' || title === 'private' || title === 'protected';\n    }\n\n    // A regex character class that contains all whitespace except linebreak characters (\\r, \\n, \\u2028, \\u2029)\n    var WHITESPACE = '[ \\\\f\\\\t\\\\v\\\\u00a0\\\\u1680\\\\u180e\\\\u2000-\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\ufeff]';\n\n    var STAR_MATCHER = '(' + WHITESPACE + '*(?:\\\\*' + WHITESPACE + '?)?)(.+|[\\r\\n\\u2028\\u2029])';\n\n    function unwrapComment(doc) {\n        // JSDoc comment is following form\n        //   /**\n        //    * .......\n        //    */\n\n        return doc.\n            // remove /**\n            replace(/^\\/\\*\\*?/, '').\n            // remove */\n            replace(/\\*\\/$/, '').\n            // remove ' * ' at the beginning of a line\n            replace(new RegExp(STAR_MATCHER, 'g'), '$2').\n            // remove trailing whitespace\n            replace(/\\s*$/, '');\n    }\n\n    /**\n     * Converts an index in an \"unwrapped\" JSDoc comment to the corresponding index in the original \"wrapped\" version\n     * @param {string} originalSource The original wrapped comment\n     * @param {number} unwrappedIndex The index of a character in the unwrapped string\n     * @returns {number} The index of the corresponding character in the original wrapped string\n     */\n    function convertUnwrappedCommentIndex(originalSource, unwrappedIndex) {\n        var replacedSource = originalSource.replace(/^\\/\\*\\*?/, '');\n        var numSkippedChars = 0;\n        var matcher = new RegExp(STAR_MATCHER, 'g');\n        var match;\n\n        while ((match = matcher.exec(replacedSource))) {\n            numSkippedChars += match[1].length;\n\n            if (match.index + match[0].length > unwrappedIndex + numSkippedChars) {\n                return unwrappedIndex + numSkippedChars + originalSource.length - replacedSource.length;\n            }\n        }\n\n        return originalSource.replace(/\\*\\/$/, '').replace(/\\s*$/, '').length;\n    }\n\n    // JSDoc Tag Parser\n\n    (function (exports) {\n        var Rules,\n            index,\n            lineNumber,\n            length,\n            source,\n            originalSource,\n            recoverable,\n            sloppy,\n            strict;\n\n        function advance() {\n            var ch = source.charCodeAt(index);\n            index += 1;\n            if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\\r' */ && source.charCodeAt(index) === 0x0A  /* '\\n' */)) {\n                lineNumber += 1;\n            }\n            return String.fromCharCode(ch);\n        }\n\n        function scanTitle() {\n            var title = '';\n            // waste '@'\n            advance();\n\n            while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {\n                title += advance();\n            }\n\n            return title;\n        }\n\n        function seekContent() {\n            var ch, waiting, last = index;\n\n            waiting = false;\n            while (last < length) {\n                ch = source.charCodeAt(last);\n                if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\\r' */ && source.charCodeAt(last + 1) === 0x0A  /* '\\n' */)) {\n                    waiting = true;\n                } else if (waiting) {\n                    if (ch === 0x40  /* '@' */) {\n                        break;\n                    }\n                    if (!esutils.code.isWhiteSpace(ch)) {\n                        waiting = false;\n                    }\n                }\n                last += 1;\n            }\n            return last;\n        }\n\n        // type expression may have nest brace, such as,\n        // { { ok: string } }\n        //\n        // therefore, scanning type expression with balancing braces.\n        function parseType(title, last, addRange) {\n            var ch, brace, type, startIndex, direct = false;\n\n\n            // search '{'\n            while (index < last) {\n                ch = source.charCodeAt(index);\n                if (esutils.code.isWhiteSpace(ch)) {\n                    advance();\n                } else if (ch === 0x7B  /* '{' */) {\n                    advance();\n                    break;\n                } else {\n                    // this is direct pattern\n                    direct = true;\n                    break;\n                }\n            }\n\n\n            if (direct) {\n                return null;\n            }\n\n            // type expression { is found\n            brace = 1;\n            type = '';\n            while (index < last) {\n                ch = source.charCodeAt(index);\n                if (esutils.code.isLineTerminator(ch)) {\n                    advance();\n                } else {\n                    if (ch === 0x7D  /* '}' */) {\n                        brace -= 1;\n                        if (brace === 0) {\n                            advance();\n                            break;\n                        }\n                    } else if (ch === 0x7B  /* '{' */) {\n                        brace += 1;\n                    }\n                    if (type === '') {\n                        startIndex = index;\n                    }\n                    type += advance();\n                }\n            }\n\n            if (brace !== 0) {\n                // braces is not balanced\n                return utility.throwError('Braces are not balanced');\n            }\n\n            if (isAllowedOptional(title)) {\n                return typed.parseParamType(type, {startIndex: convertIndex(startIndex), range: addRange});\n            }\n\n            return typed.parseType(type, {startIndex: convertIndex(startIndex), range: addRange});\n        }\n\n        function scanIdentifier(last) {\n            var identifier;\n            if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index)) && !source[index].match(/[0-9]/)) {\n                return null;\n            }\n            identifier = advance();\n            while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {\n                identifier += advance();\n            }\n            return identifier;\n        }\n\n        function skipWhiteSpace(last) {\n            while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {\n                advance();\n            }\n        }\n\n        function parseName(last, allowBrackets, allowNestedParams) {\n            var name = '',\n                useBrackets,\n                insideString;\n\n\n            skipWhiteSpace(last);\n\n            if (index >= last) {\n                return null;\n            }\n\n            if (source.charCodeAt(index) === 0x5B  /* '[' */) {\n                if (allowBrackets) {\n                    useBrackets = true;\n                    name = advance();\n                } else {\n                    return null;\n                }\n            }\n\n            name += scanIdentifier(last);\n\n            if (allowNestedParams) {\n                if (source.charCodeAt(index) === 0x3A /* ':' */ && (\n                        name === 'module' ||\n                        name === 'external' ||\n                        name === 'event')) {\n                    name += advance();\n                    name += scanIdentifier(last);\n\n                }\n                if(source.charCodeAt(index) === 0x5B  /* '[' */ && source.charCodeAt(index + 1) === 0x5D  /* ']' */){\n                    name += advance();\n                    name += advance();\n                }\n                while (source.charCodeAt(index) === 0x2E  /* '.' */ ||\n                        source.charCodeAt(index) === 0x2F  /* '/' */ ||\n                        source.charCodeAt(index) === 0x23  /* '#' */ ||\n                        source.charCodeAt(index) === 0x2D  /* '-' */ ||\n                        source.charCodeAt(index) === 0x7E  /* '~' */) {\n                    name += advance();\n                    name += scanIdentifier(last);\n                }\n            }\n\n            if (useBrackets) {\n                skipWhiteSpace(last);\n                // do we have a default value for this?\n                if (source.charCodeAt(index) === 0x3D  /* '=' */) {\n                    // consume the '='' symbol\n                    name += advance();\n                    skipWhiteSpace(last);\n\n                    var ch;\n                    var bracketDepth = 1;\n\n                    // scan in the default value\n                    while (index < last) {\n                        ch = source.charCodeAt(index);\n\n                        if (esutils.code.isWhiteSpace(ch)) {\n                            if (!insideString) {\n                                skipWhiteSpace(last);\n                                ch = source.charCodeAt(index);\n                            }\n                        }\n\n                        if (ch === 0x27 /* ''' */) {\n                            if (!insideString) {\n                                insideString = '\\'';\n                            } else {\n                                if (insideString === '\\'') {\n                                    insideString = '';\n                                }\n                            }\n                        }\n\n                        if (ch === 0x22 /* '\"' */) {\n                            if (!insideString) {\n                                insideString = '\"';\n                            } else {\n                                if (insideString === '\"') {\n                                    insideString = '';\n                                }\n                            }\n                        }\n\n                        if (ch === 0x5B /* '[' */) {\n                            bracketDepth++;\n                        } else if (ch === 0x5D  /* ']' */ &&\n                            --bracketDepth === 0) {\n                            break;\n                        }\n\n                        name += advance();\n                    }\n                }\n\n                skipWhiteSpace(last);\n\n                if (index >= last || source.charCodeAt(index) !== 0x5D  /* ']' */) {\n                    // we never found a closing ']'\n                    return null;\n                }\n\n                // collect the last ']'\n                name += advance();\n            }\n\n            return name;\n        }\n\n        function skipToTag() {\n            while (index < length && source.charCodeAt(index) !== 0x40  /* '@' */) {\n                advance();\n            }\n            if (index >= length) {\n                return false;\n            }\n            utility.assert(source.charCodeAt(index) === 0x40  /* '@' */);\n            return true;\n        }\n\n        function convertIndex(rangeIndex) {\n            if (source === originalSource) {\n                return rangeIndex;\n            }\n            return convertUnwrappedCommentIndex(originalSource, rangeIndex);\n        }\n\n        function TagParser(options, title) {\n            this._options = options;\n            this._title = title.toLowerCase();\n            this._tag = {\n                title: title,\n                description: null\n            };\n            if (this._options.lineNumbers) {\n                this._tag.lineNumber = lineNumber;\n            }\n            this._first = index - title.length - 1;\n            this._last = 0;\n            // space to save special information for title parsers.\n            this._extra = { };\n        }\n\n        // addError(err, ...)\n        TagParser.prototype.addError = function addError(errorText) {\n            var args = Array.prototype.slice.call(arguments, 1),\n                msg = errorText.replace(\n                    /%(\\d)/g,\n                    function (whole, index) {\n                        utility.assert(index < args.length, 'Message reference must be in range');\n                        return args[index];\n                    }\n                );\n\n            if (!this._tag.errors) {\n                this._tag.errors = [];\n            }\n            if (strict) {\n                utility.throwError(msg);\n            }\n            this._tag.errors.push(msg);\n            return recoverable;\n        };\n\n        TagParser.prototype.parseType = function () {\n            // type required titles\n            if (isTypeParameterRequired(this._title)) {\n                try {\n                    this._tag.type = parseType(this._title, this._last, this._options.range);\n                    if (!this._tag.type) {\n                        if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {\n                            if (!this.addError('Missing or invalid tag type')) {\n                                return false;\n                            }\n                        }\n                    }\n                } catch (error) {\n                    this._tag.type = null;\n                    if (!this.addError(error.message)) {\n                        return false;\n                    }\n                }\n            } else if (isAllowedType(this._title)) {\n                // optional types\n                try {\n                    this._tag.type = parseType(this._title, this._last, this._options.range);\n                } catch (e) {\n                    //For optional types, lets drop the thrown error when we hit the end of the file\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype._parseNamePath = function (optional) {\n            var name;\n            name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);\n            if (!name) {\n                if (!optional) {\n                    if (!this.addError('Missing or invalid tag name')) {\n                        return false;\n                    }\n                }\n            }\n            this._tag.name = name;\n            return true;\n        };\n\n        TagParser.prototype.parseNamePath = function () {\n            return this._parseNamePath(false);\n        };\n\n        TagParser.prototype.parseNamePathOptional = function () {\n            return this._parseNamePath(true);\n        };\n\n\n        TagParser.prototype.parseName = function () {\n            var assign, name;\n\n            // param, property requires name\n            if (isAllowedName(this._title)) {\n                this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));\n                if (!this._tag.name) {\n                    if (!isNameParameterRequired(this._title)) {\n                        return true;\n                    }\n\n                    // it's possible the name has already been parsed but interpreted as a type\n                    // it's also possible this is a sloppy declaration, in which case it will be\n                    // fixed at the end\n                    if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {\n                        this._extra.name = this._tag.type;\n                        this._tag.name = this._tag.type.name;\n                        this._tag.type = null;\n                    } else {\n                        if (!this.addError('Missing or invalid tag name')) {\n                            return false;\n                        }\n                    }\n                } else {\n                    name = this._tag.name;\n                    if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {\n                        // extract the default value if there is one\n                        // example: @param {string} [somebody=John Doe] description\n                        assign = name.substring(1, name.length - 1).split('=');\n                        if (assign.length > 1) {\n                            this._tag['default'] = assign.slice(1).join('=');\n                        }\n                        this._tag.name = assign[0];\n\n                        // convert to an optional type\n                        if (this._tag.type && this._tag.type.type !== 'OptionalType') {\n                            this._tag.type = {\n                                type: 'OptionalType',\n                                expression: this._tag.type\n                            };\n                        }\n                    }\n                }\n            }\n\n\n            return true;\n        };\n\n        TagParser.prototype.parseDescription = function parseDescription() {\n            var description = sliceSource(source, index, this._last).trim();\n            if (description) {\n                if ((/^-\\s+/).test(description)) {\n                    description = description.substring(2);\n                }\n                this._tag.description = description;\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseCaption = function parseDescription() {\n            var description = sliceSource(source, index, this._last).trim();\n            var captionStartTag = '<caption>';\n            var captionEndTag = '</caption>';\n            var captionStart = description.indexOf(captionStartTag);\n            var captionEnd = description.indexOf(captionEndTag);\n            if (captionStart >= 0 && captionEnd >= 0) {\n                this._tag.caption = description.substring(\n                    captionStart + captionStartTag.length, captionEnd).trim();\n                this._tag.description = description.substring(captionEnd + captionEndTag.length).trim();\n            } else {\n                this._tag.description = description;\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseKind = function parseKind() {\n            var kind, kinds;\n            kinds = {\n                'class': true,\n                'constant': true,\n                'event': true,\n                'external': true,\n                'file': true,\n                'function': true,\n                'member': true,\n                'mixin': true,\n                'module': true,\n                'namespace': true,\n                'typedef': true\n            };\n            kind = sliceSource(source, index, this._last).trim();\n            this._tag.kind = kind;\n            if (!hasOwnProperty(kinds, kind)) {\n                if (!this.addError('Invalid kind name \\'%0\\'', kind)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseAccess = function parseAccess() {\n            var access;\n            access = sliceSource(source, index, this._last).trim();\n            this._tag.access = access;\n            if (access !== 'private' && access !== 'protected' && access !== 'public') {\n                if (!this.addError('Invalid access name \\'%0\\'', access)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.parseThis = function parseThis() {\n            // this name may be a name expression (e.g. {foo.bar}),\n            // an union (e.g. {foo.bar|foo.baz}) or a name path (e.g. foo.bar)\n            var value = sliceSource(source, index, this._last).trim();\n            if (value && value.charAt(0) === '{') {\n                var gotType = this.parseType();\n                if (gotType && this._tag.type.type === 'NameExpression' || this._tag.type.type === 'UnionType') {\n                    this._tag.name = this._tag.type.name;\n                    return true;\n                } else {\n                    return this.addError('Invalid name for this');\n                }\n            } else {\n                return this.parseNamePath();\n            }\n        };\n\n        TagParser.prototype.parseVariation = function parseVariation() {\n            var variation, text;\n            text = sliceSource(source, index, this._last).trim();\n            variation = parseFloat(text, 10);\n            this._tag.variation = variation;\n            if (isNaN(variation)) {\n                if (!this.addError('Invalid variation \\'%0\\'', text)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.ensureEnd = function () {\n            var shouldBeEmpty = sliceSource(source, index, this._last).trim();\n            if (shouldBeEmpty) {\n                if (!this.addError('Unknown content \\'%0\\'', shouldBeEmpty)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n\n        TagParser.prototype.epilogue = function epilogue() {\n            var description;\n\n            description = this._tag.description;\n            // un-fix potentially sloppy declaration\n            if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === '[') {\n                this._tag.type = this._extra.name;\n                if (!this._tag.name) {\n                    this._tag.name = undefined;\n                }\n\n                if (!sloppy) {\n                    if (!this.addError('Missing or invalid tag name')) {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        };\n\n        Rules = {\n            // http://usejsdoc.org/tags-access.html\n            'access': ['parseAccess'],\n            // http://usejsdoc.org/tags-alias.html\n            'alias': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-augments.html\n            'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-constructor.html\n            'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-constructor.html\n            'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-extends.html\n            'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-example.html\n            'example': ['parseCaption'],\n            // http://usejsdoc.org/tags-deprecated.html\n            'deprecated': ['parseDescription'],\n            // http://usejsdoc.org/tags-global.html\n            'global': ['ensureEnd'],\n            // http://usejsdoc.org/tags-inner.html\n            'inner': ['ensureEnd'],\n            // http://usejsdoc.org/tags-instance.html\n            'instance': ['ensureEnd'],\n            // http://usejsdoc.org/tags-kind.html\n            'kind': ['parseKind'],\n            // http://usejsdoc.org/tags-mixes.html\n            'mixes': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-mixin.html\n            'mixin': ['parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-member.html\n            'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-method.html\n            'method': ['parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-module.html\n            'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-method.html\n            'func': ['parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-method.html\n            'function': ['parseNamePathOptional', 'ensureEnd'],\n            // Synonym: http://usejsdoc.org/tags-member.html\n            'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-name.html\n            'name': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-namespace.html\n            'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n            // http://usejsdoc.org/tags-private.html\n            'private': ['parseType', 'parseDescription'],\n            // http://usejsdoc.org/tags-protected.html\n            'protected': ['parseType', 'parseDescription'],\n            // http://usejsdoc.org/tags-public.html\n            'public': ['parseType', 'parseDescription'],\n            // http://usejsdoc.org/tags-readonly.html\n            'readonly': ['ensureEnd'],\n            // http://usejsdoc.org/tags-requires.html\n            'requires': ['parseNamePath', 'ensureEnd'],\n            // http://usejsdoc.org/tags-since.html\n            'since': ['parseDescription'],\n            // http://usejsdoc.org/tags-static.html\n            'static': ['ensureEnd'],\n            // http://usejsdoc.org/tags-summary.html\n            'summary': ['parseDescription'],\n            // http://usejsdoc.org/tags-this.html\n            'this': ['parseThis', 'ensureEnd'],\n            // http://usejsdoc.org/tags-todo.html\n            'todo': ['parseDescription'],\n            // http://usejsdoc.org/tags-typedef.html\n            'typedef': ['parseType', 'parseNamePathOptional'],\n            // http://usejsdoc.org/tags-variation.html\n            'variation': ['parseVariation'],\n            // http://usejsdoc.org/tags-version.html\n            'version': ['parseDescription']\n        };\n\n        TagParser.prototype.parse = function parse() {\n            var i, iz, sequences, method;\n\n\n            // empty title\n            if (!this._title) {\n                if (!this.addError('Missing or invalid title')) {\n                    return null;\n                }\n            }\n\n            // Seek to content last index.\n            this._last = seekContent(this._title);\n\n            if (this._options.range) {\n                this._tag.range = [this._first, source.slice(0, this._last).replace(/\\s*$/, '').length].map(convertIndex);\n            }\n\n            if (hasOwnProperty(Rules, this._title)) {\n                sequences = Rules[this._title];\n            } else {\n                // default sequences\n                sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];\n            }\n\n            for (i = 0, iz = sequences.length; i < iz; ++i) {\n                method = sequences[i];\n                if (!this[method]()) {\n                    return null;\n                }\n            }\n\n            return this._tag;\n        };\n\n        function parseTag(options) {\n            var title, parser, tag;\n\n            // skip to tag\n            if (!skipToTag()) {\n                return null;\n            }\n\n            // scan title\n            title = scanTitle();\n\n            // construct tag parser\n            parser = new TagParser(options, title);\n            tag = parser.parse();\n\n            // Seek global index to end of this tag.\n            while (index < parser._last) {\n                advance();\n            }\n\n            return tag;\n        }\n\n        //\n        // Parse JSDoc\n        //\n\n        function scanJSDocDescription(preserveWhitespace) {\n            var description = '', ch, atAllowed;\n\n            atAllowed = true;\n            while (index < length) {\n                ch = source.charCodeAt(index);\n\n                if (atAllowed && ch === 0x40  /* '@' */) {\n                    break;\n                }\n\n                if (esutils.code.isLineTerminator(ch)) {\n                    atAllowed = true;\n                } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {\n                    atAllowed = false;\n                }\n\n                description += advance();\n            }\n\n            return preserveWhitespace ? description : description.trim();\n        }\n\n        function parse(comment, options) {\n            var tags = [], tag, description, interestingTags, i, iz;\n\n            if (options === undefined) {\n                options = {};\n            }\n\n            if (typeof options.unwrap === 'boolean' && options.unwrap) {\n                source = unwrapComment(comment);\n            } else {\n                source = comment;\n            }\n\n            originalSource = comment;\n\n            // array of relevant tags\n            if (options.tags) {\n                if (Array.isArray(options.tags)) {\n                    interestingTags = { };\n                    for (i = 0, iz = options.tags.length; i < iz; i++) {\n                        if (typeof options.tags[i] === 'string') {\n                            interestingTags[options.tags[i]] = true;\n                        } else {\n                            utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\n                        }\n                    }\n                } else {\n                    utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\n                }\n            }\n\n            length = source.length;\n            index = 0;\n            lineNumber = 0;\n            recoverable = options.recoverable;\n            sloppy = options.sloppy;\n            strict = options.strict;\n\n            description = scanJSDocDescription(options.preserveWhitespace);\n\n            while (true) {\n                tag = parseTag(options);\n                if (!tag) {\n                    break;\n                }\n                if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {\n                    tags.push(tag);\n                }\n            }\n\n            return {\n                description: description,\n                tags: tags\n            };\n        }\n        exports.parse = parse;\n    }(jsdoc = {}));\n\n    exports.version = utility.VERSION;\n    exports.parse = jsdoc.parse;\n    exports.parseType = typed.parseType;\n    exports.parseParamType = typed.parseParamType;\n    exports.unwrapComment = unwrapComment;\n    exports.Syntax = shallowCopy(typed.Syntax);\n    exports.Error = utility.DoctrineError;\n    exports.type = {\n        Syntax: exports.Syntax,\n        parseType: typed.parseType,\n        parseParamType: typed.parseParamType,\n        stringify: typed.stringify\n    };\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAAA;;;WAAOC,UAAU,SAASC,SAASC,KAAK;AACtC,aAAOA,OAAO,OAAOA,QAAQ,YACxB,OAAOA,IAAIC,SAAS,cACpB,OAAOD,IAAIE,SAAS,cACpB,OAAOF,IAAIG,cAAc;IAC/B;;;;;ACLD;;;QAAI,OAAOC,OAAOC,WAAW,YAAY;AAEvCC,aAAOC,UAAU,SAASC,SAASC,MAAMC,WAAW;AAClDD,aAAKE,SAASD;AACdD,aAAKG,YAAYR,OAAOC,OAAOK,UAAUE,WAAW;UAClDC,aAAa;YACXC,OAAOL;YACPM,YAAY;YACZC,UAAU;YACVC,cAAc;UAJH;QADqC,CAAnC;MAQlB;IACF,OAAM;AAELX,aAAOC,UAAU,SAASC,SAASC,MAAMC,WAAW;AAClDD,aAAKE,SAASD;AACd,YAAIQ,WAAW,WAAY;QAAE;AAC7BA,iBAASN,YAAYF,UAAUE;AAC/BH,aAAKG,YAAY,IAAIM,SAAJ;AACjBT,aAAKG,UAAUC,cAAcJ;MAC9B;IACF;;;;;ACtBD;;;AAqBA,QAAIU,eAAe;AACnBC,YAAQC,SAAS,SAASC,GAAG;AAC3B,UAAI,CAACC,SAASD,CAAD,GAAK;AAChB,YAAIE,UAAU,CAAA;AACd,iBAASC,IAAI,GAAGA,IAAIC,UAAUC,QAAQF,KAAK;AACzCD,kBAAQI,KAAKC,QAAQH,UAAUD,EAAX,CAApB;QACD;AACD,eAAOD,QAAQM,KAAK,GAAb;MACR;AAED,UAAIL,IAAI;AACR,UAAIM,OAAOL;AACX,UAAIM,MAAMD,KAAKJ;AACf,UAAIM,MAAMC,OAAOZ,CAAD,EAAIa,QAAQhB,cAAc,SAASiB,IAAG;AACpD,YAAIA,OAAM;AAAM,iBAAO;AACvB,YAAIX,KAAKO;AAAK,iBAAOI;AACrB,gBAAQA;eACD;AAAM,mBAAOF,OAAOH,KAAKN,IAAN;eACnB;AAAM,mBAAOY,OAAON,KAAKN,IAAN;eACnB;AACH,gBAAI;AACF,qBAAOa,KAAKC,UAAUR,KAAKN,IAApB;YACR,SAAQe,GAAP;AACA,qBAAO;YACR;;AAED,mBAAOJ;;MAEZ,CAfS;AAgBV,eAASA,IAAIL,KAAKN,IAAIA,IAAIO,KAAKI,IAAIL,KAAK,EAAEN,IAAI;AAC5C,YAAIgB,OAAOL,CAAD,KAAO,CAACM,SAASN,CAAD,GAAK;AAC7BH,iBAAO,MAAMG;QACd,OAAM;AACLH,iBAAO,MAAMJ,QAAQO,CAAD;QACrB;MACF;AACD,aAAOH;IACR;AAMDb,YAAQuB,YAAY,SAASC,IAAIC,KAAK;AAEpC,UAAIC,YAAYC,OAAOC,OAAR,GAAkB;AAC/B,eAAO,WAAW;AAChB,iBAAO5B,QAAQuB,UAAUC,IAAIC,GAAtB,EAA2BI,MAAM,MAAMvB,SAAvC;QACR;MACF;AAED,UAAIsB,QAAQE,kBAAkB,MAAM;AAClC,eAAON;MACR;AAED,UAAIO,SAAS;AACb,eAASC,aAAa;AACpB,YAAI,CAACD,QAAQ;AACX,cAAIH,QAAQK,kBAAkB;AAC5B,kBAAM,IAAIC,MAAMT,GAAV;UACP,WAAUG,QAAQO,kBAAkB;AACnCC,oBAAQC,MAAMZ,GAAd;UACD,OAAM;AACLW,oBAAQE,MAAMb,GAAd;UACD;AACDM,mBAAS;QACV;AACD,eAAOP,GAAGK,MAAM,MAAMvB,SAAf;MACR;AAED,aAAO0B;IACR;AAGD,QAAIO,SAAS,CAAA;AACb,QAAIC;AACJxC,YAAQyC,WAAW,SAASC,KAAK;AAC/B,UAAIhB,YAAYc,YAAD;AACbA,uBAAeZ,QAAQe,IAAIC,cAAc;AAC3CF,YAAMA,IAAIG,YAAJ;AACN,UAAI,CAACN,OAAOG,MAAM;AAChB,YAAI,IAAII,OAAO,QAAQJ,MAAM,OAAO,GAAhC,EAAqCK,KAAKP,YAA1C,GAAyD;AAC3D,cAAIQ,MAAMpB,QAAQoB;AAClBT,iBAAOG,OAAO,WAAW;AACvB,gBAAIjB,MAAMzB,QAAQC,OAAO4B,MAAM7B,SAASM,SAA9B;AACV8B,oBAAQE,MAAM,aAAaI,KAAKM,KAAKvB,GAArC;UACD;QACF,OAAM;AACLc,iBAAOG,OAAO,WAAW;UAAE;QAC5B;MACF;AACD,aAAOH,OAAOG;IACf;AAWD,aAASjC,QAAQwC,KAAKC,MAAM;AAE1B,UAAIC,MAAM;QACRC,MAAM,CAAA;QACNC,SAASC;MAFD;AAKV,UAAIhD,UAAUC,UAAU;AAAG4C,YAAII,QAAQjD,UAAU;AACjD,UAAIA,UAAUC,UAAU;AAAG4C,YAAIK,SAASlD,UAAU;AAClD,UAAImD,UAAUP,IAAD,GAAQ;AAEnBC,YAAIO,aAAaR;MAClB,WAAUA,MAAM;AAEflD,gBAAQ2D,QAAQR,KAAKD,IAArB;MACD;AAED,UAAIxB,YAAYyB,IAAIO,UAAL;AAAkBP,YAAIO,aAAa;AAClD,UAAIhC,YAAYyB,IAAII,KAAL;AAAaJ,YAAII,QAAQ;AACxC,UAAI7B,YAAYyB,IAAIK,MAAL;AAAcL,YAAIK,SAAS;AAC1C,UAAI9B,YAAYyB,IAAIS,aAAL;AAAqBT,YAAIS,gBAAgB;AACxD,UAAIT,IAAIK;AAAQL,YAAIE,UAAUQ;AAC9B,aAAOC,YAAYX,KAAKF,KAAKE,IAAII,KAAf;IACnB;AACDvD,YAAQS,UAAUA;AAIlBA,YAAQ+C,SAAS;MACf,QAAS,CAAC,GAAG,EAAJ;MACT,UAAW,CAAC,GAAG,EAAJ;MACX,aAAc,CAAC,GAAG,EAAJ;MACd,WAAY,CAAC,GAAG,EAAJ;MACZ,SAAU,CAAC,IAAI,EAAL;MACV,QAAS,CAAC,IAAI,EAAL;MACT,SAAU,CAAC,IAAI,EAAL;MACV,QAAS,CAAC,IAAI,EAAL;MACT,QAAS,CAAC,IAAI,EAAL;MACT,SAAU,CAAC,IAAI,EAAL;MACV,WAAY,CAAC,IAAI,EAAL;MACZ,OAAQ,CAAC,IAAI,EAAL;MACR,UAAW,CAAC,IAAI,EAAL;IAbI;AAiBjB/C,YAAQsD,SAAS;MACf,WAAW;MACX,UAAU;MACV,WAAW;MACX,aAAa;MACb,QAAQ;MACR,UAAU;MACV,QAAQ;MAER,UAAU;IATK;AAajB,aAASF,iBAAiBhD,KAAKmD,WAAW;AACxC,UAAIC,QAAQxD,QAAQsD,OAAOC;AAE3B,UAAIC,OAAO;AACT,eAAO,UAAYxD,QAAQ+C,OAAOS,OAAO,KAAK,MAAMpD,MAC7C,UAAYJ,QAAQ+C,OAAOS,OAAO,KAAK;MAC/C,OAAM;AACL,eAAOpD;MACR;IACF;AAGD,aAASyC,eAAezC,KAAKmD,WAAW;AACtC,aAAOnD;IACR;AAGD,aAASqD,YAAYC,OAAO;AAC1B,UAAIC,OAAO,CAAA;AAEXD,YAAME,QAAQ,SAASC,KAAKC,KAAK;AAC/BH,aAAKE,OAAO;MACb,CAFD;AAIA,aAAOF;IACR;AAGD,aAASN,YAAYX,KAAKqB,OAAOC,cAAc;AAG7C,UAAItB,IAAIS,iBACJY,SACAE,WAAWF,MAAM/D,OAAP,KAEV+D,MAAM/D,YAAYT,QAAQS,WAE1B,EAAE+D,MAAMG,eAAeH,MAAMG,YAAYC,cAAcJ,QAAQ;AACjE,YAAIK,MAAML,MAAM/D,QAAQgE,cAActB,GAA5B;AACV,YAAI,CAAChD,SAAS0E,GAAD,GAAO;AAClBA,gBAAMf,YAAYX,KAAK0B,KAAKJ,YAAX;QAClB;AACD,eAAOI;MACR;AAGD,UAAIC,YAAYC,gBAAgB5B,KAAKqB,KAAN;AAC/B,UAAIM,WAAW;AACb,eAAOA;MACR;AAGD,UAAIE,OAAOC,OAAOD,KAAKR,KAAZ;AACX,UAAIU,cAAchB,YAAYc,IAAD;AAE7B,UAAI7B,IAAIO,YAAY;AAClBsB,eAAOC,OAAOE,oBAAoBX,KAA3B;MACR;AAID,UAAIY,QAAQZ,KAAD,MACHQ,KAAKK,QAAQ,SAAb,KAA2B,KAAKL,KAAKK,QAAQ,aAAb,KAA+B,IAAI;AACzE,eAAOC,YAAYd,KAAD;MACnB;AAGD,UAAIQ,KAAKzE,WAAW,GAAG;AACrB,YAAImE,WAAWF,KAAD,GAAS;AACrB,cAAIe,OAAOf,MAAMe,OAAO,OAAOf,MAAMe,OAAO;AAC5C,iBAAOpC,IAAIE,QAAQ,cAAckC,OAAO,KAAK,SAAtC;QACR;AACD,YAAIC,SAAShB,KAAD,GAAS;AACnB,iBAAOrB,IAAIE,QAAQP,OAAO8B,UAAUa,SAASC,KAAKlB,KAA/B,GAAuC,QAAnD;QACR;AACD,YAAImB,OAAOnB,KAAD,GAAS;AACjB,iBAAOrB,IAAIE,QAAQuC,KAAKhB,UAAUa,SAASC,KAAKlB,KAA7B,GAAqC,MAAjD;QACR;AACD,YAAIY,QAAQZ,KAAD,GAAS;AAClB,iBAAOc,YAAYd,KAAD;QACnB;MACF;AAED,UAAIqB,OAAO,IAAI1B,QAAQ,OAAO2B,SAAS,CAAC,KAAK,GAAN;AAGvC,UAAIC,QAAQvB,KAAD,GAAS;AAClBL,gBAAQ;AACR2B,iBAAS,CAAC,KAAK,GAAN;MACV;AAGD,UAAIpB,WAAWF,KAAD,GAAS;AACrB,YAAIwB,IAAIxB,MAAMe,OAAO,OAAOf,MAAMe,OAAO;AACzCM,eAAO,eAAeG,IAAI;MAC3B;AAGD,UAAIR,SAAShB,KAAD,GAAS;AACnBqB,eAAO,MAAM/C,OAAO8B,UAAUa,SAASC,KAAKlB,KAA/B;MACd;AAGD,UAAImB,OAAOnB,KAAD,GAAS;AACjBqB,eAAO,MAAMD,KAAKhB,UAAUqB,YAAYP,KAAKlB,KAAhC;MACd;AAGD,UAAIY,QAAQZ,KAAD,GAAS;AAClBqB,eAAO,MAAMP,YAAYd,KAAD;MACzB;AAED,UAAIQ,KAAKzE,WAAW,MAAM,CAAC4D,SAASK,MAAMjE,UAAU,IAAI;AACtD,eAAOuF,OAAO,KAAKD,OAAOC,OAAO;MAClC;AAED,UAAIrB,eAAe,GAAG;AACpB,YAAIe,SAAShB,KAAD,GAAS;AACnB,iBAAOrB,IAAIE,QAAQP,OAAO8B,UAAUa,SAASC,KAAKlB,KAA/B,GAAuC,QAAnD;QACR,OAAM;AACL,iBAAOrB,IAAIE,QAAQ,YAAY,SAAxB;QACR;MACF;AAEDF,UAAIC,KAAK5C,KAAKgE,KAAd;AAEA,UAAI0B;AACJ,UAAI/B,OAAO;AACT+B,iBAASC,YAAYhD,KAAKqB,OAAOC,cAAcS,aAAaF,IAAxC;MACrB,OAAM;AACLkB,iBAASlB,KAAKoB,IAAI,SAASC,KAAK;AAC9B,iBAAOC,eAAenD,KAAKqB,OAAOC,cAAcS,aAAamB,KAAKlC,KAA7C;QACtB,CAFQ;MAGV;AAEDhB,UAAIC,KAAKmD,IAAT;AAEA,aAAOC,qBAAqBN,QAAQL,MAAMC,MAAf;IAC5B;AAGD,aAASf,gBAAgB5B,KAAKqB,OAAO;AACnC,UAAI9C,YAAY8C,KAAD;AACb,eAAOrB,IAAIE,QAAQ,aAAa,WAAzB;AACT,UAAIlD,SAASqE,KAAD,GAAS;AACnB,YAAIiC,SAAS,MAAOvF,KAAKC,UAAUqD,KAAf,EAAsBzD,QAAQ,UAAU,EAAxC,EACsBA,QAAQ,MAAM,KADpC,EAEsBA,QAAQ,QAAQ,GAFtC,IAE6C;AACjE,eAAOoC,IAAIE,QAAQoD,QAAQ,QAApB;MACR;AACD,UAAIC,SAASlC,KAAD;AACV,eAAOrB,IAAIE,QAAQ,KAAKmB,OAAO,QAAxB;AACT,UAAIf,UAAUe,KAAD;AACX,eAAOrB,IAAIE,QAAQ,KAAKmB,OAAO,SAAxB;AAET,UAAInD,OAAOmD,KAAD;AACR,eAAOrB,IAAIE,QAAQ,QAAQ,MAApB;IACV;AAGD,aAASiC,YAAYd,OAAO;AAC1B,aAAO,MAAMtC,MAAM0C,UAAUa,SAASC,KAAKlB,KAA9B,IAAuC;IACrD;AAGD,aAAS2B,YAAYhD,KAAKqB,OAAOC,cAAcS,aAAaF,MAAM;AAChE,UAAIkB,SAAS,CAAA;AACb,eAAS7F,IAAI,GAAGsG,IAAInC,MAAMjE,QAAQF,IAAIsG,GAAG,EAAEtG,GAAG;AAC5C,YAAIuG,eAAepC,OAAO1D,OAAOT,CAAD,CAAd,GAAoB;AACpC6F,iBAAO1F,KAAK8F,eAAenD,KAAKqB,OAAOC,cAAcS,aACjDpE,OAAOT,CAAD,GAAK,IADW,CAA1B;QAED,OAAM;AACL6F,iBAAO1F,KAAK,EAAZ;QACD;MACF;AACDwE,WAAKX,QAAQ,SAASgC,KAAK;AACzB,YAAI,CAACA,IAAIQ,MAAM,OAAV,GAAoB;AACvBX,iBAAO1F,KAAK8F,eAAenD,KAAKqB,OAAOC,cAAcS,aACjDmB,KAAK,IADiB,CAA1B;QAED;MACF,CALD;AAMA,aAAOH;IACR;AAGD,aAASI,eAAenD,KAAKqB,OAAOC,cAAcS,aAAamB,KAAKlC,OAAO;AACzE,UAAIoB,MAAM1E,KAAKiG;AACfA,aAAO7B,OAAO8B,yBAAyBvC,OAAO6B,GAAvC,KAA+C;QAAE7B,OAAOA,MAAM6B;MAAf;AACtD,UAAIS,KAAKE,KAAK;AACZ,YAAIF,KAAKpE,KAAK;AACZ7B,gBAAMsC,IAAIE,QAAQ,mBAAmB,SAA/B;QACP,OAAM;AACLxC,gBAAMsC,IAAIE,QAAQ,YAAY,SAAxB;QACP;MACF,OAAM;AACL,YAAIyD,KAAKpE,KAAK;AACZ7B,gBAAMsC,IAAIE,QAAQ,YAAY,SAAxB;QACP;MACF;AACD,UAAI,CAACuD,eAAe1B,aAAamB,GAAd,GAAoB;AACrCd,eAAO,MAAMc,MAAM;MACpB;AACD,UAAI,CAACxF,KAAK;AACR,YAAIsC,IAAIC,KAAKiC,QAAQyB,KAAKtC,KAAtB,IAA+B,GAAG;AACpC,cAAInD,OAAOoD,YAAD,GAAgB;AACxB5D,kBAAMiD,YAAYX,KAAK2D,KAAKtC,OAAO,IAAlB;UAClB,OAAM;AACL3D,kBAAMiD,YAAYX,KAAK2D,KAAKtC,OAAOC,eAAe,CAAjC;UAClB;AACD,cAAI5D,IAAIwE,QAAQ,IAAZ,IAAoB,IAAI;AAC1B,gBAAIlB,OAAO;AACTtD,oBAAMA,IAAIoG,MAAM,IAAV,EAAgBb,IAAI,SAASc,MAAM;AACvC,uBAAO,OAAOA;cACf,CAFK,EAEHxG,KAAK,IAFF,EAEQyG,OAAO,CAFf;YAGP,OAAM;AACLtG,oBAAM,OAAOA,IAAIoG,MAAM,IAAV,EAAgBb,IAAI,SAASc,MAAM;AAC9C,uBAAO,QAAQA;cAChB,CAFY,EAEVxG,KAAK,IAFK;YAGd;UACF;QACF,OAAM;AACLG,gBAAMsC,IAAIE,QAAQ,cAAc,SAA1B;QACP;MACF;AACD,UAAI3B,YAAY6D,IAAD,GAAQ;AACrB,YAAIpB,SAASkC,IAAIQ,MAAM,OAAV,GAAoB;AAC/B,iBAAOhG;QACR;AACD0E,eAAOrE,KAAKC,UAAU,KAAKkF,GAApB;AACP,YAAId,KAAKsB,MAAM,8BAAX,GAA4C;AAC9CtB,iBAAOA,KAAK4B,OAAO,GAAG5B,KAAKhF,SAAS,CAA7B;AACPgF,iBAAOpC,IAAIE,QAAQkC,MAAM,MAAlB;QACR,OAAM;AACLA,iBAAOA,KAAKxE,QAAQ,MAAM,KAAnB,EACKA,QAAQ,QAAQ,GADrB,EAEKA,QAAQ,YAAY,GAFzB;AAGPwE,iBAAOpC,IAAIE,QAAQkC,MAAM,QAAlB;QACR;MACF;AAED,aAAOA,OAAO,OAAO1E;IACtB;AAGD,aAAS2F,qBAAqBN,QAAQL,MAAMC,QAAQ;AAClD,UAAIsB,cAAc;AAClB,UAAI7G,SAAS2F,OAAOmB,OAAO,SAASC,MAAMC,KAAK;AAC7CH;AACA,YAAIG,IAAIlC,QAAQ,IAAZ,KAAqB;AAAG+B;AAC5B,eAAOE,OAAOC,IAAIxG,QAAQ,mBAAmB,EAA/B,EAAmCR,SAAS;MAC3D,GAAE,CAJU;AAMb,UAAIA,SAAS,IAAI;AACf,eAAOuF,OAAO,MACND,SAAS,KAAK,KAAKA,OAAO,SAC3B,MACAK,OAAOxF,KAAK,OAAZ,IACA,MACAoF,OAAO;MACf;AAED,aAAOA,OAAO,KAAKD,OAAO,MAAMK,OAAOxF,KAAK,IAAZ,IAAoB,MAAMoF,OAAO;IAClE;AAKD,aAASC,QAAQyB,IAAI;AACnB,aAAOC,MAAM1B,QAAQyB,EAAd;IACR;AACDxH,YAAQ+F,UAAUA;AAElB,aAAStC,UAAUiE,KAAK;AACtB,aAAO,OAAOA,QAAQ;IACvB;AACD1H,YAAQyD,YAAYA;AAEpB,aAASpC,OAAOqG,KAAK;AACnB,aAAOA,QAAQ;IAChB;AACD1H,YAAQqB,SAASA;AAEjB,aAASsG,kBAAkBD,KAAK;AAC9B,aAAOA,OAAO;IACf;AACD1H,YAAQ2H,oBAAoBA;AAE5B,aAASjB,SAASgB,KAAK;AACrB,aAAO,OAAOA,QAAQ;IACvB;AACD1H,YAAQ0G,WAAWA;AAEnB,aAASvG,SAASuH,KAAK;AACrB,aAAO,OAAOA,QAAQ;IACvB;AACD1H,YAAQG,WAAWA;AAEnB,aAASyH,SAASF,KAAK;AACrB,aAAO,OAAOA,QAAQ;IACvB;AACD1H,YAAQ4H,WAAWA;AAEnB,aAASlG,YAAYgG,KAAK;AACxB,aAAOA,QAAQ;IAChB;AACD1H,YAAQ0B,cAAcA;AAEtB,aAAS8D,SAASqC,IAAI;AACpB,aAAOvG,SAASuG,EAAD,KAAQC,eAAeD,EAAD,MAAS;IAC/C;AACD7H,YAAQwF,WAAWA;AAEnB,aAASlE,SAASoG,KAAK;AACrB,aAAO,OAAOA,QAAQ,YAAYA,QAAQ;IAC3C;AACD1H,YAAQsB,WAAWA;AAEnB,aAASqE,OAAOoC,GAAG;AACjB,aAAOzG,SAASyG,CAAD,KAAOD,eAAeC,CAAD,MAAQ;IAC7C;AACD/H,YAAQ2F,SAASA;AAEjB,aAASP,QAAQ4C,GAAG;AAClB,aAAO1G,SAAS0G,CAAD,MACVF,eAAeE,CAAD,MAAQ,oBAAoBA,aAAa9F;IAC7D;AACDlC,YAAQoF,UAAUA;AAElB,aAASV,WAAWgD,KAAK;AACvB,aAAO,OAAOA,QAAQ;IACvB;AACD1H,YAAQ0E,aAAaA;AAErB,aAASuD,YAAYP,KAAK;AACxB,aAAOA,QAAQ,QACR,OAAOA,QAAQ,aACf,OAAOA,QAAQ,YACf,OAAOA,QAAQ,YACf,OAAOA,QAAQ,YACf,OAAOA,QAAQ;IACvB;AACD1H,YAAQiI,cAAcA;AAEtBjI,YAAQkI,WAAWC;AAEnB,aAASL,eAAeM,GAAG;AACzB,aAAOnD,OAAOL,UAAUa,SAASC,KAAK0C,CAA/B;IACR;AAGD,aAASC,IAAIrC,GAAG;AACd,aAAOA,IAAI,KAAK,MAAMA,EAAEP,SAAS,EAAX,IAAiBO,EAAEP,SAAS,EAAX;IACxC;AAGD,QAAI6C,SAAS,CAAC,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OACxD,OAAO,OAAO,KADf;AAIb,aAASC,YAAY;AACnB,UAAIR,IAAI,IAAInC,KAAJ;AACR,UAAI4C,OAAO,CAACH,IAAIN,EAAEU,SAAF,CAAD,GACHJ,IAAIN,EAAEW,WAAF,CAAD,GACHL,IAAIN,EAAEY,WAAF,CAAD,CAFJ,EAEsBjI,KAAK,GAF3B;AAGX,aAAO,CAACqH,EAAEa,QAAF,GAAaN,OAAOP,EAAEc,SAAF,IAAeL,IAApC,EAA0C9H,KAAK,GAA/C;IACR;AAIDV,YAAQ8I,MAAM,WAAW;AACvB1G,cAAQ0G,IAAI,WAAWP,UAAS,GAAIvI,QAAQC,OAAO4B,MAAM7B,SAASM,SAA9B,CAApC;IACD;AAgBDN,YAAQ+I,WAAWZ;AAEnBnI,YAAQ2D,UAAU,SAASqF,QAAQC,KAAK;AAEtC,UAAI,CAACA,OAAO,CAAC3H,SAAS2H,GAAD;AAAO,eAAOD;AAEnC,UAAIhE,OAAOC,OAAOD,KAAKiE,GAAZ;AACX,UAAI5I,IAAI2E,KAAKzE;AACb,aAAOF,KAAK;AACV2I,eAAOhE,KAAK3E,MAAM4I,IAAIjE,KAAK3E;MAC5B;AACD,aAAO2I;IACR;AAED,aAASpC,eAAe3D,KAAKiG,MAAM;AACjC,aAAOjE,OAAOL,UAAUgC,eAAelB,KAAKzC,KAAKiG,IAA1C;IACR;;;;;ACzkBD;;;;AAEA,QAAIC,eAAeC;AAWnB,aAASC,QAAQC,GAAGC,GAAG;AACrB,UAAID,MAAMC,GAAG;AACX,eAAO;MACR;AAED,UAAIC,IAAIF,EAAEG;AACV,UAAIC,IAAIH,EAAEE;AAEV,eAASE,IAAI,GAAGC,MAAMC,KAAKC,IAAIN,GAAGE,CAAZ,GAAgBC,IAAIC,KAAK,EAAED,GAAG;AAClD,YAAIL,EAAEK,OAAOJ,EAAEI,IAAI;AACjBH,cAAIF,EAAEK;AACND,cAAIH,EAAEI;AACN;QACD;MACF;AAED,UAAIH,IAAIE,GAAG;AACT,eAAO;MACR;AACD,UAAIA,IAAIF,GAAG;AACT,eAAO;MACR;AACD,aAAO;IACR;AACD,aAASO,SAASR,GAAG;AACnB,UAAIS,OAAOC,UAAU,OAAOD,OAAOC,OAAOF,aAAa,YAAY;AACjE,eAAOC,OAAOC,OAAOF,SAASR,CAAvB;MACR;AACD,aAAO,CAAC,EAAEA,KAAK,QAAQA,EAAEW;IAC1B;AA8BD,QAAIC,OAAOf;AACX,QAAIgB,SAASC,OAAOC,UAAUC;AAC9B,QAAIC,SAASC,MAAMH,UAAUI;AAC7B,QAAIC,qBAAsB,WAAY;AACpC,aAAO,SAASC,MAAM;MAAE,EAACC,SAAS;IACnC,EAFyB;AAG1B,aAASC,UAAWC,KAAK;AACvB,aAAOV,OAAOC,UAAUU,SAASC,KAAKF,GAA/B;IACR;AACD,aAASG,OAAOC,QAAQ;AACtB,UAAIpB,SAASoB,MAAD,GAAU;AACpB,eAAO;MACR;AACD,UAAI,OAAOnB,OAAOoB,gBAAgB,YAAY;AAC5C,eAAO;MACR;AACD,UAAI,OAAOA,YAAYF,WAAW,YAAY;AAC5C,eAAOE,YAAYF,OAAOC,MAAnB;MACR;AACD,UAAI,CAACA,QAAQ;AACX,eAAO;MACR;AACD,UAAIA,kBAAkBE,UAAU;AAC9B,eAAO;MACR;AACD,UAAIF,OAAOG,UAAUH,OAAOG,kBAAkBF,aAAa;AACzD,eAAO;MACR;AACD,aAAO;IACR;AAKD,QAAIG,SAASC,OAAOC,UAAUC;AAO9B,QAAIC,QAAQ;AAEZ,aAASC,QAAQC,MAAM;AACrB,UAAI,CAAC1B,KAAK2B,WAAWD,IAAhB,GAAuB;AAC1B;MACD;AACD,UAAIlB,oBAAoB;AACtB,eAAOkB,KAAKhB;MACb;AACD,UAAIkB,MAAMF,KAAKb,SAAL;AACV,UAAIgB,QAAQD,IAAIC,MAAML,KAAV;AACZ,aAAOK,SAASA,MAAM;IACvB;AACDT,WAAOU,iBAAiB,SAASA,eAAeC,SAAS;AACvD,WAAKrB,OAAO;AACZ,WAAKsB,SAASD,QAAQC;AACtB,WAAKC,WAAWF,QAAQE;AACxB,WAAKC,WAAWH,QAAQG;AACxB,UAAIH,QAAQI,SAAS;AACnB,aAAKA,UAAUJ,QAAQI;AACvB,aAAKC,mBAAmB;MACzB,OAAM;AACL,aAAKD,UAAUE,WAAW,IAAD;AACzB,aAAKD,mBAAmB;MACzB;AACD,UAAIE,qBAAqBP,QAAQO,sBAAsBC;AACvD,UAAIC,MAAMC,mBAAmB;AAC3BD,cAAMC,kBAAkB,MAAMH,kBAA9B;MACD,OAAM;AAEL,YAAII,MAAM,IAAIF,MAAJ;AACV,YAAIE,IAAIC,OAAO;AACb,cAAIC,MAAMF,IAAIC;AAGd,cAAIE,UAAUpB,QAAQa,kBAAD;AACrB,cAAIQ,MAAMF,IAAIG,QAAQ,OAAOF,OAAnB;AACV,cAAIC,OAAO,GAAG;AAGZ,gBAAIE,YAAYJ,IAAIG,QAAQ,MAAMD,MAAM,CAAxB;AAChBF,kBAAMA,IAAIK,UAAUD,YAAY,CAA1B;UACP;AAED,eAAKL,QAAQC;QACd;MACF;IACF;AAGD5C,SAAKkD,SAAS9B,OAAOU,gBAAgBU,KAArC;AAEA,aAASW,SAASC,GAAGC,GAAG;AACtB,UAAI,OAAOD,MAAM,UAAU;AACzB,eAAOA,EAAE9D,SAAS+D,IAAID,IAAIA,EAAE7C,MAAM,GAAG8C,CAAX;MAC3B,OAAM;AACL,eAAOD;MACR;IACF;AACD,aAASE,QAAQC,WAAW;AAC1B,UAAI/C,sBAAsB,CAACR,KAAK2B,WAAW4B,SAAhB,GAA4B;AACrD,eAAOvD,KAAKsD,QAAQC,SAAb;MACR;AACD,UAAIC,UAAU/B,QAAQ8B,SAAD;AACrB,UAAI7C,OAAO8C,UAAU,OAAOA,UAAU;AACtC,aAAO,cAAe9C,OAAO;IAC9B;AACD,aAAS2B,WAAWoB,MAAM;AACxB,aAAON,SAASG,QAAQG,KAAKzB,MAAN,GAAe,GAAvB,IAA8B,MACtCyB,KAAKvB,WAAW,MAChBiB,SAASG,QAAQG,KAAKxB,QAAN,GAAiB,GAAzB;IAChB;AAaD,aAASM,KAAKP,QAAQC,UAAUE,SAASD,UAAUI,oBAAoB;AACrE,YAAM,IAAIlB,OAAOU,eAAe;QAC9BK;QACAH;QACAC;QACAC;QACAI;MAL8B,CAA1B;IAOP;AAGDlB,WAAOmB,OAAOA;AASd,aAAShB,GAAGmC,OAAOvB,SAAS;AAC1B,UAAI,CAACuB;AAAOnB,aAAKmB,OAAO,MAAMvB,SAAS,MAAMf,OAAOG,EAApC;IACjB;AACDH,WAAOG,KAAKA;AAMZH,WAAOuC,QAAQ,SAASA,MAAM3B,QAAQC,UAAUE,SAAS;AACvD,UAAIH,UAAUC;AAAUM,aAAKP,QAAQC,UAAUE,SAAS,MAAMf,OAAOuC,KAAzC;IAC7B;AAKDvC,WAAOwC,WAAW,SAASA,SAAS5B,QAAQC,UAAUE,SAAS;AAC7D,UAAIH,UAAUC,UAAU;AACtBM,aAAKP,QAAQC,UAAUE,SAAS,MAAMf,OAAOwC,QAAzC;MACL;IACF;AAKDxC,WAAOyC,YAAY,SAASA,UAAU7B,QAAQC,UAAUE,SAAS;AAC/D,UAAI,CAAC2B,WAAW9B,QAAQC,UAAU,KAAnB,GAA2B;AACxCM,aAAKP,QAAQC,UAAUE,SAAS,aAAaf,OAAOyC,SAAhD;MACL;IACF;AAEDzC,WAAO2C,kBAAkB,SAASA,gBAAgB/B,QAAQC,UAAUE,SAAS;AAC3E,UAAI,CAAC2B,WAAW9B,QAAQC,UAAU,IAAnB,GAA0B;AACvCM,aAAKP,QAAQC,UAAUE,SAAS,mBAAmBf,OAAO2C,eAAtD;MACL;IACF;AAED,aAASD,WAAW9B,QAAQC,UAAU+B,SAAQC,OAAO;AAEnD,UAAIjC,WAAWC,UAAU;AACvB,eAAO;MACR,WAAUrC,SAASoC,MAAD,KAAYpC,SAASqC,QAAD,GAAY;AACjD,eAAO/C,QAAQ8C,QAAQC,QAAT,MAAuB;MAItC,WAAUjC,KAAKkE,OAAOlC,MAAZ,KAAuBhC,KAAKkE,OAAOjC,QAAZ,GAAuB;AACvD,eAAOD,OAAOmC,QAAP,MAAqBlC,SAASkC,QAAT;MAK7B,WAAUnE,KAAKoE,SAASpC,MAAd,KAAyBhC,KAAKoE,SAASnC,QAAd,GAAyB;AAC3D,eAAOD,OAAOqC,WAAWpC,SAASoC,UAC3BrC,OAAOnC,WAAWoC,SAASpC,UAC3BmC,OAAOsC,cAAcrC,SAASqC,aAC9BtC,OAAOuC,cAActC,SAASsC,aAC9BvC,OAAOwC,eAAevC,SAASuC;MAIvC,YAAWxC,WAAW,QAAQ,OAAOA,WAAW,cACrCC,aAAa,QAAQ,OAAOA,aAAa,WAAW;AAC9D,eAAO+B,UAAShC,WAAWC,WAAWD,UAAUC;MAQjD,WAAUlB,OAAOiB,MAAD,KAAYjB,OAAOkB,QAAD,KACxBtB,UAAUqB,MAAD,MAAarB,UAAUsB,QAAD,KAC/B,EAAED,kBAAkByC,gBAClBzC,kBAAkB0C,eAAe;AAC5C,eAAOxF,QAAQ,IAAIyF,WAAW3C,OAAOb,MAAtB,GACA,IAAIwD,WAAW1C,SAASd,MAAxB,CADD,MACsC;MAQrD,WAAUvB,SAASoC,MAAD,MAAapC,SAASqC,QAAD,GAAY;AAClD,eAAO;MACR,OAAM;AACLgC,gBAAQA,SAAS;UAACjC,QAAQ,CAAA;UAAIC,UAAU,CAAA;QAAvB;AAEjB,YAAI2C,cAAcX,MAAMjC,OAAOe,QAAQf,MAArB;AAClB,YAAI4C,gBAAgB,IAAI;AACtB,cAAIA,gBAAgBX,MAAMhC,SAASc,QAAQd,QAAvB,GAAkC;AACpD,mBAAO;UACR;QACF;AAEDgC,cAAMjC,OAAO6C,KAAK7C,MAAlB;AACAiC,cAAMhC,SAAS4C,KAAK5C,QAApB;AAEA,eAAO6C,SAAS9C,QAAQC,UAAU+B,SAAQC,KAA3B;MAChB;IACF;AAED,aAASc,YAAYC,QAAQ;AAC3B,aAAO9E,OAAOC,UAAUU,SAASC,KAAKkE,MAA/B,KAA0C;IAClD;AAED,aAASF,SAAS3F,GAAGC,GAAG4E,SAAQiB,sBAAsB;AACpD,UAAI9F,MAAM,QAAQA,MAAM+F,UAAa9F,MAAM,QAAQA,MAAM8F;AACvD,eAAO;AAET,UAAIlF,KAAKmF,YAAYhG,CAAjB,KAAuBa,KAAKmF,YAAY/F,CAAjB;AACzB,eAAOD,MAAMC;AACf,UAAI4E,WAAU9D,OAAOkF,eAAejG,CAAtB,MAA6Be,OAAOkF,eAAehG,CAAtB;AACzC,eAAO;AACT,UAAIiG,UAAUN,YAAY5F,CAAD;AACzB,UAAImG,UAAUP,YAAY3F,CAAD;AACzB,UAAKiG,WAAW,CAACC,WAAa,CAACD,WAAWC;AACxC,eAAO;AACT,UAAID,SAAS;AACXlG,YAAIkB,OAAOS,KAAK3B,CAAZ;AACJC,YAAIiB,OAAOS,KAAK1B,CAAZ;AACJ,eAAO0E,WAAW3E,GAAGC,GAAG4E,OAAP;MAClB;AACD,UAAIuB,KAAKC,WAAWrG,CAAD;AACnB,UAAIsG,KAAKD,WAAWpG,CAAD;AACnB,UAAIsG,KAAKlG;AAGT,UAAI+F,GAAGjG,WAAWmG,GAAGnG;AACnB,eAAO;AAETiG,SAAGI,KAAH;AACAF,SAAGE,KAAH;AAEA,WAAKnG,IAAI+F,GAAGjG,SAAS,GAAGE,KAAK,GAAGA,KAAK;AACnC,YAAI+F,GAAG/F,OAAOiG,GAAGjG;AACf,iBAAO;MACV;AAGD,WAAKA,IAAI+F,GAAGjG,SAAS,GAAGE,KAAK,GAAGA,KAAK;AACnCkG,cAAMH,GAAG/F;AACT,YAAI,CAACsE,WAAW3E,EAAEuG,MAAMtG,EAAEsG,MAAM1B,SAAQiB,oBAAzB;AACb,iBAAO;MACV;AACD,aAAO;IACR;AAKD7D,WAAOwE,eAAe,SAASA,aAAa5D,QAAQC,UAAUE,SAAS;AACrE,UAAI2B,WAAW9B,QAAQC,UAAU,KAAnB,GAA2B;AACvCM,aAAKP,QAAQC,UAAUE,SAAS,gBAAgBf,OAAOwE,YAAnD;MACL;IACF;AAEDxE,WAAOyE,qBAAqBA;AAC5B,aAASA,mBAAmB7D,QAAQC,UAAUE,SAAS;AACrD,UAAI2B,WAAW9B,QAAQC,UAAU,IAAnB,GAA0B;AACtCM,aAAKP,QAAQC,UAAUE,SAAS,sBAAsB0D,kBAAlD;MACL;IACF;AAMDzE,WAAO0E,cAAc,SAASA,YAAY9D,QAAQC,UAAUE,SAAS;AACnE,UAAIH,WAAWC,UAAU;AACvBM,aAAKP,QAAQC,UAAUE,SAAS,OAAOf,OAAO0E,WAA1C;MACL;IACF;AAKD1E,WAAO2E,iBAAiB,SAASA,eAAe/D,QAAQC,UAAUE,SAAS;AACzE,UAAIH,WAAWC,UAAU;AACvBM,aAAKP,QAAQC,UAAUE,SAAS,OAAOf,OAAO2E,cAA1C;MACL;IACF;AAED,aAASC,kBAAkBhE,QAAQC,UAAU;AAC3C,UAAI,CAACD,UAAU,CAACC,UAAU;AACxB,eAAO;MACR;AAED,UAAI/B,OAAOC,UAAUU,SAASC,KAAKmB,QAA/B,KAA4C,mBAAmB;AACjE,eAAOA,SAASgE,KAAKjE,MAAd;MACR;AAED,UAAI;AACF,YAAIA,kBAAkBC,UAAU;AAC9B,iBAAO;QACR;MACF,SAAQiE,GAAP;MAED;AAED,UAAI1D,MAAM2D,cAAclE,QAApB,GAA+B;AACjC,eAAO;MACR;AAED,aAAOA,SAASnB,KAAK,CAAA,GAAIkB,MAAlB,MAA8B;IACtC;AAED,aAASoE,UAAUC,OAAO;AACxB,UAAIC;AACJ,UAAI;AACFD,cAAK;MACN,SAAQH,GAAP;AACAI,gBAAQJ;MACT;AACD,aAAOI;IACR;AAED,aAASC,QAAQC,aAAaH,OAAOpE,UAAUE,SAAS;AACtD,UAAIH;AAEJ,UAAI,OAAOqE,UAAU,YAAY;AAC/B,cAAM,IAAII,UAAU,qCAAd;MACP;AAED,UAAI,OAAOxE,aAAa,UAAU;AAChCE,kBAAUF;AACVA,mBAAW;MACZ;AAEDD,eAASoE,UAAUC,KAAD;AAElBlE,iBAAWF,YAAYA,SAASvB,OAAO,OAAOuB,SAASvB,OAAO,OAAO,QAC1DyB,UAAU,MAAMA,UAAU;AAErC,UAAIqE,eAAe,CAACxE,QAAQ;AAC1BO,aAAKP,QAAQC,UAAU,+BAA+BE,OAAlD;MACL;AAED,UAAIuE,sBAAsB,OAAOvE,YAAY;AAC7C,UAAIwE,sBAAsB,CAACH,eAAexG,KAAK4G,QAAQ5E,MAAb;AAC1C,UAAI6E,wBAAwB,CAACL,eAAexE,UAAU,CAACC;AAEvD,UAAK0E,uBACDD,uBACAV,kBAAkBhE,QAAQC,QAAT,KACjB4E,uBAAuB;AACzBtE,aAAKP,QAAQC,UAAU,2BAA2BE,OAA9C;MACL;AAED,UAAKqE,eAAexE,UAAUC,YAC1B,CAAC+D,kBAAkBhE,QAAQC,QAAT,KAAwB,CAACuE,eAAexE,QAAS;AACrE,cAAMA;MACP;IACF;AAKDZ,WAAO0F,SAAS,SAAST,OAAmBC,OAAmBnE,SAAS;AACtEoE,cAAQ,MAAMF,OAAOC,OAAOnE,OAArB;IACR;AAGDf,WAAO2F,eAAe,SAASV,OAAmBC,OAAmBnE,SAAS;AAC5EoE,cAAQ,OAAOF,OAAOC,OAAOnE,OAAtB;IACR;AAEDf,WAAO4F,UAAU,SAAStE,KAAK;AAAE,UAAIA;AAAK,cAAMA;IAAM;AAGtD,aAASsB,OAAON,OAAOvB,SAAS;AAC9B,UAAI,CAACuB;AAAOnB,aAAKmB,OAAO,MAAMvB,SAAS,MAAM6B,MAA7B;IACjB;AACD5C,WAAO4C,SAAShF,aAAagF,QAAQ5C,QAAQ;MAC3CuC,OAAOvC,OAAO0E;MACdjC,WAAWzC,OAAO2C;MAClBH,UAAUxC,OAAO2E;MACjBH,cAAcxE,OAAOyE;IAJsB,CAAjB;AAM5BzE,WAAO4C,OAAOA,SAAS5C,OAAO4C;AAE9B,QAAIwB,aAAatF,OAAO+G,QAAQ,SAAUrG,KAAK;AAC7C,UAAIqG,OAAO,CAAA;AACX,eAASvB,OAAO9E,KAAK;AACnB,YAAIX,OAAOa,KAAKF,KAAK8E,GAAjB;AAAuBuB,eAAKpC,KAAKa,GAAV;MAC5B;AACD,aAAOuB;IACR;;;;;ACzfD;;;AAMC,KAAA,WAAY;AACT;AAEA,UAAIC;AAEJA,gBAAUC,kBAA2BC;AACrCC,cAAQH,UAAUA;AAElB,eAASI,cAAcC,SAAS;AAC5B,aAAKC,OAAO;AACZ,aAAKD,UAAUA;MAClB;AACDD,oBAAcG,YAAa,WAAY;AACnC,YAAIC,SAAS,WAAY;QAAG;AAC5BA,eAAOD,YAAYE,MAAMF;AACzB,eAAO,IAAIC,OAAJ;MACV,EAJ0B;AAK3BJ,oBAAcG,UAAUG,cAAcN;AACtCD,cAAQC,gBAAgBA;AAExB,eAASO,WAAWN,SAAS;AACzB,cAAM,IAAID,cAAcC,OAAlB;MACT;AACDF,cAAQQ,aAAaA;AAErBR,cAAQS,SAASX;IACpB,GA1BA;;;;;ACND;;;AASC,KAAA,WAAY;AACT;AAEA,UAAIY,QACAC,OACAC,QACAC,QACAC,OACAC,UACAC,OACAC,OACAC,SACAC,SACAC,aACAC;AAEJH,gBAAUI;AACVH,gBAAUG;AAEVZ,eAAS;QACLa,iBAAiB;QACjBC,YAAY;QACZC,aAAa;QACbC,kBAAkB;QAClBC,aAAa;QACbC,WAAW;QACXC,WAAW;QACXC,YAAY;QACZC,WAAW;QACXC,cAAc;QACdC,eAAe;QACfC,UAAU;QACVC,iBAAiB;QACjBC,cAAc;QACdC,cAAc;QACdC,gBAAgB;QAChBC,iBAAiB;QACjBC,mBAAmB;QACnBC,oBAAoB;QACpBC,oBAAoB;MApBf;AAuBT/B,cAAQ;QACJgC,SAAS;QACTC,QAAQ;QACRC,MAAM;QACNC,IAAI;QACJC,IAAI;QACJC,QAAQ;QACRC,QAAQ;QACRC,QAAQ;QACRC,QAAQ;QACRC,QAAQ;QACRC,QAAQ;QACRC,OAAO;QACPC,OAAO;QACPC,MAAM;QACNC,MAAM;QACNC,UAAU;QACVC,MAAM;QACNC,OAAO;QACPC,MAAM;QACNC,QAAQ;QACRC,QAAQ;QACRC,KAAK;MAtBD;AAyBR,eAASC,WAAWC,IAAI;AACpB,eAAO,kBAAkBC,QAAQC,OAAOC,aAAaH,EAApB,CAA1B,MAAuD,MAAM,CAAChD,QAAQoD,KAAKC,aAAaL,EAA1B,KAAiC,CAAChD,QAAQoD,KAAKE,iBAAiBN,EAA9B;MAC1G;AAED,eAASO,QAAQ1D,WAAUD,QAAOE,QAAOC,QAAO;AAC5C,aAAKyD,YAAY3D;AACjB,aAAK4D,SAAS7D;AACd,aAAK8D,SAAS5D;AACd,aAAK6D,SAAS5D;MACjB;AAEDwD,cAAQK,UAAUC,UAAU,WAAY;AACpChE,mBAAW,KAAK2D;AAChB5D,gBAAQ,KAAK6D;AACb3D,gBAAQ,KAAK4D;AACb3D,gBAAQ,KAAK4D;MAChB;AAEDJ,cAAQO,OAAO,WAAY;AACvB,eAAO,IAAIP,QAAQ1D,UAAUD,OAAOE,OAAOC,KAApC;MACV;AAED,eAASgE,cAAcC,MAAMC,OAAO;AAChC,YAAI9D,UAAU;AACV6D,eAAKC,QAAQ,CAACA,MAAM,KAAK/D,aAAa+D,MAAM,KAAK/D,WAApC;QAChB;AACD,eAAO8D;MACV;AAED,eAASE,UAAU;AACf,YAAIlB,KAAKtD,OAAOyE,OAAOvE,KAAd;AACTA,iBAAS;AACT,eAAOoD;MACV;AAED,eAASoB,cAAcC,QAAQ;AAC3B,YAAIC,GAAGC,KAAKvB,IAAII,OAAO;AAEvBmB,cAAOF,WAAW,MAAO,IAAI;AAC7B,aAAKC,IAAI,GAAGA,IAAIC,KAAK,EAAED,GAAG;AACtB,cAAI1E,QAAQD,UAAUK,QAAQoD,KAAKoB,WAAW9E,OAAO+E,WAAW7E,KAAlB,CAAxB,GAAmD;AACrEoD,iBAAKkB,QAAO;AACZd,mBAAOA,OAAO,KAAK,mBAAmBH,QAAQD,GAAG0B,YAAH,CAA3B;UACtB,OAAM;AACH,mBAAO;UACV;QACJ;AACD,eAAOxB,OAAOC,aAAaC,IAApB;MACV;AAED,eAASuB,aAAa;AAClB,YAAIC,MAAM,IAAIC,OAAO7B,IAAII,MAAM0B,WAAWjB;AAC1CgB,gBAAQnF,OAAOyE,OAAOvE,KAAd;AACR,UAAEA;AAEF,eAAOA,QAAQD,QAAQ;AACnBqD,eAAKkB,QAAO;AAEZ,cAAIlB,OAAO6B,OAAO;AACdA,oBAAQ;AACR;UACH,WAAU7B,OAAO,MAAM;AACpBA,iBAAKkB,QAAO;AACZ,gBAAI,CAAClE,QAAQoD,KAAKE,iBAAiBN,GAAGyB,WAAW,CAAd,CAA9B,GAAiD;AAClD,sBAAQzB;qBACH;AACD4B,yBAAO;AACP;qBACC;AACDA,yBAAO;AACP;qBACC;AACDA,yBAAO;AACP;qBACC;qBACA;AACDf,4BAAUjE;AACVkF,8BAAYV,cAAcpB,EAAD;AACzB,sBAAI8B,WAAW;AACXF,2BAAOE;kBACV,OAAM;AACHlF,4BAAQiE;AACRe,2BAAO5B;kBACV;AACD;qBACC;AACD4B,yBAAO;AACP;qBACC;AACDA,yBAAO;AACP;qBACC;AACDA,yBAAO;AACP;;AAGA,sBAAI5E,QAAQoD,KAAK2B,aAAa/B,GAAGyB,WAAW,CAAd,CAA1B,GAA6C;AAC7CrB,2BAAO,WAAWH,QAAQD,EAAnB;AAQP,wBAAIpD,QAAQD,UAAUK,QAAQoD,KAAK2B,aAAarF,OAAO+E,WAAW7E,KAAlB,CAA1B,GAAqD;AAEvEwD,6BAAOA,OAAO,IAAI,WAAWH,QAAQiB,QAAO,CAA1B;AAIlB,0BAAI,OAAOjB,QAAQD,EAAf,KAAsB,KAClBpD,QAAQD,UACRK,QAAQoD,KAAK2B,aAAarF,OAAO+E,WAAW7E,KAAlB,CAA1B,GAAqD;AACzDwD,+BAAOA,OAAO,IAAI,WAAWH,QAAQiB,QAAO,CAA1B;sBACrB;oBACJ;AACDU,2BAAO1B,OAAOC,aAAaC,IAApB;kBACV,OAAM;AACHwB,2BAAO5B;kBACV;AACD;;YAEP,OAAM;AACH,kBAAIA,OAAQ,QAAQtD,OAAO+E,WAAW7E,KAAlB,MAA6B,IAAkB;AAC/D,kBAAEA;cACL;YACJ;UACJ,WAAUI,QAAQoD,KAAKE,iBAAiBN,GAAGyB,WAAW,CAAd,CAA9B,GAAiD;AACxD;UACH,OAAM;AACHG,mBAAO5B;UACV;QACJ;AAED,YAAI6B,UAAU,IAAI;AACd5E,kBAAQ+E,WAAW,kBAAnB;QACH;AAEDjF,gBAAQ6E;AACR,eAAOnF,MAAMmD;MAChB;AAED,eAASqC,aAAa;AAClB,YAAIC,QAAQlC;AAEZkC,iBAAS;AACTlC,aAAKtD,OAAO+E,WAAW7E,KAAlB;AAEL,YAAIoD,OAAO,IAAiB;AACxBkC,mBAAShB,QAAO;AAChBlB,eAAKtD,OAAO+E,WAAW7E,KAAlB;AAEL,cAAIsF,WAAW,KAAK;AAChB,gBAAIlC,OAAO,OAAmBA,OAAO,IAAiB;AAClDkC,wBAAUhB,QAAO;AACjB,qBAAOtE,QAAQD,QAAQ;AACnBqD,qBAAKtD,OAAO+E,WAAW7E,KAAlB;AACL,oBAAI,CAACI,QAAQoD,KAAKoB,WAAWxB,EAAxB,GAA6B;AAC9B;gBACH;AACDkC,0BAAUhB,QAAO;cACpB;AAED,kBAAIgB,OAAOvF,UAAU,GAAG;AAEpBM,wBAAQ+E,WAAW,kBAAnB;cACH;AAED,kBAAIpF,QAAQD,QAAQ;AAChBqD,qBAAKtD,OAAO+E,WAAW7E,KAAlB;AACL,oBAAII,QAAQoD,KAAK+B,qBAAqBnC,EAAlC,GAAuC;AACvC/C,0BAAQ+E,WAAW,kBAAnB;gBACH;cACJ;AACDjF,sBAAQqF,SAASF,QAAQ,EAAT;AAChB,qBAAOzF,MAAMoD;YAChB;AAED,gBAAI7C,QAAQoD,KAAK2B,aAAa/B,EAA1B,GAA+B;AAC/BkC,wBAAUhB,QAAO;AACjB,qBAAOtE,QAAQD,QAAQ;AACnBqD,qBAAKtD,OAAO+E,WAAW7E,KAAlB;AACL,oBAAI,CAACI,QAAQoD,KAAK2B,aAAa/B,EAA1B,GAA+B;AAChC;gBACH;AACDkC,0BAAUhB,QAAO;cACpB;AAED,kBAAItE,QAAQD,QAAQ;AAChBqD,qBAAKtD,OAAO+E,WAAW7E,KAAlB;AACL,oBAAII,QAAQoD,KAAK+B,qBAAqBnC,EAAlC,KAAyChD,QAAQoD,KAAKiC,eAAerC,EAA5B,GAAiC;AAC1E/C,0BAAQ+E,WAAW,kBAAnB;gBACH;cACJ;AACDjF,sBAAQqF,SAASF,QAAQ,CAAT;AAChB,qBAAOzF,MAAMoD;YAChB;AAED,gBAAI7C,QAAQoD,KAAKiC,eAAerC,EAA5B,GAAiC;AACjC/C,sBAAQ+E,WAAW,kBAAnB;YACH;UACJ;AAED,iBAAOpF,QAAQD,QAAQ;AACnBqD,iBAAKtD,OAAO+E,WAAW7E,KAAlB;AACL,gBAAI,CAACI,QAAQoD,KAAKiC,eAAerC,EAA5B,GAAiC;AAClC;YACH;AACDkC,sBAAUhB,QAAO;UACpB;QACJ;AAED,YAAIlB,OAAO,IAAiB;AACxBkC,oBAAUhB,QAAO;AACjB,iBAAOtE,QAAQD,QAAQ;AACnBqD,iBAAKtD,OAAO+E,WAAW7E,KAAlB;AACL,gBAAI,CAACI,QAAQoD,KAAKiC,eAAerC,EAA5B,GAAiC;AAClC;YACH;AACDkC,sBAAUhB,QAAO;UACpB;QACJ;AAED,YAAIlB,OAAO,OAAmBA,OAAO,IAAiB;AAClDkC,oBAAUhB,QAAO;AAEjBlB,eAAKtD,OAAO+E,WAAW7E,KAAlB;AACL,cAAIoD,OAAO,MAAmBA,OAAO,IAAiB;AAClDkC,sBAAUhB,QAAO;UACpB;AAEDlB,eAAKtD,OAAO+E,WAAW7E,KAAlB;AACL,cAAII,QAAQoD,KAAKiC,eAAerC,EAA5B,GAAiC;AACjCkC,sBAAUhB,QAAO;AACjB,mBAAOtE,QAAQD,QAAQ;AACnBqD,mBAAKtD,OAAO+E,WAAW7E,KAAlB;AACL,kBAAI,CAACI,QAAQoD,KAAKiC,eAAerC,EAA5B,GAAiC;AAClC;cACH;AACDkC,wBAAUhB,QAAO;YACpB;UACJ,OAAM;AACHjE,oBAAQ+E,WAAW,kBAAnB;UACH;QACJ;AAED,YAAIpF,QAAQD,QAAQ;AAChBqD,eAAKtD,OAAO+E,WAAW7E,KAAlB;AACL,cAAII,QAAQoD,KAAK+B,qBAAqBnC,EAAlC,GAAuC;AACvC/C,oBAAQ+E,WAAW,kBAAnB;UACH;QACJ;AAEDjF,gBAAQuF,WAAWJ,MAAD;AAClB,eAAOzF,MAAMoD;MAChB;AAGD,eAAS0C,eAAe;AACpB,YAAIvC,IAAIwC;AAERzF,gBAAQmE,QAAO;AACf,eAAOtE,QAAQD,UAAUoD,WAAWrD,OAAO+E,WAAW7E,KAAlB,CAAD,GAA4B;AAC3DoD,eAAKtD,OAAO+E,WAAW7E,KAAlB;AACL,cAAIoD,OAAO,IAAiB;AACxB,gBAAKpD,QAAQ,KAAMD,QAAQ;AACvB,qBAAOF,MAAMgC;YAChB;AACD+D,kBAAM9F,OAAO+E,WAAW7E,QAAQ,CAA1B;AACN,gBAAI4F,QAAQ,IAAiB;AACzB;YACH;UACJ;AACDzF,mBAASmE,QAAO;QACnB;AACD,eAAOzE,MAAMkD;MAChB;AAED,eAAS8C,OAAO;AACZ,YAAIzC;AAEJnD,mBAAWD;AAEX,eAAOA,QAAQD,UAAUK,QAAQoD,KAAKC,aAAa3D,OAAO+E,WAAW7E,KAAlB,CAA1B,GAAqD;AAC1EsE,kBAAO;QACV;AACD,YAAItE,SAASD,QAAQ;AACjBG,kBAAQL,MAAMqD;AACd,iBAAOhD;QACV;AAEDkD,aAAKtD,OAAO+E,WAAW7E,KAAlB;AACL,gBAAQoD;eACH;eACA;AACDlD,oBAAQ6E,WAAU;AAClB,mBAAO7E;eAEN;AACDoE,oBAAO;AACPpE,oBAAQL,MAAM4C;AACd,mBAAOvC;eAEN;AACDoE,oBAAO;AACPpE,oBAAQL,MAAM2C;AACd,mBAAOtC;eAEN;AACDoE,oBAAO;AACPpE,oBAAQL,MAAMqC;AACd,mBAAOhC;eAEN;AACDoE,oBAAO;AACPpE,oBAAQL,MAAMsC;AACd,mBAAOjC;eAEN;AACDoE,oBAAO;AACPpE,oBAAQL,MAAMyC;AACd,mBAAOpC;eAEN;AACDoE,oBAAO;AACPpE,oBAAQL,MAAM0C;AACd,mBAAOrC;eAEN;AACDoE,oBAAO;AACPpE,oBAAQL,MAAMuC;AACd,mBAAOlC;eAEN;AACDoE,oBAAO;AACPpE,oBAAQL,MAAMwC;AACd,mBAAOnC;eAEN;AACD,gBAAIF,QAAQ,IAAID,QAAQ;AACpBqD,mBAAKtD,OAAO+E,WAAW7E,QAAQ,CAA1B;AACL,kBAAIoD,OAAO,IAAiB;AACxBkB,wBAAO;AACPA,wBAAO;AACPpE,wBAAQL,MAAMiC;AACd,uBAAO5B;cACV;AAED,kBAAIkD,OAAO,MAAmBpD,QAAQ,IAAID,UAAUD,OAAO+E,WAAW7E,QAAQ,CAA1B,MAAiC,IAAiB;AAClGsE,wBAAO;AACPA,wBAAO;AACPA,wBAAO;AACPpE,wBAAQL,MAAMkC;AACd,uBAAO7B;cACV;AAED,kBAAIE,QAAQoD,KAAKiC,eAAerC,EAA5B,GAAiC;AACjClD,wBAAQmF,WAAU;AAClB,uBAAOnF;cACV;YACJ;AACDA,oBAAQL,MAAMgC;AACd,mBAAO3B;eAEN;AACDoE,oBAAO;AACPpE,oBAAQL,MAAMmC;AACd,mBAAO9B;eAEN;AACDoE,oBAAO;AACPpE,oBAAQL,MAAMoC;AACd,mBAAO/B;eAEN;AACDoE,oBAAO;AACPpE,oBAAQL,MAAM6C;AACd,mBAAOxC;eAEN;AACDoE,oBAAO;AACPpE,oBAAQL,MAAM8C;AACd,mBAAOzC;eAEN;AACDoE,oBAAO;AACPpE,oBAAQL,MAAM+C;AACd,mBAAO1C;eAEN;AACDoE,oBAAO;AACPpE,oBAAQL,MAAMgD;AACd,mBAAO3C;eAEN;AACDoE,oBAAO;AACPpE,oBAAQL,MAAMiD;AACd,mBAAO5C;eAEN;AACDA,oBAAQmF,WAAU;AAClB,mBAAOnF;;AAGP,gBAAIE,QAAQoD,KAAKiC,eAAerC,EAA5B,GAAiC;AACjClD,sBAAQmF,WAAU;AAClB,qBAAOnF;YACV;AAODG,oBAAQyF,OAAO3C,WAAWC,EAAD,CAAzB;AACAlD,oBAAQyF,aAAY;AACpB,mBAAOzF;;MAEd;AAED,eAAS6F,QAAQC,QAAQC,MAAM;AAC3B5F,gBAAQyF,OAAO5F,UAAU8F,QAAQC,QAAQ,4BAAzC;AACAJ,aAAI;MACP;AAED,eAASK,OAAOF,QAAQG,SAAS;AAC7B,YAAIjG,UAAU8F,QAAQ;AAClB3F,kBAAQ+E,WAAWe,WAAW,kBAA9B;QACH;AACDN,aAAI;MACP;AAWD,eAASO,iBAAiB;AACtB,YAAIC,UAAUC,aAAatG,QAAQ;AACnC+F,gBAAQlG,MAAMqC,QAAQ,+BAAf;AACPmE,mBAAW,CAAA;AACX,YAAInG,UAAUL,MAAMsC,QAAQ;AACxB,iBAAO,MAAM;AACTkE,qBAASE,KAAKC,oBAAmB,CAAjC;AACA,gBAAItG,UAAUL,MAAMsC,QAAQ;AACxB;YACH;AACD+D,mBAAOrG,MAAM8C,IAAP;UACT;QACJ;AACDoD,gBAAQlG,MAAMsC,QAAQ,6BAAf;AACP,eAAOgC,cAAc;UACjBsC,MAAM7G,OAAOkB;UACbuF;QAFiB,GAGlB,CAACC,YAAYrG,QAAb,CAHiB;MAIvB;AASD,eAASyG,iBAAiB;AACtB,YAAIL,UAAUC,aAAatG,QAAQ,GAAG2G;AACtCZ,gBAAQlG,MAAMyC,QAAQ,+BAAf;AACP+D,mBAAW,CAAA;AACX,eAAOnG,UAAUL,MAAM0C,QAAQ;AAC3B,cAAIrC,UAAUL,MAAMkC,MAAM;AACtB4E,6BAAiB3G,QAAQ;AACzB+F,oBAAQlG,MAAMkC,IAAP;AACPsE,qBAASE,KAAKpC,cAAc;cACxBsC,MAAM7G,OAAOwB;cACbwF,YAAYJ,oBAAmB;YAFP,GAGzB,CAACG,gBAAgB1G,QAAjB,CAHwB,CAA3B;AAIA;UACH,OAAM;AACHoG,qBAASE,KAAKC,oBAAmB,CAAjC;UACH;AACD,cAAItG,UAAUL,MAAM0C,QAAQ;AACxB2D,mBAAOrG,MAAM2C,KAAP;UACT;QACJ;AACD0D,eAAOrG,MAAM0C,MAAP;AACN,eAAO4B,cAAc;UACjBsC,MAAM7G,OAAOmB;UACbsF;QAFiB,GAGlB,CAACC,YAAYrG,QAAb,CAHiB;MAIvB;AAED,eAAS4G,iBAAiB;AACtB,YAAIC,IAAI3G;AACR,YAAID,UAAUL,MAAMkD,QAAQ7C,UAAUL,MAAMmD,QAAQ;AAChD6C,eAAI;AACJ,iBAAOiB;QACV;AAED,YAAI5G,UAAUL,MAAMoD,QAAQ;AACxB8C,kBAAQlG,MAAMoD,MAAP;AACP,iBAAOK,OAAOwD,CAAD;QAChB;AAEDzG,gBAAQ+E,WAAW,kBAAnB;MACH;AAWD,eAAS2B,iBAAiB;AACtB,YAAIC,KAAKC,aAAahH;AAEtB+G,cAAMH,eAAc;AACpB,YAAI3G,UAAUL,MAAM4C,OAAO;AACvBsD,kBAAQlG,MAAM4C,KAAP;AACP,iBAAO0B,cAAc;YACjBsC,MAAM7G,OAAOqB;YACb+F;YACA7G,OAAOqG,oBAAmB;UAHT,GAIlB,CAACS,YAAYhH,QAAb,CAJiB;QAKvB;AACD,eAAOkE,cAAc;UACjBsC,MAAM7G,OAAOqB;UACb+F;UACA7G,OAAO;QAHU,GAIlB,CAAC8G,YAAYhH,QAAb,CAJiB;MAKvB;AAQD,eAASiH,kBAAkB;AACvB,YAAIC,QAAQF,aAAajH,QAAQ,GAAGoH;AAEpCrB,gBAAQlG,MAAMuC,QAAQ,gCAAf;AACP+E,iBAAS,CAAA;AACT,YAAIjH,UAAUL,MAAM2C,OAAO;AACvBuD,kBAAQlG,MAAM2C,KAAP;QACV,OAAM;AACH,iBAAOtC,UAAUL,MAAMwC,QAAQ;AAC3B8E,mBAAOZ,KAAKQ,eAAc,CAA1B;AACA,gBAAI7G,UAAUL,MAAMwC,QAAQ;AACxB6D,qBAAOrG,MAAM2C,KAAP;YACT;UACJ;QACJ;AACD4E,mBAAWpH;AACXkG,eAAOrG,MAAMwC,MAAP;AACN,eAAO8B,cAAc;UACjBsC,MAAM7G,OAAOoB;UACbmG;QAFiB,GAGlB,CAACF,YAAYG,QAAb,CAHiB;MAIvB;AASD,eAASC,sBAAsB;AAC3B,YAAIC,OAAOnH,OAAO8G,aAAajH,QAAQsH,KAAKvH;AAC5CmG,eAAOrG,MAAMkD,IAAP;AAEN,YAAI7C,UAAUL,MAAM4C,UACZ6E,SAAS,YACTA,SAAS,cACTA,SAAS,UAAU;AACvBvB,kBAAQlG,MAAM4C,KAAP;AACP6E,kBAAQ,MAAMnH;AACd+F,iBAAOrG,MAAMkD,IAAP;QACT;AAED,eAAOoB,cAAc;UACjBsC,MAAM7G,OAAO4B;UACb8F;QAFiB,GAGlB,CAACL,YAAYhH,QAAb,CAHiB;MAIvB;AAKD,eAASsH,0BAA0B;AAC/B,YAAIlB,WAAW,CAAA;AAEfA,iBAASE,KAAKiB,SAAQ,CAAtB;AACA,eAAOtH,UAAUL,MAAM2C,OAAO;AAC1BuD,kBAAQlG,MAAM2C,KAAP;AACP6D,mBAASE,KAAKiB,SAAQ,CAAtB;QACH;AACD,eAAOnB;MACV;AASD,eAASoB,gBAAgB;AACrB,YAAIC,MAAMC,cAAcrB,aAAatG,QAAQG,MAAMJ;AAEnD2H,eAAOL,oBAAmB;AAC1B,YAAInH,UAAUL,MAAMiC,UAAU5B,UAAUL,MAAMmC,IAAI;AAC9C6D,eAAI;AACJ8B,yBAAeJ,wBAAuB;AACtCrB,iBAAOrG,MAAMoC,EAAP;AACN,iBAAOkC,cAAc;YACjBsC,MAAM7G,OAAO6B;YACbmF,YAAYc;YACZC;UAHiB,GAIlB,CAACrB,YAAYrG,QAAb,CAJiB;QAKvB;AACD,eAAOyH;MACV;AASD,eAASE,kBAAkB;AACvB7B,gBAAQlG,MAAM4C,OAAO,gCAAd;AACP,YAAIvC,UAAUL,MAAMkD,QAAQ5C,UAAU,QAAQ;AAC1C4F,kBAAQlG,MAAMkD,IAAP;AACP,iBAAO;YACH0D,MAAM7G,OAAOiB;UADV;QAGV;AACD,eAAO2F,oBAAmB;MAC7B;AAyBD,eAASqB,sBAAsB;AAC3B,YAAIC,SAAS,CAAA,GAAIC,mBAAmB,OAAOL,MAAMM,OAAO,OAAO1B,YAAYK,iBAAiB3G,QAAQ,GAAGiI;AAEvG,eAAO/H,UAAUL,MAAMsC,QAAQ;AAC3B,cAAIjC,UAAUL,MAAMkC,MAAM;AAEtBgE,oBAAQlG,MAAMkC,IAAP;AACPiG,mBAAO;UACV;AAED1B,uBAAarG;AAEbyH,iBAAOlB,oBAAmB;AAC1B,cAAIkB,KAAKjB,SAAS7G,OAAO4B,kBAAkBtB,UAAUL,MAAM4C,OAAO;AAC9DwF,6BAAiBhI,WAAWyH,KAAKJ,KAAKvH;AAEtCgG,oBAAQlG,MAAM4C,KAAP;AACPiF,mBAAOvD,cAAc;cACjBsC,MAAM7G,OAAOuB;cACbmG,MAAMI,KAAKJ;cACXV,YAAYJ,oBAAmB;YAHd,GAIlB,CAACyB,gBAAgBhI,QAAjB,CAJiB;UAKvB;AACD,cAAIC,UAAUL,MAAMiD,OAAO;AACvBiD,oBAAQlG,MAAMiD,KAAP;AACP4E,mBAAOvD,cAAc;cACjBsC,MAAM7G,OAAO0B;cACbsF,YAAYc;YAFK,GAGlB,CAACpB,YAAYrG,QAAb,CAHiB;AAIpB8H,+BAAmB;UACtB,OAAM;AACH,gBAAIA,kBAAkB;AAClB1H,sBAAQ+E,WAAW,kBAAnB;YACH;UACJ;AACD,cAAI4C,MAAM;AACNN,mBAAOvD,cAAc;cACjBsC,MAAM7G,OAAOwB;cACbwF,YAAYc;YAFK,GAGlB,CAACf,gBAAgB1G,QAAjB,CAHiB;UAIvB;AACD6H,iBAAOvB,KAAKmB,IAAZ;AACA,cAAIxH,UAAUL,MAAMsC,QAAQ;AACxB+D,mBAAOrG,MAAM2C,KAAP;UACT;QACJ;AACD,eAAOsF;MACV;AASD,eAASI,oBAAoB;AACzB,YAAIC,OAAOC,aAAaN,QAAQO,QAAQC,QAAQhC,aAAatG,QAAQG,MAAMJ;AAC3EM,gBAAQyF,OAAO5F,UAAUL,MAAMkD,QAAQ5C,UAAU,YAAY,2CAA7D;AACA4F,gBAAQlG,MAAMkD,IAAP;AAIPmD,eAAOrG,MAAMqC,MAAP;AAENiG,gBAAQ;AACRL,iBAAS,CAAA;AACTM,sBAAc;AACd,YAAIlI,UAAUL,MAAMsC,QAAQ;AAExB,cAAIjC,UAAUL,MAAMkD,SACX5C,UAAU,UAAUA,UAAU,QAAQ;AAG3CgI,oBAAQhI,UAAU;AAClB4F,oBAAQlG,MAAMkD,IAAP;AACPmD,mBAAOrG,MAAM4C,KAAP;AACN2F,0BAAcX,cAAa;AAC3B,gBAAIvH,UAAUL,MAAM2C,OAAO;AACvBuD,sBAAQlG,MAAM2C,KAAP;AACPsF,uBAASD,oBAAmB;YAC/B;UACJ,OAAM;AACHC,qBAASD,oBAAmB;UAC/B;QACJ;AAED3B,eAAOrG,MAAMsC,MAAP;AAENkG,iBAAS;AACT,YAAInI,UAAUL,MAAM4C,OAAO;AACvB4F,mBAAST,gBAAe;QAC3B;AAEDU,iBAASnE,cAAc;UACnBsC,MAAM7G,OAAOsB;UACb4G;UACAO;QAHmB,GAIpB,CAAC/B,YAAYrG,QAAb,CAJmB;AAKtB,YAAImI,aAAa;AAEbE,iBAAO,UAAUF;AACjB,cAAID,OAAO;AACPG,mBAAO,SAAS;UACnB;QACJ;AACD,eAAOA;MACV;AAWD,eAASC,2BAA2B;AAChC,YAAIC,SAASlC;AACb,gBAAQpG;eACHL,MAAM6C;AACPqD,oBAAQlG,MAAM6C,IAAP;AACP,mBAAOyB,cAAc;cACjBsC,MAAM7G,OAAOc;YADI,GAElB,CAACT,WAAW,GAAGA,QAAf,CAFiB;eAInBJ,MAAMqC;AACP,mBAAOkE,eAAc;eAEpBvG,MAAMyC;AACP,mBAAOoE,eAAc;eAEpB7G,MAAMuC;AACP,mBAAO8E,gBAAe;eAErBrH,MAAMkD;AACPuD,yBAAatG,QAAQG,MAAMJ;AAE3B,gBAAII,UAAU,QAAQ;AAClB4F,sBAAQlG,MAAMkD,IAAP;AACP,qBAAOoB,cAAc;gBACjBsC,MAAM7G,OAAOe;cADI,GAElB,CAAC2F,YAAYrG,QAAb,CAFiB;YAGvB;AAED,gBAAIE,UAAU,aAAa;AACvB4F,sBAAQlG,MAAMkD,IAAP;AACP,qBAAOoB,cAAc;gBACjBsC,MAAM7G,OAAOgB;cADI,GAElB,CAAC0F,YAAYrG,QAAb,CAFiB;YAGvB;AAED,gBAAIE,UAAU,UAAUA,UAAU,SAAS;AACvC4F,sBAAQlG,MAAMkD,IAAP;AACP,qBAAOoB,cAAc;gBACjBsC,MAAM7G,OAAOgC;gBACbzB,OAAOA,UAAU;cAFA,GAGlB,CAACmG,YAAYrG,QAAb,CAHiB;YAIvB;AAEDuI,sBAAU7E,QAAQO,KAAR;AACV,gBAAI/D,UAAU,YAAY;AACtB,kBAAI;AACA,uBAAO+H,kBAAiB;cAC3B,SAAQO,GAAP;AACED,wBAAQvE,QAAR;cACH;YACJ;AAED,mBAAOwD,cAAa;eAEnB5H,MAAMmD;AACP6C,iBAAI;AACJ,mBAAO1B,cAAc;cACjBsC,MAAM7G,OAAO8B;cACbvB;YAFiB,GAGlB,CAACF,WAAWE,MAAMJ,SAAS,GAAGE,QAA9B,CAHiB;eAKnBJ,MAAMoD;AACP4C,iBAAI;AACJ,mBAAO1B,cAAc;cACjBsC,MAAM7G,OAAO+B;cACbxB;YAFiB,GAGlB,CAACF,WAAWqD,OAAOnD,KAAD,EAAQJ,QAAQE,QAAlC,CAHiB;;AAMpBI,oBAAQ+E,WAAW,kBAAnB;;MAEP;AAUD,eAASoB,sBAAsB;AAC3B,YAAIkB,MAAMT;AAEV,YAAI/G,UAAUL,MAAM+C,UAAU;AAC1BqE,uBAAajH,QAAQ;AACrB+F,kBAAQlG,MAAM+C,QAAP;AACP,cAAI1C,UAAUL,MAAM2C,SAAStC,UAAUL,MAAMiD,SAAS5C,UAAUL,MAAMwC,UAC9DnC,UAAUL,MAAMsC,UAAUjC,UAAUL,MAAM8C,QAAQzC,UAAUL,MAAMqD,OAClEhD,UAAUL,MAAM0C,UAAUrC,UAAUL,MAAMoC,IAAI;AAClD,mBAAOkC,cAAc;cACjBsC,MAAM7G,OAAOa;YADI,GAElB,CAACwG,YAAYhH,QAAb,CAFiB;UAGvB;AACD,iBAAOkE,cAAc;YACjBsC,MAAM7G,OAAO2B;YACbqF,YAAY2B,yBAAwB;YACpC9D,QAAQ;UAHS,GAIlB,CAACwC,YAAYhH,QAAb,CAJiB;QAKvB,WAAUC,UAAUL,MAAMgD,MAAM;AAC7BoE,uBAAajH,QAAQ;AACrB+F,kBAAQlG,MAAMgD,IAAP;AACP,iBAAOsB,cAAc;YACjBsC,MAAM7G,OAAOyB;YACbuF,YAAY2B,yBAAwB;YACpC9D,QAAQ;UAHS,GAIlB,CAACwC,YAAYhH,QAAb,CAJiB;QAKvB,OAAM;AACHgH,uBAAahH;QAChB;AAEDyH,eAAOa,yBAAwB;AAC/B,YAAIrI,UAAUL,MAAMgD,MAAM;AACtBkD,kBAAQlG,MAAMgD,IAAP;AACP,iBAAOsB,cAAc;YACjBsC,MAAM7G,OAAOyB;YACbuF,YAAYc;YACZjD,QAAQ;UAHS,GAIlB,CAACwC,YAAYhH,QAAb,CAJiB;QAKvB;AAED,YAAIC,UAAUL,MAAM+C,UAAU;AAC1BmD,kBAAQlG,MAAM+C,QAAP;AACP,iBAAOuB,cAAc;YACjBsC,MAAM7G,OAAO2B;YACbqF,YAAYc;YACZjD,QAAQ;UAHS,GAIlB,CAACwC,YAAYhH,QAAb,CAJiB;QAKvB;AAED,YAAIC,UAAUL,MAAMyC,QAAQ;AACxByD,kBAAQlG,MAAMyC,MAAP;AACP4D,iBAAOrG,MAAM0C,QAAQ,+CAA+CpC,QAAQ,KAAtE;AACN,iBAAOgE,cAAc;YACjBsC,MAAM7G,OAAO6B;YACbmF,YAAYzC,cAAc;cACtBsC,MAAM7G,OAAO4B;cACb8F,MAAM;YAFgB,GAGvB,CAACL,YAAYhH,QAAb,CAHsB;YAIzB0H,cAAc,CAACD,IAAD;UANG,GAOlB,CAACT,YAAYhH,QAAb,CAPiB;QAQvB;AAED,eAAOyH;MACV;AAWD,eAASF,WAAW;AAChB,YAAIE,MAAMrB;AAEVqB,eAAOlB,oBAAmB;AAC1B,YAAItG,UAAUL,MAAM8C,MAAM;AACtB,iBAAO+E;QACV;AAEDrB,mBAAW,CAACqB,IAAD;AACX3B,gBAAQlG,MAAM8C,IAAP;AACP,eAAO,MAAM;AACT0D,mBAASE,KAAKC,oBAAmB,CAAjC;AACA,cAAItG,UAAUL,MAAM8C,MAAM;AACtB;UACH;AACDoD,kBAAQlG,MAAM8C,IAAP;QACV;AAED,eAAOwB,cAAc;UACjBsC,MAAM7G,OAAOkB;UACbuF;QAFiB,GAGlB,CAAC,GAAGrG,KAAJ,CAHiB;MAIvB;AAED,eAAS0I,oBAAoB;AACzB,YAAIhB;AAEJ,YAAIxH,UAAUL,MAAMkC,MAAM;AACtBgE,kBAAQlG,MAAMkC,IAAP;AACP,iBAAOoC,cAAc;YACjBsC,MAAM7G,OAAOwB;YACbwF,YAAYY,SAAQ;UAFH,GAGlB,CAAC,GAAGxH,KAAJ,CAHiB;QAIvB;AAED0H,eAAOF,SAAQ;AACf,YAAItH,UAAUL,MAAMiD,OAAO;AACvBiD,kBAAQlG,MAAMiD,KAAP;AACP,iBAAOqB,cAAc;YACjBsC,MAAM7G,OAAO0B;YACbsF,YAAYc;UAFK,GAGlB,CAAC,GAAG1H,KAAJ,CAHiB;QAIvB;AAED,eAAO0H;MACV;AAED,eAASiB,UAAUC,KAAKC,KAAK;AACzB,YAAInB;AAEJ5H,iBAAS8I;AACT7I,iBAASD,OAAOC;AAChBC,gBAAQ;AACRC,mBAAW;AACXM,mBAAWsI,OAAOA,IAAIxE;AACtB/D,sBAAcuI,OAAOA,IAAIvC,cAAc;AAEvCT,aAAI;AACJ6B,eAAOF,SAAQ;AAEf,YAAIqB,OAAOA,IAAIC,WAAW;AACtB,iBAAO;YACHlC,YAAYc;YACZ1H,OAAOC;UAFJ;QAIV;AAED,YAAIC,UAAUL,MAAMqD,KAAK;AACrB7C,kBAAQ+E,WAAW,kBAAnB;QACH;AAED,eAAOsC;MACV;AAED,eAASqB,eAAeH,KAAKC,KAAK;AAC9B,YAAInB;AAEJ5H,iBAAS8I;AACT7I,iBAASD,OAAOC;AAChBC,gBAAQ;AACRC,mBAAW;AACXM,mBAAWsI,OAAOA,IAAIxE;AACtB/D,sBAAcuI,OAAOA,IAAIvC,cAAc;AAEvCT,aAAI;AACJ6B,eAAOgB,kBAAiB;AAExB,YAAIG,OAAOA,IAAIC,WAAW;AACtB,iBAAO;YACHlC,YAAYc;YACZ1H,OAAOC;UAFJ;QAIV;AAED,YAAIC,UAAUL,MAAMqD,KAAK;AACrB7C,kBAAQ+E,WAAW,kBAAnB;QACH;AAED,eAAOsC;MACV;AAED,eAASsB,cAAc5E,MAAM6E,SAASC,UAAU;AAC5C,YAAIb,QAAQ3D,GAAGyE;AAEf,gBAAQ/E,KAAKqC;eACR7G,OAAOa;AACR4H,qBAAS;AACT;eAECzI,OAAOc;AACR2H,qBAAS;AACT;eAECzI,OAAOe;AACR0H,qBAAS;AACT;eAECzI,OAAOgB;AACRyH,qBAAS;AACT;eAECzI,OAAOiB;AACRwH,qBAAS;AACT;eAECzI,OAAOkB;AACR,gBAAI,CAACoI,UAAU;AACXb,uBAAS;YACZ,OAAM;AACHA,uBAAS;YACZ;AAED,iBAAK3D,IAAI,GAAGyE,KAAK/E,KAAKiC,SAAStG,QAAQ2E,IAAIyE,IAAI,EAAEzE,GAAG;AAChD2D,wBAAUW,cAAc5E,KAAKiC,SAAS3B,IAAIuE,OAAnB;AACvB,kBAAKvE,IAAI,MAAOyE,IAAI;AAChBd,0BAAUY,UAAU,MAAM;cAC7B;YACJ;AAED,gBAAI,CAACC,UAAU;AACXb,wBAAU;YACb;AACD;eAECzI,OAAOmB;AACRsH,qBAAS;AACT,iBAAK3D,IAAI,GAAGyE,KAAK/E,KAAKiC,SAAStG,QAAQ2E,IAAIyE,IAAI,EAAEzE,GAAG;AAChD2D,wBAAUW,cAAc5E,KAAKiC,SAAS3B,IAAIuE,OAAnB;AACvB,kBAAKvE,IAAI,MAAOyE,IAAI;AAChBd,0BAAUY,UAAU,MAAM;cAC7B;YACJ;AACDZ,sBAAU;AACV;eAECzI,OAAOoB;AACRqH,qBAAS;AACT,iBAAK3D,IAAI,GAAGyE,KAAK/E,KAAK+C,OAAOpH,QAAQ2E,IAAIyE,IAAI,EAAEzE,GAAG;AAC9C2D,wBAAUW,cAAc5E,KAAK+C,OAAOzC,IAAIuE,OAAjB;AACvB,kBAAKvE,IAAI,MAAOyE,IAAI;AAChBd,0BAAUY,UAAU,MAAM;cAC7B;YACJ;AACDZ,sBAAU;AACV;eAECzI,OAAOqB;AACR,gBAAImD,KAAKjE,OAAO;AACZkI,uBAASjE,KAAK4C,OAAOiC,UAAU,MAAM,QAAQD,cAAc5E,KAAKjE,OAAO8I,OAAb;YAC7D,OAAM;AACHZ,uBAASjE,KAAK4C;YACjB;AACD;eAECpH,OAAOsB;AACRmH,qBAASY,UAAU,cAAc;AAEjC,gBAAI7E,KAAK,SAAS;AACd,kBAAIA,KAAK,QAAQ;AACbiE,0BAAWY,UAAU,SAAS;cACjC,OAAM;AACHZ,0BAAWY,UAAU,UAAU;cAClC;AAEDZ,wBAAUW,cAAc5E,KAAK,SAAS6E,OAAf;AAEvB,kBAAI7E,KAAK0D,OAAO/H,WAAW,GAAG;AAC1BsI,0BAAUY,UAAU,MAAM;cAC7B;YACJ;AAED,iBAAKvE,IAAI,GAAGyE,KAAK/E,KAAK0D,OAAO/H,QAAQ2E,IAAIyE,IAAI,EAAEzE,GAAG;AAC9C2D,wBAAUW,cAAc5E,KAAK0D,OAAOpD,IAAIuE,OAAjB;AACvB,kBAAKvE,IAAI,MAAOyE,IAAI;AAChBd,0BAAUY,UAAU,MAAM;cAC7B;YACJ;AAEDZ,sBAAU;AAEV,gBAAIjE,KAAKiE,QAAQ;AACbA,yBAAWY,UAAU,MAAM,QAAQD,cAAc5E,KAAKiE,QAAQY,OAAd;YACnD;AACD;eAECrJ,OAAOuB;AACRkH,qBAASjE,KAAKkD,QAAQ2B,UAAU,MAAM,QAAQD,cAAc5E,KAAKwC,YAAYqC,OAAlB;AAC3D;eAECrJ,OAAOwB;AACRiH,qBAAS;AACT,gBAAIjE,KAAKwC,YAAY;AACjByB,wBAAUW,cAAc5E,KAAKwC,YAAYqC,OAAlB;YAC1B;AACD;eAECrJ,OAAOyB;AACR,gBAAI+C,KAAKK,QAAQ;AACb4D,uBAAS,MAAMW,cAAc5E,KAAKwC,YAAYqC,OAAlB;YAC/B,OAAM;AACHZ,uBAASW,cAAc5E,KAAKwC,YAAYqC,OAAlB,IAA6B;YACtD;AACD;eAECrJ,OAAO0B;AACR+G,qBAASW,cAAc5E,KAAKwC,YAAYqC,OAAlB,IAA6B;AACnD;eAECrJ,OAAO2B;AACR,gBAAI6C,KAAKK,QAAQ;AACb4D,uBAAS,MAAMW,cAAc5E,KAAKwC,YAAYqC,OAAlB;YAC/B,OAAM;AACHZ,uBAASW,cAAc5E,KAAKwC,YAAYqC,OAAlB,IAA6B;YACtD;AACD;eAECrJ,OAAO4B;AACR6G,qBAASjE,KAAKkD;AACd;eAEC1H,OAAO6B;AACR4G,qBAASW,cAAc5E,KAAKwC,YAAYqC,OAAlB,IAA6B;AACnD,iBAAKvE,IAAI,GAAGyE,KAAK/E,KAAKuD,aAAa5H,QAAQ2E,IAAIyE,IAAI,EAAEzE,GAAG;AACpD2D,wBAAUW,cAAc5E,KAAKuD,aAAajD,IAAIuE,OAAvB;AACvB,kBAAKvE,IAAI,MAAOyE,IAAI;AAChBd,0BAAUY,UAAU,MAAM;cAC7B;YACJ;AACDZ,sBAAU;AACV;eAECzI,OAAO8B;AACR2G,qBAAS,MAAMjE,KAAKjE,QAAQ;AAC5B;eAECP,OAAO+B;AACR0G,qBAAS/E,OAAOc,KAAKjE,KAAN;AACf;eAECP,OAAOgC;AACRyG,qBAAS/E,OAAOc,KAAKjE,KAAN;AACf;;AAGAE,oBAAQ+E,WAAW,kBAAkBhB,KAAKqC,IAA1C;;AAGJ,eAAO4B;MACV;AAED,eAASe,UAAUhF,MAAMiF,SAAS;AAC9B,YAAIA,WAAW,MAAM;AACjBA,oBAAU,CAAA;QACb;AACD,eAAOL,cAAc5E,MAAMiF,QAAQJ,SAASI,QAAQH,QAAhC;MACvB;AAEDI,cAAQX,YAAYA;AACpBW,cAAQP,iBAAiBA;AACzBO,cAAQF,YAAYA;AACpBE,cAAQ1J,SAASA;IACpB,GA9wCA;;;;;ACTD;;;AAOC,KAAA,WAAY;AACT;AAEA,UAAI2J,OACAC,SACAC,OACAC,SACAC;AAEJD,gBAAUE;AACVL,cAAQK;AACRJ,gBAAUI;AAEV,eAASC,YAAYC,QAAQC,OAAOC,MAAM;AACtC,eAAOF,OAAOG,MAAMF,OAAOC,IAApB;MACV;AAEDL,uBAAkB,WAAY;AAC1B,YAAIO,OAAOC,OAAOC,UAAUT;AAC5B,eAAO,SAASA,gBAAeU,KAAKC,MAAM;AACtC,iBAAOJ,KAAKK,KAAKF,KAAKC,IAAf;QACV;MACJ,EALiB;AAMlB,eAASE,YAAYH,KAAK;AACtB,YAAII,MAAM,CAAA,GAAIC;AACd,aAAKA,OAAOL,KAAK;AACb,cAAIA,IAAIV,eAAee,GAAnB,GAAyB;AACzBD,gBAAIC,OAAOL,IAAIK;UAClB;QACJ;AACD,eAAOD;MACV;AAED,eAASE,oBAAoBC,IAAI;AAC7B,eAAQA,MAAM,MAAmBA,MAAM,OAClCA,MAAM,MAAmBA,MAAM,MAC/BA,MAAM,MAAmBA,MAAM;MACvC;AAED,eAASC,aAAaC,OAAO;AACzB,eAAOA,UAAU,WAAWA,UAAU,cAAcA,UAAU;MACjE;AAED,eAASC,cAAcD,OAAO;AAC1B,eAAOA,UAAU,YAAYA,UAAU;MAC1C;AAED,eAASE,WAAWF,OAAO;AACvB,eAAOA,UAAU,cAAcA,UAAU;MAC5C;AAED,eAASG,wBAAwBH,OAAO;AACpC,eAAOD,aAAaC,KAAD,KAAWE,WAAWF,KAAD,KACpCA,UAAU,WAAWA,UAAU,UAAUA,UAAU,WAAWA,UAAU;MAC/E;AAED,eAASI,cAAcJ,OAAO;AAC1B,eAAOG,wBAAwBH,KAAD,KAAWA,UAAU,WAAWA,UAAU;MAC3E;AAED,eAASK,gBAAgBL,OAAO;AAC5B,eAAOE,WAAWF,KAAD,KAAWD,aAAaC,KAAD;MAC3C;AAED,eAASM,kBAAkBN,OAAO;AAC9B,eAAOE,WAAWF,KAAD,KAAWD,aAAaC,KAAD;MAC3C;AAED,eAASO,wBAAwBP,OAAO;AACpC,eAAOD,aAAaC,KAAD,KAAWC,cAAcD,KAAD,KACvCA,UAAU,YAAYA,UAAU,UAChCA,UAAU,gBAAgBA,UAAU,UACpCA,UAAU,UAAUA,UAAU,aAAaE,WAAWF,KAAD;MAC5D;AAID,eAASQ,cAAcR,OAAO;AAC1B,eAAOO,wBAAwBP,KAAD,KAAWA,UAAU,YAAYA,UAAU,WAAWA,UAAU,cAC1FA,UAAU,eAAeA,UAAU,YAAYA,UAAU,SAASA,UAAU,YAC5EA,UAAU,iBAAiBA,UAAU,WAAWA,UAAU,aAAaA,UAAU,cACjFA,UAAU,YAAYA,UAAU,aAAaA,UAAU;MAC9D;AAGD,UAAIS,aAAa;AAEjB,UAAIC,eAAe,MAAMD,aAAa,YAAYA,aAAa;AAE/D,eAASE,cAAcC,KAAK;AAMxB,eAAOA,IAEHC,QAAQ,YAAY,EAFjB,EAIHA,QAAQ,SAAS,EAJd,EAMHA,QAAQ,IAAIC,OAAOJ,cAAc,GAAzB,GAA+B,IANpC,EAQHG,QAAQ,QAAQ,EARb;MASV;AAQD,eAASE,6BAA6BC,gBAAgBC,gBAAgB;AAClE,YAAIC,iBAAiBF,eAAeH,QAAQ,YAAY,EAAnC;AACrB,YAAIM,kBAAkB;AACtB,YAAIC,UAAU,IAAIN,OAAOJ,cAAc,GAAzB;AACd,YAAIW;AAEJ,eAAQA,QAAQD,QAAQE,KAAKJ,cAAb,GAA+B;AAC3CC,6BAAmBE,MAAM,GAAGE;AAE5B,cAAIF,MAAMpC,QAAQoC,MAAM,GAAGE,SAASN,iBAAiBE,iBAAiB;AAClE,mBAAOF,iBAAiBE,kBAAkBH,eAAeO,SAASL,eAAeK;UACpF;QACJ;AAED,eAAOP,eAAeH,QAAQ,SAAS,EAAhC,EAAoCA,QAAQ,QAAQ,EAApD,EAAwDU;MAClE;AAIA,OAAA,SAAUC,UAAS;AAChB,YAAIC,OACAxC,OACAyC,YACAH,QACAvC,QACAgC,gBACAW,aACAC,QACAC;AAEJ,iBAASC,UAAU;AACf,cAAIhC,KAAKd,OAAO+C,WAAW9C,KAAlB;AACTA,mBAAS;AACT,cAAIL,QAAQoD,KAAKC,iBAAiBnC,EAA9B,KAAqC,EAAEA,OAAO,MAAoBd,OAAO+C,WAAW9C,KAAlB,MAA6B,KAAmB;AAClHyC,0BAAc;UACjB;AACD,iBAAOQ,OAAOC,aAAarC,EAApB;QACV;AAED,iBAASsC,YAAY;AACjB,cAAIpC,QAAQ;AAEZ8B,kBAAO;AAEP,iBAAO7C,QAAQsC,UAAU1B,oBAAoBb,OAAO+C,WAAW9C,KAAlB,CAAD,GAA4B;AACpEe,qBAAS8B,QAAO;UACnB;AAED,iBAAO9B;QACV;AAED,iBAASqC,cAAc;AACnB,cAAIvC,IAAIwC,SAASpD,OAAOD;AAExBqD,oBAAU;AACV,iBAAOpD,OAAOqC,QAAQ;AAClBzB,iBAAKd,OAAO+C,WAAW7C,IAAlB;AACL,gBAAIN,QAAQoD,KAAKC,iBAAiBnC,EAA9B,KAAqC,EAAEA,OAAO,MAAoBd,OAAO+C,WAAW7C,OAAO,CAAzB,MAAgC,KAAmB;AACrHoD,wBAAU;YACb,WAAUA,SAAS;AAChB,kBAAIxC,OAAO,IAAiB;AACxB;cACH;AACD,kBAAI,CAAClB,QAAQoD,KAAKO,aAAazC,EAA1B,GAA+B;AAChCwC,0BAAU;cACb;YACJ;AACDpD,oBAAQ;UACX;AACD,iBAAOA;QACV;AAMD,iBAASsD,UAAUxC,OAAOd,MAAMuD,UAAU;AACtC,cAAI3C,IAAI4C,OAAOC,MAAMC,YAAYC,SAAS;AAI1C,iBAAO5D,QAAQC,MAAM;AACjBY,iBAAKd,OAAO+C,WAAW9C,KAAlB;AACL,gBAAIL,QAAQoD,KAAKO,aAAazC,EAA1B,GAA+B;AAC/BgC,sBAAO;YACV,WAAUhC,OAAO,KAAiB;AAC/BgC,sBAAO;AACP;YACH,OAAM;AAEHe,uBAAS;AACT;YACH;UACJ;AAGD,cAAIA,QAAQ;AACR,mBAAO;UACV;AAGDH,kBAAQ;AACRC,iBAAO;AACP,iBAAO1D,QAAQC,MAAM;AACjBY,iBAAKd,OAAO+C,WAAW9C,KAAlB;AACL,gBAAIL,QAAQoD,KAAKC,iBAAiBnC,EAA9B,GAAmC;AACnCgC,sBAAO;YACV,OAAM;AACH,kBAAIhC,OAAO,KAAiB;AACxB4C,yBAAS;AACT,oBAAIA,UAAU,GAAG;AACbZ,0BAAO;AACP;gBACH;cACJ,WAAUhC,OAAO,KAAiB;AAC/B4C,yBAAS;cACZ;AACD,kBAAIC,SAAS,IAAI;AACbC,6BAAa3D;cAChB;AACD0D,sBAAQb,QAAO;YAClB;UACJ;AAED,cAAIY,UAAU,GAAG;AAEb,mBAAOhE,QAAQoE,WAAW,yBAAnB;UACV;AAED,cAAIxC,kBAAkBN,KAAD,GAAS;AAC1B,mBAAOvB,MAAMsE,eAAeJ,MAAM;cAACC,YAAYI,aAAaJ,UAAD;cAAcK,OAAOR;YAA9C,CAA3B;UACV;AAED,iBAAOhE,MAAM+D,UAAUG,MAAM;YAACC,YAAYI,aAAaJ,UAAD;YAAcK,OAAOR;UAA9C,CAAtB;QACV;AAED,iBAASS,eAAehE,MAAM;AAC1B,cAAIiE;AACJ,cAAI,CAACvE,QAAQoD,KAAKoB,qBAAqBpE,OAAO+C,WAAW9C,KAAlB,CAAlC,KAA+D,CAACD,OAAOC,OAAOoC,MAAM,OAApB,GAA8B;AAC/F,mBAAO;UACV;AACD8B,uBAAarB,QAAO;AACpB,iBAAO7C,QAAQC,QAAQN,QAAQoD,KAAKqB,oBAAoBrE,OAAO+C,WAAW9C,KAAlB,CAAjC,GAA4D;AAC/EkE,0BAAcrB,QAAO;UACxB;AACD,iBAAOqB;QACV;AAED,iBAASG,eAAepE,MAAM;AAC1B,iBAAOD,QAAQC,SAASN,QAAQoD,KAAKO,aAAavD,OAAO+C,WAAW9C,KAAlB,CAA1B,KAAuDL,QAAQoD,KAAKC,iBAAiBjD,OAAO+C,WAAW9C,KAAlB,CAA9B,IAA0D;AACrI6C,oBAAO;UACV;QACJ;AAED,iBAASyB,UAAUrE,MAAMsE,eAAeC,mBAAmB;AACvD,cAAIjE,OAAO,IACPkE,aACAC;AAGJL,yBAAepE,IAAD;AAEd,cAAID,SAASC,MAAM;AACf,mBAAO;UACV;AAED,cAAIF,OAAO+C,WAAW9C,KAAlB,MAA6B,IAAiB;AAC9C,gBAAIuE,eAAe;AACfE,4BAAc;AACdlE,qBAAOsC,QAAO;YACjB,OAAM;AACH,qBAAO;YACV;UACJ;AAEDtC,kBAAQ0D,eAAehE,IAAD;AAEtB,cAAIuE,mBAAmB;AACnB,gBAAIzE,OAAO+C,WAAW9C,KAAlB,MAA6B,OACzBO,SAAS,YACTA,SAAS,cACTA,SAAS,UAAU;AACvBA,sBAAQsC,QAAO;AACftC,sBAAQ0D,eAAehE,IAAD;YAEzB;AACD,gBAAGF,OAAO+C,WAAW9C,KAAlB,MAA6B,MAAmBD,OAAO+C,WAAW9C,QAAQ,CAA1B,MAAiC,IAAgB;AAChGO,sBAAQsC,QAAO;AACftC,sBAAQsC,QAAO;YAClB;AACD,mBAAO9C,OAAO+C,WAAW9C,KAAlB,MAA6B,MAC5BD,OAAO+C,WAAW9C,KAAlB,MAA6B,MAC7BD,OAAO+C,WAAW9C,KAAlB,MAA6B,MAC7BD,OAAO+C,WAAW9C,KAAlB,MAA6B,MAC7BD,OAAO+C,WAAW9C,KAAlB,MAA6B,KAAiB;AAClDO,sBAAQsC,QAAO;AACftC,sBAAQ0D,eAAehE,IAAD;YACzB;UACJ;AAED,cAAIwE,aAAa;AACbJ,2BAAepE,IAAD;AAEd,gBAAIF,OAAO+C,WAAW9C,KAAlB,MAA6B,IAAiB;AAE9CO,sBAAQsC,QAAO;AACfwB,6BAAepE,IAAD;AAEd,kBAAIY;AACJ,kBAAI8D,eAAe;AAGnB,qBAAO3E,QAAQC,MAAM;AACjBY,qBAAKd,OAAO+C,WAAW9C,KAAlB;AAEL,oBAAIL,QAAQoD,KAAKO,aAAazC,EAA1B,GAA+B;AAC/B,sBAAI,CAAC6D,cAAc;AACfL,mCAAepE,IAAD;AACdY,yBAAKd,OAAO+C,WAAW9C,KAAlB;kBACR;gBACJ;AAED,oBAAIa,OAAO,IAAgB;AACvB,sBAAI,CAAC6D,cAAc;AACfA,mCAAe;kBAClB,OAAM;AACH,wBAAIA,iBAAiB,KAAM;AACvBA,qCAAe;oBAClB;kBACJ;gBACJ;AAED,oBAAI7D,OAAO,IAAgB;AACvB,sBAAI,CAAC6D,cAAc;AACfA,mCAAe;kBAClB,OAAM;AACH,wBAAIA,iBAAiB,KAAK;AACtBA,qCAAe;oBAClB;kBACJ;gBACJ;AAED,oBAAI7D,OAAO,IAAgB;AACvB8D;gBACH,WAAU9D,OAAO,MACd,EAAE8D,iBAAiB,GAAG;AACtB;gBACH;AAEDpE,wBAAQsC,QAAO;cAClB;YACJ;AAEDwB,2BAAepE,IAAD;AAEd,gBAAID,SAASC,QAAQF,OAAO+C,WAAW9C,KAAlB,MAA6B,IAAiB;AAE/D,qBAAO;YACV;AAGDO,oBAAQsC,QAAO;UAClB;AAED,iBAAOtC;QACV;AAED,iBAASqE,YAAY;AACjB,iBAAO5E,QAAQsC,UAAUvC,OAAO+C,WAAW9C,KAAlB,MAA6B,IAAiB;AACnE6C,oBAAO;UACV;AACD,cAAI7C,SAASsC,QAAQ;AACjB,mBAAO;UACV;AACD7C,kBAAQoF;YAAO9E,OAAO+C,WAAW9C,KAAlB,MAA6B;UAA5C;AACA,iBAAO;QACV;AAED,iBAAS+D,aAAae,YAAY;AAC9B,cAAI/E,WAAWgC,gBAAgB;AAC3B,mBAAO+C;UACV;AACD,iBAAOhD,6BAA6BC,gBAAgB+C,UAAjB;QACtC;AAED,iBAASC,UAAUC,SAASjE,OAAO;AAC/B,eAAKkE,WAAWD;AAChB,eAAKE,SAASnE,MAAMoE,YAAN;AACd,eAAKC,OAAO;YACRrE;YACAsE,aAAa;UAFL;AAIZ,cAAI,KAAKJ,SAASK,aAAa;AAC3B,iBAAKF,KAAK3C,aAAaA;UAC1B;AACD,eAAK8C,SAASvF,QAAQe,MAAMuB,SAAS;AACrC,eAAKkD,QAAQ;AAEb,eAAKC,SAAS,CAAA;QACjB;AAGDV,kBAAU1E,UAAUqF,WAAW,SAASA,SAASC,WAAW;AACxD,cAAIC,OAAOC,MAAMxF,UAAUH,MAAMM,KAAKsF,WAAW,CAAtC,GACPC,MAAMJ,UAAU/D,QACZ,UACA,SAAUoE,OAAOhG,QAAO;AACpBP,oBAAQoF,OAAO7E,SAAQ4F,KAAKtD,QAAQ,oCAApC;AACA,mBAAOsD,KAAK5F;UACf,CALC;AAQV,cAAI,CAAC,KAAKoF,KAAKa,QAAQ;AACnB,iBAAKb,KAAKa,SAAS,CAAA;UACtB;AACD,cAAIrD,QAAQ;AACRnD,oBAAQoE,WAAWkC,GAAnB;UACH;AACD,eAAKX,KAAKa,OAAOC,KAAKH,GAAtB;AACA,iBAAOrD;QACV;AAEDqC,kBAAU1E,UAAUkD,YAAY,WAAY;AAExC,cAAIjC,wBAAwB,KAAK4D,MAAN,GAAe;AACtC,gBAAI;AACA,mBAAKE,KAAK1B,OAAOH,UAAU,KAAK2B,QAAQ,KAAKM,OAAO,KAAKP,SAASjB,KAAxC;AAC1B,kBAAI,CAAC,KAAKoB,KAAK1B,MAAM;AACjB,oBAAI,CAAC5C,aAAa,KAAKoE,MAAN,KAAiB,CAAClE,cAAc,KAAKkE,MAAN,GAAe;AAC3D,sBAAI,CAAC,KAAKQ,SAAS,6BAAd,GAA8C;AAC/C,2BAAO;kBACV;gBACJ;cACJ;YACJ,SAAQS,OAAP;AACE,mBAAKf,KAAK1B,OAAO;AACjB,kBAAI,CAAC,KAAKgC,SAASS,MAAMC,OAApB,GAA8B;AAC/B,uBAAO;cACV;YACJ;UACJ,WAAU7E,cAAc,KAAK2D,MAAN,GAAe;AAEnC,gBAAI;AACA,mBAAKE,KAAK1B,OAAOH,UAAU,KAAK2B,QAAQ,KAAKM,OAAO,KAAKP,SAASjB,KAAxC;YAC7B,SAAQqC,GAAP;YAED;UACJ;AACD,iBAAO;QACV;AAEDtB,kBAAU1E,UAAUiG,iBAAiB,SAAUC,UAAU;AACrD,cAAIhG;AACJA,iBAAO+D,UAAU,KAAKkB,OAAO7C,UAAUtB,kBAAkB,KAAK6D,MAAN,GAAe,IAAvD;AAChB,cAAI,CAAC3E,MAAM;AACP,gBAAI,CAACgG,UAAU;AACX,kBAAI,CAAC,KAAKb,SAAS,6BAAd,GAA8C;AAC/C,uBAAO;cACV;YACJ;UACJ;AACD,eAAKN,KAAK7E,OAAOA;AACjB,iBAAO;QACV;AAEDwE,kBAAU1E,UAAUmG,gBAAgB,WAAY;AAC5C,iBAAO,KAAKF,eAAe,KAApB;QACV;AAEDvB,kBAAU1E,UAAUoG,wBAAwB,WAAY;AACpD,iBAAO,KAAKH,eAAe,IAApB;QACV;AAGDvB,kBAAU1E,UAAUiE,YAAY,WAAY;AACxC,cAAIoC,QAAQnG;AAGZ,cAAIY,cAAc,KAAK+D,MAAN,GAAe;AAC5B,iBAAKE,KAAK7E,OAAO+D,UAAU,KAAKkB,OAAO7C,UAAUtB,kBAAkB,KAAK6D,MAAN,GAAe9D,gBAAgB,KAAK8D,MAAN,CAAtE;AAC1B,gBAAI,CAAC,KAAKE,KAAK7E,MAAM;AACjB,kBAAI,CAACW,wBAAwB,KAAKgE,MAAN,GAAe;AACvC,uBAAO;cACV;AAKD,kBAAIpE,aAAa,KAAKoE,MAAN,KAAiB,KAAKE,KAAK1B,QAAQ,KAAK0B,KAAK1B,KAAKnD,MAAM;AACpE,qBAAKkF,OAAOlF,OAAO,KAAK6E,KAAK1B;AAC7B,qBAAK0B,KAAK7E,OAAO,KAAK6E,KAAK1B,KAAKnD;AAChC,qBAAK6E,KAAK1B,OAAO;cACpB,OAAM;AACH,oBAAI,CAAC,KAAKgC,SAAS,6BAAd,GAA8C;AAC/C,yBAAO;gBACV;cACJ;YACJ,OAAM;AACHnF,qBAAO,KAAK6E,KAAK7E;AACjB,kBAAIA,KAAKoG,OAAO,CAAZ,MAAmB,OAAOpG,KAAKoG,OAAOpG,KAAK+B,SAAS,CAA1B,MAAiC,KAAK;AAGhEoE,yBAASnG,KAAKqG,UAAU,GAAGrG,KAAK+B,SAAS,CAAhC,EAAmCuE,MAAM,GAAzC;AACT,oBAAIH,OAAOpE,SAAS,GAAG;AACnB,uBAAK8C,KAAK,aAAasB,OAAOxG,MAAM,CAAb,EAAgB4G,KAAK,GAArB;gBAC1B;AACD,qBAAK1B,KAAK7E,OAAOmG,OAAO;AAGxB,oBAAI,KAAKtB,KAAK1B,QAAQ,KAAK0B,KAAK1B,KAAKA,SAAS,gBAAgB;AAC1D,uBAAK0B,KAAK1B,OAAO;oBACbA,MAAM;oBACNqD,YAAY,KAAK3B,KAAK1B;kBAFT;gBAIpB;cACJ;YACJ;UACJ;AAGD,iBAAO;QACV;AAEDqB,kBAAU1E,UAAU2G,mBAAmB,SAASA,mBAAmB;AAC/D,cAAI3B,cAAcvF,YAAYC,QAAQC,OAAO,KAAKwF,KAArB,EAA4ByB,KAAvC;AAClB,cAAI5B,aAAa;AACb,gBAAK,QAAS6B,KAAK7B,WAAf,GAA6B;AAC7BA,4BAAcA,YAAYuB,UAAU,CAAtB;YACjB;AACD,iBAAKxB,KAAKC,cAAcA;UAC3B;AACD,iBAAO;QACV;AAEDN,kBAAU1E,UAAU8G,eAAe,SAASH,mBAAmB;AAC3D,cAAI3B,cAAcvF,YAAYC,QAAQC,OAAO,KAAKwF,KAArB,EAA4ByB,KAAvC;AAClB,cAAIG,kBAAkB;AACtB,cAAIC,gBAAgB;AACpB,cAAIC,eAAejC,YAAYkC,QAAQH,eAApB;AACnB,cAAII,aAAanC,YAAYkC,QAAQF,aAApB;AACjB,cAAIC,gBAAgB,KAAKE,cAAc,GAAG;AACtC,iBAAKpC,KAAKqC,UAAUpC,YAAYuB,UAC5BU,eAAeF,gBAAgB9E,QAAQkF,UADvB,EACmCP,KADnC;AAEpB,iBAAK7B,KAAKC,cAAcA,YAAYuB,UAAUY,aAAaH,cAAc/E,MAAjD,EAAyD2E,KAAzD;UAC3B,OAAM;AACH,iBAAK7B,KAAKC,cAAcA;UAC3B;AACD,iBAAO;QACV;AAEDN,kBAAU1E,UAAUqH,YAAY,SAASA,YAAY;AACjD,cAAIC,MAAMC;AACVA,kBAAQ;YACJ,SAAS;YACT,YAAY;YACZ,SAAS;YACT,YAAY;YACZ,QAAQ;YACR,YAAY;YACZ,UAAU;YACV,SAAS;YACT,UAAU;YACV,aAAa;YACb,WAAW;UAXP;AAaRD,iBAAO7H,YAAYC,QAAQC,OAAO,KAAKwF,KAArB,EAA4ByB,KAAvC;AACP,eAAK7B,KAAKuC,OAAOA;AACjB,cAAI,CAAC/H,eAAegI,OAAOD,IAAR,GAAe;AAC9B,gBAAI,CAAC,KAAKjC,SAAS,0BAA4BiC,IAA1C,GAAiD;AAClD,qBAAO;YACV;UACJ;AACD,iBAAO;QACV;AAED5C,kBAAU1E,UAAUwH,cAAc,SAASA,cAAc;AACrD,cAAIC;AACJA,mBAAShI,YAAYC,QAAQC,OAAO,KAAKwF,KAArB,EAA4ByB,KAAvC;AACT,eAAK7B,KAAK0C,SAASA;AACnB,cAAIA,WAAW,aAAaA,WAAW,eAAeA,WAAW,UAAU;AACvE,gBAAI,CAAC,KAAKpC,SAAS,4BAA8BoC,MAA5C,GAAqD;AACtD,qBAAO;YACV;UACJ;AACD,iBAAO;QACV;AAED/C,kBAAU1E,UAAU0H,YAAY,SAASA,YAAY;AAGjD,cAAIC,QAAQlI,YAAYC,QAAQC,OAAO,KAAKwF,KAArB,EAA4ByB,KAAvC;AACZ,cAAIe,SAASA,MAAMrB,OAAO,CAAb,MAAoB,KAAK;AAClC,gBAAIsB,UAAU,KAAK1E,UAAL;AACd,gBAAI0E,WAAW,KAAK7C,KAAK1B,KAAKA,SAAS,oBAAoB,KAAK0B,KAAK1B,KAAKA,SAAS,aAAa;AAC5F,mBAAK0B,KAAK7E,OAAO,KAAK6E,KAAK1B,KAAKnD;AAChC,qBAAO;YACV,OAAM;AACH,qBAAO,KAAKmF,SAAS,uBAAd;YACV;UACJ,OAAM;AACH,mBAAO,KAAKc,cAAL;UACV;QACJ;AAEDzB,kBAAU1E,UAAU6H,iBAAiB,SAASA,iBAAiB;AAC3D,cAAIC,WAAWC;AACfA,iBAAOtI,YAAYC,QAAQC,OAAO,KAAKwF,KAArB,EAA4ByB,KAAvC;AACPkB,sBAAYE,WAAWD,MAAM,EAAP;AACtB,eAAKhD,KAAK+C,YAAYA;AACtB,cAAIG,MAAMH,SAAD,GAAa;AAClB,gBAAI,CAAC,KAAKzC,SAAS,0BAA4B0C,IAA1C,GAAiD;AAClD,qBAAO;YACV;UACJ;AACD,iBAAO;QACV;AAEDrD,kBAAU1E,UAAUkI,YAAY,WAAY;AACxC,cAAIC,gBAAgB1I,YAAYC,QAAQC,OAAO,KAAKwF,KAArB,EAA4ByB,KAAvC;AACpB,cAAIuB,eAAe;AACf,gBAAI,CAAC,KAAK9C,SAAS,wBAA0B8C,aAAxC,GAAwD;AACzD,qBAAO;YACV;UACJ;AACD,iBAAO;QACV;AAEDzD,kBAAU1E,UAAUoI,WAAW,SAASA,WAAW;AAC/C,cAAIpD;AAEJA,wBAAc,KAAKD,KAAKC;AAExB,cAAIhE,kBAAkB,KAAK6D,MAAN,KAAiB,CAAC,KAAKE,KAAK1B,QAAQ2B,eAAeA,YAAYsB,OAAO,CAAnB,MAA0B,KAAK;AACnG,iBAAKvB,KAAK1B,OAAO,KAAK+B,OAAOlF;AAC7B,gBAAI,CAAC,KAAK6E,KAAK7E,MAAM;AACjB,mBAAK6E,KAAK7E,OAAOmI;YACpB;AAED,gBAAI,CAAC/F,QAAQ;AACT,kBAAI,CAAC,KAAK+C,SAAS,6BAAd,GAA8C;AAC/C,uBAAO;cACV;YACJ;UACJ;AAED,iBAAO;QACV;AAEDlD,gBAAQ;UAEJ,UAAU,CAAC,aAAD;UAEV,SAAS,CAAC,iBAAiB,WAAlB;UAET,YAAY,CAAC,aAAa,yBAAyB,WAAvC;UAEZ,eAAe,CAAC,aAAa,yBAAyB,WAAvC;UAEf,SAAS,CAAC,aAAa,yBAAyB,WAAvC;UAET,WAAW,CAAC,aAAa,yBAAyB,WAAvC;UAEX,WAAW,CAAC,cAAD;UAEX,cAAc,CAAC,kBAAD;UAEd,UAAU,CAAC,WAAD;UAEV,SAAS,CAAC,WAAD;UAET,YAAY,CAAC,WAAD;UAEZ,QAAQ,CAAC,WAAD;UAER,SAAS,CAAC,iBAAiB,WAAlB;UAET,SAAS,CAAC,yBAAyB,WAA1B;UAET,UAAU,CAAC,aAAa,yBAAyB,WAAvC;UAEV,UAAU,CAAC,yBAAyB,WAA1B;UAEV,UAAU,CAAC,aAAa,yBAAyB,WAAvC;UAEV,QAAQ,CAAC,yBAAyB,WAA1B;UAER,YAAY,CAAC,yBAAyB,WAA1B;UAEZ,OAAO,CAAC,aAAa,yBAAyB,WAAvC;UAEP,QAAQ,CAAC,iBAAiB,WAAlB;UAER,aAAa,CAAC,aAAa,yBAAyB,WAAvC;UAEb,WAAW,CAAC,aAAa,kBAAd;UAEX,aAAa,CAAC,aAAa,kBAAd;UAEb,UAAU,CAAC,aAAa,kBAAd;UAEV,YAAY,CAAC,WAAD;UAEZ,YAAY,CAAC,iBAAiB,WAAlB;UAEZ,SAAS,CAAC,kBAAD;UAET,UAAU,CAAC,WAAD;UAEV,WAAW,CAAC,kBAAD;UAEX,QAAQ,CAAC,aAAa,WAAd;UAER,QAAQ,CAAC,kBAAD;UAER,WAAW,CAAC,aAAa,uBAAd;UAEX,aAAa,CAAC,gBAAD;UAEb,WAAW,CAAC,kBAAD;QAtEP;AAyERuC,kBAAU1E,UAAUsI,QAAQ,SAASA,SAAQ;AACzC,cAAIC,GAAGC,IAAIC,WAAWC;AAItB,cAAI,CAAC,KAAK7D,QAAQ;AACd,gBAAI,CAAC,KAAKQ,SAAS,0BAAd,GAA2C;AAC5C,qBAAO;YACV;UACJ;AAGD,eAAKF,QAAQpC,YAAY,KAAK8B,MAAN;AAExB,cAAI,KAAKD,SAASjB,OAAO;AACrB,iBAAKoB,KAAKpB,QAAQ,CAAC,KAAKuB,QAAQxF,OAAOG,MAAM,GAAG,KAAKsF,KAArB,EAA4B5D,QAAQ,QAAQ,EAA5C,EAAgDU,MAA9D,EAAsE0G,IAAIjF,YAA1E;UACrB;AAED,cAAInE,eAAe4C,OAAO,KAAK0C,MAAb,GAAsB;AACpC4D,wBAAYtG,MAAM,KAAK0C;UAC1B,OAAM;AAEH4D,wBAAY,CAAC,aAAa,aAAa,oBAAoB,UAA/C;UACf;AAED,eAAKF,IAAI,GAAGC,KAAKC,UAAUxG,QAAQsG,IAAIC,IAAI,EAAED,GAAG;AAC5CG,qBAASD,UAAUF;AACnB,gBAAI,CAAC,KAAKG,QAAL,GAAgB;AACjB,qBAAO;YACV;UACJ;AAED,iBAAO,KAAK3D;QACf;AAED,iBAAS6D,SAASjE,SAAS;AACvB,cAAIjE,OAAOmI,QAAQC;AAGnB,cAAI,CAACvE,UAAS,GAAI;AACd,mBAAO;UACV;AAGD7D,kBAAQoC,UAAS;AAGjB+F,mBAAS,IAAInE,UAAUC,SAASjE,KAAvB;AACToI,gBAAMD,OAAOP,MAAP;AAGN,iBAAO3I,QAAQkJ,OAAO1D,OAAO;AACzB3C,oBAAO;UACV;AAED,iBAAOsG;QACV;AAMD,iBAASC,qBAAqBC,oBAAoB;AAC9C,cAAIhE,cAAc,IAAIxE,IAAIyI;AAE1BA,sBAAY;AACZ,iBAAOtJ,QAAQsC,QAAQ;AACnBzB,iBAAKd,OAAO+C,WAAW9C,KAAlB;AAEL,gBAAIsJ,aAAazI,OAAO,IAAiB;AACrC;YACH;AAED,gBAAIlB,QAAQoD,KAAKC,iBAAiBnC,EAA9B,GAAmC;AACnCyI,0BAAY;YACf,WAAUA,aAAa,CAAC3J,QAAQoD,KAAKO,aAAazC,EAA1B,GAA+B;AACpDyI,0BAAY;YACf;AAEDjE,2BAAexC,QAAO;UACzB;AAED,iBAAOwG,qBAAqBhE,cAAcA,YAAY4B,KAAZ;QAC7C;AAED,iBAAS0B,MAAMY,SAASvE,SAAS;AAC7B,cAAIwE,OAAO,CAAA,GAAIL,KAAK9D,aAAaoE,iBAAiBb,GAAGC;AAErD,cAAI7D,YAAY0D,QAAW;AACvB1D,sBAAU,CAAA;UACb;AAED,cAAI,OAAOA,QAAQ0E,WAAW,aAAa1E,QAAQ0E,QAAQ;AACvD3J,qBAAS2B,cAAc6H,OAAD;UACzB,OAAM;AACHxJ,qBAASwJ;UACZ;AAEDxH,2BAAiBwH;AAGjB,cAAIvE,QAAQwE,MAAM;AACd,gBAAI3D,MAAM8D,QAAQ3E,QAAQwE,IAAtB,GAA6B;AAC7BC,gCAAkB,CAAA;AAClB,mBAAKb,IAAI,GAAGC,KAAK7D,QAAQwE,KAAKlH,QAAQsG,IAAIC,IAAID,KAAK;AAC/C,oBAAI,OAAO5D,QAAQwE,KAAKZ,OAAO,UAAU;AACrCa,kCAAgBzE,QAAQwE,KAAKZ,MAAM;gBACtC,OAAM;AACHnJ,0BAAQoE,WAAW,+BAA+BmB,QAAQwE,IAA1D;gBACH;cACJ;YACJ,OAAM;AACH/J,sBAAQoE,WAAW,+BAA+BmB,QAAQwE,IAA1D;YACH;UACJ;AAEDlH,mBAASvC,OAAOuC;AAChBtC,kBAAQ;AACRyC,uBAAa;AACbC,wBAAcsC,QAAQtC;AACtBC,mBAASqC,QAAQrC;AACjBC,mBAASoC,QAAQpC;AAEjByC,wBAAc+D,qBAAqBpE,QAAQqE,kBAAT;AAElC,iBAAO,MAAM;AACTF,kBAAMF,SAASjE,OAAD;AACd,gBAAI,CAACmE,KAAK;AACN;YACH;AACD,gBAAI,CAACM,mBAAmBA,gBAAgB7J,eAAeuJ,IAAIpI,KAAnC,GAA2C;AAC/DyI,mBAAKtD,KAAKiD,GAAV;YACH;UACJ;AAED,iBAAO;YACH9D;YACAmE;UAFG;QAIV;AACDjH,QAAAA,SAAQoG,QAAQA;MACnB,GAACjJ,QAAQ,CAAA,CAvuBT;AAyuBD6C,cAAQqH,UAAUnK,QAAQoK;AAC1BtH,cAAQoG,QAAQjJ,MAAMiJ;AACtBpG,cAAQgB,YAAY/D,MAAM+D;AAC1BhB,cAAQuB,iBAAiBtE,MAAMsE;AAC/BvB,cAAQb,gBAAgBA;AACxBa,cAAQuH,SAASrJ,YAAYjB,MAAMsK,MAAP;AAC5BvH,cAAQwH,QAAQtK,QAAQuK;AACxBzH,cAAQmB,OAAO;QACXoG,QAAQvH,QAAQuH;QAChBvG,WAAW/D,MAAM+D;QACjBO,gBAAgBtE,MAAMsE;QACtBmG,WAAWzK,MAAMyK;MAJN;IAMlB,GAz3BA;;;",
  "names": ["module", "exports", "isBuffer", "arg", "copy", "fill", "readUInt8", "Object", "create", "module", "exports", "inherits", "ctor", "superCtor", "super_", "prototype", "constructor", "value", "enumerable", "writable", "configurable", "TempCtor", "formatRegExp", "exports", "format", "f", "isString", "objects", "i", "arguments", "length", "push", "inspect", "join", "args", "len", "str", "String", "replace", "x", "Number", "JSON", "stringify", "_", "isNull", "isObject", "deprecate", "fn", "msg", "isUndefined", "global", "process", "apply", "noDeprecation", "warned", "deprecated", "throwDeprecation", "Error", "traceDeprecation", "console", "trace", "error", "debugs", "debugEnviron", "debuglog", "set", "env", "NODE_DEBUG", "toUpperCase", "RegExp", "test", "pid", "obj", "opts", "ctx", "seen", "stylize", "stylizeNoColor", "depth", "colors", "isBoolean", "showHidden", "_extend", "customInspect", "stylizeWithColor", "formatValue", "styles", "styleType", "style", "arrayToHash", "array", "hash", "forEach", "val", "idx", "value", "recurseTimes", "isFunction", "constructor", "prototype", "ret", "primitive", "formatPrimitive", "keys", "Object", "visibleKeys", "getOwnPropertyNames", "isError", "indexOf", "formatError", "name", "isRegExp", "toString", "call", "isDate", "Date", "base", "braces", "isArray", "n", "toUTCString", "output", "formatArray", "map", "key", "formatProperty", "pop", "reduceToSingleString", "simple", "isNumber", "l", "hasOwnProperty", "match", "desc", "getOwnPropertyDescriptor", "get", "split", "line", "substr", "numLinesEst", "reduce", "prev", "cur", "ar", "Array", "arg", "isNullOrUndefined", "isSymbol", "re", "objectToString", "d", "e", "isPrimitive", "isBuffer", "require", "o", "pad", "months", "timestamp", "time", "getHours", "getMinutes", "getSeconds", "getDate", "getMonth", "log", "inherits", "origin", "add", "prop", "objectAssign", "require", "compare", "a", "b", "x", "length", "y", "i", "len", "Math", "min", "isBuffer", "global", "Buffer", "_isBuffer", "util", "hasOwn", "Object", "prototype", "hasOwnProperty", "pSlice", "Array", "slice", "functionsHaveNames", "foo", "name", "pToString", "obj", "toString", "call", "isView", "arrbuf", "ArrayBuffer", "DataView", "buffer", "assert", "module", "exports", "ok", "regex", "getName", "func", "isFunction", "str", "match", "AssertionError", "options", "actual", "expected", "operator", "message", "generatedMessage", "getMessage", "stackStartFunction", "fail", "Error", "captureStackTrace", "err", "stack", "out", "fn_name", "idx", "indexOf", "next_line", "substring", "inherits", "truncate", "s", "n", "inspect", "something", "rawname", "self", "value", "equal", "notEqual", "deepEqual", "_deepEqual", "deepStrictEqual", "strict", "memos", "isDate", "getTime", "isRegExp", "source", "multiline", "lastIndex", "ignoreCase", "Float32Array", "Float64Array", "Uint8Array", "actualIndex", "push", "objEquiv", "isArguments", "object", "actualVisitedObjects", "undefined", "isPrimitive", "getPrototypeOf", "aIsArgs", "bIsArgs", "ka", "objectKeys", "kb", "key", "sort", "notDeepEqual", "notDeepStrictEqual", "strictEqual", "notStrictEqual", "expectedException", "test", "e", "isPrototypeOf", "_tryBlock", "block", "error", "_throws", "shouldThrow", "TypeError", "userProvidedMessage", "isUnwantedException", "isError", "isUnexpectedException", "throws", "doesNotThrow", "ifError", "keys", "VERSION", "require", "version", "exports", "DoctrineError", "message", "name", "prototype", "Middle", "Error", "constructor", "throwError", "assert", "Syntax", "Token", "source", "length", "index", "previous", "token", "value", "esutils", "utility", "rangeOffset", "addRange", "require", "NullableLiteral", "AllLiteral", "NullLiteral", "UndefinedLiteral", "VoidLiteral", "UnionType", "ArrayType", "RecordType", "FieldType", "FunctionType", "ParameterType", "RestType", "NonNullableType", "OptionalType", "NullableType", "NameExpression", "TypeApplication", "StringLiteralType", "NumericLiteralType", "BooleanLiteralType", "ILLEGAL", "DOT_LT", "REST", "LT", "GT", "LPAREN", "RPAREN", "LBRACE", "RBRACE", "LBRACK", "RBRACK", "COMMA", "COLON", "STAR", "PIPE", "QUESTION", "BANG", "EQUAL", "NAME", "STRING", "NUMBER", "EOF", "isTypeName", "ch", "indexOf", "String", "fromCharCode", "code", "isWhiteSpace", "isLineTerminator", "Context", "_previous", "_index", "_token", "_value", "prototype", "restore", "save", "maybeAddRange", "node", "range", "advance", "charAt", "scanHexEscape", "prefix", "i", "len", "isHexDigit", "charCodeAt", "toLowerCase", "scanString", "str", "quote", "unescaped", "isOctalDigit", "throwError", "scanNumber", "number", "isIdentifierStartES5", "parseInt", "isDecimalDigit", "parseFloat", "scanTypeName", "ch2", "next", "assert", "consume", "target", "text", "expect", "message", "parseUnionType", "elements", "startIndex", "push", "parseTypeExpression", "type", "parseArrayType", "restStartIndex", "expression", "parseFieldName", "v", "parseFieldType", "key", "rangeStart", "parseRecordType", "fields", "rangeEnd", "parseNameExpression", "name", "parseTypeExpressionList", "parseTop", "parseTypeName", "expr", "applications", "parseResultType", "parseParametersType", "params", "optionalSequence", "rest", "nameStartIndex", "parseFunctionType", "isNew", "thisBinding", "result", "fnType", "parseBasicTypeExpression", "context", "e", "parseTopParamType", "parseType", "src", "opt", "midstream", "parseParamType", "stringifyImpl", "compact", "topLevel", "iz", "stringify", "options", "exports", "typed", "utility", "jsdoc", "esutils", "hasOwnProperty", "require", "sliceSource", "source", "index", "last", "slice", "func", "Object", "prototype", "obj", "name", "call", "shallowCopy", "ret", "key", "isASCIIAlphanumeric", "ch", "isParamTitle", "title", "isReturnTitle", "isProperty", "isNameParameterRequired", "isAllowedName", "isAllowedNested", "isAllowedOptional", "isTypeParameterRequired", "isAllowedType", "WHITESPACE", "STAR_MATCHER", "unwrapComment", "doc", "replace", "RegExp", "convertUnwrappedCommentIndex", "originalSource", "unwrappedIndex", "replacedSource", "numSkippedChars", "matcher", "match", "exec", "length", "exports", "Rules", "lineNumber", "recoverable", "sloppy", "strict", "advance", "charCodeAt", "code", "isLineTerminator", "String", "fromCharCode", "scanTitle", "seekContent", "waiting", "isWhiteSpace", "parseType", "addRange", "brace", "type", "startIndex", "direct", "throwError", "parseParamType", "convertIndex", "range", "scanIdentifier", "identifier", "isIdentifierStartES5", "isIdentifierPartES5", "skipWhiteSpace", "parseName", "allowBrackets", "allowNestedParams", "useBrackets", "insideString", "bracketDepth", "skipToTag", "assert", "rangeIndex", "TagParser", "options", "_options", "_title", "toLowerCase", "_tag", "description", "lineNumbers", "_first", "_last", "_extra", "addError", "errorText", "args", "Array", "arguments", "msg", "whole", "errors", "push", "error", "message", "e", "_parseNamePath", "optional", "parseNamePath", "parseNamePathOptional", "assign", "charAt", "substring", "split", "join", "expression", "parseDescription", "trim", "test", "parseCaption", "captionStartTag", "captionEndTag", "captionStart", "indexOf", "captionEnd", "caption", "parseKind", "kind", "kinds", "parseAccess", "access", "parseThis", "value", "gotType", "parseVariation", "variation", "text", "parseFloat", "isNaN", "ensureEnd", "shouldBeEmpty", "epilogue", "undefined", "parse", "i", "iz", "sequences", "method", "map", "parseTag", "parser", "tag", "scanJSDocDescription", "preserveWhitespace", "atAllowed", "comment", "tags", "interestingTags", "unwrap", "isArray", "version", "VERSION", "Syntax", "Error", "DoctrineError", "stringify"]
}

{
  "version": 3,
  "sources": ["dep:acorn-walk", "../../../../node_modules/acorn-walk/dist/walk.mjs"],
  "sourcesContent": ["\nexport * from \"../node_modules/acorn-walk/dist/walk.mjs\"", "// AST walker module for Mozilla Parser API compatible trees\n\n// A simple walk is one where you simply specify callbacks to be\n// called on specific nodes. The last two arguments are optional. A\n// simple use would be\n//\n//     walk.simple(myTree, {\n//         Expression: function(node) { ... }\n//     });\n//\n// to do something with all expressions. All Parser API node types\n// can be used to identify node types, as well as Expression and\n// Statement, which denote categories of nodes.\n//\n// The base argument can be used to pass a custom (recursive)\n// walker, and state can be used to give this walked an initial\n// state.\n\nfunction simple(node, visitors, baseVisitor, state, override) {\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type, found = visitors[type];\n    baseVisitor[type](node, st, c);\n    if (found) { found(node, st); }\n  })(node, state, override);\n}\n\n// An ancestor walk keeps an array of ancestor nodes (including the\n// current node) and passes them to the callback as third parameter\n// (and also as state parameter when no other state is present).\nfunction ancestor(node, visitors, baseVisitor, state, override) {\n  var ancestors = [];\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type, found = visitors[type];\n    var isNew = node !== ancestors[ancestors.length - 1];\n    if (isNew) { ancestors.push(node); }\n    baseVisitor[type](node, st, c);\n    if (found) { found(node, st || ancestors, ancestors); }\n    if (isNew) { ancestors.pop(); }\n  })(node, state, override);\n}\n\n// A recursive walk is one where your functions override the default\n// walkers. They can modify and replace the state parameter that's\n// threaded through the walk, and can opt how and whether to walk\n// their child nodes (by calling their third argument on these\n// nodes).\nfunction recursive(node, state, funcs, baseVisitor, override) {\n  var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor\n  ;(function c(node, st, override) {\n    visitor[override || node.type](node, st, c);\n  })(node, state, override);\n}\n\nfunction makeTest(test) {\n  if (typeof test === \"string\")\n    { return function (type) { return type === test; } }\n  else if (!test)\n    { return function () { return true; } }\n  else\n    { return test }\n}\n\nvar Found = function Found(node, state) { this.node = node; this.state = state; };\n\n// A full walk triggers the callback on each node\nfunction full(node, callback, baseVisitor, state, override) {\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type;\n    baseVisitor[type](node, st, c);\n    if (!override) { callback(node, st, type); }\n  })(node, state, override);\n}\n\n// An fullAncestor walk is like an ancestor walk, but triggers\n// the callback on each node\nfunction fullAncestor(node, callback, baseVisitor, state) {\n  if (!baseVisitor) { baseVisitor = base; }\n  var ancestors = []\n  ;(function c(node, st, override) {\n    var type = override || node.type;\n    var isNew = node !== ancestors[ancestors.length - 1];\n    if (isNew) { ancestors.push(node); }\n    baseVisitor[type](node, st, c);\n    if (!override) { callback(node, st || ancestors, ancestors, type); }\n    if (isNew) { ancestors.pop(); }\n  })(node, state);\n}\n\n// Find a node with a given start, end, and type (all are optional,\n// null can be used as wildcard). Returns a {node, state} object, or\n// undefined when it doesn't find a matching node.\nfunction findNodeAt(node, start, end, test, baseVisitor, state) {\n  if (!baseVisitor) { baseVisitor = base; }\n  test = makeTest(test);\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n      if ((start == null || node.start <= start) &&\n          (end == null || node.end >= end))\n        { baseVisitor[type](node, st, c); }\n      if ((start == null || node.start === start) &&\n          (end == null || node.end === end) &&\n          test(type, node))\n        { throw new Found(node, st) }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the innermost node of a given type that contains the given\n// position. Interface similar to findNodeAt.\nfunction findNodeAround(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n      if (node.start > pos || node.end < pos) { return }\n      baseVisitor[type](node, st, c);\n      if (test(type, node)) { throw new Found(node, st) }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the outermost matching node after a given position.\nfunction findNodeAfter(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  try {\n    (function c(node, st, override) {\n      if (node.end < pos) { return }\n      var type = override || node.type;\n      if (node.start >= pos && test(type, node)) { throw new Found(node, st) }\n      baseVisitor[type](node, st, c);\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the outermost matching node before a given position.\nfunction findNodeBefore(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  var max\n  ;(function c(node, st, override) {\n    if (node.start > pos) { return }\n    var type = override || node.type;\n    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n      { max = new Found(node, st); }\n    baseVisitor[type](node, st, c);\n  })(node, state);\n  return max\n}\n\n// Fallback to an Object.create polyfill for older environments.\nvar create = Object.create || function(proto) {\n  function Ctor() {}\n  Ctor.prototype = proto;\n  return new Ctor\n};\n\n// Used to create a custom walker. Will fill in all missing node\n// type properties with the defaults.\nfunction make(funcs, baseVisitor) {\n  var visitor = create(baseVisitor || base);\n  for (var type in funcs) { visitor[type] = funcs[type]; }\n  return visitor\n}\n\nfunction skipThrough(node, st, c) { c(node, st); }\nfunction ignore(_node, _st, _c) {}\n\n// Node walkers.\n\nvar base = {};\n\nbase.Program = base.BlockStatement = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1)\n    {\n    var stmt = list[i];\n\n    c(stmt, st, \"Statement\");\n  }\n};\nbase.Statement = skipThrough;\nbase.EmptyStatement = ignore;\nbase.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression =\n  function (node, st, c) { return c(node.expression, st, \"Expression\"); };\nbase.IfStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Statement\");\n  if (node.alternate) { c(node.alternate, st, \"Statement\"); }\n};\nbase.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); };\nbase.BreakStatement = base.ContinueStatement = ignore;\nbase.WithStatement = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.SwitchStatement = function (node, st, c) {\n  c(node.discriminant, st, \"Expression\");\n  for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {\n    var cs = list$1[i$1];\n\n    if (cs.test) { c(cs.test, st, \"Expression\"); }\n    for (var i = 0, list = cs.consequent; i < list.length; i += 1)\n      {\n      var cons = list[i];\n\n      c(cons, st, \"Statement\");\n    }\n  }\n};\nbase.SwitchCase = function (node, st, c) {\n  if (node.test) { c(node.test, st, \"Expression\"); }\n  for (var i = 0, list = node.consequent; i < list.length; i += 1)\n    {\n    var cons = list[i];\n\n    c(cons, st, \"Statement\");\n  }\n};\nbase.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n  if (node.argument) { c(node.argument, st, \"Expression\"); }\n};\nbase.ThrowStatement = base.SpreadElement =\n  function (node, st, c) { return c(node.argument, st, \"Expression\"); };\nbase.TryStatement = function (node, st, c) {\n  c(node.block, st, \"Statement\");\n  if (node.handler) { c(node.handler, st); }\n  if (node.finalizer) { c(node.finalizer, st, \"Statement\"); }\n};\nbase.CatchClause = function (node, st, c) {\n  if (node.param) { c(node.param, st, \"Pattern\"); }\n  c(node.body, st, \"Statement\");\n};\nbase.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.ForStatement = function (node, st, c) {\n  if (node.init) { c(node.init, st, \"ForInit\"); }\n  if (node.test) { c(node.test, st, \"Expression\"); }\n  if (node.update) { c(node.update, st, \"Expression\"); }\n  c(node.body, st, \"Statement\");\n};\nbase.ForInStatement = base.ForOfStatement = function (node, st, c) {\n  c(node.left, st, \"ForInit\");\n  c(node.right, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.ForInit = function (node, st, c) {\n  if (node.type === \"VariableDeclaration\") { c(node, st); }\n  else { c(node, st, \"Expression\"); }\n};\nbase.DebuggerStatement = ignore;\n\nbase.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); };\nbase.VariableDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.declarations; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    c(decl, st);\n  }\n};\nbase.VariableDeclarator = function (node, st, c) {\n  c(node.id, st, \"Pattern\");\n  if (node.init) { c(node.init, st, \"Expression\"); }\n};\n\nbase.Function = function (node, st, c) {\n  if (node.id) { c(node.id, st, \"Pattern\"); }\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    c(param, st, \"Pattern\");\n  }\n  c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n};\n\nbase.Pattern = function (node, st, c) {\n  if (node.type === \"Identifier\")\n    { c(node, st, \"VariablePattern\"); }\n  else if (node.type === \"MemberExpression\")\n    { c(node, st, \"MemberPattern\"); }\n  else\n    { c(node, st); }\n};\nbase.VariablePattern = ignore;\nbase.MemberPattern = skipThrough;\nbase.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); };\nbase.ArrayPattern = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) { c(elt, st, \"Pattern\"); }\n  }\n};\nbase.ObjectPattern = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1) {\n    var prop = list[i];\n\n    if (prop.type === \"Property\") {\n      if (prop.computed) { c(prop.key, st, \"Expression\"); }\n      c(prop.value, st, \"Pattern\");\n    } else if (prop.type === \"RestElement\") {\n      c(prop.argument, st, \"Pattern\");\n    }\n  }\n};\n\nbase.Expression = skipThrough;\nbase.ThisExpression = base.Super = base.MetaProperty = ignore;\nbase.ArrayExpression = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) { c(elt, st, \"Expression\"); }\n  }\n};\nbase.ObjectExpression = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1)\n    {\n    var prop = list[i];\n\n    c(prop, st);\n  }\n};\nbase.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\nbase.SequenceExpression = function (node, st, c) {\n  for (var i = 0, list = node.expressions; i < list.length; i += 1)\n    {\n    var expr = list[i];\n\n    c(expr, st, \"Expression\");\n  }\n};\nbase.TemplateLiteral = function (node, st, c) {\n  for (var i = 0, list = node.quasis; i < list.length; i += 1)\n    {\n    var quasi = list[i];\n\n    c(quasi, st);\n  }\n\n  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)\n    {\n    var expr = list$1[i$1];\n\n    c(expr, st, \"Expression\");\n  }\n};\nbase.TemplateElement = ignore;\nbase.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n  c(node.argument, st, \"Expression\");\n};\nbase.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n  c(node.left, st, \"Expression\");\n  c(node.right, st, \"Expression\");\n};\nbase.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n  c(node.left, st, \"Pattern\");\n  c(node.right, st, \"Expression\");\n};\nbase.ConditionalExpression = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Expression\");\n  c(node.alternate, st, \"Expression\");\n};\nbase.NewExpression = base.CallExpression = function (node, st, c) {\n  c(node.callee, st, \"Expression\");\n  if (node.arguments)\n    { for (var i = 0, list = node.arguments; i < list.length; i += 1)\n      {\n        var arg = list[i];\n\n        c(arg, st, \"Expression\");\n      } }\n};\nbase.MemberExpression = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  if (node.computed) { c(node.property, st, \"Expression\"); }\n};\nbase.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n  if (node.declaration)\n    { c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\"); }\n  if (node.source) { c(node.source, st, \"Expression\"); }\n};\nbase.ExportAllDeclaration = function (node, st, c) {\n  if (node.exported)\n    { c(node.exported, st); }\n  c(node.source, st, \"Expression\");\n};\nbase.ImportDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.specifiers; i < list.length; i += 1)\n    {\n    var spec = list[i];\n\n    c(spec, st);\n  }\n  c(node.source, st, \"Expression\");\n};\nbase.ImportExpression = function (node, st, c) {\n  c(node.source, st, \"Expression\");\n};\nbase.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;\n\nbase.TaggedTemplateExpression = function (node, st, c) {\n  c(node.tag, st, \"Expression\");\n  c(node.quasi, st, \"Expression\");\n};\nbase.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); };\nbase.Class = function (node, st, c) {\n  if (node.id) { c(node.id, st, \"Pattern\"); }\n  if (node.superClass) { c(node.superClass, st, \"Expression\"); }\n  c(node.body, st);\n};\nbase.ClassBody = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1)\n    {\n    var elt = list[i];\n\n    c(elt, st);\n  }\n};\nbase.MethodDefinition = base.Property = function (node, st, c) {\n  if (node.computed) { c(node.key, st, \"Expression\"); }\n  c(node.value, st, \"Expression\");\n};\n\nexport { ancestor, base, findNodeAfter, findNodeAround, findNodeAt, findNodeBefore, full, fullAncestor, make, recursive, simple };\n"],
  "mappings": "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",
  "names": ["simple", "node", "visitors", "baseVisitor", "state", "override", "base", "c", "st", "type", "found", "ancestor", "ancestors", "isNew", "length", "push", "pop", "recursive", "funcs", "visitor", "make", "undefined", "makeTest", "test", "Found", "full", "callback", "fullAncestor", "findNodeAt", "start", "end", "e", "findNodeAround", "pos", "findNodeAfter", "findNodeBefore", "max", "create", "Object", "proto", "Ctor", "prototype", "skipThrough", "ignore", "_node", "_st", "_c", "Program", "BlockStatement", "i", "list", "body", "stmt", "Statement", "EmptyStatement", "ExpressionStatement", "ParenthesizedExpression", "ChainExpression", "expression", "IfStatement", "consequent", "alternate", "LabeledStatement", "BreakStatement", "ContinueStatement", "WithStatement", "object", "SwitchStatement", "discriminant", "i$1", "list$1", "cases", "cs", "cons", "SwitchCase", "ReturnStatement", "YieldExpression", "AwaitExpression", "argument", "ThrowStatement", "SpreadElement", "TryStatement", "block", "handler", "finalizer", "CatchClause", "param", "WhileStatement", "DoWhileStatement", "ForStatement", "init", "update", "ForInStatement", "ForOfStatement", "left", "right", "ForInit", "DebuggerStatement", "FunctionDeclaration", "VariableDeclaration", "declarations", "decl", "VariableDeclarator", "id", "Function", "params", "Pattern", "VariablePattern", "MemberPattern", "RestElement", "ArrayPattern", "elements", "elt", "ObjectPattern", "properties", "prop", "computed", "key", "value", "Expression", "ThisExpression", "Super", "MetaProperty", "ArrayExpression", "ObjectExpression", "FunctionExpression", "ArrowFunctionExpression", "SequenceExpression", "expressions", "expr", "TemplateLiteral", "quasis", "quasi", "TemplateElement", "UnaryExpression", "UpdateExpression", "BinaryExpression", "LogicalExpression", "AssignmentExpression", "AssignmentPattern", "ConditionalExpression", "NewExpression", "CallExpression", "callee", "arguments", "arg", "MemberExpression", "property", "ExportNamedDeclaration", "ExportDefaultDeclaration", "declaration", "source", "ExportAllDeclaration", "exported", "ImportDeclaration", "specifiers", "spec", "ImportExpression", "ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier", "Identifier", "Literal", "TaggedTemplateExpression", "tag", "ClassDeclaration", "ClassExpression", "Class", "superClass", "ClassBody", "MethodDefinition", "Property"]
}

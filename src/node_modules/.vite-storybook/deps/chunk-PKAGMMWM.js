import {
  require_is_regexp
} from "./chunk-OPAZLAKG.js";
import {
  require_regexp_get_flags
} from "./chunk-BNKHNS7O.js";
import {
  require_inherit_if_required,
  require_regexp_sticky_helpers,
  require_regexp_unsupported_dot_all,
  require_regexp_unsupported_ncg,
  require_to_string
} from "./chunk-WDY4P2NX.js";
import {
  require_create_non_enumerable_property,
  require_define_built_in,
  require_descriptors,
  require_fails,
  require_function_uncurry_this,
  require_global,
  require_has_own_property,
  require_internal_state,
  require_is_forced,
  require_object_define_property,
  require_object_get_own_property_names,
  require_object_is_prototype_of,
  require_set_species,
  require_well_known_symbol
} from "./chunk-IPK6NK5O.js";
import {
  __commonJS,
  __esm,
  init_define_ngDevMode
} from "./chunk-XN7ES5DP.js";

// node_modules/core-js/internals/proxy-accessor.js
var require_proxy_accessor = __commonJS({
  "node_modules/core-js/internals/proxy-accessor.js"(exports, module) {
    init_define_ngDevMode();
    var defineProperty = require_object_define_property().f;
    module.exports = function(Target, Source, key) {
      key in Target || defineProperty(Target, key, {
        configurable: true,
        get: function() {
          return Source[key];
        },
        set: function(it) {
          Source[key] = it;
        }
      });
    };
  }
});

// node_modules/core-js/modules/es.regexp.constructor.js
var DESCRIPTORS, global, uncurryThis, isForced, inheritIfRequired, createNonEnumerableProperty, getOwnPropertyNames, isPrototypeOf, isRegExp, toString, getRegExpFlags, stickyHelpers, proxyAccessor, defineBuiltIn, fails, hasOwn, enforceInternalState, setSpecies, wellKnownSymbol, UNSUPPORTED_DOT_ALL, UNSUPPORTED_NCG, MATCH, NativeRegExp, RegExpPrototype, SyntaxError, exec, charAt, replace, stringIndexOf, stringSlice, IS_NCG, re1, re2, CORRECT_NEW, MISSED_STICKY, UNSUPPORTED_Y, BASE_FORCED, handleDotAll, handleNCG, RegExpWrapper, keys, index;
var init_es_regexp_constructor = __esm({
  "node_modules/core-js/modules/es.regexp.constructor.js"() {
    init_define_ngDevMode();
    DESCRIPTORS = require_descriptors();
    global = require_global();
    uncurryThis = require_function_uncurry_this();
    isForced = require_is_forced();
    inheritIfRequired = require_inherit_if_required();
    createNonEnumerableProperty = require_create_non_enumerable_property();
    getOwnPropertyNames = require_object_get_own_property_names().f;
    isPrototypeOf = require_object_is_prototype_of();
    isRegExp = require_is_regexp();
    toString = require_to_string();
    getRegExpFlags = require_regexp_get_flags();
    stickyHelpers = require_regexp_sticky_helpers();
    proxyAccessor = require_proxy_accessor();
    defineBuiltIn = require_define_built_in();
    fails = require_fails();
    hasOwn = require_has_own_property();
    enforceInternalState = require_internal_state().enforce;
    setSpecies = require_set_species();
    wellKnownSymbol = require_well_known_symbol();
    UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
    UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
    MATCH = wellKnownSymbol("match");
    NativeRegExp = global.RegExp;
    RegExpPrototype = NativeRegExp.prototype;
    SyntaxError = global.SyntaxError;
    exec = uncurryThis(RegExpPrototype.exec);
    charAt = uncurryThis("".charAt);
    replace = uncurryThis("".replace);
    stringIndexOf = uncurryThis("".indexOf);
    stringSlice = uncurryThis("".slice);
    IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
    re1 = /a/g;
    re2 = /a/g;
    CORRECT_NEW = new NativeRegExp(re1) !== re1;
    MISSED_STICKY = stickyHelpers.MISSED_STICKY;
    UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
    BASE_FORCED = DESCRIPTORS && (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function() {
      re2[MATCH] = false;
      return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, "i") != "/a/i";
    }));
    handleDotAll = function(string) {
      var length = string.length;
      var index = 0;
      var result = "";
      var brackets = false;
      var chr;
      for (; index <= length; index++) {
        chr = charAt(string, index);
        if (chr === "\\") {
          result += chr + charAt(string, ++index);
          continue;
        }
        if (!brackets && chr === ".") {
          result += "[\\s\\S]";
        } else {
          if (chr === "[") {
            brackets = true;
          } else if (chr === "]") {
            brackets = false;
          }
          result += chr;
        }
      }
      return result;
    };
    handleNCG = function(string) {
      var length = string.length;
      var index = 0;
      var result = "";
      var named = [];
      var names = {};
      var brackets = false;
      var ncg = false;
      var groupid = 0;
      var groupname = "";
      var chr;
      for (; index <= length; index++) {
        chr = charAt(string, index);
        if (chr === "\\") {
          chr = chr + charAt(string, ++index);
        } else if (chr === "]") {
          brackets = false;
        } else if (!brackets)
          switch (true) {
            case chr === "[":
              brackets = true;
              break;
            case chr === "(":
              if (exec(IS_NCG, stringSlice(string, index + 1))) {
                index += 2;
                ncg = true;
              }
              result += chr;
              groupid++;
              continue;
            case (chr === ">" && ncg):
              if (groupname === "" || hasOwn(names, groupname)) {
                throw new SyntaxError("Invalid capture group name");
              }
              names[groupname] = true;
              named[named.length] = [groupname, groupid];
              ncg = false;
              groupname = "";
              continue;
          }
        if (ncg)
          groupname += chr;
        else
          result += chr;
      }
      return [result, named];
    };
    if (isForced("RegExp", BASE_FORCED)) {
      RegExpWrapper = function RegExp(pattern, flags) {
        var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);
        var patternIsRegExp = isRegExp(pattern);
        var flagsAreUndefined = flags === void 0;
        var groups = [];
        var rawPattern = pattern;
        var rawFlags, dotAll, sticky, handled, result, state;
        if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
          return pattern;
        }
        if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {
          pattern = pattern.source;
          if (flagsAreUndefined)
            flags = getRegExpFlags(rawPattern);
        }
        pattern = pattern === void 0 ? "" : toString(pattern);
        flags = flags === void 0 ? "" : toString(flags);
        rawPattern = pattern;
        if (UNSUPPORTED_DOT_ALL && "dotAll" in re1) {
          dotAll = !!flags && stringIndexOf(flags, "s") > -1;
          if (dotAll)
            flags = replace(flags, /s/g, "");
        }
        rawFlags = flags;
        if (MISSED_STICKY && "sticky" in re1) {
          sticky = !!flags && stringIndexOf(flags, "y") > -1;
          if (sticky && UNSUPPORTED_Y)
            flags = replace(flags, /y/g, "");
        }
        if (UNSUPPORTED_NCG) {
          handled = handleNCG(pattern);
          pattern = handled[0];
          groups = handled[1];
        }
        result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
        if (dotAll || sticky || groups.length) {
          state = enforceInternalState(result);
          if (dotAll) {
            state.dotAll = true;
            state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
          }
          if (sticky)
            state.sticky = true;
          if (groups.length)
            state.groups = groups;
        }
        if (pattern !== rawPattern)
          try {
            createNonEnumerableProperty(result, "source", rawPattern === "" ? "(?:)" : rawPattern);
          } catch (error) {
          }
        return result;
      };
      for (keys = getOwnPropertyNames(NativeRegExp), index = 0; keys.length > index; ) {
        proxyAccessor(RegExpWrapper, NativeRegExp, keys[index++]);
      }
      RegExpPrototype.constructor = RegExpWrapper;
      RegExpWrapper.prototype = RegExpPrototype;
      defineBuiltIn(global, "RegExp", RegExpWrapper, {
        constructor: true
      });
    }
    setSpecies("RegExp");
  }
});

export {
  init_es_regexp_constructor
};
//# sourceMappingURL=chunk-PKAGMMWM.js.map

{
  "version": 3,
  "sources": ["../../../../node_modules/jest-mock/build/index.js"],
  "sourcesContent": ["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.spyOn = exports.mocked = exports.fn = exports.ModuleMocker = void 0;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable local/ban-types-eventually, local/prefer-rest-params-eventually */\n\n/**\n * Possible types of a MockFunctionResult.\n * 'return': The call completed by returning normally.\n * 'throw': The call completed by throwing a value.\n * 'incomplete': The call has not completed yet. This is possible if you read\n *               the  mock function result from within the mock function itself\n *               (or a function called by the mock function).\n */\n\n/**\n * Represents the result of a single call to a mock function.\n */\n// see https://github.com/Microsoft/TypeScript/issues/25215\nconst MOCK_CONSTRUCTOR_NAME = 'mockConstructor';\nconst FUNCTION_NAME_RESERVED_PATTERN = /[\\s!-\\/:-@\\[-`{-~]/;\nconst FUNCTION_NAME_RESERVED_REPLACE = new RegExp(\n  FUNCTION_NAME_RESERVED_PATTERN.source,\n  'g'\n);\nconst RESERVED_KEYWORDS = new Set([\n  'arguments',\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'enum',\n  'eval',\n  'export',\n  'extends',\n  'false',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'implements',\n  'import',\n  'in',\n  'instanceof',\n  'interface',\n  'let',\n  'new',\n  'null',\n  'package',\n  'private',\n  'protected',\n  'public',\n  'return',\n  'static',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'true',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield'\n]);\n\nfunction matchArity(fn, length) {\n  let mockConstructor;\n\n  switch (length) {\n    case 1:\n      mockConstructor = function (_a) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 2:\n      mockConstructor = function (_a, _b) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 3:\n      mockConstructor = function (_a, _b, _c) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 4:\n      mockConstructor = function (_a, _b, _c, _d) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 5:\n      mockConstructor = function (_a, _b, _c, _d, _e) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 6:\n      mockConstructor = function (_a, _b, _c, _d, _e, _f) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 7:\n      mockConstructor = function (_a, _b, _c, _d, _e, _f, _g) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 8:\n      mockConstructor = function (_a, _b, _c, _d, _e, _f, _g, _h) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    case 9:\n      mockConstructor = function (_a, _b, _c, _d, _e, _f, _g, _h, _i) {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n\n    default:\n      mockConstructor = function () {\n        return fn.apply(this, arguments);\n      };\n\n      break;\n  }\n\n  return mockConstructor;\n}\n\nfunction getObjectType(value) {\n  return Object.prototype.toString.apply(value).slice(8, -1);\n}\n\nfunction getType(ref) {\n  const typeName = getObjectType(ref);\n\n  if (\n    typeName === 'Function' ||\n    typeName === 'AsyncFunction' ||\n    typeName === 'GeneratorFunction'\n  ) {\n    return 'function';\n  } else if (Array.isArray(ref)) {\n    return 'array';\n  } else if (typeName === 'Object') {\n    return 'object';\n  } else if (\n    typeName === 'Number' ||\n    typeName === 'String' ||\n    typeName === 'Boolean' ||\n    typeName === 'Symbol'\n  ) {\n    return 'constant';\n  } else if (\n    typeName === 'Map' ||\n    typeName === 'WeakMap' ||\n    typeName === 'Set'\n  ) {\n    return 'collection';\n  } else if (typeName === 'RegExp') {\n    return 'regexp';\n  } else if (ref === undefined) {\n    return 'undefined';\n  } else if (ref === null) {\n    return 'null';\n  } else {\n    return null;\n  }\n}\n\nfunction isReadonlyProp(object, prop) {\n  if (\n    prop === 'arguments' ||\n    prop === 'caller' ||\n    prop === 'callee' ||\n    prop === 'name' ||\n    prop === 'length'\n  ) {\n    const typeName = getObjectType(object);\n    return (\n      typeName === 'Function' ||\n      typeName === 'AsyncFunction' ||\n      typeName === 'GeneratorFunction'\n    );\n  }\n\n  if (\n    prop === 'source' ||\n    prop === 'global' ||\n    prop === 'ignoreCase' ||\n    prop === 'multiline'\n  ) {\n    return getObjectType(object) === 'RegExp';\n  }\n\n  return false;\n}\n\nclass ModuleMocker {\n  /**\n   * @see README.md\n   * @param global Global object of the test environment, used to create\n   * mocks\n   */\n  constructor(global) {\n    _defineProperty(this, '_environmentGlobal', void 0);\n\n    _defineProperty(this, '_mockState', void 0);\n\n    _defineProperty(this, '_mockConfigRegistry', void 0);\n\n    _defineProperty(this, '_spyState', void 0);\n\n    _defineProperty(this, '_invocationCallCounter', void 0);\n\n    this._environmentGlobal = global;\n    this._mockState = new WeakMap();\n    this._mockConfigRegistry = new WeakMap();\n    this._spyState = new Set();\n    this._invocationCallCounter = 1;\n  }\n\n  _getSlots(object) {\n    if (!object) {\n      return [];\n    }\n\n    const slots = new Set();\n    const EnvObjectProto = this._environmentGlobal.Object.prototype;\n    const EnvFunctionProto = this._environmentGlobal.Function.prototype;\n    const EnvRegExpProto = this._environmentGlobal.RegExp.prototype; // Also check the builtins in the current context as they leak through\n    // core node modules.\n\n    const ObjectProto = Object.prototype;\n    const FunctionProto = Function.prototype;\n    const RegExpProto = RegExp.prototype; // Properties of Object.prototype, Function.prototype and RegExp.prototype\n    // are never reported as slots\n\n    while (\n      object != null &&\n      object !== EnvObjectProto &&\n      object !== EnvFunctionProto &&\n      object !== EnvRegExpProto &&\n      object !== ObjectProto &&\n      object !== FunctionProto &&\n      object !== RegExpProto\n    ) {\n      const ownNames = Object.getOwnPropertyNames(object);\n\n      for (let i = 0; i < ownNames.length; i++) {\n        const prop = ownNames[i];\n\n        if (!isReadonlyProp(object, prop)) {\n          const propDesc = Object.getOwnPropertyDescriptor(object, prop);\n\n          if ((propDesc !== undefined && !propDesc.get) || object.__esModule) {\n            slots.add(prop);\n          }\n        }\n      }\n\n      object = Object.getPrototypeOf(object);\n    }\n\n    return Array.from(slots);\n  }\n\n  _ensureMockConfig(f) {\n    let config = this._mockConfigRegistry.get(f);\n\n    if (!config) {\n      config = this._defaultMockConfig();\n\n      this._mockConfigRegistry.set(f, config);\n    }\n\n    return config;\n  }\n\n  _ensureMockState(f) {\n    let state = this._mockState.get(f);\n\n    if (!state) {\n      state = this._defaultMockState();\n\n      this._mockState.set(f, state);\n    }\n\n    if (state.calls.length > 0) {\n      state.lastCall = state.calls[state.calls.length - 1];\n    }\n\n    return state;\n  }\n\n  _defaultMockConfig() {\n    return {\n      mockImpl: undefined,\n      mockName: 'jest.fn()',\n      specificMockImpls: [],\n      specificReturnValues: []\n    };\n  }\n\n  _defaultMockState() {\n    return {\n      calls: [],\n      instances: [],\n      invocationCallOrder: [],\n      results: []\n    };\n  }\n\n  _makeComponent(metadata, restore) {\n    if (metadata.type === 'object') {\n      return new this._environmentGlobal.Object();\n    } else if (metadata.type === 'array') {\n      return new this._environmentGlobal.Array();\n    } else if (metadata.type === 'regexp') {\n      return new this._environmentGlobal.RegExp('');\n    } else if (\n      metadata.type === 'constant' ||\n      metadata.type === 'collection' ||\n      metadata.type === 'null' ||\n      metadata.type === 'undefined'\n    ) {\n      return metadata.value;\n    } else if (metadata.type === 'function') {\n      const prototype =\n        (metadata.members &&\n          metadata.members.prototype &&\n          metadata.members.prototype.members) ||\n        {};\n\n      const prototypeSlots = this._getSlots(prototype);\n\n      const mocker = this;\n      const mockConstructor = matchArity(function (...args) {\n        const mockState = mocker._ensureMockState(f);\n\n        const mockConfig = mocker._ensureMockConfig(f);\n\n        mockState.instances.push(this);\n        mockState.calls.push(args); // Create and record an \"incomplete\" mock result immediately upon\n        // calling rather than waiting for the mock to return. This avoids\n        // issues caused by recursion where results can be recorded in the\n        // wrong order.\n\n        const mockResult = {\n          type: 'incomplete',\n          value: undefined\n        };\n        mockState.results.push(mockResult);\n        mockState.invocationCallOrder.push(mocker._invocationCallCounter++); // Will be set to the return value of the mock if an error is not thrown\n\n        let finalReturnValue; // Will be set to the error that is thrown by the mock (if it throws)\n\n        let thrownError; // Will be set to true if the mock throws an error. The presence of a\n        // value in `thrownError` is not a 100% reliable indicator because a\n        // function could throw a value of undefined.\n\n        let callDidThrowError = false;\n\n        try {\n          // The bulk of the implementation is wrapped in an immediately\n          // executed arrow function so the return value of the mock function\n          // can be easily captured and recorded, despite the many separate\n          // return points within the logic.\n          finalReturnValue = (() => {\n            if (this instanceof f) {\n              // This is probably being called as a constructor\n              prototypeSlots.forEach(slot => {\n                // Copy prototype methods to the instance to make\n                // it easier to interact with mock instance call and\n                // return values\n                if (prototype[slot].type === 'function') {\n                  // @ts-expect-error no index signature\n                  const protoImpl = this[slot]; // @ts-expect-error no index signature\n\n                  this[slot] = mocker.generateFromMetadata(prototype[slot]); // @ts-expect-error no index signature\n\n                  this[slot]._protoImpl = protoImpl;\n                }\n              }); // Run the mock constructor implementation\n\n              const mockImpl = mockConfig.specificMockImpls.length\n                ? mockConfig.specificMockImpls.shift()\n                : mockConfig.mockImpl;\n              return mockImpl && mockImpl.apply(this, arguments);\n            } // If mockImplementationOnce()/mockImplementation() is last set,\n            // implementation use the mock\n\n            let specificMockImpl = mockConfig.specificMockImpls.shift();\n\n            if (specificMockImpl === undefined) {\n              specificMockImpl = mockConfig.mockImpl;\n            }\n\n            if (specificMockImpl) {\n              return specificMockImpl.apply(this, arguments);\n            } // Otherwise use prototype implementation\n\n            if (f._protoImpl) {\n              return f._protoImpl.apply(this, arguments);\n            }\n\n            return undefined;\n          })();\n        } catch (error) {\n          // Store the thrown error so we can record it, then re-throw it.\n          thrownError = error;\n          callDidThrowError = true;\n          throw error;\n        } finally {\n          // Record the result of the function.\n          // NOTE: Intentionally NOT pushing/indexing into the array of mock\n          //       results here to avoid corrupting results data if mockClear()\n          //       is called during the execution of the mock.\n          mockResult.type = callDidThrowError ? 'throw' : 'return';\n          mockResult.value = callDidThrowError ? thrownError : finalReturnValue;\n        }\n\n        return finalReturnValue;\n      }, metadata.length || 0);\n\n      const f = this._createMockFunction(metadata, mockConstructor);\n\n      f._isMockFunction = true;\n\n      f.getMockImplementation = () => this._ensureMockConfig(f).mockImpl;\n\n      if (typeof restore === 'function') {\n        this._spyState.add(restore);\n      }\n\n      this._mockState.set(f, this._defaultMockState());\n\n      this._mockConfigRegistry.set(f, this._defaultMockConfig());\n\n      Object.defineProperty(f, 'mock', {\n        configurable: false,\n        enumerable: true,\n        get: () => this._ensureMockState(f),\n        set: val => this._mockState.set(f, val)\n      });\n\n      f.mockClear = () => {\n        this._mockState.delete(f);\n\n        return f;\n      };\n\n      f.mockReset = () => {\n        f.mockClear();\n\n        this._mockConfigRegistry.delete(f);\n\n        return f;\n      };\n\n      f.mockRestore = () => {\n        f.mockReset();\n        return restore ? restore() : undefined;\n      };\n\n      f.mockReturnValueOnce = (\n        value // next function call will return this value or default return value\n      ) => f.mockImplementationOnce(() => value);\n\n      f.mockResolvedValueOnce = value =>\n        f.mockImplementationOnce(() => Promise.resolve(value));\n\n      f.mockRejectedValueOnce = value =>\n        f.mockImplementationOnce(() => Promise.reject(value));\n\n      f.mockReturnValue = (\n        value // next function call will return specified return value or this one\n      ) => f.mockImplementation(() => value);\n\n      f.mockResolvedValue = value =>\n        f.mockImplementation(() => Promise.resolve(value));\n\n      f.mockRejectedValue = value =>\n        f.mockImplementation(() => Promise.reject(value));\n\n      f.mockImplementationOnce = fn => {\n        // next function call will use this mock implementation return value\n        // or default mock implementation return value\n        const mockConfig = this._ensureMockConfig(f);\n\n        mockConfig.specificMockImpls.push(fn);\n        return f;\n      };\n\n      f.mockImplementation = fn => {\n        // next function call will use mock implementation return value\n        const mockConfig = this._ensureMockConfig(f);\n\n        mockConfig.mockImpl = fn;\n        return f;\n      };\n\n      f.mockReturnThis = () =>\n        f.mockImplementation(function () {\n          return this;\n        });\n\n      f.mockName = name => {\n        if (name) {\n          const mockConfig = this._ensureMockConfig(f);\n\n          mockConfig.mockName = name;\n        }\n\n        return f;\n      };\n\n      f.getMockName = () => {\n        const mockConfig = this._ensureMockConfig(f);\n\n        return mockConfig.mockName || 'jest.fn()';\n      };\n\n      if (metadata.mockImpl) {\n        f.mockImplementation(metadata.mockImpl);\n      }\n\n      return f;\n    } else {\n      const unknownType = metadata.type || 'undefined type';\n      throw new Error('Unrecognized type ' + unknownType);\n    }\n  }\n\n  _createMockFunction(metadata, mockConstructor) {\n    let name = metadata.name;\n\n    if (!name) {\n      return mockConstructor;\n    } // Preserve `name` property of mocked function.\n\n    const boundFunctionPrefix = 'bound ';\n    let bindCall = ''; // if-do-while for perf reasons. The common case is for the if to fail.\n\n    if (name && name.startsWith(boundFunctionPrefix)) {\n      do {\n        name = name.substring(boundFunctionPrefix.length); // Call bind() just to alter the function name.\n\n        bindCall = '.bind(null)';\n      } while (name && name.startsWith(boundFunctionPrefix));\n    } // Special case functions named `mockConstructor` to guard for infinite\n    // loops.\n\n    if (name === MOCK_CONSTRUCTOR_NAME) {\n      return mockConstructor;\n    }\n\n    if (\n      // It's a syntax error to define functions with a reserved keyword\n      // as name.\n      RESERVED_KEYWORDS.has(name) || // It's also a syntax error to define functions with a name that starts with a number\n      /^\\d/.test(name)\n    ) {\n      name = '$' + name;\n    } // It's also a syntax error to define a function with a reserved character\n    // as part of it's name.\n\n    if (FUNCTION_NAME_RESERVED_PATTERN.test(name)) {\n      name = name.replace(FUNCTION_NAME_RESERVED_REPLACE, '$');\n    }\n\n    const body =\n      'return function ' +\n      name +\n      '() {' +\n      'return ' +\n      MOCK_CONSTRUCTOR_NAME +\n      '.apply(this,arguments);' +\n      '}' +\n      bindCall;\n    const createConstructor = new this._environmentGlobal.Function(\n      MOCK_CONSTRUCTOR_NAME,\n      body\n    );\n    return createConstructor(mockConstructor);\n  }\n\n  _generateMock(metadata, callbacks, refs) {\n    // metadata not compatible but it's the same type, maybe problem with\n    // overloading of _makeComponent and not _generateMock?\n    // @ts-expect-error\n    const mock = this._makeComponent(metadata);\n\n    if (metadata.refID != null) {\n      refs[metadata.refID] = mock;\n    }\n\n    this._getSlots(metadata.members).forEach(slot => {\n      const slotMetadata = (metadata.members && metadata.members[slot]) || {};\n\n      if (slotMetadata.ref != null) {\n        callbacks.push(\n          (function (ref) {\n            return () => (mock[slot] = refs[ref]);\n          })(slotMetadata.ref)\n        );\n      } else {\n        mock[slot] = this._generateMock(slotMetadata, callbacks, refs);\n      }\n    });\n\n    if (\n      metadata.type !== 'undefined' &&\n      metadata.type !== 'null' &&\n      mock.prototype &&\n      typeof mock.prototype === 'object'\n    ) {\n      mock.prototype.constructor = mock;\n    }\n\n    return mock;\n  }\n  /**\n   * @see README.md\n   * @param _metadata Metadata for the mock in the schema returned by the\n   * getMetadata method of this module.\n   */\n\n  generateFromMetadata(_metadata) {\n    const callbacks = [];\n    const refs = {};\n\n    const mock = this._generateMock(_metadata, callbacks, refs);\n\n    callbacks.forEach(setter => setter());\n    return mock;\n  }\n  /**\n   * @see README.md\n   * @param component The component for which to retrieve metadata.\n   */\n\n  getMetadata(component, _refs) {\n    const refs = _refs || new Map();\n    const ref = refs.get(component);\n\n    if (ref != null) {\n      return {\n        ref\n      };\n    }\n\n    const type = getType(component);\n\n    if (!type) {\n      return null;\n    }\n\n    const metadata = {\n      type\n    };\n\n    if (\n      type === 'constant' ||\n      type === 'collection' ||\n      type === 'undefined' ||\n      type === 'null'\n    ) {\n      metadata.value = component;\n      return metadata;\n    } else if (type === 'function') {\n      // @ts-expect-error this is a function so it has a name\n      metadata.name = component.name; // @ts-expect-error may be a mock\n\n      if (component._isMockFunction === true) {\n        // @ts-expect-error may be a mock\n        metadata.mockImpl = component.getMockImplementation();\n      }\n    }\n\n    metadata.refID = refs.size;\n    refs.set(component, metadata.refID);\n    let members = null; // Leave arrays alone\n\n    if (type !== 'array') {\n      this._getSlots(component).forEach(slot => {\n        if (\n          type === 'function' && // @ts-expect-error may be a mock\n          component._isMockFunction === true &&\n          slot.match(/^mock/)\n        ) {\n          return;\n        } // @ts-expect-error no index signature\n\n        const slotMetadata = this.getMetadata(component[slot], refs);\n\n        if (slotMetadata) {\n          if (!members) {\n            members = {};\n          }\n\n          members[slot] = slotMetadata;\n        }\n      });\n    }\n\n    if (members) {\n      metadata.members = members;\n    }\n\n    return metadata;\n  }\n\n  isMockFunction(fn) {\n    return !!fn && fn._isMockFunction === true;\n  }\n\n  fn(implementation) {\n    const length = implementation ? implementation.length : 0;\n\n    const fn = this._makeComponent({\n      length,\n      type: 'function'\n    });\n\n    if (implementation) {\n      fn.mockImplementation(implementation);\n    }\n\n    return fn;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  spyOn(object, methodName, accessType) {\n    if (accessType) {\n      return this._spyOnProperty(object, methodName, accessType);\n    }\n\n    if (typeof object !== 'object' && typeof object !== 'function') {\n      throw new Error(\n        'Cannot spyOn on a primitive value; ' + this._typeOf(object) + ' given'\n      );\n    }\n\n    const original = object[methodName];\n\n    if (!this.isMockFunction(original)) {\n      if (typeof original !== 'function') {\n        throw new Error(\n          'Cannot spy the ' +\n            methodName +\n            ' property because it is not a function; ' +\n            this._typeOf(original) +\n            ' given instead'\n        );\n      }\n\n      const isMethodOwner = Object.prototype.hasOwnProperty.call(\n        object,\n        methodName\n      );\n      let descriptor = Object.getOwnPropertyDescriptor(object, methodName);\n      let proto = Object.getPrototypeOf(object);\n\n      while (!descriptor && proto !== null) {\n        descriptor = Object.getOwnPropertyDescriptor(proto, methodName);\n        proto = Object.getPrototypeOf(proto);\n      }\n\n      let mock;\n\n      if (descriptor && descriptor.get) {\n        const originalGet = descriptor.get;\n        mock = this._makeComponent(\n          {\n            type: 'function'\n          },\n          () => {\n            descriptor.get = originalGet;\n            Object.defineProperty(object, methodName, descriptor);\n          }\n        );\n\n        descriptor.get = () => mock;\n\n        Object.defineProperty(object, methodName, descriptor);\n      } else {\n        mock = this._makeComponent(\n          {\n            type: 'function'\n          },\n          () => {\n            if (isMethodOwner) {\n              object[methodName] = original;\n            } else {\n              delete object[methodName];\n            }\n          }\n        ); // @ts-expect-error overriding original method with a Mock\n\n        object[methodName] = mock;\n      }\n\n      mock.mockImplementation(function () {\n        return original.apply(this, arguments);\n      });\n    }\n\n    return object[methodName];\n  }\n\n  _spyOnProperty(obj, propertyName, accessType = 'get') {\n    if (typeof obj !== 'object' && typeof obj !== 'function') {\n      throw new Error(\n        'Cannot spyOn on a primitive value; ' + this._typeOf(obj) + ' given'\n      );\n    }\n\n    if (!obj) {\n      throw new Error(\n        'spyOn could not find an object to spy upon for ' + propertyName + ''\n      );\n    }\n\n    if (!propertyName) {\n      throw new Error('No property name supplied');\n    }\n\n    let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);\n    let proto = Object.getPrototypeOf(obj);\n\n    while (!descriptor && proto !== null) {\n      descriptor = Object.getOwnPropertyDescriptor(proto, propertyName);\n      proto = Object.getPrototypeOf(proto);\n    }\n\n    if (!descriptor) {\n      throw new Error(propertyName + ' property does not exist');\n    }\n\n    if (!descriptor.configurable) {\n      throw new Error(propertyName + ' is not declared configurable');\n    }\n\n    if (!descriptor[accessType]) {\n      throw new Error(\n        'Property ' + propertyName + ' does not have access type ' + accessType\n      );\n    }\n\n    const original = descriptor[accessType];\n\n    if (!this.isMockFunction(original)) {\n      if (typeof original !== 'function') {\n        throw new Error(\n          'Cannot spy the ' +\n            propertyName +\n            ' property because it is not a function; ' +\n            this._typeOf(original) +\n            ' given instead'\n        );\n      } // @ts-expect-error: mock is assignable\n\n      descriptor[accessType] = this._makeComponent(\n        {\n          type: 'function'\n        },\n        () => {\n          // @ts-expect-error: mock is assignable\n          descriptor[accessType] = original;\n          Object.defineProperty(obj, propertyName, descriptor);\n        }\n      );\n      descriptor[accessType].mockImplementation(function () {\n        // @ts-expect-error\n        return original.apply(this, arguments);\n      });\n    }\n\n    Object.defineProperty(obj, propertyName, descriptor);\n    return descriptor[accessType];\n  }\n\n  clearAllMocks() {\n    this._mockState = new WeakMap();\n  }\n\n  resetAllMocks() {\n    this._mockConfigRegistry = new WeakMap();\n    this._mockState = new WeakMap();\n  }\n\n  restoreAllMocks() {\n    this._spyState.forEach(restore => restore());\n\n    this._spyState = new Set();\n  }\n\n  _typeOf(value) {\n    return value == null ? '' + value : typeof value;\n  } // the typings test helper\n\n  mocked(item, _deep = false) {\n    return item;\n  }\n}\n\nexports.ModuleMocker = ModuleMocker;\nconst JestMock = new ModuleMocker(global);\nconst fn = JestMock.fn.bind(JestMock);\nexports.fn = fn;\nconst spyOn = JestMock.spyOn.bind(JestMock);\nexports.spyOn = spyOn;\nconst mocked = JestMock.mocked.bind(JestMock);\nexports.mocked = mocked;\n"],
  "mappings": "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",
  "names": ["Object", "defineProperty", "exports", "value", "spyOn", "mocked", "fn", "ModuleMocker", "_defineProperty", "obj", "key", "enumerable", "configurable", "writable", "MOCK_CONSTRUCTOR_NAME", "FUNCTION_NAME_RESERVED_PATTERN", "FUNCTION_NAME_RESERVED_REPLACE", "RegExp", "source", "RESERVED_KEYWORDS", "Set", "matchArity", "length", "mockConstructor", "_a", "apply", "arguments", "_b", "_c", "_d", "_e", "_f", "_g", "_h", "_i", "getObjectType", "prototype", "toString", "slice", "getType", "ref", "typeName", "Array", "isArray", "undefined", "isReadonlyProp", "object", "prop", "constructor", "global", "_environmentGlobal", "_mockState", "WeakMap", "_mockConfigRegistry", "_spyState", "_invocationCallCounter", "_getSlots", "slots", "EnvObjectProto", "EnvFunctionProto", "Function", "EnvRegExpProto", "ObjectProto", "FunctionProto", "RegExpProto", "ownNames", "getOwnPropertyNames", "i", "propDesc", "getOwnPropertyDescriptor", "get", "__esModule", "add", "getPrototypeOf", "from", "_ensureMockConfig", "f", "config", "_defaultMockConfig", "set", "_ensureMockState", "state", "_defaultMockState", "calls", "lastCall", "mockImpl", "mockName", "specificMockImpls", "specificReturnValues", "instances", "invocationCallOrder", "results", "_makeComponent", "metadata", "restore", "type", "members", "prototypeSlots", "mocker", "args", "mockState", "mockConfig", "push", "mockResult", "finalReturnValue", "thrownError", "callDidThrowError", "forEach", "slot", "protoImpl", "generateFromMetadata", "_protoImpl", "shift", "specificMockImpl", "error", "_createMockFunction", "_isMockFunction", "getMockImplementation", "val", "mockClear", "delete", "mockReset", "mockRestore", "mockReturnValueOnce", "mockImplementationOnce", "mockResolvedValueOnce", "Promise", "resolve", "mockRejectedValueOnce", "reject", "mockReturnValue", "mockImplementation", "mockResolvedValue", "mockRejectedValue", "mockReturnThis", "name", "getMockName", "unknownType", "Error", "boundFunctionPrefix", "bindCall", "startsWith", "substring", "has", "test", "replace", "body", "createConstructor", "_generateMock", "callbacks", "refs", "mock", "refID", "slotMetadata", "_metadata", "setter", "getMetadata", "component", "_refs", "Map", "size", "match", "isMockFunction", "implementation", "methodName", "accessType", "_spyOnProperty", "_typeOf", "original", "isMethodOwner", "hasOwnProperty", "call", "descriptor", "proto", "originalGet", "propertyName", "clearAllMocks", "resetAllMocks", "restoreAllMocks", "item", "_deep", "JestMock", "bind"]
}

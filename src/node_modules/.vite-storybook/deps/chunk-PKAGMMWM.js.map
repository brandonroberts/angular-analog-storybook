{
  "version": 3,
  "sources": ["../../../../node_modules/core-js/internals/proxy-accessor.js", "../../../../node_modules/core-js/modules/es.regexp.constructor.js"],
  "sourcesContent": ["var defineProperty = require('../internals/object-define-property').f;\n\nmodule.exports = function (Target, Source, key) {\n  key in Target || defineProperty(Target, key, {\n    configurable: true,\n    get: function () { return Source[key]; },\n    set: function (it) { Source[key] = it; }\n  });\n};\n", "var DESCRIPTORS = require('../internals/descriptors');\nvar global = require('../internals/global');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar isForced = require('../internals/is-forced');\nvar inheritIfRequired = require('../internals/inherit-if-required');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar getOwnPropertyNames = require('../internals/object-get-own-property-names').f;\nvar isPrototypeOf = require('../internals/object-is-prototype-of');\nvar isRegExp = require('../internals/is-regexp');\nvar toString = require('../internals/to-string');\nvar getRegExpFlags = require('../internals/regexp-get-flags');\nvar stickyHelpers = require('../internals/regexp-sticky-helpers');\nvar proxyAccessor = require('../internals/proxy-accessor');\nvar defineBuiltIn = require('../internals/define-built-in');\nvar fails = require('../internals/fails');\nvar hasOwn = require('../internals/has-own-property');\nvar enforceInternalState = require('../internals/internal-state').enforce;\nvar setSpecies = require('../internals/set-species');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\nvar UNSUPPORTED_DOT_ALL = require('../internals/regexp-unsupported-dot-all');\nvar UNSUPPORTED_NCG = require('../internals/regexp-unsupported-ncg');\n\nvar MATCH = wellKnownSymbol('match');\nvar NativeRegExp = global.RegExp;\nvar RegExpPrototype = NativeRegExp.prototype;\nvar SyntaxError = global.SyntaxError;\nvar exec = uncurryThis(RegExpPrototype.exec);\nvar charAt = uncurryThis(''.charAt);\nvar replace = uncurryThis(''.replace);\nvar stringIndexOf = uncurryThis(''.indexOf);\nvar stringSlice = uncurryThis(''.slice);\n// TODO: Use only proper RegExpIdentifierName\nvar IS_NCG = /^\\?<[^\\s\\d!#%&*+<=>@^][^\\s!#%&*+<=>@^]*>/;\nvar re1 = /a/g;\nvar re2 = /a/g;\n\n// \"new\" should create a new object, old webkit bug\nvar CORRECT_NEW = new NativeRegExp(re1) !== re1;\n\nvar MISSED_STICKY = stickyHelpers.MISSED_STICKY;\nvar UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;\n\nvar BASE_FORCED = DESCRIPTORS &&\n  (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function () {\n    re2[MATCH] = false;\n    // RegExp constructor can alter flags and IsRegExp works correct with @@match\n    return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';\n  }));\n\nvar handleDotAll = function (string) {\n  var length = string.length;\n  var index = 0;\n  var result = '';\n  var brackets = false;\n  var chr;\n  for (; index <= length; index++) {\n    chr = charAt(string, index);\n    if (chr === '\\\\') {\n      result += chr + charAt(string, ++index);\n      continue;\n    }\n    if (!brackets && chr === '.') {\n      result += '[\\\\s\\\\S]';\n    } else {\n      if (chr === '[') {\n        brackets = true;\n      } else if (chr === ']') {\n        brackets = false;\n      } result += chr;\n    }\n  } return result;\n};\n\nvar handleNCG = function (string) {\n  var length = string.length;\n  var index = 0;\n  var result = '';\n  var named = [];\n  var names = {};\n  var brackets = false;\n  var ncg = false;\n  var groupid = 0;\n  var groupname = '';\n  var chr;\n  for (; index <= length; index++) {\n    chr = charAt(string, index);\n    if (chr === '\\\\') {\n      chr = chr + charAt(string, ++index);\n    } else if (chr === ']') {\n      brackets = false;\n    } else if (!brackets) switch (true) {\n      case chr === '[':\n        brackets = true;\n        break;\n      case chr === '(':\n        if (exec(IS_NCG, stringSlice(string, index + 1))) {\n          index += 2;\n          ncg = true;\n        }\n        result += chr;\n        groupid++;\n        continue;\n      case chr === '>' && ncg:\n        if (groupname === '' || hasOwn(names, groupname)) {\n          throw new SyntaxError('Invalid capture group name');\n        }\n        names[groupname] = true;\n        named[named.length] = [groupname, groupid];\n        ncg = false;\n        groupname = '';\n        continue;\n    }\n    if (ncg) groupname += chr;\n    else result += chr;\n  } return [result, named];\n};\n\n// `RegExp` constructor\n// https://tc39.es/ecma262/#sec-regexp-constructor\nif (isForced('RegExp', BASE_FORCED)) {\n  var RegExpWrapper = function RegExp(pattern, flags) {\n    var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);\n    var patternIsRegExp = isRegExp(pattern);\n    var flagsAreUndefined = flags === undefined;\n    var groups = [];\n    var rawPattern = pattern;\n    var rawFlags, dotAll, sticky, handled, result, state;\n\n    if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {\n      return pattern;\n    }\n\n    if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {\n      pattern = pattern.source;\n      if (flagsAreUndefined) flags = getRegExpFlags(rawPattern);\n    }\n\n    pattern = pattern === undefined ? '' : toString(pattern);\n    flags = flags === undefined ? '' : toString(flags);\n    rawPattern = pattern;\n\n    if (UNSUPPORTED_DOT_ALL && 'dotAll' in re1) {\n      dotAll = !!flags && stringIndexOf(flags, 's') > -1;\n      if (dotAll) flags = replace(flags, /s/g, '');\n    }\n\n    rawFlags = flags;\n\n    if (MISSED_STICKY && 'sticky' in re1) {\n      sticky = !!flags && stringIndexOf(flags, 'y') > -1;\n      if (sticky && UNSUPPORTED_Y) flags = replace(flags, /y/g, '');\n    }\n\n    if (UNSUPPORTED_NCG) {\n      handled = handleNCG(pattern);\n      pattern = handled[0];\n      groups = handled[1];\n    }\n\n    result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);\n\n    if (dotAll || sticky || groups.length) {\n      state = enforceInternalState(result);\n      if (dotAll) {\n        state.dotAll = true;\n        state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);\n      }\n      if (sticky) state.sticky = true;\n      if (groups.length) state.groups = groups;\n    }\n\n    if (pattern !== rawPattern) try {\n      // fails in old engines, but we have no alternatives for unsupported regex syntax\n      createNonEnumerableProperty(result, 'source', rawPattern === '' ? '(?:)' : rawPattern);\n    } catch (error) { /* empty */ }\n\n    return result;\n  };\n\n  for (var keys = getOwnPropertyNames(NativeRegExp), index = 0; keys.length > index;) {\n    proxyAccessor(RegExpWrapper, NativeRegExp, keys[index++]);\n  }\n\n  RegExpPrototype.constructor = RegExpWrapper;\n  RegExpWrapper.prototype = RegExpPrototype;\n  defineBuiltIn(global, 'RegExp', RegExpWrapper, { constructor: true });\n}\n\n// https://tc39.es/ecma262/#sec-get-regexp-@@species\nsetSpecies('RegExp');\n"],
  "mappings": "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",
  "names": ["defineProperty", "require", "f", "module", "exports", "Target", "Source", "key", "configurable", "get", "set", "it", "DESCRIPTORS", "global", "uncurryThis", "isForced", "inheritIfRequired", "createNonEnumerableProperty", "getOwnPropertyNames", "isPrototypeOf", "isRegExp", "toString", "getRegExpFlags", "stickyHelpers", "proxyAccessor", "defineBuiltIn", "fails", "hasOwn", "enforceInternalState", "setSpecies", "wellKnownSymbol", "UNSUPPORTED_DOT_ALL", "UNSUPPORTED_NCG", "MATCH", "NativeRegExp", "RegExpPrototype", "SyntaxError", "exec", "charAt", "replace", "stringIndexOf", "stringSlice", "IS_NCG", "re1", "re2", "CORRECT_NEW", "MISSED_STICKY", "UNSUPPORTED_Y", "BASE_FORCED", "handleDotAll", "handleNCG", "RegExpWrapper", "keys", "index", "require", "f", "enforce", "RegExp", "prototype", "indexOf", "slice", "string", "length", "result", "brackets", "chr", "named", "names", "ncg", "groupid", "groupname", "pattern", "flags", "thisIsRegExp", "patternIsRegExp", "flagsAreUndefined", "undefined", "groups", "rawPattern", "rawFlags", "dotAll", "sticky", "handled", "state", "constructor", "source", "raw", "error"]
}
